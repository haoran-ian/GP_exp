{"id": "b86da5d4-f532-43e8-915b-4b5879d6b85e", "fitness": 0.03635295035425092, "name": "PSO_SA_Optimizer", "description": "A hybrid Particle Swarm Optimization (PSO) with Simulated Annealing (SA) to efficiently explore and exploit the search space.", "code": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 0, "feedback": "The algorithm PSO_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03635 with standard deviation 0.04201.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.12751920659104155, 0.1067487018891985, 0.14499932203988442, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0243354565800894, 0.030140601005097967, 0.020236538576863694, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07098008690800295, 0.05442909554523934, 0.05127623591101682, 0.020000000000000018, 0.04607921210104626, 0.020000000000000018, 0.024807256463523664, 0.08594148016760361, 0.07500741715524184, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.066202622639571, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13694574233130408, 0.109438234796564, 0.13627749065626493, 0.021727113577140078, 0.020000000000000018, 0.020000000000000018, 0.09308152682549153, 0.0863116411064907, 0.07046532302189068, 0.13621283788874594, 0.14438239178146428, 0.1160417955509998, 0.07624980925423785, 0.08857839090777131, 0.07262966701636286, 0.13539838641259683, 0.11581261798582065, 0.12986164751779228, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13361773160952028, 0.08421227652997942, 0.0895133107273659, 0.06527120746322768, 0.06012359081965424, 0.056492493752391515, 0.14680046364871946, 0.13589170657517036, 0.15475448018179316, 0.05210055136520553, 0.03392426887360889, 0.03413806055226121, 0.045527069636850936, 0.03710204189643396, 0.0453452556661863, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02240338674979936, 0.012962696886805514, 0.01082770722242199, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08398199062204115, 0.0798319644339649, 0.08013753786925659, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06432566672457651, 0.06680345496056173, 0.12274862419232846, 0.1054846297706834, 0.10674297088963713, 0.0698549172960996, 0.04198836322876953, 0.053936809511723194, 0.09567385378489301, 0.0810780182084716, 0.10479723546004005, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.038718773267439444, 0.036939817737021485, 0.03476748768127025, 0.031383045621377614, 0.03034513883213419, 0.026229605091440344, 0.13861677662330096, 0.13123409970527322, 0.13450861748860743, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0021711840369675883, 0.0, 0.0011655721611930625, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04325980246798666, 0.04434823304483193, 0.03207792736068338, 0.0, 0.0, 0.0, 0.03319906181834864, 0.03753213255583987, 0.03337308352159596, 0.08655630915365731, 0.09080317406894656, 0.08121976008767862, 0.03024751049896035, 0.027361078951456674, 0.022578614854175116, 0.07951679205853779, 0.07119648006213619, 0.058121508171307235, 0.0, 0.0, 0.0, 0.010204361199838585, 0.011620187903495394, 0.012204123020669866, 0.007838119271151078, 0.010051284513262426, 0.01071051028772485, 0.12228897412157291, 0.1304161139054778, 0.10831987488800565, 0.0, 0.0, 0.0]}}
{"id": "3e06758d-719e-4ee4-9d39-4befd5043800", "fitness": 0.03645976756701862, "name": "PSO_SA_Optimizer", "description": "A hybrid Particle Swarm Optimization (PSO) with Simulated Annealing (SA), refined by adjusting the inertia weight dynamically for enhanced balance between exploration and exploitation.", "code": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 1, "feedback": "The algorithm PSO_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03646 with standard deviation 0.04242.", "error": "", "parent_ids": ["b86da5d4-f532-43e8-915b-4b5879d6b85e"], "operator": null, "metadata": {"aucs": [0.1333677980320459, 0.10990678761697215, 0.14474852129493743, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0234746073373292, 0.020000000000000018, 0.02170375441693506, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06727350989916236, 0.05435352201329691, 0.05081131229257707, 0.020000000000000018, 0.04445209977420683, 0.020000000000000018, 0.024807256463523664, 0.08594148016760361, 0.06813757382890484, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07036377349391243, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1367358308981469, 0.12147569578595263, 0.14197092337469597, 0.020000000000000018, 0.020213770631302364, 0.020000000000000018, 0.08072694858327945, 0.08859370372204667, 0.07712752136263279, 0.13898692718618633, 0.1515833359372445, 0.12929167629743887, 0.0799198048252181, 0.10396885203382678, 0.06822044079812994, 0.12450381801488308, 0.1429786068697152, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12607203825236502, 0.0862974427130625, 0.0895133107273659, 0.06527120746322768, 0.05561718520981285, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05084149147894634, 0.037458934937274924, 0.030933881740368152, 0.042488308131394925, 0.0378806170354159, 0.05798648206159418, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023180861598791846, 0.01306406206082189, 0.0139003968528284, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011935490308778163, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09017823015819726, 0.07540017087918993, 0.07837981893651058, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05395939349942802, 0.12737380888809013, 0.10319492373171935, 0.10494498592011736, 0.06654389938153715, 0.045678210673408826, 0.053936809511723194, 0.08642014451374946, 0.08593036271443777, 0.10174955423539245, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03427145154372435, 0.03630310377893209, 0.03987649338254684, 0.02551546392939119, 0.03402486791445469, 0.025689020722006406, 0.13294751901474866, 0.13144137623993313, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00419368509697815, 0.0, 8.307336846824498e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03615574836225943, 0.04155686963766203, 0.03373945629369013, 0.0, 0.0, 0.0, 0.032580769046655744, 0.03753213255583987, 0.034883534723147314, 0.08699828172943258, 0.09014149777151204, 0.07762808476912131, 0.029589505068833066, 0.030327668426323395, 0.022082891692664974, 0.0828352245023587, 0.07342355894605945, 0.05795444005561956, 0.0, 0.0, 0.0, 0.010138762814311364, 0.012119441656370022, 0.012517732801037629, 0.00835613816789138, 0.010051284513262426, 0.010974932040168528, 0.11664316434004407, 0.1304161139054778, 0.11777209732374327, 0.0, 0.0, 0.0]}}
{"id": "2b7f10fd-3661-4a67-ac29-a043479ca441", "fitness": 0.03637845848371176, "name": "PSO_SA_Optimizer", "description": "Enhanced Hybrid PSO-SA with adaptive velocity scaling for improved convergence speed.", "code": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                velocity_scale = 0.5 + np.random.rand()  # Adaptive velocity scaling\n                self.velocities[i] = (velocity_scale * self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 2, "feedback": "The algorithm PSO_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03638 with standard deviation 0.04198.", "error": "", "parent_ids": ["3e06758d-719e-4ee4-9d39-4befd5043800"], "operator": null, "metadata": {"aucs": [0.10417300567348375, 0.08969309184736429, 0.13239116963173558, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.038395052426235976, 0.020088594160234452, 0.026459996015750886, 0.020000000000000018, 0.03298626664455251, 0.021044834336047646, 0.06880221594851177, 0.052773579308849294, 0.05077254446627255, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03357298852593038, 0.08594148016760361, 0.087203261728102, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806911224589956, 0.12501982047968596, 0.13576803482082567, 0.02153431793838867, 0.020000000000000018, 0.024849894118948113, 0.08703841060810613, 0.0863116411064907, 0.07015575039186472, 0.14743243061205868, 0.13323277534341382, 0.12150296876762579, 0.06914929863457175, 0.08116121698040957, 0.06643545930442729, 0.12981852772995206, 0.11266015643174487, 0.12650126379478943, 0.1206688130319874, 0.020000000000000018, 0.12076524410575884, 0.10819636878037442, 0.10326630610071685, 0.0895133107273659, 0.06527120746322768, 0.05016947198363231, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15822277914516492, 0.038669801718039354, 0.04794411034336288, 0.02657375009670604, 0.05486840475414523, 0.02982515501201133, 0.056528637792597314, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015696714275856505, 0.014045080564468404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0678314358379829, 0.06436223529417018, 0.07454875898993985, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05514270593988668, 0.06147825531143891, 0.05395939349942802, 0.12048566826904628, 0.10574642467340245, 0.1038838662780992, 0.06476256121082058, 0.03781411833282977, 0.05482781559409633, 0.09036017273808028, 0.08552069685281216, 0.10458374752933608, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026594145430106075, 0.030820077617307207, 0.0357049318549294, 0.030863203836203335, 0.025348316190602183, 0.024640285494433645, 0.13923889484613294, 0.13330247343215074, 0.13734675098955096, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0383221224602438, 0.03888436241130766, 0.042064043391004, 0.0, 0.0, 0.0, 0.03302887841494484, 0.03753213255583987, 0.04361549623181138, 0.08470272266973633, 0.08663519006852893, 0.07850802586058692, 0.023906334041730704, 0.03172611060604513, 0.025972876538778333, 0.0783159310348418, 0.07230437438878468, 0.06367133710219985, 0.0, 0.0, 0.0, 0.010599451199135745, 0.011509264372811301, 0.010576532426210039, 0.007792064719929881, 0.010359934848276575, 0.0077866890174194126, 0.1359043232367807, 0.1304161139054778, 0.10704463949182363, 0.0, 0.0, 0.0]}}
{"id": "ead7ce0d-9b65-403a-a4a0-11626a778f3d", "fitness": 0.03643838795870696, "name": "PSO_SA_Optimizer", "description": "Enhanced PSO-Simulated Annealing hybrid by increasing cognitive coefficient to 2.0 for improved local search precision.", "code": "import numpy as np\n\nclass PSO_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9 \n        self.cognitive_coeff = 2.0  # Changed from 1.5 to 2.0\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 3, "feedback": "The algorithm PSO_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03644 with standard deviation 0.04238.", "error": "", "parent_ids": ["3e06758d-719e-4ee4-9d39-4befd5043800"], "operator": null, "metadata": {"aucs": [0.1333677980320459, 0.10990678761697215, 0.14474852129493743, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0234746073373292, 0.020000000000000018, 0.02170375441693506, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06727350989916236, 0.05435352201329691, 0.05081131229257707, 0.020000000000000018, 0.04445209977420683, 0.020000000000000018, 0.024807256463523664, 0.08594148016760361, 0.06813757382890484, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07036377349391243, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1367358308981469, 0.12147569578595263, 0.14197092337469597, 0.020000000000000018, 0.020213770631302364, 0.020000000000000018, 0.08072694858327945, 0.08859370372204667, 0.07712752136263279, 0.13898692718618633, 0.1515833359372445, 0.12929167629743887, 0.0799198048252181, 0.10396885203382678, 0.06822044079812994, 0.12450381801488308, 0.1429786068697152, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12607203825236502, 0.0862974427130625, 0.0895133107273659, 0.06527120746322768, 0.05561718520981285, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05084149147894634, 0.037458934937274924, 0.030933881740368152, 0.04262052902817526, 0.03930652569485593, 0.05795796389807917, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021836755466261737, 0.01293892321404766, 0.014359603215636563, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010879969180182858, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08726342361862072, 0.08203571389218312, 0.07837981893651058, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058216713843670775, 0.06529769312582034, 0.05405544244090865, 0.12246143920190056, 0.10350314503877289, 0.10455862116434145, 0.066068742683006, 0.045678210673408826, 0.053936809511723194, 0.08593520256858678, 0.08379203738645769, 0.10174955423539245, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03361206540401451, 0.03443840423755529, 0.04106316580608538, 0.031385059110428104, 0.031547340066031104, 0.025725075217858606, 0.13141309820135194, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00167054320394866, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03615574836225943, 0.04414659542351462, 0.0365095312795668, 0.0, 0.0, 0.0, 0.033817494119789626, 0.037551343918173496, 0.030214947507745893, 0.08699828172943258, 0.08984132889956131, 0.07780211668017845, 0.028512529236246253, 0.031354505742485994, 0.01938976847968088, 0.07886101422938441, 0.07274242365384465, 0.05915110282538161, 0.0, 0.0, 0.0, 0.010139358031998613, 0.011435370766493813, 0.012219785268033356, 0.007860284692289277, 0.010051284513262426, 0.010827604840720984, 0.11765980991359215, 0.1304161139054778, 0.11777209732374327, 0.0, 0.0, 0.0]}}
{"id": "4af32244-7a03-4ffc-a18e-83f92e5f1b13", "fitness": 0.033873711680745475, "name": "Enhanced_PSO_SA_Optimizer", "description": "An enhanced hybrid optimizer combining Particle Swarm Optimization (PSO) with Simulated Annealing (SA), utilizing adaptive velocity decay and dynamic neighborhood topology for improved convergence.", "code": "import numpy as np\n\nclass Enhanced_PSO_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            local_best_positions = self._compute_local_best()\n\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position with adaptive inertia weight\n                self.inertia_weight = max(0.4, self.inertia_weight - (0.5 / self.budget))\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (local_best_positions[i] - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score\n\n    def _compute_local_best(self):\n        local_best_positions = np.copy(self.particles)\n        for i in range(self.population_size):\n            neighbors = self._get_neighbors(i)\n            best_neighbor_score = float('inf')\n            best_neighbor = None\n            for neighbor in neighbors:\n                if self.personal_best_scores[neighbor] < best_neighbor_score:\n                    best_neighbor_score = self.personal_best_scores[neighbor]\n                    best_neighbor = self.personal_best_positions[neighbor]\n            local_best_positions[i] = best_neighbor if best_neighbor is not None else self.particles[i]\n        return local_best_positions\n\n    def _get_neighbors(self, idx):\n        # Consider the particle itself and its two nearest neighbors\n        return [(idx - 1) % self.population_size, idx, (idx + 1) % self.population_size]", "configspace": "", "generation": 4, "feedback": "The algorithm Enhanced_PSO_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03387 with standard deviation 0.03994.", "error": "", "parent_ids": ["3e06758d-719e-4ee4-9d39-4befd5043800"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.08161900596079763, 0.12306446648310054, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024617173333518982, 0.020000000000000018, 0.020996791844869467, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.049535380207934465, 0.042540812959791174, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03351184306167798, 0.08594148016760361, 0.06723274640451293, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11895964378543733, 0.08865629518912466, 0.13084903150896143, 0.020000000000000018, 0.025933726020066716, 0.020000000000000018, 0.09166669879947664, 0.0863116411064907, 0.07015575039186472, 0.13127499098850337, 0.13323277534341382, 0.1160417955509998, 0.07583828874690823, 0.07990382579724953, 0.05610455226583122, 0.11205586464406281, 0.09577763236819037, 0.12451637507523738, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.11311119840678951, 0.0895133107273659, 0.07373017004609961, 0.052667058784686804, 0.12713256449612198, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.055505888198675524, 0.04288670355756241, 0.02657375009670604, 0.02756300309123305, 0.020486392570417178, 0.03910155267332782, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012455117659720516, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07803071094463032, 0.05556855928302473, 0.07250753890862927, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05661448724890927, 0.06147825531143891, 0.06480298398566153, 0.11869262382913237, 0.0965342724067757, 0.103827810524169, 0.0618680647438703, 0.039277730392975774, 0.05903030018458, 0.08206584144365847, 0.07273487270943235, 0.08807105303750307, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025918491983344838, 0.029043163533977734, 0.029962410273599582, 0.024895242935785933, 0.02320449859976237, 0.024640285494433645, 0.13771174569525613, 0.15491366503542392, 0.14006612665749285, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.032996868622169884, 0.03440654604132698, 0.020933825831312203, 0.0, 0.0, 0.0, 0.03667536810823213, 0.037587593331993685, 0.029527450992300697, 0.08541235127466551, 0.08018663952797278, 0.07353614484073712, 0.029524369544828732, 0.029376787366480195, 0.022322426759604608, 0.06501016208547095, 0.05922203257964387, 0.04837277047046751, 0.0, 0.0, 0.0, 0.010982121020126856, 0.008803353158453042, 0.01085877745527375, 0.007357985685952806, 0.010051284513262426, 0.007259537265468574, 0.1112398058338967, 0.1304161139054778, 0.11134118739209453, 0.0, 0.0, 0.0]}}
{"id": "fde2b8fa-9262-4743-b8c9-0d813a6ac0ba", "fitness": 0.03642129284004505, "name": "PSO_SA_Adaptive_Optimizer", "description": "A hybrid PSO with SA and adaptive population size, dynamically shrinking to focus the search towards promising solutions for enhanced convergence.", "code": "import numpy as np\n\nclass PSO_SA_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.final_population_size = 5\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.initial_population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            population_size = self.initial_population_size - int(\n                (self.initial_population_size - self.final_population_size) * (self.current_evals / self.budget))\n            population_size = max(self.final_population_size, population_size)\n            \n            for i in range(population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 5, "feedback": "The algorithm PSO_SA_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03642 with standard deviation 0.04231.", "error": "", "parent_ids": ["3e06758d-719e-4ee4-9d39-4befd5043800"], "operator": null, "metadata": {"aucs": [0.1333677980320459, 0.10990678761697215, 0.14474852129493743, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0234746073373292, 0.020000000000000018, 0.02170375441693506, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06727350989916236, 0.05435352201329691, 0.05081131229257707, 0.020000000000000018, 0.04445209977420683, 0.020000000000000018, 0.024807256463523664, 0.08594148016760361, 0.06813757382890484, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07036377349391243, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1367358308981469, 0.12147569578595263, 0.14197092337469597, 0.020000000000000018, 0.020213770631302364, 0.020000000000000018, 0.08072694858327945, 0.08859370372204667, 0.07712752136263279, 0.13898692718618633, 0.1515833359372445, 0.12929167629743887, 0.0799198048252181, 0.10396885203382678, 0.06822044079812994, 0.12450381801488308, 0.1429786068697152, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12607203825236502, 0.0862974427130625, 0.0895133107273659, 0.06527120746322768, 0.05561718520981285, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05084149147894634, 0.037458934937274924, 0.030933881740368152, 0.040820888688899215, 0.03764151176639885, 0.056890107059036854, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025374316343583225, 0.014416594955764972, 0.01428011896458814, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011011893746001866, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08870388088981196, 0.07906764537722066, 0.07951021620696408, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05395939349942802, 0.11869262382913237, 0.1052882771416429, 0.10281775224528589, 0.0731499108215995, 0.045678210673408826, 0.053936809511723194, 0.08669273958373358, 0.07642436772501293, 0.10265579807266878, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03361206540401451, 0.03937590304107108, 0.03767436758585285, 0.025313873526862096, 0.031547340066031104, 0.030883356819212393, 0.13141309820135194, 0.13317436869940846, 0.13742665328285208, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004977334553402546, 0.0, 0.005824076873037098, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03615574836225943, 0.04292529664613942, 0.03659631272158004, 0.0, 0.0, 0.0, 0.030262202767467716, 0.03753213255583987, 0.03553037163197459, 0.08699828172943258, 0.08958221995379756, 0.0766528424084082, 0.025159445409451586, 0.029223877740129467, 0.02163940611332027, 0.07777672011394798, 0.0729779953924965, 0.05721530661815999, 0.0, 0.0, 0.0, 0.009667148535201786, 0.011184541770018819, 0.013389122194946035, 0.007952091889586121, 0.010051284513262426, 0.009563587309427635, 0.11590498584905073, 0.1304161139054778, 0.11777209732374327, 0.0, 0.0, 0.0]}}
{"id": "7923f034-28a1-47dd-9134-ca7568e4ebc6", "fitness": 0.03610498368776874, "name": "PSO_SA_Adaptive_Optimizer", "description": "A PSO with Adaptive Learning Factors and Dynamic Simulated Annealing, adjusting learning rates based on improvements and dynamically varying cooling rates for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass PSO_SA_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.init_cognitive_coeff = 1.5\n        self.init_social_coeff = 1.5\n        self.temperature = 100.0\n        self.init_cooling_rate = 0.99\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Adaptive cognitive and social coefficients\n                cognitive_coeff = self.init_cognitive_coeff * np.random.uniform(0.5, 1.5)\n                social_coeff = self.init_social_coeff * np.random.uniform(0.5, 1.5)\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Dynamic Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic cooling rate based on progress\n            progress = (self.global_best_score - np.min(self.personal_best_scores)) / self.global_best_score\n            self.temperature *= max(self.init_cooling_rate * (1 - progress), 0.9)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 6, "feedback": "The algorithm PSO_SA_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03610 with standard deviation 0.04176.", "error": "", "parent_ids": ["3e06758d-719e-4ee4-9d39-4befd5043800"], "operator": null, "metadata": {"aucs": [0.11300383621087529, 0.11247859458714615, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04265141137060624, 0.020000000000000018, 0.020000000000000018, 0.023462020010656226, 0.020000000000000018, 0.020000000000000018, 0.06660463670637395, 0.06135421078380021, 0.04967737343672207, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.08275193151123483, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13609545983685334, 0.11197064686534564, 0.13286622282340832, 0.02153645619901523, 0.020508639248356997, 0.02949797881701377, 0.08072694858327945, 0.0863116411064907, 0.09251697623931276, 0.1473325742979461, 0.14022683634111488, 0.12409759406734677, 0.08493625056229392, 0.07990382579724953, 0.06775972179127476, 0.13068160852321853, 0.11814242368549155, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1315801632881013, 0.10056957151715651, 0.0895133107273659, 0.06527120746322768, 0.0796362665751229, 0.056492493752391515, 0.14736878274612086, 0.13886090742544754, 0.15498645081046514, 0.041333545244848446, 0.04052404183075253, 0.036021790144183385, 0.04118996329580826, 0.030130625902402786, 0.05015175308359576, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013730790595113396, 0.01624445914786099, 0.011862667852975628, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010282932923773247, 0.010000000000000009, 0.014467074903655508, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07755785857470698, 0.06438631143370488, 0.0838465256983032, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06375873533075482, 0.05395939349942802, 0.1267389829927965, 0.10089319208341219, 0.10281775224528589, 0.07318812706741229, 0.045361374911333074, 0.055143112084947266, 0.09292832040729249, 0.09229906514546826, 0.10799177067543764, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03368410334386607, 0.03841358691676622, 0.03995852520716914, 0.028907648445282375, 0.024513073795496276, 0.02624180157950906, 0.13141309820135194, 0.13466428228574012, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011691824742338208, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.041219658386289826, 0.034829871423226466, 0.034726451593073304, 0.0, 0.0, 0.0, 0.03343429562002953, 0.03753213255583987, 0.04074188887069041, 0.08593052639534848, 0.07992291172184163, 0.09068150391112229, 0.02743780912601368, 0.024192448856156457, 0.019198983764063815, 0.08036525152556839, 0.07338180622757551, 0.06441904264627951, 0.0, 0.0, 0.0, 0.010215401400647472, 0.011103118717341265, 0.014119624921209106, 0.007588009138175367, 0.010051284513262426, 0.010343378600205844, 0.11659159482637038, 0.1304161139054778, 0.11077851061761068, 0.0, 0.0, 0.0]}}
{"id": "5d54538d-f018-45a7-a84b-3bf58f9c69be", "fitness": 0.03726714172220739, "name": "PSO_GA_SA_Optimizer", "description": "A blend of Particle Swarm Optimization, Simulated Annealing, and Genetic Algorithms to enhance diversity and convergence through crossover and mutation.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1  # New mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 7, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03727 with standard deviation 0.04310.", "error": "", "parent_ids": ["3e06758d-719e-4ee4-9d39-4befd5043800"], "operator": null, "metadata": {"aucs": [0.14269552770277638, 0.10270619952063076, 0.1320373329534561, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03302390068101635, 0.020000000000000018, 0.025077186730844025, 0.020000000000000018, 0.020000000000000018, 0.022200991309191842, 0.08316679377057401, 0.04817498707713863, 0.051152265568870536, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.09400607932066052, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07554316868418354, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13600972042041692, 0.10724638731888392, 0.13534597190056785, 0.023584917533062577, 0.020091041721637115, 0.024496276952331475, 0.08072694858327945, 0.08739524888165873, 0.0734470353789285, 0.13679999066162696, 0.13454688041210605, 0.1327304111115999, 0.07026362603016334, 0.0821283584019108, 0.07383360667258276, 0.125847707518293, 0.12223691312474183, 0.15196173891692089, 0.020000000000000018, 0.020000000000000018, 0.10665544597619092, 0.1570380527296379, 0.09330592629628365, 0.0895133107273659, 0.06692136870455723, 0.05217257977436196, 0.056492493752391515, 0.16168003872028447, 0.13589170657517036, 0.15475448018179316, 0.04679029580371208, 0.047134652756161355, 0.033545567365231066, 0.04286720529709076, 0.038341483513037344, 0.061221779518464414, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018998135825996965, 0.010928237744636582, 0.01126354564480092, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012268751403027411, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0775192389600754, 0.06953030371328406, 0.07023151670751548, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0555526805941553, 0.06147825531143891, 0.05402393374660408, 0.12168740743263784, 0.10397549969866948, 0.10392794347817969, 0.06374211781943384, 0.05123739275287609, 0.053936809511723194, 0.09269987023543824, 0.09124071623776164, 0.10994618502491404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027049736138282543, 0.031641546866616466, 0.04965764158487873, 0.04228854565763984, 0.024918913159640232, 0.027772212544817543, 0.13528058477726257, 0.131506553849149, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.01072175563601041, 0.00894510322559905, 0.0, 0.0037070872912139397, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0474041382208773, 0.03637780640966792, 0.032678231570054006, 0.0, 0.0, 0.0, 0.04321291538440464, 0.03753213255583987, 0.038146398713371776, 0.08265800387724398, 0.0903251838626552, 0.07582373261172748, 0.027772114219755784, 0.03384821748095301, 0.02080863421290502, 0.07781076090783601, 0.08134038938271748, 0.0685657302306224, 0.0, 0.0, 0.0, 0.01042779497770785, 0.011239025944269176, 0.013182224605994053, 0.008061981563613152, 0.010051284513262426, 0.008700149636183041, 0.11969203384907334, 0.14378089947082895, 0.11563200149025832, 0.0, 0.0, 0.0]}}
{"id": "3ae1b87a-30ef-4b2d-b91b-83e334a261c9", "fitness": 0.036779050352691356, "name": "PSO_GA_SA_Optimizer", "description": "An optimized hybrid algorithm combining PSO, Simulated Annealing, and Genetic Algorithms enhanced by adaptive inertia weight for improved convergence.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1  # New mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                \n                # Adaptive inertia weight update\n                self.inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 8, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03678 with standard deviation 0.04278.", "error": "", "parent_ids": ["5d54538d-f018-45a7-a84b-3bf58f9c69be"], "operator": null, "metadata": {"aucs": [0.1412644806850324, 0.1034310764606583, 0.13227545543469998, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03358195630688787, 0.020000000000000018, 0.02275555840175203, 0.020000000000000018, 0.020000000000000018, 0.02161427481186806, 0.08308102883465862, 0.04811309937328989, 0.05102082102121075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.10907851753994136, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13524346498745932, 0.10662693721192729, 0.13562138015130698, 0.0217366629347836, 0.020000000000000018, 0.025985203947394675, 0.09436671813122588, 0.0863116411064907, 0.07015575039186472, 0.142323927832801, 0.13742755427285624, 0.12260103776192377, 0.07004604521364888, 0.07990382579724953, 0.06956485753155917, 0.1284262888859522, 0.11320036917378185, 0.1231635917626559, 0.020000000000000018, 0.020000000000000018, 0.10574405449436652, 0.15406705006698074, 0.09477409761313138, 0.0895133107273659, 0.0755902325867478, 0.05299816348357567, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.04080720147585082, 0.037794362406423865, 0.027781048899211624, 0.043575698769149906, 0.03878427465430623, 0.06290328318605143, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018423811868520934, 0.010434596126447704, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013202793621221676, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012970347924154746, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0719675939394433, 0.07073235200342776, 0.06976593198056724, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05395939349942802, 0.12155285411450445, 0.10732911743552809, 0.10628826114679057, 0.0642319146939827, 0.04909201781231487, 0.053936809511723194, 0.09605882270138055, 0.08777787885277188, 0.1030774425940667, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030688163431382143, 0.03952869331899489, 0.05114045021809954, 0.029086863729434476, 0.02428284677441317, 0.027399764595668286, 0.14395087581962684, 0.1378939537100493, 0.13508690610579888, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00879407279144051, 0.0, 0.000557272361979777, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04805809492568214, 0.03848427835738699, 0.02859411792892308, 0.0, 0.0, 0.0, 0.04185621982075516, 0.03963489481576499, 0.03627078428109487, 0.0836160739937688, 0.08879082767989088, 0.0795304786897646, 0.03012742742949759, 0.02541518409246024, 0.021880159007406808, 0.07787705921750343, 0.07652564247828453, 0.06931178688529338, 0.0, 0.0, 0.0, 0.010126057724479831, 0.0109646002421252, 0.012968444887921704, 0.008035057582404304, 0.010051284513262426, 0.009030843012520662, 0.13881663539583255, 0.13226256949527193, 0.11614497991986883, 0.0, 0.0, 0.0]}}
{"id": "6a024c75-ef1e-4153-a077-14e2ce7f13a6", "fitness": 0.03633355244915593, "name": "PSO_GA_SA_Optimizer", "description": "Enhance convergence speed and precision by incorporating Differential Evolution features into the hybrid PSO/GA/SA framework.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.8  # Modified inertia weight\n        self.cognitive_coeff = 1.4  # Modified cognitive coefficient\n        self.social_coeff = 1.4  # Modified social coefficient\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n        self.f = 0.5  # New DE scale factor\n        self.cr = 0.9  # New DE crossover probability\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = self.particles[idxs]\n                mutant_vector = x1 + self.f * (x2 - x3)\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr:\n                        trial_vector[j] = mutant_vector[j]\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                trial_score = func(trial_vector)\n                self.current_evals += 1\n                if trial_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - trial_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 9, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03633 with standard deviation 0.04266.", "error": "", "parent_ids": ["5d54538d-f018-45a7-a84b-3bf58f9c69be"], "operator": null, "metadata": {"aucs": [0.1053004630914458, 0.11385293086301695, 0.1390568103248998, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02843538127732581, 0.020432718359661206, 0.020000000000000018, 0.02187525396832679, 0.020000000000000018, 0.02647504337005724, 0.06362345839181449, 0.041672564843779014, 0.04995403843911672, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04519869246568764, 0.1350485427725553, 0.06623821832059806, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13864752546228432, 0.12951819086210203, 0.1461096771966155, 0.020000000000000018, 0.02098243193321292, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.1471855235886841, 0.16252119730710035, 0.12153308160875809, 0.0794547043124666, 0.09229438428833492, 0.08514026445200651, 0.12301438762971739, 0.11134880440464456, 0.13424461134029653, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.07292120586292017, 0.0895133107273659, 0.07209596590510192, 0.075097757672136, 0.056492493752391515, 0.14840877483151527, 0.13589170657517036, 0.15475448018179316, 0.051603756366775166, 0.04269519527715093, 0.03613921248143326, 0.0492223803909243, 0.029022180646319007, 0.042810499471693464, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020461094253834244, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014471554079051985, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010507476871584376, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06667157153007741, 0.0657092157649024, 0.1024183550798442, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06686447673820306, 0.06147825531143891, 0.05548404709637633, 0.11976082638880536, 0.10557859126010383, 0.10588681176867698, 0.07196236635623843, 0.04921222076698584, 0.055623905017488484, 0.09395450064177269, 0.07547471399093386, 0.10702761246570214, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027846681001032936, 0.03478290487429814, 0.036085430691397025, 0.026949040521561884, 0.026791867470401742, 0.024640285494433645, 0.13889054585471083, 0.13352950582172896, 0.14374021938842096, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0003067980756003008, 0.00025478874026707565, 0.02426885065444362, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04483667047176321, 0.038759509985767604, 0.03207366853239746, 0.0, 0.0, 0.0, 0.030262202767467716, 0.03753213255583987, 0.029778586325735157, 0.0880523258994852, 0.08181997122896023, 0.08731953442791385, 0.020257315054486136, 0.026053931757031523, 0.021534205587281807, 0.08000807998912896, 0.07114633702348616, 0.0812660871767773, 0.0, 0.0, 0.0, 0.011552037776753732, 0.013343800562273578, 0.011093678182594102, 0.008503765131807728, 0.010051284513262426, 0.007837715760786734, 0.11857264496466258, 0.1304161139054778, 0.10812268558701377, 0.0, 0.0, 0.0]}}
{"id": "25c85b42-83e8-4d95-80a5-ba3a395e78fa", "fitness": 0.037260208935832574, "name": "PSO_GA_SA_Optimizer", "description": "Introduced dynamic inertia weight adjustment to balance exploration and exploitation over iterations.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1  # New mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            # Dynamic inertia weight adjustment\n            self.inertia_weight = 0.9 - (0.5 * (self.current_evals / self.budget))\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 10, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03726 with standard deviation 0.04315.", "error": "", "parent_ids": ["5d54538d-f018-45a7-a84b-3bf58f9c69be"], "operator": null, "metadata": {"aucs": [0.14269552770277638, 0.10270619952063076, 0.1320373329534561, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03302390068101635, 0.020000000000000018, 0.025077186730844025, 0.020000000000000018, 0.020000000000000018, 0.022200991309191842, 0.08316679377057401, 0.04817498707713863, 0.051152265568870536, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.09400607932066052, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07554316868418354, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13600972042041692, 0.10724638731888392, 0.13534597190056785, 0.023584917533062577, 0.020091041721637115, 0.024496276952331475, 0.08072694858327945, 0.08739524888165873, 0.0734470353789285, 0.13679999066162696, 0.13454688041210605, 0.1327304111115999, 0.07026362603016334, 0.0821283584019108, 0.07383360667258276, 0.125847707518293, 0.12223691312474183, 0.15196173891692089, 0.020000000000000018, 0.020000000000000018, 0.10665544597619092, 0.1570380527296379, 0.09330592629628365, 0.0895133107273659, 0.06692136870455723, 0.05217257977436196, 0.056492493752391515, 0.16168003872028447, 0.13589170657517036, 0.15475448018179316, 0.04679029580371208, 0.047134652756161355, 0.033545567365231066, 0.04312488506989398, 0.038275047429546905, 0.06338912626587456, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018338220063409127, 0.010623393444307405, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07156324160880156, 0.07059561640743994, 0.0703105560386672, 0.010000000000000009, 0.010000000000000009, 0.010147040354816395, 0.05459995317003097, 0.06147825531143891, 0.05604405276908375, 0.12177009810817419, 0.10454434269225876, 0.10474397892876719, 0.06388512857081086, 0.05148480507241315, 0.053936809511723194, 0.0939248991787055, 0.08668261028486013, 0.10994618502491404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031149566675425677, 0.03907080616763314, 0.04968005909732043, 0.029614830831262928, 0.023690470278644682, 0.02716801214079856, 0.14033479982133545, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009074732653587048, 0.0, 0.0006047700034469417, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0478298177898957, 0.03955940953877635, 0.03282838815161637, 0.0, 0.0, 0.0, 0.04103838743944055, 0.03871071841537732, 0.038146398713371776, 0.08401809791883663, 0.08901818611393186, 0.07846531414261126, 0.029389174322497547, 0.03384821748095301, 0.022246551987179286, 0.07906674273286018, 0.07986356687847807, 0.06947940558937105, 0.0, 0.0, 0.0, 0.010702563946895949, 0.010855920599429303, 0.013035994542460294, 0.008061007688589306, 0.010051284513262426, 0.009031801149030239, 0.11799275144111676, 0.14378089947082895, 0.11563200149025832, 0.0, 0.0, 0.0]}}
{"id": "778bf374-6fc4-4500-a0f9-8c7bccd766c6", "fitness": -Infinity, "name": "Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced exploration by integrating a Lvy flight mechanism and adaptive mutation in a hybrid PSO-GA-SA framework for improved global search capability.", "code": "import numpy as np\n\nclass Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                    (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=size)\n        v = np.random.normal(0, 1, size=size)\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.1 * step\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_strength = np.random.rand() * (self.upper_bound - self.lower_bound) * 0.01\n                    mutation_vector = np.random.normal(0, mutation_strength, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration with Lvy flight\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + self.levy_flight(self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 11, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["5d54538d-f018-45a7-a84b-3bf58f9c69be"], "operator": null, "metadata": {}}
{"id": "baabd7ac-cc9b-4808-8e99-090b693e76ad", "fitness": 0.03687694530852169, "name": "Enhanced_PSO_GA_SA_DE_Optimizer", "description": "Introducing a hybrid optimizer that integrates Differential Evolution into the existing PSO, GA, and SA framework to enhance exploration and exploitation capabilities.", "code": "import numpy as np\n\nclass Enhanced_PSO_GA_SA_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1  # Genetic mutation rate\n        self.F = 0.5  # Differential evolution mutation factor\n        self.CR = 0.9  # Crossover probability for differential evolution\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position using PSO\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Differential Evolution\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                indices = [ind for ind in range(self.population_size) if ind != i]\n                a, b, c = self.particles[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                self.current_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 12, "feedback": "The algorithm Enhanced_PSO_GA_SA_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03688 with standard deviation 0.04184.", "error": "", "parent_ids": ["5d54538d-f018-45a7-a84b-3bf58f9c69be"], "operator": null, "metadata": {"aucs": [0.10561984826270499, 0.09688496488793075, 0.1386878983494998, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.039920064869729655, 0.03768706039136693, 0.020000000000000018, 0.03146347265315086, 0.02413774006493208, 0.020292643802823473, 0.06090894647238254, 0.05689259389308543, 0.05353202947426294, 0.06675765195632977, 0.04177120433554693, 0.020000000000000018, 0.07208507268696251, 0.08594148016760361, 0.06460639107535604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13313749395477514, 0.11697845206268154, 0.1582481606083661, 0.029816261243351794, 0.020000000000000018, 0.020000000000000018, 0.0862926971281226, 0.08965924746767684, 0.07266866995744292, 0.1313406151659765, 0.1530028410290899, 0.12925264173170636, 0.08844189516516765, 0.0856000628185527, 0.064470582674378, 0.1214078971877649, 0.11399414619732029, 0.1244465207018206, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12235157385473405, 0.090984574433713, 0.0895133107273659, 0.06527120746322768, 0.08299569625013337, 0.05925467810423102, 0.14788658928598508, 0.1381523663836427, 0.15475448018179316, 0.04878550181488894, 0.04035668157103711, 0.04828474355110246, 0.0692815892169587, 0.04203905407856812, 0.06003372744815716, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012583109995435438, 0.010000000000000009, 0.012507270188774844, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019659532152442316, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07906720197782957, 0.06789900115303249, 0.08864233762607088, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06191504955621596, 0.05395939349942802, 0.12192707580743345, 0.10649871382059672, 0.10507776527263446, 0.07047038540190442, 0.05552222934107276, 0.053936809511723194, 0.08800062602484138, 0.07662363815590278, 0.10347514917819423, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.043070705833569756, 0.03471498735536249, 0.037345731668079085, 0.04665193234095355, 0.023699725155532314, 0.026273179557399495, 0.13454516119211812, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0014351934593429538, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0518188645019112, 0.044229504019536514, 0.026687785296675037, 0.0, 0.0, 0.0, 0.038347904981896996, 0.03797338122961191, 0.03215554626925299, 0.08072936840952094, 0.0886306709452791, 0.0777997230911347, 0.032826710712905216, 0.024561879367633432, 0.019070195319295546, 0.0764157545801798, 0.0665216385508226, 0.06336308176008643, 0.0, 0.0, 0.0, 0.00998694013100887, 0.011336695559866605, 0.010518509222284145, 0.008248748692411434, 0.010051284513262426, 0.009898643525483752, 0.11965975478480584, 0.1304161139054778, 0.11315925395712867, 0.0, 0.0, 0.0]}}
{"id": "d20560bc-f28d-483b-a5e5-5752aec20317", "fitness": 0.03365736391583494, "name": "AdaptiveHybridOptimizer", "description": "Introduce Adaptive Harmony Search into PSO_GA_SA_Optimizer to dynamically balance exploration and exploitation by adjusting pitch adjustment and harmony memory considerations.", "code": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.hm_consideration_rate = 0.9\n        self.pitch_adjustment_rate = 0.2\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Harmony Memory Consideration\n                if np.random.rand() < self.hm_consideration_rate:\n                    harmony_particle = np.random.choice(self.population_size)\n                    self.particles[i] = self.personal_best_positions[harmony_particle]\n                \n                # Pitch Adjustment\n                if np.random.rand() < self.pitch_adjustment_rate:\n                    adjustment_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += adjustment_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 13, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03366 with standard deviation 0.03954.", "error": "", "parent_ids": ["5d54538d-f018-45a7-a84b-3bf58f9c69be"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.07974239134720762, 0.1299752747246865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02528560063857921, 0.025010003599591046, 0.020000000000000018, 0.020000000000000018, 0.028462621400740074, 0.053062565463101286, 0.053690131323950285, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.08594148016760361, 0.06683735444035388, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09994410407015442, 0.0941907906656021, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.022619940105954917, 0.08072694858327945, 0.0863116411064907, 0.09882927436361344, 0.12990506644848054, 0.13787447546524811, 0.12163747258584212, 0.07943667233554408, 0.07990382579724953, 0.06625773841972005, 0.11205586464406281, 0.10510888718349032, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.11405879284805853, 0.0895133107273659, 0.06527120746322768, 0.054417703198461176, 0.0989007591188954, 0.14568927090979966, 0.13589170657517036, 0.15638455209911395, 0.041359411078631614, 0.03392426887360889, 0.02657375009670604, 0.02775355336272267, 0.018679826500255348, 0.0408220352578591, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014038851609486702, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021540214326037033, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061968640395791974, 0.06636934308949605, 0.06542455977718065, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059348497725780214, 0.06147825531143891, 0.05562954934750097, 0.12333284440759229, 0.09356267114715211, 0.10281775224528589, 0.06010959995011189, 0.03518359929680204, 0.053936809511723194, 0.08598337418667723, 0.08133790810006969, 0.0914851250821187, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025402737663328567, 0.029990690295695455, 0.026018756973356538, 0.026996355914940318, 0.022487143875263516, 0.0252477813802785, 0.13141309820135194, 0.13826285747987965, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.00027301294543835564, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03068158491996198, 0.030163622104217414, 0.018344480915701622, 0.0, 0.0, 0.0, 0.03348139112599957, 0.04404976435436536, 0.0388251084044583, 0.08195416348540863, 0.08305827473618, 0.07101644508719374, 0.02353545684442282, 0.026553876973102852, 0.019610885933736277, 0.06501016208547095, 0.05775643297460331, 0.047303840136902364, 0.0, 0.0, 0.0, 0.009698157186472378, 0.0091307640863737, 0.009433151669329232, 0.007354325247402649, 0.010665604251700711, 0.007259537265468574, 0.11553107148715869, 0.1304161139054778, 0.10737332523161935, 0.0, 0.0, 0.0]}}
{"id": "eb982708-08bc-4c01-8354-aaa2a2245120", "fitness": 0.0372947873388472, "name": "PSO_GA_SA_Optimizer", "description": "Integrate dynamic mutation rate based on evaluation progress to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1  # New mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation with dynamic rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 14, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03729 with standard deviation 0.04322.", "error": "", "parent_ids": ["5d54538d-f018-45a7-a84b-3bf58f9c69be"], "operator": null, "metadata": {"aucs": [0.14269552770277638, 0.10270619952063076, 0.1320373329534561, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03302390068101635, 0.020000000000000018, 0.025077186730844025, 0.020000000000000018, 0.020000000000000018, 0.022200991309191842, 0.08316679377057401, 0.04817498707713863, 0.051152265568870536, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.09400607932066052, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07554316868418354, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13600972042041692, 0.10724638731888392, 0.13534597190056785, 0.023584917533062577, 0.020091041721637115, 0.024496276952331475, 0.08072694858327945, 0.08739524888165873, 0.0734470353789285, 0.13679999066162696, 0.13454688041210605, 0.1327304111115999, 0.07026362603016334, 0.0821283584019108, 0.07383360667258276, 0.125847707518293, 0.12223691312474183, 0.15196173891692089, 0.020000000000000018, 0.020000000000000018, 0.10665544597619092, 0.1570380527296379, 0.09330592629628365, 0.0895133107273659, 0.06692136870455723, 0.05217257977436196, 0.056492493752391515, 0.16168003872028447, 0.13589170657517036, 0.15475448018179316, 0.04679029580371208, 0.047134652756161355, 0.033545567365231066, 0.04855989199626942, 0.0267505332631508, 0.061221779518464414, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014120168932619581, 0.013418006859672538, 0.01126354564480092, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07545290286418893, 0.07155349864706073, 0.07023151670751548, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0625438918107123, 0.05612281540920849, 0.11981927798987613, 0.1103836516917539, 0.10392794347817969, 0.06841654269181419, 0.05585679377936259, 0.053936809511723194, 0.09151290501919906, 0.09296563419551906, 0.10994618502491404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027113926247607445, 0.04042740287086677, 0.05309281060564641, 0.02514455911833513, 0.026400612831771197, 0.027250426745940026, 0.13713646599388796, 0.1318598690740811, 0.1348054281481461, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013085895471344422, 0.0, 0.0012461820186396855, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0474041382208773, 0.03740663877794492, 0.030557156704361432, 0.0, 0.0, 0.0, 0.04103838743944055, 0.038584883387122626, 0.038146398713371776, 0.08265800387724398, 0.09051167577736197, 0.07582373261172748, 0.028443519800438577, 0.03384821748095301, 0.020609228679360547, 0.07781076090783601, 0.07986356687847807, 0.07105062169589316, 0.0, 0.0, 0.0, 0.01042779497770785, 0.010866920553869952, 0.013797357857999848, 0.008061981563613152, 0.010051284513262426, 0.008700149636183041, 0.11969203384907334, 0.14378089947082895, 0.11563200149025832, 0.0, 0.0, 0.0]}}
{"id": "7b70ccd3-1639-4ed3-86c1-73a660c4088e", "fitness": 0.03676398903143555, "name": "PSO_GA_SA_Optimizer", "description": "Adjust inertia weight dynamically based on progress to enhance convergence rate.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                \n                dynamic_inertia_weight = 0.9 - 0.5 * (self.current_evals / self.budget)  # Updated line\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +  # Updated line\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 15, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03676 with standard deviation 0.04280.", "error": "", "parent_ids": ["eb982708-08bc-4c01-8354-aaa2a2245120"], "operator": null, "metadata": {"aucs": [0.1412644806850324, 0.1034310764606583, 0.13227545543469998, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03358195630688787, 0.020000000000000018, 0.02275555840175203, 0.020000000000000018, 0.020000000000000018, 0.02161427481186806, 0.08308102883465862, 0.04811309937328989, 0.05102082102121075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.10907851753994136, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13524346498745932, 0.10662693721192729, 0.13562138015130698, 0.0217366629347836, 0.020000000000000018, 0.025985203947394675, 0.09436671813122588, 0.0863116411064907, 0.07015575039186472, 0.142323927832801, 0.13742755427285624, 0.12260103776192377, 0.07004604521364888, 0.07990382579724953, 0.06956485753155917, 0.1284262888859522, 0.11320036917378185, 0.1231635917626559, 0.020000000000000018, 0.020000000000000018, 0.10574405449436652, 0.15406705006698074, 0.09477409761313138, 0.0895133107273659, 0.0755902325867478, 0.05299816348357567, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.04080720147585082, 0.037794362406423865, 0.027781048899211624, 0.04850513664499223, 0.02488796176167396, 0.06515845147021093, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014252272105409802, 0.011217403715040208, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06609938331105536, 0.072606288319231, 0.06976593198056724, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05395939349942802, 0.12194972770013035, 0.10517137252495179, 0.10281775224528589, 0.07889200158142284, 0.05378396552577713, 0.05682121634388837, 0.09137466136365358, 0.09148648624603373, 0.1030774425940667, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026989094412537717, 0.03949279745851941, 0.04985988809496944, 0.0252756102952868, 0.024854867798195568, 0.02701738938698084, 0.14395087581962684, 0.13123409970527322, 0.13690091051972564, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013169930739389213, 0.0, 0.0015554831735791197, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04805809492568214, 0.037756176137389574, 0.03164233510529901, 0.0, 0.0, 0.0, 0.041856219820764595, 0.03833666842981176, 0.03627078428109487, 0.0836160739937688, 0.08946729111667184, 0.0795304786897646, 0.029696749672886158, 0.027844213430812892, 0.022000965128186722, 0.07787705921750343, 0.07652564247828453, 0.07026756154456293, 0.0, 0.0, 0.0, 0.010126057724479831, 0.011070812122894402, 0.013903990884182926, 0.008035057582404304, 0.010051284513262426, 0.009030843012520662, 0.13881663539583255, 0.13226256949527193, 0.11942395523834437, 0.0, 0.0, 0.0]}}
{"id": "1316e792-f80b-43b1-b0b2-f840ccf6acd4", "fitness": -0.02986279211027861, "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive learning rates and multi-swarm coordination to dynamically balance exploration and exploitation for enhanced optimization performance.", "code": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.current_evals = 0\n        self.mutation_rate = 0.1\n        self.swarm_count = 3\n\n        # Initialize swarms\n        self.swarms = [self._initialize_swarm() for _ in range(self.swarm_count)]\n\n    def _initialize_swarm(self):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = np.zeros(self.dim)\n        global_best_score = float('inf')\n        return {\n            \"particles\": particles,\n            \"velocities\": velocities,\n            \"personal_best_positions\": personal_best_positions,\n            \"personal_best_scores\": personal_best_scores,\n            \"global_best_position\": global_best_position,\n            \"global_best_score\": global_best_score\n        }\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for swarm in self.swarms:\n                particles = swarm[\"particles\"]\n                velocities = swarm[\"velocities\"]\n                personal_best_positions = swarm[\"personal_best_positions\"]\n                personal_best_scores = swarm[\"personal_best_scores\"]\n                global_best_position = swarm[\"global_best_position\"]\n                global_best_score = swarm[\"global_best_score\"]\n\n                for i in range(self.population_size):\n                    # Evaluate fitness\n                    score = func(particles[i])\n                    self.current_evals += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = particles[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = particles[i].copy()\n\n                    # Update velocity and position with adaptive learning rates\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    learning_rate = 0.5 + (0.5 * self.current_evals / self.budget)\n                    cognitive_velocity = learning_rate * self.cognitive_coeff * r1 * (personal_best_positions[i] - particles[i])\n                    social_velocity = learning_rate * self.social_coeff * r2 * (global_best_position - particles[i])\n                    velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                    particles[i] += velocities[i]\n\n                    # Ensure particles are within bounds\n                    particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n\n                    # Apply mutation with dynamic rate\n                    dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                    if np.random.rand() < dynamic_mutation_rate:\n                        mutation_vector = np.random.normal(0, 1, self.dim)\n                        particles[i] += mutation_vector\n                        particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n\n                # Update global best for the swarm\n                swarm[\"global_best_position\"] = global_best_position\n                swarm[\"global_best_score\"] = global_best_score\n\n            # Swarm coordination\n            best_swarm = min(self.swarms, key=lambda s: s[\"global_best_score\"])\n            for swarm in self.swarms:\n                if np.random.rand() < 0.5:\n                    swarm[\"global_best_position\"] = best_swarm[\"global_best_position\"]\n                    swarm[\"global_best_score\"] = best_swarm[\"global_best_score\"]\n\n        # Return the best position and score found\n        best_swarm = min(self.swarms, key=lambda s: s[\"global_best_score\"])\n        return best_swarm[\"global_best_position\"], best_swarm[\"global_best_score\"]", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02986 with standard deviation 0.11386.", "error": "", "parent_ids": ["eb982708-08bc-4c01-8354-aaa2a2245120"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.12348833090107103, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020295376689952294, 0.0211362780617389, 0.07396305085998622, 0.055768252647667826, 0.060643492043757075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029648639398641707, 0.08594148016760361, 0.06896121963328417, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1101133250360653, 0.1496148607094101, 0.1319606165694367, 0.040631117045411, 0.03492330279238676, 0.020000000000000018, 0.11191920853867388, 0.0863116411064907, 0.0822157670957746, 0.12990506644848054, 0.13323277534341382, 0.14243566322505752, 0.06737252964817986, 0.07990382579724953, 0.08043876116275528, 0.12033722849236428, 0.1095529550571146, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.07520566670458595, 0.09734502640454634, 0.06933604870818644, 0.046654443254379285, 0.056492493752391515, 0.1482865420069157, 0.13602009687464944, 0.15475448018179316, 0.038669801718039354, 0.042155338115487107, 0.02862818547725343, 0.045874580443729496, 0.05994703069833063, 0.05553546792008479, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08710760552572339, 0.07634850230044721, 0.07795110339007683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0651434270636847, 0.05395939349942802, 0.12668103136097542, 0.1013818350842085, 0.10464082242859829, 0.06804896492598456, 0.044491549334428115, 0.05419638711581887, 0.09459674731687284, 0.08278682745430332, 0.09813056149483645, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028448370392701428, 0.03281771313742621, 0.038732119444667146, 0.0320577924648775, 0.02317577698018236, 0.02486832447995424, 0.1425687631537984, 0.14051923111392173, 0.1349187489941004, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19615215756607163, -0.19538321582764584, -0.19996545108991404, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1441946082525134, -0.15916112044459685, -0.16636533584483915, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.16073175340679335, -0.13883486186017868, -0.15361880489392155, -0.10093158741759556, -0.09987104294890581, -0.09478575693017488, -0.17032973325768852, -0.1689242844883796, -0.1603987609234998, -0.10941984838427876, -0.12098097878776337, -0.12693879880255565, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18722088304809326, -0.1880792703020595, -0.18726539578849177, -0.19110048129507184, -0.18780676904453797, -0.18924600760016563, -0.06449301712455524, -0.042069699210217415, -0.0636528712690203, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "ce7d679b-f6db-4a27-8bb2-3887078ac4bd", "fitness": 0.036613722141558364, "name": "ImprovedPSO_GA_SA_Optimizer", "description": "Introduce adaptive learning factors and chaotic maps to enhance exploration and convergence capabilities.", "code": "import numpy as np\n\nclass ImprovedPSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        \n        # Initialize chaotic map value\n        self.chaotic_value = np.random.rand()\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update chaotic map\n                self.chaotic_value = 4 * self.chaotic_value * (1 - self.chaotic_value)\n\n                # Adaptive learning factors\n                r1 = self.chaotic_value\n                r2 = np.random.rand()\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation with dynamic rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 17, "feedback": "The algorithm ImprovedPSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03661 with standard deviation 0.04227.", "error": "", "parent_ids": ["eb982708-08bc-4c01-8354-aaa2a2245120"], "operator": null, "metadata": {"aucs": [0.09977759594969826, 0.09841739723150422, 0.13724333363539865, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03555428649265535, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07095690208771233, 0.05698846534525248, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05326677420019155, 0.08674605356041543, 0.0961711738654597, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13647066080236614, 0.1111333446235625, 0.17528932205471992, 0.026398617666962387, 0.02037043401120342, 0.020000000000000018, 0.10791728778802367, 0.0863116411064907, 0.07015575039186472, 0.12990506644848054, 0.13323277534341382, 0.11754439179374332, 0.06320204227841064, 0.07990382579724953, 0.07394012228286873, 0.1238390659645403, 0.10716377198299609, 0.1241744873340821, 0.020000000000000018, 0.020000000000000018, 0.03578076085166093, 0.14688891625187606, 0.08057830543551903, 0.09639863038872765, 0.06527120746322768, 0.07938516477317559, 0.056492493752391515, 0.1438526290318487, 0.14360110951727023, 0.15475448018179316, 0.05545533449594697, 0.034683238573708364, 0.03986583714641001, 0.04409544388940656, 0.02786196692554055, 0.049129093286407466, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023007626882044607, 0.011256030536485495, 0.012976879080320636, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08417905058399366, 0.06385447419425294, 0.08851604451422146, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06608381233398619, 0.059877456940018337, 0.12606908779015613, 0.1131320244178542, 0.10281775224528589, 0.07163596461035782, 0.04188542478381907, 0.053936809511723194, 0.09076351367528968, 0.08501869939077311, 0.10380476215994161, 0.05553492877393751, 0.010000000000000009, 0.010000000000000009, 0.02584984222725084, 0.03772997897702424, 0.05622248606848412, 0.034697363436269724, 0.023526831532595938, 0.02606978565417928, 0.13141309820135194, 0.13208793251968387, 0.14857554378949456, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.008365388993990752, 0.0, 0.002108913860922157, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04663893456651769, 0.03610344299933943, 0.03927586610312939, 0.0, 0.0, 0.0, 0.0332602355313516, 0.03753213255583987, 0.03713450065802504, 0.08699828172943258, 0.08719968358779573, 0.07756136080011311, 0.02474617101527643, 0.03355099802004535, 0.019177692358609, 0.07729034738910567, 0.06812848928403115, 0.06874215056867683, 0.0, 0.0, 0.0, 0.01085599356506306, 0.0114791594161745, 0.0106341504020393, 0.007699841144149566, 0.010051284513262426, 0.008018316524841862, 0.12260289411940117, 0.1304161139054778, 0.11213897277666063, 0.0, 0.0, 0.0]}}
{"id": "70d0e3c3-960c-4a1f-bd3b-f4ce2d24020c", "fitness": 0.0371351866151367, "name": "PSO_GA_SA_Optimizer", "description": "Enhance velocity update mechanism by introducing adaptive inertia weight based on progress.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1  # New mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                adaptive_inertia = self.inertia_weight * (1 - self.current_evals / self.budget) + 0.4\n                self.velocities[i] = (adaptive_inertia * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation with dynamic rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 18, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03714 with standard deviation 0.04272.", "error": "", "parent_ids": ["eb982708-08bc-4c01-8354-aaa2a2245120"], "operator": null, "metadata": {"aucs": [0.14777361232074182, 0.10359146992696455, 0.13060859169418138, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03107262528326371, 0.024267102236196103, 0.020000000000000018, 0.020000000000000018, 0.047975022130356426, 0.020000000000000018, 0.08349778635150851, 0.051938990627267256, 0.04959331325760474, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0442455848835166, 0.09687700589719617, 0.0833859044811015, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14006443166438232, 0.10988122980980752, 0.13391463043973728, 0.02777407387110742, 0.020000000000000018, 0.02390692841457609, 0.08072694858327945, 0.0863116411064907, 0.08468070010374118, 0.12990506644848054, 0.1433902620040054, 0.12509977165171737, 0.07066514522398792, 0.07990382579724953, 0.06743458388616308, 0.1251502944983125, 0.12360097913630297, 0.12857069813676358, 0.020000000000000018, 0.020000000000000018, 0.10869384105198776, 0.1604586793476589, 0.07292120586292017, 0.0895133107273659, 0.06527120746322768, 0.06760215786565438, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05564314671592485, 0.03818234155274636, 0.03492352112551178, 0.04863794056092008, 0.030347019455900903, 0.061380258301577006, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014370878262605524, 0.01016002910884084, 0.01340891878881445, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012969151813517765, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08959464616961643, 0.0715363138947509, 0.06702393540155926, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.061502918125486694, 0.05395939349942802, 0.13098430494391233, 0.10477145209214367, 0.10281775224528589, 0.07394451214397824, 0.054221072862661424, 0.053936809511723194, 0.0854616738235745, 0.0893689382379208, 0.10262067383563755, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027360273099117594, 0.04221428033515284, 0.048728451074517065, 0.024895242935785933, 0.03403723495475086, 0.026895905079915683, 0.14379390331441844, 0.14229959188615737, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012751218498794237, 0.0, 0.006519942301502657, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.044561368515343425, 0.03783141484845276, 0.03724951250771169, 0.0, 0.0, 0.0, 0.03596363576907835, 0.04037256858283811, 0.039693160117198145, 0.08433995510086278, 0.08871043431624803, 0.07899021924033134, 0.027607490128060963, 0.026234746744719817, 0.023344678018050624, 0.07584391788397782, 0.07560846185695635, 0.07139864687607245, 0.0, 0.0, 0.0, 0.013878252961915027, 0.012531069127700967, 0.013655256356213119, 0.008201577766828283, 0.010051284513262426, 0.008976707330120903, 0.11825053693401588, 0.1304161139054778, 0.1165825162092683, 0.0, 0.0, 0.0]}}
{"id": "46d2442c-fff4-46b9-bc01-3c60d421395b", "fitness": 0.03732517593479709, "name": "PSO_GA_SA_Optimizer", "description": "Introduce adaptive inertia weight and cooling schedule to improve convergence and exploration dynamics.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)  # Change 1\n            adjusted_cooling_rate = 0.99 + 0.01 * (self.current_evals / self.budget)     # Change 2\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +  # Change 3\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation with dynamic rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= adjusted_cooling_rate  # Change 4\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 19, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03733 with standard deviation 0.04324.", "error": "", "parent_ids": ["eb982708-08bc-4c01-8354-aaa2a2245120"], "operator": null, "metadata": {"aucs": [0.14269552770277638, 0.10270619952063076, 0.1320373329534561, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03302390068101635, 0.020000000000000018, 0.025077186730844025, 0.020000000000000018, 0.020000000000000018, 0.022200991309191842, 0.08316679377057401, 0.04817498707713863, 0.051152265568870536, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.09400607932066052, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07554316868418354, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13600972042041692, 0.10724638731888392, 0.13534597190056785, 0.023584917533062577, 0.020091041721637115, 0.024496276952331475, 0.08072694858327945, 0.08739524888165873, 0.0734470353789285, 0.13679999066162696, 0.13454688041210605, 0.1327304111115999, 0.07026362603016334, 0.0821283584019108, 0.07383360667258276, 0.125847707518293, 0.12223691312474183, 0.15196173891692089, 0.020000000000000018, 0.020000000000000018, 0.10665544597619092, 0.1570380527296379, 0.09330592629628365, 0.0895133107273659, 0.06692136870455723, 0.05217257977436196, 0.056492493752391515, 0.16168003872028447, 0.13589170657517036, 0.15475448018179316, 0.04679029580371208, 0.047134652756161355, 0.033545567365231066, 0.04875153417934153, 0.025142887060776165, 0.06328332478475895, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014132097125169607, 0.011639922783229562, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010168433180383518, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017956461564855086, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06649304712770432, 0.07184120085910284, 0.0703105560386672, 0.010000000000000009, 0.010000000000000009, 0.010147040354816395, 0.05459995317003097, 0.06147825531143891, 0.05402393374660408, 0.11936606040574194, 0.10743726485175487, 0.10759875682900588, 0.06850588021124038, 0.05585679377936259, 0.05638324229361402, 0.08617867458589468, 0.09328487812215192, 0.10994618502491404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027113926247607445, 0.039718214876246494, 0.04965764158487873, 0.025250568956544206, 0.024669555956284395, 0.026953628674816654, 0.13572642606896634, 0.13781375042010158, 0.13445236571765318, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013217598026632249, 0.0, 0.0013601519142955043, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0478298177898957, 0.03768386488580844, 0.030699960397395976, 0.0, 0.0, 0.0, 0.04103838743944055, 0.03753213255583987, 0.038146398713371776, 0.08401809791883663, 0.08982676361123998, 0.07846531414261126, 0.03028592212025072, 0.03384821748095301, 0.02584761189121343, 0.07781076090783601, 0.07986356687847807, 0.07271045229028861, 0.0, 0.0, 0.0, 0.010702563946895949, 0.011074561970081498, 0.01389723936771492, 0.008061007688589306, 0.010051284513262426, 0.009031801149030239, 0.11799275144111676, 0.14378089947082895, 0.12083952851711988, 0.0, 0.0, 0.0]}}
{"id": "cf39b5a6-50dd-4f2e-b05f-d10f6334d8c4", "fitness": -0.07707874785698508, "name": "PSO_GA_SA_Optimizer", "description": "Enhance the balance between exploration and exploitation by introducing dynamic population size and adaptive velocity scaling in a hybrid PSO-GA-SA framework.", "code": "import numpy as np\n\nclass PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.max_population_size = 40\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.population_size = self.initial_population_size\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            # Dynamic adjustments\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adjusted_cooling_rate = 0.99 + 0.01 * (self.current_evals / self.budget)\n            dynamic_population_size = int(self.initial_population_size + \n                                          (self.max_population_size - self.initial_population_size) * \n                                          (self.current_evals / self.budget))\n            velocity_scaling_factor = 1 + 0.5 * (self.current_evals / self.budget)\n\n            # Adjust population size\n            if dynamic_population_size > self.population_size:\n                additional_particles = dynamic_population_size - self.population_size\n                new_particles = np.random.uniform(self.lower_bound, self.upper_bound, (additional_particles, self.dim))\n                self.particles = np.vstack((self.particles, new_particles))\n                new_velocities = np.random.uniform(-1, 1, (additional_particles, self.dim))\n                self.velocities = np.vstack((self.velocities, new_velocities))\n                new_personal_best_scores = np.full(additional_particles, float('inf'))\n                self.personal_best_scores = np.concatenate((self.personal_best_scores, new_personal_best_scores))\n                self.personal_best_positions = np.vstack((self.personal_best_positions, new_particles))\n                self.population_size = dynamic_population_size\n\n            for i in range(self.population_size):\n                # Evaluate fitness\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] + \n                                      cognitive_velocity + social_velocity) * velocity_scaling_factor\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Apply mutation with dynamic rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= adjusted_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 20, "feedback": "The algorithm PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.07708 with standard deviation 0.18147.", "error": "", "parent_ids": ["46d2442c-fff4-46b9-bc01-3c60d421395b"], "operator": null, "metadata": {"aucs": [0.14269552770277638, 0.10270619952063076, 0.1320373329534561, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03302390068101635, 0.020000000000000018, 0.025077186730844025, 0.020000000000000018, 0.020000000000000018, 0.022200991309191842, 0.08316679377057401, 0.04817498707713863, 0.051152265568870536, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03442426860268488, 0.08594148016760361, 0.09400607932066052, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07554316868418354, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13600972042041692, 0.10724638731888392, 0.13534597190056785, 0.023584917533062577, 0.020091041721637115, 0.024496276952331475, 0.08072694858327945, 0.08739524888165873, 0.0734470353789285, 0.13679999066162696, 0.13454688041210605, 0.1327304111115999, 0.07026362603016334, 0.0821283584019108, 0.07383360667258276, 0.125847707518293, 0.12223691312474183, 0.15196173891692089, 0.020000000000000018, 0.020000000000000018, 0.10665544597619092, 0.1570380527296379, 0.09330592629628365, 0.0895133107273659, 0.06692136870455723, 0.05217257977436196, 0.056492493752391515, 0.16168003872028447, 0.13589170657517036, 0.15475448018179316, 0.04679029580371208, 0.047134652756161355, 0.033545567365231066, 0.04367977690384406, 0.033127135357856385, 0.06279557692751281, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014020240675511553, 0.010806310561782051, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06430725527457026, 0.0800806380827861, 0.07343426466262726, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05625879541525536, 0.06274404244155274, 0.05402393374660408, 0.12045661859942014, 0.11147320125545757, 0.10689907354428074, 0.0664728631961995, 0.05629870583187968, 0.054535810282885566, 0.09107631517420545, 0.09296563419551906, 0.10994618502491404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030499492298302844, 0.03909052353992981, 0.04965764158487873, 0.024895242935785933, 0.025102121468360994, 0.02615084483540242, 0.13528058477726257, 0.13413169037997097, 0.1368384824415415, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.3328544485800906, -0.3500000000000001, -0.3442009971752611, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.2849674230178656, -0.2971397836422305, -0.3002222691087788, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.2929142421890054, -0.2968976089483917, -0.2967272248171682, -0.235583946746879, -0.22878364904506077, -0.24221553947046015, -0.3066876653181765, -0.302571269682282, -0.32434438956537326, -0.24161999883944318, -0.23565471730682463, -0.2512179960944778, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001, -0.333498641983887, -0.3349357947424667, -0.33241423164513173, -0.339273776994492, -0.33620030921288757, -0.33768302892084545, -0.18280939192812284, -0.15373963956715442, -0.1916394369756027, -0.3500000000000001, -0.3500000000000001, -0.3500000000000001]}}
{"id": "656fdc10-7c4a-4e26-8e21-d6dfddd2dbcc", "fitness": 0.03783286379288962, "name": "Enhanced_PSO_GA_SA_Optimizer", "description": "Integrate adaptive swarm diversity control and elitist learning strategies to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adjusted_cooling_rate = 0.99 + 0.01 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adjusted_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 21, "feedback": "The algorithm Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03783 with standard deviation 0.04305.", "error": "", "parent_ids": ["46d2442c-fff4-46b9-bc01-3c60d421395b"], "operator": null, "metadata": {"aucs": [0.129724293710911, 0.08770485760826074, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.038056664673542184, 0.02804438703032308, 0.02739612751035836, 0.02638595451019854, 0.020000000000000018, 0.020000000000000018, 0.06897410761607947, 0.04571476654601048, 0.052868185984048965, 0.020000000000000018, 0.04804782806236729, 0.020000000000000018, 0.029673563635418843, 0.1073963099400026, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13008912807843587, 0.10989230686690432, 0.13084903150896143, 0.026190607776297004, 0.03335870908822869, 0.020000000000000018, 0.08798491804384156, 0.0863116411064907, 0.07934231505328637, 0.15207424465284758, 0.1409621568643712, 0.1160417955509998, 0.08202275767594014, 0.08910241066565305, 0.07060836199861564, 0.1396798720146143, 0.11805383954676674, 0.13140936910034073, 0.020000000000000018, 0.031876454654310216, 0.11543800639898683, 0.10819636878037442, 0.10114468397554166, 0.0895133107273659, 0.06694543657217678, 0.08673301425325863, 0.08017885823061699, 0.1438526290318487, 0.1615981488273326, 0.15643588568825317, 0.05561983407376103, 0.06336397484114076, 0.03142505684023322, 0.055929406599525944, 0.041368818557508846, 0.04727373908989363, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015394237728757365, 0.010000000000000009, 0.012060864647309488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09118405456288159, 0.07031160110371648, 0.07785893813510625, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05980894848238816, 0.13024202688033393, 0.10672676194030606, 0.10554848007101258, 0.06529124376082374, 0.04433744899761893, 0.055063176561625404, 0.1151179562292306, 0.0919147941237719, 0.10523484328184163, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028196829043476312, 0.04346064502338709, 0.0485845194357194, 0.033839399883083154, 0.026033922767967677, 0.028215160296564346, 0.13159659655424316, 0.13483362961512857, 0.13567927031294258, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.009977906700928019, 2.4745475823428897e-05, 0.0034544719251896616, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04145884478864237, 0.04512879029509731, 0.035869615668791544, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.0868167707718841, 0.08643245041688996, 0.0806641952599999, 0.02441709198606279, 0.03211594830074238, 0.0262161308865414, 0.08790662990447307, 0.07932093329664514, 0.07456826064271271, 0.0, 0.0, 0.0, 0.010930474457600092, 0.01124511294575048, 0.011426553452878019, 0.007572388534343832, 0.010051284513262426, 0.009531227098463546, 0.11557273811935442, 0.1304161139054778, 0.10645334874496537, 0.0, 0.0, 0.0]}}
{"id": "c141465f-2f20-41cc-89af-ddbcbb4fd435", "fitness": 0.03809658747390368, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Leverage dynamic elite swapping and adaptive cooling strategies to enhance convergence and robustness in multi-modal landscapes.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 22, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03810 with standard deviation 0.04309.", "error": "", "parent_ids": ["656fdc10-7c4a-4e26-8e21-d6dfddd2dbcc"], "operator": null, "metadata": {"aucs": [0.129724293710911, 0.08770485760826074, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.038056664673542184, 0.02804438703032308, 0.02739612751035836, 0.02638595451019854, 0.020000000000000018, 0.020000000000000018, 0.06897410761607947, 0.04571476654601048, 0.052868185984048965, 0.020000000000000018, 0.04804782806236729, 0.020000000000000018, 0.029673563635418843, 0.1073963099400026, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13008912807843587, 0.10989230686690432, 0.13084903150896143, 0.026190607776297004, 0.03335870908822869, 0.020000000000000018, 0.08798491804384156, 0.0863116411064907, 0.07934231505328637, 0.15207424465284758, 0.1409621568643712, 0.1160417955509998, 0.08202275767594014, 0.08910241066565305, 0.07060836199861564, 0.1396798720146143, 0.11805383954676674, 0.13140936910034073, 0.020000000000000018, 0.031876454654310216, 0.11543800639898683, 0.10819636878037442, 0.10114468397554166, 0.0895133107273659, 0.06694543657217678, 0.08673301425325863, 0.08017885823061699, 0.1438526290318487, 0.1615981488273326, 0.15643588568825317, 0.05561983407376103, 0.06336397484114076, 0.03142505684023322, 0.056291775289731394, 0.03807040432032782, 0.04502878700682389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01436842533050997, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09824894976093024, 0.0725586276742578, 0.07672279144514538, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06167858343109078, 0.05898755351602569, 0.13024202688033393, 0.10672676194030606, 0.10554848007101258, 0.06604029554470481, 0.04645680525636142, 0.05542339927412965, 0.1151179562292306, 0.09054271134209291, 0.10299439307972391, 0.049957023956989755, 0.010000000000000009, 0.010000000000000009, 0.03158756347293845, 0.054936633806419444, 0.04466415577516192, 0.034291284604191064, 0.02571510693552226, 0.02863732059457147, 0.13155659444263756, 0.13483362961512857, 0.1376815257799805, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.009573485385090619, 0.0016098218025749622, 0.003828336606564342, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04182026076023215, 0.045592671303820165, 0.03097017398105051, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.0868167707718841, 0.08644195778802699, 0.08089909618416502, 0.02832630300063943, 0.033438257842061336, 0.0244498589101666, 0.08551450040033814, 0.07886686914280683, 0.07585748958325123, 0.0, 0.0, 0.0, 0.010930474457600092, 0.01124511294575048, 0.011372571252873942, 0.007891443124806719, 0.010658810307096145, 0.009338237799093152, 0.11557273811935442, 0.1304161139054778, 0.11078099043815437, 0.0, 0.0, 0.0]}}
{"id": "2b790a3e-7d2d-4c18-87f2-a96e1becb5cf", "fitness": 0.0383635172742922, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Leverage dynamic elite swapping and a slightly increased adaptive mutation rate to enhance exploration and convergence in multi-modal landscapes.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 23, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03836 with standard deviation 0.04384.", "error": "", "parent_ids": ["c141465f-2f20-41cc-89af-ddbcbb4fd435"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.0839450790977253, 0.0862026053078705, 0.07060836199861564, 0.15540823504255796, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304171, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.056291775289731394, 0.025645394454639203, 0.04467355870919232, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01436842533050997, 0.010859039880770083, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09824894976093024, 0.06674718057880313, 0.07729746675840521, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05898755351602569, 0.13024202688033393, 0.1007715324307924, 0.10878101076094604, 0.06604029554470481, 0.04480230022655163, 0.05419827627927365, 0.1151179562292306, 0.09197276408735666, 0.10396731586450647, 0.049957023956989755, 0.010000000000000009, 0.010000000000000009, 0.03158756347293845, 0.03886849630342626, 0.05300193353481897, 0.034291284604191064, 0.025401469006308908, 0.029119455061328403, 0.13155659444263756, 0.13248938574173508, 0.1337832524086161, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.009573485385090619, 0.0016098218025749622, 0.00701622289784154, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04182026076023215, 0.04615015847145865, 0.031836518355168875, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.0868167707718841, 0.08636316923206055, 0.0814545885943525, 0.02832630300063943, 0.031722861846575134, 0.026122919657381338, 0.08551450040033814, 0.07886686914280683, 0.07787329541492194, 0.0, 0.0, 0.0, 0.010930474457600092, 0.01124511294575048, 0.011110886751444005, 0.007891443124806719, 0.010329269741772618, 0.009338237799093152, 0.11557273811935442, 0.1304161139054778, 0.11078099043815437, 0.0, 0.0, 0.0]}}
{"id": "e69eb94e-c15a-4683-83b0-ce789fde31ba", "fitness": 0.0372868096719074, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introduce dynamic social coefficient to better adapt exploration and exploitation over time.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                # Dynamic social coefficient\n                dynamic_social_coeff = self.social_coeff * (0.5 + 0.5 * (self.current_evals / self.budget))\n                social_velocity = dynamic_social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 24, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03729 with standard deviation 0.04318.", "error": "", "parent_ids": ["2b790a3e-7d2d-4c18-87f2-a96e1becb5cf"], "operator": null, "metadata": {"aucs": [0.1409125026634337, 0.10462093515846083, 0.15549977146388305, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02707743929514861, 0.027447907992018905, 0.02337922125208236, 0.020293653871103268, 0.030924272345118187, 0.020000000000000018, 0.049834101565292555, 0.04089031357367734, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02584571170577421, 0.09807604622128041, 0.06205769213222323, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13542955351211705, 0.08895154839738995, 0.13084903150896143, 0.021730628181951817, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.09581741956809753, 0.07934231505328637, 0.14162956727768516, 0.1513775673395924, 0.13086323766267105, 0.08747186755749492, 0.07990382579724953, 0.06570345850998249, 0.12392016282605856, 0.10363174760384908, 0.12835952754563384, 0.020000000000000018, 0.03017417904757136, 0.12365378358662227, 0.10819636878037442, 0.10395928741392824, 0.10862157217161017, 0.08005451958420284, 0.07829859781841231, 0.0680097023427726, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.04855392215788057, 0.037316683947038354, 0.037973860295475115, 0.053485671727976136, 0.030581466216097808, 0.05290834248005882, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010128029445003683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012059135670363097, 0.012332666265755465, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08859733681490323, 0.0728077595070481, 0.08198501700572836, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05886863298719103, 0.06147825531143891, 0.05395939349942802, 0.14080845549149512, 0.11976384324885925, 0.10314060277569725, 0.0800036355427074, 0.05556824761747048, 0.05437943294357406, 0.09523877443085316, 0.09315100338617688, 0.11874254761448655, 0.02777612787385808, 0.010000000000000009, 0.010000000000000009, 0.03446788838896464, 0.029043163533977734, 0.046443507690244856, 0.03325945326321178, 0.02563503276444934, 0.026212920906125037, 0.13141309820135194, 0.14516617890920547, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0063973577270316495, 7.215414229655437e-06, 0.003019066608535459, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0407394314710714, 0.042788637961115095, 0.030815205253545863, 0.0, 0.0, 0.0, 0.03896614264153331, 0.03753213255583987, 0.02972044757432102, 0.08473963314014199, 0.08639215236372122, 0.08248923746638437, 0.02818054380969659, 0.028974988917327527, 0.0250004280472228, 0.0908208020147191, 0.08075627541364017, 0.08114245316742053, 0.0, 0.0, 0.0, 0.013481728561428374, 0.01160168080395596, 0.011853853795105729, 0.01127670623617949, 0.010051284513262426, 0.009694128434381444, 0.11271254298776678, 0.1304161139054778, 0.10975224914279791, 0.0, 0.0, 0.0]}}
{"id": "01ca56d7-d1f4-4882-89d1-eec1dbf29ea9", "fitness": 0.038193290919109474, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Fine-tune inertia and mutation adaptivity to enhance convergence dynamics in diverse landscapes.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.3 + 0.6 * (1 - self.current_evals / self.budget)  # Refined inertia weight\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - 0.5 * self.current_evals / self.budget)  # Refined mutation adaptivity\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 25, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03819 with standard deviation 0.04392.", "error": "", "parent_ids": ["2b790a3e-7d2d-4c18-87f2-a96e1becb5cf"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.08394507909772542, 0.0862026053078705, 0.07060836199861564, 0.15540823504256307, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304193, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.05622629348325392, 0.025719286100323036, 0.04463861919176315, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013952615333174045, 0.010616289461145234, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.0102662862087185, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09818201215852251, 0.06552448864054472, 0.07759681827534304, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055821334244387955, 0.062276189541616955, 0.05898755351602569, 0.1320220635230086, 0.10145439420525815, 0.10786414763567531, 0.06587996988259281, 0.04310201399926039, 0.053936809511723194, 0.11518549986416882, 0.09088114931914493, 0.10744185298890996, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03209681217611571, 0.03857694338064721, 0.05243450686440365, 0.034439335960984474, 0.02592964389146757, 0.02796742441174871, 0.13155659444263756, 0.1351137360946444, 0.13416672186331946, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.010016413021461501, 0.001897007683883789, 0.004071619862085818, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04204967222122635, 0.04625604058957722, 0.03262680100087867, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.045611138661814876, 0.08873172189200806, 0.08367542388880567, 0.08244681868425674, 0.029269606079403543, 0.031582609804143846, 0.025116195523648965, 0.08551450040033803, 0.07816919895156871, 0.07537391995979192, 0.0, 0.0, 0.0, 0.011169519392934313, 0.01124511294575048, 0.012670359825273758, 0.00856762786639853, 0.010477113524238635, 0.009736267700085954, 0.11557273811935442, 0.1304161139054778, 0.11049314522398124, 0.0, 0.0, 0.0]}}
{"id": "8b908f94-3673-454f-aa95-c8434012f119", "fitness": 0.0383635172742922, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhance the elite dynamic swapping strategy by increasing the swapping frequency to improve solution exploration.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % self.population_size == 0:  # Increased swapping frequency\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 26, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03836 with standard deviation 0.04384.", "error": "", "parent_ids": ["2b790a3e-7d2d-4c18-87f2-a96e1becb5cf"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.0839450790977253, 0.0862026053078705, 0.07060836199861564, 0.15540823504255796, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304171, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.056291775289731394, 0.025645394454639203, 0.04467355870919232, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01436842533050997, 0.010859039880770083, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09824894976093024, 0.06674718057880313, 0.07729746675840521, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05898755351602569, 0.13024202688033393, 0.1007715324307924, 0.10878101076094604, 0.06604029554470481, 0.04480230022655163, 0.05419827627927365, 0.1151179562292306, 0.09197276408735666, 0.10396731586450647, 0.049957023956989755, 0.010000000000000009, 0.010000000000000009, 0.03158756347293845, 0.03886849630342626, 0.05300193353481897, 0.034291284604191064, 0.025401469006308908, 0.029119455061328403, 0.13155659444263756, 0.13248938574173508, 0.1337832524086161, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.009573485385090619, 0.0016098218025749622, 0.00701622289784154, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04182026076023215, 0.04615015847145865, 0.031836518355168875, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.0868167707718841, 0.08636316923206055, 0.0814545885943525, 0.02832630300063943, 0.031722861846575134, 0.026122919657381338, 0.08551450040033814, 0.07886686914280683, 0.07787329541492194, 0.0, 0.0, 0.0, 0.010930474457600092, 0.01124511294575048, 0.011110886751444005, 0.007891443124806719, 0.010329269741772618, 0.009338237799093152, 0.11557273811935442, 0.1304161139054778, 0.11078099043815437, 0.0, 0.0, 0.0]}}
{"id": "181b54bb-cac3-481b-8e00-1c32d31e0ecf", "fitness": 0.038133570411053926, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Hybridize PSO with adaptive chaotic perturbations to enhance diversity and escape local optima in complex landscapes.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n        # Chaotic sequence parameter\n        self.chaotic_param = 0.7\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Chaotic perturbation\n            chaotic_sequence = self.chaotic_param * (1 - self.chaotic_param)\n            self.chaotic_param = chaotic_sequence\n            if self.current_evals % self.population_size == 0:\n                perturbation = np.random.normal(0, chaotic_sequence, self.dim)\n                self.global_best_position += perturbation\n                self.global_best_position = np.clip(self.global_best_position, self.lower_bound, self.upper_bound)\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 27, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03813 with standard deviation 0.04381.", "error": "", "parent_ids": ["2b790a3e-7d2d-4c18-87f2-a96e1becb5cf"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.0839450790977253, 0.0862026053078705, 0.07060836199861564, 0.15540823504255796, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304171, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.056806939254532396, 0.030157186600474728, 0.04530470189219504, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01616574594409992, 0.010000000000000009, 0.010122957259498744, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01243249683730896, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09114505470304424, 0.06433968792189104, 0.07330330118743544, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05494608812391022, 0.06147825531143891, 0.05898755351602569, 0.13024202688033393, 0.10249392552467318, 0.10786414763567531, 0.06793062039506637, 0.04607294806253659, 0.053936809511723194, 0.1151179562292306, 0.09329613819853133, 0.10680655699815134, 0.018553590967207434, 0.010000000000000009, 0.010000000000000009, 0.028196829043476312, 0.034544894946019866, 0.05243450686440365, 0.03372343978884185, 0.02454293299146959, 0.0325740730937959, 0.13155659444263756, 0.13168681631460488, 0.1337832524086161, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.010710710545456026, 0.0, 0.00463723363454005, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.040239484515480095, 0.04181298200720873, 0.03339054378058304, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.08977858047031684, 0.0841383159904916, 0.0806641952599999, 0.025970818268148843, 0.032068986812099465, 0.0244498589101666, 0.08551450040033814, 0.07774721130397655, 0.07809312982677996, 0.0, 0.0, 0.0, 0.010895624840883356, 0.01124511294575048, 0.010854699276610535, 0.007354325247402649, 0.011063080523635027, 0.009407352200599517, 0.11557273811935442, 0.1304161139054778, 0.1096557550182845, 0.0, 0.0, 0.0]}}
{"id": "905b17a5-e1b7-435d-9915-5f5e96a53767", "fitness": 0.038430355237629436, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Slightly increase the personal best influence to enhance convergence speed.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 28, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03843 with standard deviation 0.04388.", "error": "", "parent_ids": ["2b790a3e-7d2d-4c18-87f2-a96e1becb5cf"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.0839450790977253, 0.0862026053078705, 0.07060836199861564, 0.15540823504255796, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304171, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.056287802073278104, 0.025679495282248332, 0.04464179909631094, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014291010906163581, 0.010784776973323473, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.0103420066405836, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09793885483772091, 0.0645466258677273, 0.0776893614003058, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.056592069102073594, 0.06206803539525141, 0.05898755351602569, 0.13024202688033393, 0.10071427352858864, 0.10786414763567531, 0.07001544742924704, 0.04585112473490127, 0.05890087225508356, 0.1151179562292306, 0.08943666315340204, 0.10744721150482661, 0.051345601931398366, 0.010000000000000009, 0.010000000000000009, 0.03156309584700934, 0.038283597392141266, 0.05243450686440365, 0.034174174599158724, 0.02519420172400133, 0.02796367935123456, 0.13155659444263756, 0.13168681631460488, 0.1337832524086161, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.010070878087574231, 0.0018235674521190903, 0.007195514328145025, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.041957258622387306, 0.04605355925878196, 0.031605006908755784, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.08741592361047035, 0.0855657204061151, 0.08125978280834933, 0.029144240301826274, 0.03235133709533533, 0.0244498589101666, 0.08555718310747806, 0.08197785060889828, 0.07903565382484701, 0.0, 0.0, 0.0, 0.011235924498564032, 0.01124511294575048, 0.011266603578647505, 0.007891654522014346, 0.010299140833218812, 0.009316274507221167, 0.11557273811935442, 0.1304161139054778, 0.11213596913578072, 0.0, 0.0, 0.0]}}
{"id": "5e8c52e9-c0b9-4bfd-bc06-931c2b096ff3", "fitness": 0.03750239012448543, "name": "Advanced_Diverse_Strategy_Optimizer", "description": "Introduce diversity preservation and adaptive strategy switching to enhance convergence and global exploration.", "code": "import numpy as np\n\nclass Advanced_Diverse_Strategy_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.7  # Increased cognitive coefficient for exploration\n        self.social_coeff = 1.4\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.5 + 0.4 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.6 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation strategy\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Introduce adaptive exploration strategy\n            if self.current_evals < self.budget / 2:\n                for i in range(self.population_size):\n                    candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                    candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_solution)\n                    self.current_evals += 1\n                    if candidate_score < self.personal_best_scores[i] or \\\n                       np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                        self.particles[i] = candidate_solution\n                        self.personal_best_scores[i] = candidate_score\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 29, "feedback": "The algorithm Advanced_Diverse_Strategy_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03750 with standard deviation 0.04314.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.13568567631355, 0.08655947155723365, 0.13852631528161463, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03479088705499467, 0.021968817144383923, 0.028586271169866118, 0.03212720580495765, 0.020000000000000018, 0.020000000000000018, 0.06479977941318049, 0.04593979384116398, 0.0521562042360314, 0.020000000000000018, 0.05005170640281387, 0.020000000000000018, 0.023245346750239593, 0.0875050450475564, 0.08753569795389182, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12483169187021503, 0.10305064156735244, 0.13084903150896143, 0.030380075601459833, 0.02990059312416382, 0.020000000000000018, 0.08713802420402772, 0.0863116411064907, 0.07934231505328637, 0.13603607004899532, 0.14679606830701264, 0.13458805206824198, 0.07665788568629583, 0.10266303487409578, 0.07890179233932537, 0.13716940378251108, 0.14265161475860677, 0.12960076708962076, 0.020000000000000018, 0.020000000000000018, 0.12685969214051795, 0.10819636878037442, 0.10802591081777024, 0.0895133107273659, 0.07705669540247129, 0.07323783880966739, 0.06420115556790162, 0.1438526290318487, 0.1493659609324015, 0.15475448018179316, 0.051328349861219924, 0.03392426887360889, 0.02938108183792809, 0.058198304111693244, 0.03774066011221788, 0.04901262092232417, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013068851762574107, 0.010111757007894684, 0.01075673364211549, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015043029391204943, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09257524874407286, 0.0703761941142973, 0.07787157106457387, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06047699381492322, 0.06147825531143891, 0.05395939349942802, 0.13024202688033393, 0.099198115857423, 0.10281775224528589, 0.06847283543862459, 0.04276606058648502, 0.053936809511723194, 0.10420585433558305, 0.088758442150079, 0.10882816597792644, 0.015486728230956315, 0.010000000000000009, 0.010000000000000009, 0.026594670233180295, 0.05298984438697374, 0.04107876631827334, 0.03141328323916981, 0.026091359872509545, 0.027850809020868783, 0.13834986568654128, 0.1395146915819676, 0.13809461879827123, 0.011588410281510697, 0.010000000000000009, 0.010000000000000009, 0.008946361568984762, 0.0006257894930365993, 3.0251005366355166e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.042131013656662164, 0.044581803737387515, 0.03316201103342298, 0.0, 0.0, 0.0, 0.032478335218920296, 0.03753213255583987, 0.035157662832624115, 0.08497081860327227, 0.0844153154349847, 0.08199172715262204, 0.028471394814317263, 0.02814944320541135, 0.026329297910034577, 0.08928531657029026, 0.08233421179620459, 0.07613114193770043, 0.0, 0.0, 0.0, 0.010899060897226476, 0.011157147264115097, 0.011184190728487642, 0.007472886816858759, 0.011021349901476296, 0.009226949804139961, 0.1177858890528598, 0.1304161139054778, 0.10963526193167383, 0.0, 0.0, 0.0]}}
{"id": "891fb41d-1869-4498-b9d2-885b9ed1a2dc", "fitness": 0.038368027598470224, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Adjust cognitive and mutation dynamics for better convergence and diversity.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.65  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)**0.5  # Changed rate\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 30, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03837 with standard deviation 0.04387.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.0839450790977253, 0.0862026053078705, 0.07060836199861564, 0.15540823504255796, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304171, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.056282058729505646, 0.02566750328679579, 0.04457210469496797, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014232262108656468, 0.01074779380440305, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.010375474299897602, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09804270471161458, 0.06317956043766226, 0.07778107994793404, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059940864655544934, 0.0619531191173166, 0.05898755351602569, 0.13024202688033393, 0.10084623819155314, 0.10786414763567531, 0.06590342238378999, 0.04225750929339955, 0.05398724359580109, 0.1151179562292306, 0.0918474532806719, 0.10401883655997712, 0.05263288013191281, 0.010000000000000009, 0.010000000000000009, 0.031550871053710794, 0.03797432293181269, 0.05243450686440365, 0.034100323794506004, 0.02493809601868424, 0.027673759413079146, 0.13155659444263756, 0.1350639226845023, 0.1337832524086161, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.010090703748158347, 0.0020211497318217697, 0.0035512584918327983, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04180008311842831, 0.0458649013821667, 0.032671593328218895, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.0456111386618171, 0.0868167707718841, 0.08384779012604238, 0.08202883999873234, 0.0284597299012026, 0.0314671418439636, 0.025050098314151947, 0.08766240237040535, 0.08020544565101828, 0.07480266564678262, 0.0, 0.0, 0.0, 0.011406785335121628, 0.01124511294575048, 0.012645371686324403, 0.008760625741674244, 0.010497764810961985, 0.00974149413796399, 0.11764364566234209, 0.1304161139054778, 0.1104931452239808, 0.0, 0.0, 0.0]}}
{"id": "1b107a19-a135-4d95-9cf9-884c6d18adaf", "fitness": 0.03803043275287763, "name": "Adaptive_Population_Inertia_Optimizer", "description": "Introduce adaptive population size and inertia weight adjustment based on convergence to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Population_Inertia_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.min_population_size = 5\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.initial_population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            # Adaptive inertia weight\n            completion_ratio = self.current_evals / self.budget\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - completion_ratio**2)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * completion_ratio)\n\n            for i in range(len(self.particles)):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - completion_ratio)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(len(self.particles)):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (len(self.particles) * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n            \n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n            # Adaptive population size reduction\n            if len(self.particles) > self.min_population_size and completion_ratio > 0.5:\n                self.particles = self.particles[:int(self.initial_population_size * (1 - completion_ratio / 2))]\n                self.velocities = self.velocities[:len(self.particles)]\n                self.personal_best_positions = self.personal_best_positions[:len(self.particles)]\n                self.personal_best_scores = self.personal_best_scores[:len(self.particles)]\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 31, "feedback": "The algorithm Adaptive_Population_Inertia_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03803 with standard deviation 0.04366.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09418720475118025, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.030981689575350413, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.052396379508301116, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.125823598443083, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11701248576161216, 0.13084903150896143, 0.030331871386380937, 0.032089679199030274, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.14293108476691108, 0.1160417955509998, 0.0839450790977253, 0.09150741548915886, 0.07060836199861564, 0.15540823504255796, 0.11329152128051401, 0.13140936910034073, 0.020000000000000018, 0.020000000000000018, 0.11543800639898683, 0.10819636878037442, 0.10578409455025328, 0.0895133107273659, 0.08576572527081283, 0.11314561848263194, 0.08017885823061699, 0.1438526290318487, 0.14959436843128582, 0.15643588568825317, 0.0529724151451092, 0.041915344929398635, 0.03142505684023322, 0.055992117048224044, 0.02557372695063731, 0.04454020900640243, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015364258735937164, 0.01166547288755071, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09844844265430519, 0.06764160054912827, 0.07723751721040917, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.060057320295207384, 0.13024202688033393, 0.10247800697581666, 0.11017834849201114, 0.06811612082588736, 0.041567825028726135, 0.060436279132959236, 0.1151179562292306, 0.09053785965692152, 0.10753378853841022, 0.013217454150856178, 0.010000000000000009, 0.010000000000000009, 0.032147598695485335, 0.039138736477518865, 0.05293090571538228, 0.03387042878780633, 0.025423800809642683, 0.03354905898375693, 0.13155659444263756, 0.13410160702914398, 0.1337832524086161, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.009507965970887655, 0.0011714761809394902, 0.0036330374209204708, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.041898130276240564, 0.04649341800685036, 0.03230671878228619, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.0456111386618171, 0.0868167707718841, 0.08712968949245892, 0.0832854477109336, 0.02807568944096739, 0.0314671418439636, 0.027038519782939918, 0.0885307535825599, 0.07904623368704644, 0.07402443593648245, 0.0, 0.0, 0.0, 0.010829530630790174, 0.01124511294575048, 0.012278555975405503, 0.007596255385407424, 0.010761148609627735, 0.00971197581540939, 0.11557273811935442, 0.1304161139054778, 0.11302572465613847, 0.0, 0.0, 0.0]}}
{"id": "ddff0feb-43fe-4673-bde3-90f8f056486e", "fitness": 0.03577159984400765, "name": "Adaptive_Hybrid_PSO_GA_SA_Optimizer", "description": "Employ a dynamically adjusted hybrid PSO-GA-SA strategy that emphasizes adaptive diversity and elitism for robust exploration and exploitation.", "code": "import numpy as np\n\nclass Adaptive_Hybrid_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.inertia_weight = 0.8\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.7\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:5])  # More elitist selection\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            inertia_weight = self.inertia_weight * (0.5 + 0.5 * (1 - self.current_evals / self.budget))\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_velocity = r3 * (self.elite_positions[np.random.randint(0, 5)] - self.particles[i])\n                self.velocities[i] = (inertia_weight * self.velocities[i] + \n                                      cognitive_velocity + social_velocity + diversity_velocity)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:5]]\n\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 32, "feedback": "The algorithm Adaptive_Hybrid_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03577 with standard deviation 0.04098.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.09895930583274548, 0.09696248123656492, 0.13034083244306838, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037252591133128066, 0.020385699327755913, 0.020000000000000018, 0.020000000000000018, 0.023893113624539275, 0.020000000000000018, 0.0620847657127519, 0.057251633900241905, 0.052895942031969456, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.08946176979653131, 0.057929235093625686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11266058158583436, 0.11076356211738836, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.023178562540558723, 0.0830297693381774, 0.0863116411064907, 0.07015575039186472, 0.13544222262475936, 0.13323277534341382, 0.1218431588130483, 0.07761830845986306, 0.08439295194656993, 0.05967998823180265, 0.12893844280850386, 0.11110583487074532, 0.12191976134240401, 0.08194774513021197, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.10021051466220288, 0.0895133107273659, 0.0677162831653646, 0.05842016157321639, 0.05908900877306711, 0.14837240524596385, 0.14243283588818745, 0.16519264193923644, 0.05158449799566678, 0.04038150449648914, 0.04627909042421263, 0.03444492933494503, 0.03563137546057793, 0.049956315606846546, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06827454273086331, 0.012772516339456974, 0.010594280874430706, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014517860198079657, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07807722228017566, 0.08133030029796506, 0.07869123606167694, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05813266665433825, 0.1344996243986345, 0.09869508530418292, 0.10319701590591279, 0.05756835603815702, 0.041726591010868175, 0.05507027678875542, 0.09613804107937385, 0.09296127937868293, 0.10047434280555567, 0.0352387573945967, 0.010000000000000009, 0.010000000000000009, 0.03319523694989712, 0.029795503118299926, 0.03214306918977783, 0.0267310635949356, 0.026770205758247956, 0.027021511321015934, 0.14089412991971872, 0.13254277612375265, 0.13657981042649026, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0023784395496966315, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03291529537492677, 0.046267735481774985, 0.027158425781540707, 0.0, 0.0, 0.0, 0.03836946705540323, 0.03753213255583987, 0.03584048145623564, 0.081659891021727, 0.08107183155618503, 0.07835412715527978, 0.02374265811651677, 0.024311202971662338, 0.0207522686319348, 0.07461178704953053, 0.07568845409607505, 0.06902828078253476, 0.0, 0.0, 0.0, 0.010147761157483726, 0.01000399491698134, 0.010944057204107738, 0.008062598717476277, 0.010051284513262426, 0.00855748172022941, 0.11698865696568983, 0.1304161139054778, 0.11094557902528945, 0.0, 0.0, 0.0]}}
{"id": "634ff4b8-96e7-4b4c-b2c3-a584ae69074d", "fitness": 0.03835639186877017, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced velocity update by adding momentum factor and slightly tweaking mutation for improved convergence.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]  # Added momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.05  # Tweaked mutation\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 33, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03836 with standard deviation 0.04393.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09389762070786989, 0.14216462766416638, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026542151728906616, 0.020000000000000018, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.0526445047837969, 0.05296263898276632, 0.020000000000000018, 0.03998301344053545, 0.020000000000000018, 0.0247005191513614, 0.125823598443083, 0.08331112459933232, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0426813279811501, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11572522169458954, 0.13084903150896143, 0.033254368699775494, 0.028702450470981966, 0.02206363250467558, 0.08072694858327945, 0.0863116411064907, 0.08262506424599991, 0.1371411441309246, 0.15219139112379576, 0.13774879466133827, 0.07918304035357526, 0.09349207802752058, 0.061644669597526125, 0.14617131634436842, 0.10929452499473269, 0.13530757514602554, 0.020000000000000018, 0.02244058053862208, 0.11453513498718493, 0.10819636878037442, 0.10748163989535131, 0.09477723779459823, 0.08136447482843667, 0.1248505511622311, 0.07168258744411193, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.03768226411552178, 0.034363697608362, 0.06104665402476772, 0.022407024088587857, 0.05433410264677585, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014332101002063391, 0.010000000000000009, 0.012531911674418028, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010361818893683816, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09825263818174124, 0.06622109692458511, 0.08453822183892401, 0.010000000000000009, 0.010000000000000009, 0.01386692263774425, 0.05691281275570503, 0.06147825531143891, 0.05701092319288492, 0.1252582999907953, 0.10108109551441924, 0.10642503898371103, 0.0787744944845431, 0.05234619160351495, 0.053936809511723194, 0.1023418203372336, 0.08637657937487286, 0.10213199906566739, 0.025139540140989958, 0.010000000000000009, 0.010000000000000009, 0.033734541558979925, 0.04117656628084376, 0.05865880973985771, 0.037367184754101834, 0.024228974774687773, 0.03536816184129643, 0.1322938289835497, 0.1367458439006538, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.007532514068885665, 0.0, 0.005790803632244157, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04432906131204328, 0.04580460334264169, 0.03261670878753509, 0.0, 0.0, 0.0, 0.03520394851587838, 0.04832539568382688, 0.04117852977698999, 0.08684566808875416, 0.08295429489124428, 0.08124872396404059, 0.0268548149458121, 0.029882594529717754, 0.024734229437639477, 0.08374706076160987, 0.08162469398152683, 0.07516048587321089, 0.0, 0.0, 0.0, 0.01066309419363709, 0.011441923340644311, 0.012533778127228556, 0.009102957370293985, 0.011370249789292464, 0.009874043064054927, 0.11565886654656599, 0.14071628587952523, 0.10669834866997252, 0.0, 0.0, 0.0]}}
{"id": "440784d8-04f4-495e-8678-1a118067a824", "fitness": 0.03789307361638348, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introduce adaptive social coefficient and diversity influence to enhance exploration and convergence balance.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_social_coeff = self.social_coeff + 0.5 * np.sin(np.pi * self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = adaptive_social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + 0.6 * diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 34, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03789 with standard deviation 0.04351.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.12818024038986464, 0.09486945204902153, 0.14862001548874604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0350378089108091, 0.020000000000000018, 0.020000000000000018, 0.03070205442919216, 0.020000000000000018, 0.020000000000000018, 0.06767575303982365, 0.05156415511817358, 0.053247693457185385, 0.020000000000000018, 0.04934635042289681, 0.020000000000000018, 0.026991305895173845, 0.1046710235422128, 0.09367848534744672, 0.028160142875026994, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14421600004060187, 0.11746850626316696, 0.13084903150896143, 0.03340667659490337, 0.020000000000000018, 0.02255825547435053, 0.08072694858327945, 0.0921293229551553, 0.07934231505328637, 0.13976692998385187, 0.14907539932426384, 0.1260723136885804, 0.07341783554639503, 0.0829135134699599, 0.06880099485979285, 0.12632573305565475, 0.10620527245848888, 0.1316969657246415, 0.020000000000000018, 0.021127397657670022, 0.08784701038536813, 0.11957480935240772, 0.11292050621584138, 0.10645394744904679, 0.0677602479758912, 0.14181797771482307, 0.08095959393552421, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.04361584471953617, 0.03637558906165106, 0.0326807944319043, 0.05385166855665502, 0.026444844933278144, 0.058654155729870316, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016925268104691193, 0.010059676802347872, 0.011625914711865915, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09753287582906689, 0.06807616752401768, 0.07838001970353259, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05903522168097819, 0.06376687098561662, 0.056425231391154296, 0.13272834046145476, 0.10430062505490756, 0.10281775224528589, 0.06741315204662868, 0.05134325541882745, 0.05588586757087666, 0.09967757657463072, 0.09632750680869562, 0.11752358100693838, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030205966928061767, 0.034850454237928985, 0.05384635176192276, 0.02725106126704735, 0.029361728393209052, 0.028433615332496887, 0.13141309820135194, 0.13316051993548417, 0.1470693598805467, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012406582591052429, 0.0017968671417065707, 0.00694330587141323, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04243547067748665, 0.04603365032882312, 0.031232905921724008, 0.0, 0.0, 0.0, 0.03651929622000172, 0.04078666955648236, 0.03724613027149515, 0.08235085013714016, 0.08724535326113736, 0.0859140416603007, 0.027689460852176828, 0.029924691281793203, 0.0284390804940593, 0.08806541910195331, 0.07948328717462072, 0.07581762901639011, 0.0, 0.0, 0.0, 0.011156674369736552, 0.011200773648019302, 0.011171896502091272, 0.010436814890428359, 0.010051284513262426, 0.009427503726249009, 0.11345746868948281, 0.1304161139054778, 0.10951792001557148, 0.0, 0.0, 0.0]}}
{"id": "945ea8be-03d0-4eb6-8bcd-000fe6168517", "fitness": 0.037064557863696064, "name": "Enhanced_Metaheuristic_Optimizer", "description": "Integrate adaptive parameter tuning and a hybrid exploration mechanism to enhance convergence and diversity.", "code": "import numpy as np\n\nclass Enhanced_Metaheuristic_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            dynamic_cognitive_coeff = self.cognitive_coeff + 0.5 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = dynamic_cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 35, "feedback": "The algorithm Enhanced_Metaheuristic_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03706 with standard deviation 0.04275.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.12355532821429815, 0.08760814757058144, 0.14005566140408088, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03418184366286159, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02016858672236599, 0.020000000000000018, 0.07772246783119385, 0.051552810254503645, 0.052569428644732685, 0.020000000000000018, 0.033443130916649855, 0.020000000000000018, 0.03532950783658828, 0.08594148016760361, 0.08448082070974594, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12150365125502505, 0.10085351013826838, 0.13084903150896143, 0.042342782104442755, 0.020000000000000018, 0.023199598106355523, 0.08072694858327945, 0.08821426520338549, 0.08574572552306792, 0.13980322640722354, 0.15370733900336686, 0.12236599776098955, 0.08022254009667162, 0.08248075658232434, 0.07608013801032965, 0.12675625534857293, 0.1067504060141169, 0.12236270489272527, 0.020000000000000018, 0.020000000000000018, 0.122881893761847, 0.15731124224540105, 0.09440051013114925, 0.0895133107273659, 0.06527120746322768, 0.06945110896404572, 0.056492493752391515, 0.1495972353977062, 0.13589170657517036, 0.15475448018179316, 0.056053173497479736, 0.03886736965642479, 0.03445629649014048, 0.04154177017929461, 0.03089329239520866, 0.06063823864145601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014046984218537117, 0.010000000000000009, 0.011517717409709194, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012754847525548563, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08071817819228144, 0.07029594327259536, 0.0723096377747231, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06208461195035253, 0.05395939349942802, 0.14038783944665156, 0.11511191518993347, 0.10450201418181693, 0.0738298019874486, 0.054835686411409235, 0.0558015655917905, 0.10203650571942968, 0.08921428110937124, 0.10700934863571887, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028984653556866302, 0.038245450860509345, 0.046247553912116546, 0.026006995427764856, 0.027345106013096365, 0.02548235223129469, 0.13141309820135194, 0.13123409970527322, 0.14429724085891504, 0.010000000000000009, 0.010000000000000009, 0.010321307015435988, 0.008305703655596686, 0.0038281238495092573, 0.004420871329748777, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04621348823465121, 0.04119846209036826, 0.036696198742076414, 0.0, 0.0, 0.0, 0.03529441150168855, 0.03753213255583987, 0.037877418848900835, 0.08633081609837756, 0.09047820925324235, 0.08031003307202811, 0.023725554606456756, 0.02704742434058005, 0.018796907049733247, 0.08667805088629155, 0.08084777770015972, 0.07045085099715864, 0.0, 0.0, 0.0, 0.01001647088652613, 0.012174600429071591, 0.013385663893972444, 0.007426444174607361, 0.010051284513262426, 0.00988003595670861, 0.11387214608794427, 0.1304161139054778, 0.11950580029455549, 0.0, 0.0, 0.0]}}
{"id": "3e747f31-56e5-4033-921e-416a2aa19b0b", "fitness": 0.03843122796523476, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introducing dynamic control for cognitive and social coefficients alongside a modified cooling strategy to enhance adaptability and convergence.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 36, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03843 with standard deviation 0.04390.", "error": "", "parent_ids": ["905b17a5-e1b7-435d-9915-5f5e96a53767"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.0839450790977253, 0.0862026053078705, 0.07060836199861564, 0.15540823504255796, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304171, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.05627324609526663, 0.0256963005567864, 0.04472232128852183, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014289182870669603, 0.01078260455969482, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012641938597723335, 0.0103420066405836, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09795134810102812, 0.06469375095595264, 0.077663089970055, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055639811360991276, 0.062037399531071125, 0.05898755351602569, 0.13024202688033393, 0.10041589715378552, 0.10786414763567531, 0.06966382567115059, 0.04534374459704338, 0.05780315679880632, 0.1151179562292306, 0.09016175078853084, 0.11263950825821378, 0.051665891958901144, 0.010000000000000009, 0.010000000000000009, 0.031568930905161774, 0.03811238482620227, 0.05243450686440365, 0.034174210286894935, 0.025131938729531234, 0.028010466455441807, 0.13155659444263756, 0.13321587220690678, 0.13384446365027525, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.010041428245649131, 0.0018149299978241773, 0.007201007097926038, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04197735762885846, 0.046067285273465486, 0.031615732830225785, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.08733218573815404, 0.08565016933370306, 0.08129055331372337, 0.029238221198243486, 0.03250314857777059, 0.0244498589101666, 0.08551450040033814, 0.08347853173747832, 0.07490384510084769, 0.0, 0.0, 0.0, 0.011228471301938603, 0.01124511294575048, 0.011266178003199068, 0.007898902368360883, 0.010300059421161634, 0.00931695037399971, 0.11557273811935442, 0.1304161139054778, 0.1095123041483822, 0.0, 0.0, 0.0]}}
{"id": "7d161e26-cf28-4630-949d-e16a7268aaa5", "fitness": 0.038423019476986044, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Slightly adjusted the randomized component of cognitive and social coefficients to improve search balance and convergence precision.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.cos(np.pi * self.current_evals / self.budget)  # Changed from sin to cos for slight variation\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 37, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03842 with standard deviation 0.04385.", "error": "", "parent_ids": ["3e747f31-56e5-4033-921e-416a2aa19b0b"], "operator": null, "metadata": {"aucs": [0.13988249483034354, 0.09461336433093326, 0.14432444845585846, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03108405293958172, 0.0220242153903486, 0.02739612751035836, 0.028555808432387253, 0.020000000000000018, 0.020000000000000018, 0.06961995757799144, 0.05233940891142341, 0.052868185984048965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03164892264351349, 0.1092473522124301, 0.07976876896261331, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13566496603220768, 0.11752592692121422, 0.13084903150896143, 0.030331871386380937, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07934231505328637, 0.13713295160299444, 0.15850111410924994, 0.1160417955509998, 0.0839450790977253, 0.0862026053078705, 0.07060836199861564, 0.15540823504255796, 0.1121186177732405, 0.13140936910034073, 0.020000000000000018, 0.11284527980114789, 0.11543800639898683, 0.10819636878037442, 0.10129581591304171, 0.0895133107273659, 0.08576572527081283, 0.13111709603622845, 0.08017885823061699, 0.1438526290318487, 0.13746893726807974, 0.15643588568825317, 0.0529724151451092, 0.03392426887360889, 0.03142505684023322, 0.056276823369892814, 0.025672975190783043, 0.044749579403913886, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014312894473715088, 0.010830231198792672, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012067402497958013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016781867083697555, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09816153253535076, 0.06621921153729493, 0.07740568183595475, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.054753122134048926, 0.06208567412499799, 0.05898755351602569, 0.13024202688033393, 0.10047755645455902, 0.10786414763567531, 0.06723783730594834, 0.04363620057629092, 0.05544442467880939, 0.1151179562292306, 0.09428621316029495, 0.10302544960318338, 0.05003324424330258, 0.010000000000000009, 0.010000000000000009, 0.03158462086962255, 0.038487739037340596, 0.05243450686440365, 0.034252403432535106, 0.025253438829616393, 0.028659968770880395, 0.13202381610816172, 0.13476520292180694, 0.1337832524086161, 0.01106953391339105, 0.010000000000000009, 0.010000000000000009, 0.009764985975179052, 0.0016811712734778883, 0.007088914933516599, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04177116079055665, 0.04600793858332575, 0.031770306445212615, 0.0, 0.0, 0.0, 0.03579999233285325, 0.04227622452156221, 0.04555248300445003, 0.08691404088773125, 0.08625940887387695, 0.08126349615343531, 0.02872376988707548, 0.0314671418439636, 0.025933489351390282, 0.08685913338520923, 0.08593321856232938, 0.07611765702475215, 0.0, 0.0, 0.0, 0.011141260792619123, 0.01124511294575048, 0.011155026394668921, 0.007898766609872765, 0.010306027534829232, 0.009330610970830988, 0.11557273811935442, 0.1304161139054778, 0.1072143347362986, 0.0, 0.0, 0.0]}}
{"id": "9613a2d1-e500-4b1d-a4e7-b2109f170def", "fitness": 0.03861879989675403, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introducing momentum-driven velocity adaptation and adaptive temperature scaling for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]  # Added momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))  # Added adaptive scaling\n            \n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 38, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03862 with standard deviation 0.04437.", "error": "", "parent_ids": ["3e747f31-56e5-4033-921e-416a2aa19b0b"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.06057955339872889, 0.026276544973413807, 0.044237291479742424, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014694142849066338, 0.01154065116932157, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09837639713657498, 0.06726496685060024, 0.07747566141930695, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.061745986985642376, 0.05443545187094356, 0.12731111196137856, 0.09973071595557248, 0.1083274071367265, 0.0787744944845431, 0.04974074653682192, 0.053936809511723194, 0.09690108901703198, 0.0837184153140883, 0.11007333539475195, 0.03594270683607359, 0.010000000000000009, 0.010000000000000009, 0.03458052430791314, 0.03833348885516341, 0.05392873067202941, 0.03380430171150861, 0.025543579885116685, 0.03330211511487835, 0.13186619252479614, 0.13377526647088855, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009475522845508899, 0.00011775215007503448, 0.006821143229484239, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04260533019278423, 0.04582561413844877, 0.03160404920442228, 0.0, 0.0, 0.0, 0.039003340094371786, 0.04832539568382688, 0.04011043303894324, 0.08395148161298527, 0.08355908251755362, 0.08655342187059589, 0.026763174189230576, 0.029882594529717754, 0.026120386218198344, 0.08378628405285637, 0.08243077727502979, 0.07928683269457348, 0.0, 0.0, 0.0, 0.010872803072828008, 0.011441923340644311, 0.011197996563543033, 0.0075446188613785825, 0.010584537826002216, 0.00937559252455733, 0.12126207436352077, 0.14071628587952523, 0.11269529096061182, 0.0, 0.0, 0.0]}}
{"id": "7b050b1e-f938-4128-b527-4866b04451a6", "fitness": -0.03255301513275687, "name": "Advanced_Adaptive_DE_SGD_Optimizer", "description": "Introducing adaptive differential evolution with stochastic gradient descent inspired velocity update for improved convergence in diverse landscapes.", "code": "import numpy as np\n\nclass Advanced_Adaptive_DE_SGD_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.scaling_factor = 0.8\n        self.crossover_rate = 0.9\n        self.current_evals = 0\n        self.learning_rate = 0.01  # For SGD-inspired updates\n\n        # Initialize population\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_position = np.zeros(self.dim)\n        self.best_score = float('inf')\n        self.scores = np.full(self.population_size, float('inf'))\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.scaling_factor * (b - c)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_score = func(trial)\n                self.current_evals += 1\n                if trial_score < self.scores[i]:\n                    self.scores[i] = trial_score\n                    self.population[i] = trial\n                    if trial_score < self.best_score:\n                        self.best_score = trial_score\n                        self.best_position = trial\n\n            # Adaptive scaling and crossover rates\n            self.scaling_factor = 0.5 + 0.5 * np.sin((np.pi * self.current_evals) / (2.0 * self.budget))\n            self.crossover_rate = 0.7 + 0.3 * np.cos((np.pi * self.current_evals) / (2.0 * self.budget))\n\n            # Stochastic Gradient Descent inspired updates\n            for i in range(self.population_size):\n                gradient = np.random.normal(0, 1, self.dim) * (self.population[i] - self.best_position)\n                self.population[i] -= self.learning_rate * gradient\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n        return self.best_position, self.best_score", "configspace": "", "generation": 39, "feedback": "The algorithm Advanced_Adaptive_DE_SGD_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.03255 with standard deviation 0.11342.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.10387717693643372, 0.10922794858445739, 0.10991065538172617, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023774712545430843, 0.022565056616117296, 0.025344285351905027, 0.027759140768879975, 0.020000000000000018, 0.020000000000000018, 0.05719413605013146, 0.07259502652694527, 0.04876288979171606, 0.037160857760610067, 0.020000000000000018, 0.020000000000000018, 0.056305678367149614, 0.020000000000000018, 0.03795110493914511, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1604824445032801, 0.12209118286918252, 0.13852082693673362, 0.0310096867010603, 0.02323473032064305, 0.023443708200042823, 0.06591508562913306, 0.078798932151812, 0.07193538395783383, 0.13307913480196543, 0.12643032988098535, 0.12350341431571166, 0.09333392124199347, 0.06151211522804356, 0.057390580530910174, 0.13892742270450464, 0.12482173845396549, 0.11202004721422387, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06768078372749864, 0.0690395096266514, 0.1270922786233314, 0.041732649801586086, 0.06078744994772589, 0.07269939853984597, 0.1623080481840441, 0.13463926154099992, 0.13648145944927914, 0.03662171068505726, 0.028033402969416588, 0.024005406356955916, 0.03128496706555339, 0.061476055068434454, 0.023899895708117125, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013103024121789097, 0.048888141193752954, 0.01901645996865997, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057877119776043706, 0.05714408682119787, 0.04972909411626569, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06041085899892418, 0.05731435306950383, 0.0763117952049529, 0.1009217522137551, 0.10546098783709557, 0.0912729183744565, 0.04824137372200621, 0.060423789168821296, 0.03460610768612393, 0.06719373958277552, 0.07787496035147368, 0.058887225860732806, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026769645455297142, 0.026494317538540035, 0.025946431095774214, 0.022555632840369766, 0.021881039896876953, 0.020337668022139876, 0.1579922103397845, 0.13230430520481695, 0.1309954764018464, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19081956069598616, -0.15420826209061111, -0.17328381917845803, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15448412521786303, -0.15620885535607032, -0.13721249910788513, -0.1149737138289626, -0.10695560388975967, -0.10960269625887964, -0.1834425578021126, -0.17146497202863298, -0.1780620251862406, -0.1620840930270342, -0.15028639036896774, -0.14339961849616722, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18729492382284296, -0.19008531037189602, -0.1887083607534128, -0.19190071770378458, -0.18619846620229463, -0.19167293007385067, -0.06487115671516275, -0.05045744656924667, -0.04038931135031398, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "73a0c1ef-3b03-4cb5-957e-477c7ca51ca7", "fitness": 0.03782549248826208, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer_Chaotic", "description": "Introduces chaotic maps for parameter control and stochastic ranking for adaptive elitism to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n        \n        # Initialize chaotic maps\n        self.chaotic_map = 0.7\n        self.chaotic_sequence = np.random.rand(self.budget)\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position with chaotic map influence\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate using chaotic map\n                dynamic_mutation_rate = self.mutation_rate * self.chaotic_map\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Chaotic map update\n            self.chaotic_map = 4 * self.chaotic_map * (1 - self.chaotic_map)\n            \n            # Stochastic ranking for elite selection\n            stochastic_indices = np.argsort(self.personal_best_scores + np.random.rand(self.population_size))\n            self.elite_positions = self.personal_best_positions[stochastic_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            \n            # Dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 40, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03783 with standard deviation 0.04278.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.11976707096130368, 0.1639869732955529, 0.12092736761265743, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029270424875630585, 0.022443206870582877, 0.030927783264530162, 0.022479470866337836, 0.020000000000000018, 0.03037105285786823, 0.08357994832949034, 0.06585825022885938, 0.07221327073744954, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.050007924043855234, 0.08520227102709788, 0.07268008148686822, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1266760719799518, 0.13940238938717742, 0.1480021697754077, 0.029687051006250686, 0.028876390479496195, 0.025197912815482337, 0.08103697533824916, 0.09185341799367652, 0.09715101589699282, 0.12932348148977268, 0.12687343353843883, 0.1419327198316498, 0.07737484242836556, 0.07108260468273331, 0.06895846604334677, 0.12256059862691049, 0.09971512629505808, 0.1254099196902021, 0.10201715923744659, 0.020000000000000018, 0.1092203351251686, 0.07296399023358846, 0.1041463043201929, 0.06977929924552395, 0.07323863761209337, 0.08004501356131244, 0.04240861652714345, 0.14870010560887603, 0.14510459507043094, 0.14922277101038672, 0.05456895967846376, 0.03755806258575012, 0.04087711972908581, 0.0480173316016298, 0.03806754056533901, 0.06282003120420154, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023762692183433964, 0.015066383637039826, 0.02498455130612387, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020581952303147855, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011068222503590075, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08551990298555834, 0.09904794740658063, 0.07584866025597659, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0624249398115202, 0.06271011701462126, 0.06361391992324128, 0.09942392305777148, 0.10527736861290304, 0.10150041165993573, 0.05342433710380723, 0.04930174272306598, 0.050657357148652604, 0.1018319442131137, 0.0935114942869103, 0.11241902486519917, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034935342732924646, 0.03745813755210459, 0.025701099459877197, 0.025966778582144245, 0.044910174303142814, 0.030859754734489653, 0.14185143210268636, 0.131893951942457, 0.13564605836106114, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010055071055729004, 0.0006504779644410652, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.050764473330384696, 0.04701388337352663, 0.030416061736102673, 0.0, 0.0, 0.0, 0.03329010098929874, 0.03766741152360065, 0.03043264729775952, 0.0858491221060228, 0.08645549193397639, 0.08198311450626372, 0.025712339606445922, 0.030499738888905448, 0.028179610314559844, 0.09116218792732445, 0.08606813778958566, 0.07393664610857154, 0.0, 0.0, 0.0, 0.01113442082842031, 0.009308647934920478, 0.010802828501672246, 0.00974555823901313, 0.010401275305624402, 0.007472564961825245, 0.12185492862269665, 0.13157088679293993, 0.1070935703780358, 0.0, 0.0, 0.0]}}
{"id": "c222cad7-6c3b-4cef-a6d2-12372ec4b004", "fitness": 0.038494324092750457, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Incorporating dynamic diversity control using elite positions for enhanced global exploration.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i]) * (1 + 0.1 * np.cos(2 * np.pi * self.current_evals / self.budget))  # Modified dynamic diversity control\n                momentum = 0.1 * self.velocities[i]  # Added momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))  # Added adaptive scaling\n            \n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 41, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03849 with standard deviation 0.04422.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1323746329038502, 0.09450130210576502, 0.1420673075976373, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03450886552059529, 0.027086438099722887, 0.02386844402242716, 0.02975840252507067, 0.020000000000000018, 0.020000000000000018, 0.07063258435312292, 0.052725143237191796, 0.05301525207685642, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029673563635418843, 0.1104909853457291, 0.08133663764942067, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13103231433047202, 0.11648584057947065, 0.13084903150896143, 0.031582631602373956, 0.020000000000000018, 0.022800030233802615, 0.08988558768626109, 0.0863116411064907, 0.07946681968559177, 0.1392287717584776, 0.1598664630858636, 0.1160417955509998, 0.07874751630427934, 0.08652203868061481, 0.0744458050420147, 0.1409687289142484, 0.12614518805541497, 0.13537647318812474, 0.020000000000000018, 0.11727754603635221, 0.12258604153051278, 0.10819636878037442, 0.11343432727783831, 0.0895133107273659, 0.07304782750493954, 0.13940463307221396, 0.07707524633803686, 0.16147315909505167, 0.1395016060980282, 0.15475448018179316, 0.048237623968188315, 0.035992428956654554, 0.050869895420784794, 0.05736482176990876, 0.02650857022271158, 0.0442383839509658, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014870533234654704, 0.01142579709350966, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0973765056885385, 0.06690446819768214, 0.07816599871416019, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06178494610327201, 0.06149985338779462, 0.05574485666690865, 0.12724898686247532, 0.10363482487480458, 0.10891490867280207, 0.07376997986382505, 0.04290398744865054, 0.053936809511723194, 0.10769152745562638, 0.087060582107232, 0.10611186284188978, 0.014961569351533699, 0.010000000000000009, 0.010000000000000009, 0.03562266704171524, 0.038248402646352875, 0.05378685044070708, 0.03428865905372036, 0.0256465079524254, 0.03248424909650138, 0.13154552827643573, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009323438833441777, 5.128800658482646e-05, 0.002414101329384244, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04225750654996108, 0.04393484991665819, 0.031338391744431204, 0.0, 0.0, 0.0, 0.03660988916331176, 0.04886221779150124, 0.03246993201589998, 0.08588406916789282, 0.08576893065759794, 0.0871767308627075, 0.02581427058106811, 0.031004042178167213, 0.025468995937578565, 0.08436199187682414, 0.0786336788499743, 0.07788615625538631, 0.0, 0.0, 0.0, 0.010848720453271121, 0.01143547644624443, 0.011204799121312448, 0.009337425672319988, 0.0105734528282454, 0.009328932361771125, 0.1112398058338967, 0.1304161139054778, 0.12124848439790992, 0.0, 0.0, 0.0]}}
{"id": "bf070c33-4293-434f-bce9-8af874d47ee3", "fitness": 0.038062648174613835, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Improved adaptive control by incorporating particle swarm intelligence with refined diversity and mutation mechanisms.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.7 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])  # Increased diversity control\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.15, self.dim)  # Increased mutation standard deviation\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            \n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 42, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03806 with standard deviation 0.04361.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1324202332468638, 0.09383205026334995, 0.137279704042629, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03711644866163766, 0.03008288073542731, 0.021111244610660163, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07237770458931014, 0.052433881912289926, 0.052772305386386664, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.16202399387387845, 0.08019547741734057, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11381349264449059, 0.11204543606976847, 0.13084903150896143, 0.037997224500891824, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.14684801758100918, 0.15150866150587428, 0.11658978781557228, 0.06814221642131768, 0.10508472382230338, 0.059908243530375827, 0.13904885712064885, 0.13584975098144358, 0.13815918033080754, 0.047068752579976, 0.10271189612321452, 0.11578984750374122, 0.12604610392322657, 0.08152216345881191, 0.0895133107273659, 0.06527120746322768, 0.10267988360983449, 0.06575845693394977, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05214837321898669, 0.048145250713936494, 0.03726777837645878, 0.05148881560414098, 0.03356621014981476, 0.05193612546059778, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011635116041910032, 0.012562573914174258, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010340737933092314, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09333835265360735, 0.0687119384973287, 0.07594493506010169, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07026448533242713, 0.07238482306376104, 0.05395939349942802, 0.12474554788351266, 0.10360908706676364, 0.10448261612365572, 0.0645500685951097, 0.04453498607276041, 0.053936809511723194, 0.09854805092947327, 0.08816430751451065, 0.11786469112144227, 0.04963467483966244, 0.010000000000000009, 0.010000000000000009, 0.02946829017962882, 0.039292450281415925, 0.05462396016569726, 0.03781497534290423, 0.023805207126767147, 0.033801468969590354, 0.13282791123751014, 0.13949558938587314, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.007979434452823009, 0.0003393583638012787, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03982071615482541, 0.0440390954420693, 0.029952595843123264, 0.0, 0.0, 0.0, 0.0315463125156803, 0.03753213255583987, 0.040017128389796985, 0.08362729254727286, 0.08536321792378643, 0.08165403980011277, 0.02546219896709845, 0.025275626878397017, 0.021153998885210634, 0.0782483673308696, 0.07444129021809842, 0.07433536663531781, 0.0, 0.0, 0.0, 0.01099438710583256, 0.011817388734848278, 0.010762317767537, 0.007795512612120081, 0.010051284513262426, 0.009274259629548864, 0.1139070445880036, 0.1304161139054778, 0.1082559961621763, 0.0, 0.0, 0.0]}}
{"id": "beb2e8e7-b802-4845-a57f-21357322ae76", "fitness": 0.038451112065870895, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced exploration through adaptive inertia weight oscillation for improved convergence in high-dimensional spaces.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            # Modified line for adaptive inertia weight oscillation\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget) + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]  # Added momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))  # Added adaptive scaling\n            \n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 43, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03845 with standard deviation 0.04434.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.060461923935727246, 0.026255634428698493, 0.04443551313649663, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015259230680961244, 0.01208442330766113, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0973354045467254, 0.06700060933569507, 0.07726260460914636, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06583154995617624, 0.055840576932412955, 0.129268153663747, 0.10191992773896696, 0.1083274071367265, 0.0787744944845431, 0.04609442739734748, 0.05546727080393277, 0.098147710339762, 0.08330027536258955, 0.11188296622763327, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034817560916530654, 0.03874228930247059, 0.053852686652151927, 0.0343599139974613, 0.025669295931043057, 0.03201025959416881, 0.13141309820135194, 0.13390970452804485, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009228357244217111, 0.00020578274540683505, 0.006227174966375815, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04214206687987354, 0.04626982586787365, 0.031526950224629036, 0.0, 0.0, 0.0, 0.035428696664262294, 0.04832539568382688, 0.04011043303894324, 0.08438922084303802, 0.0838479526915531, 0.08471656622597923, 0.0271059457549937, 0.029882594529717754, 0.026571533877070452, 0.08325228303312326, 0.08340860430985542, 0.07660627099173056, 0.0, 0.0, 0.0, 0.010788053985259394, 0.011441923340644311, 0.01136970196189191, 0.008341223411306387, 0.01037874080336676, 0.009306270373796388, 0.1144867892228395, 0.14071628587952523, 0.10611128958553562, 0.0, 0.0, 0.0]}}
{"id": "e22b4c27-0b2a-4b7b-bfe9-03c8cd63eba4", "fitness": 0.03816780067425837, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Optimized exploration by refining dynamic inertia weight calculation for improved convergence.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.6 * (1 - self.current_evals / self.budget)  # Refined calculation\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]  # Added momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))  # Added adaptive scaling\n            \n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 44, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03817 with standard deviation 0.04392.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.13550680653888436, 0.09420483108980415, 0.14163704243783304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0283794207186554, 0.030135296314492188, 0.020304881044955092, 0.027350393379651505, 0.02059413930183529, 0.020000000000000018, 0.07097992833690503, 0.05285621406126384, 0.0532391185183293, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.0734163452669927, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13268520455051802, 0.1169712944200918, 0.13084903150896143, 0.032412616546026785, 0.020000000000000018, 0.020000000000000018, 0.08257454052083402, 0.0863116411064907, 0.09751781853040087, 0.14424412130522768, 0.14837801176230814, 0.12213213699016279, 0.07805826617049005, 0.1092342001726081, 0.07032885620226947, 0.13058915213512334, 0.11957819832588001, 0.14437395411399445, 0.020000000000000018, 0.11038946512012293, 0.12044689594017155, 0.10819636878037442, 0.11085475307644932, 0.09029545807586858, 0.07434928139420949, 0.1406595214662374, 0.077926129036888, 0.1438526290318487, 0.13615481880700708, 0.15475448018179316, 0.038669801718039354, 0.04723313020061226, 0.030609904824323464, 0.06170825875692865, 0.028332701608785538, 0.044269743823326824, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01477798680973108, 0.01213803243883771, 0.01010493536261492, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013535830358444523, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09749896744663888, 0.06679226326112597, 0.07725284571867919, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05502505769252353, 0.06147825531143891, 0.06353119922410011, 0.12025345974695478, 0.10367855229462886, 0.10574598459741424, 0.06534050401774294, 0.046366849582585856, 0.053936809511723194, 0.10342442567008447, 0.08585532472721102, 0.10447948210894875, 0.011315809952478051, 0.010000000000000009, 0.010000000000000009, 0.03431146342276237, 0.038230646084099984, 0.05466941875275566, 0.026800976729312698, 0.024847297953729308, 0.026142338205974336, 0.13453760644348534, 0.1379217616817363, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009097783330383913, 0.000342684976726515, 0.0020927479895618273, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04165365091573814, 0.04345303190792438, 0.03134808787596777, 0.0, 0.0, 0.0, 0.03699941221368819, 0.050872347434812726, 0.03774830206231461, 0.08346975118377797, 0.0873538275092468, 0.08593986532914588, 0.0300514128664211, 0.03089734189400717, 0.02270251300304038, 0.08239949269269287, 0.07981970546513029, 0.07770231976375552, 0.0, 0.0, 0.0, 0.010769693611198061, 0.011596166735731273, 0.01086837829297882, 0.008434859438860798, 0.010051284513262426, 0.009362145818271994, 0.1112398058338967, 0.1304161139054778, 0.1150465738483476, 0.0, 0.0, 0.0]}}
{"id": "ceb9a35a-30a6-46fc-92b7-029a5d48bb3b", "fitness": 0.03746840603990485, "name": "QuantumEnhanced_Optimizer", "description": "Integrating adaptive quantum-inspired mechanisms to enhance exploration in high-dimensional spaces while maintaining convergence efficiency.", "code": "import numpy as np\n\nclass QuantumEnhanced_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.3\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n    \n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.3 + 0.4 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                quantum_influence = 0.05 * np.tanh(self.velocities[i])  # Quantum-inspired influence\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + quantum_influence)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.05, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.05 * np.cos(np.pi * self.current_evals / self.budget))\n            \n            self.cognitive_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.2 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 45, "feedback": "The algorithm QuantumEnhanced_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03747 with standard deviation 0.04354.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.12141274378270583, 0.08795829924850329, 0.14840159053716884, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03928127804523929, 0.027293069124084357, 0.020000000000000018, 0.02322418826648731, 0.034468464390020825, 0.025030789041822987, 0.0627455240738406, 0.048440530101270585, 0.052393651474876735, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.09978687596475222, 0.08390997194895244, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11400173393464119, 0.10407400199340144, 0.14823765264030686, 0.03890253871468985, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.0899239941700114, 0.14499501664114167, 0.15964052864605138, 0.1228063819106816, 0.0847645418104852, 0.09949463388969815, 0.07877083149986475, 0.12261138033605279, 0.10654366294610385, 0.15030250142677348, 0.020000000000000018, 0.020000000000000018, 0.022340184230565163, 0.13833232454507938, 0.09632861382545255, 0.09125859448068407, 0.0838063306072957, 0.06278643186040145, 0.056492493752391515, 0.17897537195397717, 0.13589170657517036, 0.15475448018179316, 0.04682938384843138, 0.04192985406141436, 0.03042128331034799, 0.05231834125627177, 0.027123801309041462, 0.06670032275820448, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015913323044359662, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010805788017731577, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08952071371535797, 0.07504046212385718, 0.07681716027317886, 0.010000000000000009, 0.010000000000000009, 0.012909629230564934, 0.05966450769839082, 0.07381358993271192, 0.06365580122120507, 0.12914498847403555, 0.10915600687214677, 0.10388488869651402, 0.07093924002989882, 0.04145083707154906, 0.05487054459074059, 0.10349255741540186, 0.10595033110913787, 0.1022960947927316, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03808434331621202, 0.055778830181692496, 0.032667126512382794, 0.031382004170710354, 0.023615253325680263, 0.026367570425574804, 0.1358224964087883, 0.13123409970527322, 0.1397937987091662, 0.011811655623315986, 0.010000000000000009, 0.010000000000000009, 0.015330193970626294, 0.003879771059701609, 0.005950539180937353, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.047611290533245754, 0.04151685200920141, 0.02918464430585277, 0.0, 0.0, 0.0, 0.03284514921099413, 0.03753213255583987, 0.0392509083956053, 0.08499282602622671, 0.08811984823612395, 0.0830225090949881, 0.028172516750378906, 0.03488081575681756, 0.025610122937910096, 0.08876416002847387, 0.08181618109761768, 0.07706210689201276, 0.0, 0.0, 0.0, 0.010689945011122859, 0.012580701151248097, 0.012427278778231465, 0.007656972299945108, 0.010472757561240775, 0.008135380924974345, 0.12509972479316545, 0.1304161139054778, 0.11828078790701513, 0.0, 0.0, 0.0]}}
{"id": "ff7b5e23-af8e-4582-b5b4-ecf66731f538", "fitness": 0.03525325440468272, "name": "Hybrid_LocalSearch_MultiPopulation_Optimizer", "description": "Introducing hybridized local search and multi-population dynamics for enhanced convergence speed and diversification.", "code": "import numpy as np\n\nclass Hybrid_LocalSearch_MultiPopulation_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6\n        self.temperature = 100.0\n        self.cooling_rate = 0.95\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.subpop_size = self.population_size // 2\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Local Search Improvement\n                if np.random.rand() < 0.3:\n                    local_vector = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.particles[i] + local_vector\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_score = func(local_solution)\n                    self.current_evals += 1\n                    if local_score < self.personal_best_scores[i]:\n                        self.personal_best_positions[i] = local_solution\n                        self.personal_best_scores[i] = local_score\n                        if local_score < self.global_best_score:\n                            self.global_best_score = local_score\n                            self.global_best_position = local_solution\n\n            # Simulated Annealing-like exploration\n            for i in range(self.subpop_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Adjusting parameters dynamically\n            self.temperature *= self.cooling_rate\n            self.inertia_weight = 0.4 + 0.3 * (1 - self.current_evals / self.budget)\n\n            # Multi-population exchange\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.particles)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 46, "feedback": "The algorithm Hybrid_LocalSearch_MultiPopulation_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03525 with standard deviation 0.04674.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.15056575478186207, 0.12239683348411379, 0.1379930602369328, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03468487696676248, 0.020000000000000018, 0.020000000000000018, 0.039641341024105214, 0.02427886409291513, 0.020000000000000018, 0.08335044476400899, 0.05733752678693382, 0.0495249822266669, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.060996720567390805, 0.08772600116644613, 0.08098215377310769, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15621187351615518, 0.1076922282644186, 0.13275028259271382, 0.044573544550155164, 0.020000000000000018, 0.020000000000000018, 0.08449695336873697, 0.08511999000615578, 0.08972716518137702, 0.14561872796287534, 0.1505633041528306, 0.12423694027818921, 0.06964659451223765, 0.09302396223990061, 0.06547169541257858, 0.13163392612836078, 0.12795672755741505, 0.12264523151685969, 0.15775426924420233, 0.020000000000000018, 0.020000000000000018, 0.10677177815807992, 0.08477141353515805, 0.09772777330175031, 0.06425444040545014, 0.1365551193645862, 0.056998750959439404, 0.15233015399210015, 0.13509646431032962, 0.16249525908027695, 0.048423840826880005, 0.03730274424362845, 0.033346623360362315, 0.03692758185571743, 0.0328506797750997, 0.06248710611102837, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025466031124481203, 0.0184812112886803, 0.02012893276151062, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013269534361210145, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0876413273647687, 0.08623966489474566, 0.08337317599096328, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06525496156379973, 0.06372543925563756, 0.05347104120102386, 0.12430167388014235, 0.09727392210387786, 0.10254444658268502, 0.08052662595484605, 0.03971475064258245, 0.0579052412335328, 0.10006734985456422, 0.10137590738982416, 0.1047937387256268, 0.018436795429142894, 0.010000000000000009, 0.010000000000000009, 0.027844992356695908, 0.037502094972138966, 0.035699317540425546, 0.03364065202038602, 0.040604406083117106, 0.02649070367165285, 0.1393396511773617, 0.13463374450781895, 0.13949106505018183, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009582977124704017, 0.0, -0.04038781670568303, 0.0, 0.0, 0.0, 0.0, -0.020000000000000018, -0.040000000000000036, 0.0, 0.0, -0.010000000000000009, 0.0005660686023198913, 0.0, -0.010000000000000009, 0.0, 0.0, -0.040000000000000036, 0.0, -0.020000000000000018, -0.010000000000000009, 0.0, -0.030000000000000027, 0.0, 0.0, 0.0, -0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, -0.010000000000000009, 0.0, 0.0, -0.06000000000000005, 0.0, 0.0, -0.010000000000000009, 0.043649892837964166, 0.05046889657283882, 0.026223908585239042, 0.0, 0.0, -0.040000000000000036, 0.03309019627949683, 0.009450890075673346, -0.009868264735344967, 0.08312406981803189, 0.0899724456784382, 0.052507896717633895, 0.022630595943077814, 0.029670293836253747, -0.024366489024443494, 0.07880499989195033, 0.08552449753556435, 0.026623404471268763, 0.0, 0.0, -0.030000000000000027, 0.010647676809435347, 0.013504483803813971, 0.002904884177712841, 0.007428942379836934, 0.010909578549750276, 0.0002930093831393643, 0.1297893560996889, 0.11294185185746985, 0.0928346002259165, 0.0, 0.0, -0.040000000000000036]}}
{"id": "50de6317-f887-44f2-b0d0-a61c6533b9c9", "fitness": 0.0380248960087693, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced exploration through dynamic adaptive velocity and mutation scaling.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]  # Added momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i] * (1 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget))  # Added adaptive scaling factor\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))  # Added adaptive scaling\n            \n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 47, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03802 with standard deviation 0.04374.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.13743047945287457, 0.09601913547093122, 0.14307646361944704, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027729192491929955, 0.02412301802279171, 0.020409972560322287, 0.02442001502959623, 0.020000000000000018, 0.020000000000000018, 0.07273844082140624, 0.052933718576576916, 0.0538027226716955, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1044696929985317, 0.07433943010216637, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1285768356399134, 0.11568595419846872, 0.13084903150896143, 0.03749652989272245, 0.020000000000000018, 0.020000000000000018, 0.08850912303222713, 0.0863116411064907, 0.08099704213132641, 0.14026459077282427, 0.1724062774704842, 0.1238680825842825, 0.07608862230345925, 0.09450690454006949, 0.06319331714800247, 0.12451589621701831, 0.12275207210974381, 0.12800865119487326, 0.020000000000000018, 0.10109979106057265, 0.12300718659453136, 0.10819636878037442, 0.11301560582800874, 0.0895133107273659, 0.06527120746322768, 0.13779981043988998, 0.08567565180765924, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.045818791474798726, 0.041074262812270224, 0.027189348038355043, 0.05802456297679004, 0.028135806628559856, 0.04233479663442796, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016025172567085355, 0.01196480973383085, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01239136681207531, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09687188186947282, 0.06545519256401078, 0.07778177733716607, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057729704966409945, 0.06147825531143891, 0.05395939349942802, 0.1240854963055048, 0.10411470960491243, 0.10514704524887364, 0.07237627083923603, 0.04501613093692225, 0.055410607799246225, 0.1091210826589859, 0.08916222021186626, 0.10585356993341355, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04072115167154999, 0.03561103465893789, 0.053279642761690504, 0.03494234407688668, 0.0260145807541039, 0.03737703003097326, 0.13258639103062564, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010523803991939085, 0.00037224321297812946, 0.00014580753422821502, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.042465369114944695, 0.04491469808443582, 0.034102005949004144, 0.0, 0.0, 0.0, 0.030262202767467716, 0.04309068162902563, 0.04016574081419988, 0.08381359277179212, 0.08399978377460182, 0.0787412790206733, 0.030793788290247148, 0.03532424685852542, 0.026251152431179592, 0.0842473110962415, 0.0795092704976702, 0.07880802379851726, 0.0, 0.0, 0.0, 0.010868767060398743, 0.011566032480850752, 0.010877508657606283, 0.008001206196076693, 0.010557196638143918, 0.009339397251130643, 0.11183548359642392, 0.1304161139054778, 0.12201192529570959, 0.0, 0.0, 0.0]}}
{"id": "10a416ed-0469-4bf8-a382-f43bd9599ef9", "fitness": 0.037329366544645776, "name": "Quantum_Inspired_Adaptive_Optimizer", "description": "Leveraging quantum-inspired superposition states and dynamic learning rates to enhance diversity and convergence in complex search landscapes.", "code": "import numpy as np\n\nclass Quantum_Inspired_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.4\n        self.temperature = 100.0\n        self.cooling_rate = 0.95\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n        \n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.5 + 0.4 * (1 - self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n                \n                # Update velocity and position\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                superposition_effect = np.random.normal(0, 0.1, self.dim)\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + superposition_effect)\n                self.particles[i] += self.velocities[i]\n                \n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                # Dynamic mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Cool down the temperature\n            self.temperature *= self.cooling_rate\n            \n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.4 + 0.2 * np.cos(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.3 + 0.2 * np.cos(np.pi * self.current_evals / self.budget)\n        \n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 48, "feedback": "The algorithm Quantum_Inspired_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03733 with standard deviation 0.04334.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.10206779044323777, 0.08396737198966009, 0.14438041666992563, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.028876948411156067, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020471841962875548, 0.020000000000000018, 0.05522975943435848, 0.047720070703035966, 0.05002467011358791, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04457640387574002, 0.0879413410420582, 0.07368789947738308, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12547394963124736, 0.09501141359741427, 0.15774181743375948, 0.024581880131151812, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.09017905820018934, 0.07337024663890301, 0.12990506644848054, 0.15162014951304315, 0.13150065897238017, 0.07678524143716448, 0.08409235491918221, 0.07616444926405808, 0.13154160928754555, 0.15578689147640046, 0.1449868125752528, 0.020000000000000018, 0.020000000000000018, 0.10386787199199388, 0.14231154952941916, 0.0793074820988392, 0.0895133107273659, 0.08399125312001887, 0.14356822488818988, 0.056492493752391515, 0.1501201839847358, 0.13621670769770644, 0.15475448018179316, 0.05239882865404877, 0.03392426887360889, 0.029902854947555402, 0.048350316601055376, 0.03112980573358315, 0.057302910429588017, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014015051171294646, 0.010616321593272304, 0.010966256946987163, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014472852921070922, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08258879516529083, 0.07451557194626102, 0.07889166932635605, 0.010000000000000009, 0.010000000000000009, 0.015661607085298956, 0.054639414910159556, 0.06552193161444875, 0.05786109270218165, 0.12852130441655207, 0.10045855156845773, 0.10869494398245327, 0.07959782497138956, 0.042533015471575286, 0.056702157875801906, 0.09545516665038922, 0.08973361297655136, 0.10729801537892414, 0.06184127449482901, 0.010000000000000009, 0.010000000000000009, 0.03264150316279635, 0.03760652189084923, 0.03717821573962865, 0.029456751040998097, 0.02785245724057417, 0.02832320174819103, 0.13601764419766538, 0.13364356761349105, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015774695518684045, 0.00033076780770802117, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.044985194689880936, 0.034605609166197815, 0.024932827101058597, 0.0, 0.0, 0.0, 0.03647263039403226, 0.037539298158179024, 0.05117875319269993, 0.08890597832641622, 0.087423142247951, 0.07579735021174994, 0.02591310880462272, 0.028300352947066454, 0.024397260855332226, 0.07984777087219885, 0.07716883482308934, 0.07695037268835803, 0.0, 0.0, 0.0, 0.011109764116770338, 0.01157612776626693, 0.01022542147291261, 0.00788295803582617, 0.01205196403058495, 0.010024869262160063, 0.1112398058338967, 0.1304161139054778, 0.10943704775764507, 0.0, 0.0, 0.0]}}
{"id": "e8d4230e-39dd-46a1-99a6-d9d80ec73f61", "fitness": 0.03717765621090794, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced momentum strategies and adaptive coefficients to improve convergence and exploration balance.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.7  # Adjusted inertia weight for exploration-exploitation balance\n        self.cognitive_coeff = 1.8  # Increased cognitive coefficient for better personal best attraction\n        self.social_coeff = 1.4\n        self.temperature = 120.0  # Increased initial temperature for more exploration\n        self.cooling_rate = 0.96  # Further adjusted cooling rate\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.3 + 0.6 * (1 - self.current_evals / self.budget)  # More dynamic range\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                momentum = 0.2 * self.velocities[i]  # Increased momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + momentum)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.15, self.dim)  # Wider exploration\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate\n\n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.7 + 0.2 * np.sin(np.pi * self.current_evals / self.budget)  # Enhanced dynamics\n            self.social_coeff = 1.3 + 0.1 * np.cos(np.pi * self.current_evals / self.budget)\n            \n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 49, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03718 with standard deviation 0.04291.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1406750318075609, 0.08845784090139208, 0.1313713506876607, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021387646784345127, 0.022430212336468247, 0.022337212783189342, 0.03362153934003742, 0.020000000000000018, 0.020000000000000018, 0.07745681535643367, 0.05163620041327277, 0.05349540731402924, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02829263084111233, 0.0912006876116297, 0.08114489278349057, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037760450904020804, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11996593699498925, 0.10555696781251467, 0.13084903150896143, 0.02976475604411477, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07581616292009874, 0.14596322834172482, 0.15057933225485443, 0.14135983156974008, 0.08114653383415704, 0.08748025472548393, 0.06411754046796103, 0.13194444613169654, 0.12397670197320354, 0.1262846602506219, 0.020000000000000018, 0.020000000000000018, 0.10773442272437406, 0.15127468622481244, 0.07292120586292017, 0.09651452801169169, 0.0809838108457791, 0.07204109329858, 0.056492493752391515, 0.14750386872616195, 0.13589170657517036, 0.15475448018179316, 0.050292959767317846, 0.036814839558305446, 0.028356113895496082, 0.05277123282589358, 0.03321414629405284, 0.060379772121303965, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018515256056731877, 0.010260190497908717, 0.01146156162247125, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011082797179800208, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08482079907720663, 0.073347870074297, 0.07388482547813968, 0.010000000000000009, 0.010000000000000009, 0.012864225647178817, 0.05459995317003097, 0.062206850256318225, 0.058458384658622964, 0.132529715138201, 0.1034572711940549, 0.10525877591177302, 0.0739505018607014, 0.04619915944430486, 0.05505438475009106, 0.09372891370584968, 0.08476751860486875, 0.10710740647056194, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03219842436690268, 0.04028053805170517, 0.03581821697999554, 0.027086375153141606, 0.0454859490303966, 0.025621858142839238, 0.1403026929585378, 0.1323689122533156, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01456255185145594, 0.0030564718054784112, 0.004589899456253654, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04610572784416078, 0.03961310410908947, 0.030684324339395608, 0.0, 0.0, 0.0, 0.034544983884819525, 0.03753213255583987, 0.0350807596325482, 0.0867601984769878, 0.09130442731121902, 0.08308519902450984, 0.027976195054758124, 0.031823095654791134, 0.020041815442987887, 0.09053044091323836, 0.07798994792923186, 0.07158357494344103, 0.0, 0.0, 0.0, 0.010203517684801211, 0.012459836644180156, 0.011915292824585921, 0.008165292852111428, 0.010444299606669705, 0.00818971836184279, 0.12498178231094415, 0.13265504940008266, 0.11693826644554617, 0.0, 0.0, 0.0]}}
{"id": "fc27ce98-135c-4935-aeab-453e3ced922d", "fitness": 0.03709838126987673, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer_v2", "description": "Introducing adaptive learning rates and diversity preservation through a multi-layer hybrid approach for balanced exploration-exploitation.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Dynamic elite swapping\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.cos(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 50, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03710 with standard deviation 0.04299.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.14135508860498758, 0.09497207901070548, 0.12885453385016632, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026449125807932017, 0.024823107531019017, 0.020937154776576428, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07359837722251994, 0.05136670313167202, 0.05157130144132127, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.10804363219929314, 0.08021405969770112, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1249675693137412, 0.10312683413976065, 0.13084903150896143, 0.03117777794805021, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.149491014117217, 0.15748558861414141, 0.1207581696386133, 0.07835753494120612, 0.10016394968132092, 0.07249223273357042, 0.13729019726851366, 0.11829145357897486, 0.12191976134240401, 0.020000000000000018, 0.10402516927645877, 0.020000000000000018, 0.12620518366220945, 0.08904823826894614, 0.0895133107273659, 0.06527120746322768, 0.07044465787255005, 0.056492493752391515, 0.1457616315951068, 0.14274301295500236, 0.15475448018179316, 0.039638088673134786, 0.03938865317981799, 0.037196343953933675, 0.050620580617774524, 0.030583669947542247, 0.045376742505917056, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013033716002231133, 0.011323796382674667, 0.010052209852708494, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011169523499983458, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09319385480094755, 0.06449252968760466, 0.08195978850614438, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06704634734205583, 0.06147825531143891, 0.06316286147429873, 0.12474554788351266, 0.09951423996621744, 0.10726747256847757, 0.05982266647328416, 0.047607085127614246, 0.053936809511723194, 0.09849954582790532, 0.08458981285054601, 0.1140077138004254, 0.08491516670202326, 0.010000000000000009, 0.010000000000000009, 0.027017412601177404, 0.04529686718448811, 0.0551146990877982, 0.03621949742333597, 0.024159061675130822, 0.0258464635014779, 0.13141309820135194, 0.14518448261416794, 0.1339892132212337, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009779491383021255, 0.0008208914290241953, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.037613854567201344, 0.03978143628661357, 0.03157394757111287, 0.0, 0.0, 0.0, 0.03979862337536777, 0.038256897373039056, 0.02953683646174421, 0.08912503485927914, 0.08349929327109384, 0.07818930574555205, 0.023813375982799978, 0.0257581936771224, 0.02390464683855842, 0.07090654895105342, 0.07661788190444307, 0.06991139254207213, 0.0, 0.0, 0.0, 0.009939544104567655, 0.011126899241485133, 0.011697636433716574, 0.008067051475911358, 0.010065717131705676, 0.009425454492802077, 0.14119055064517627, 0.1304161139054778, 0.12031456599603696, 0.0, 0.0, 0.0]}}
{"id": "ff69e654-5cec-4327-885c-aa5bf89ae7e9", "fitness": -Infinity, "name": "Advanced_MultiSwarm_Chaotic_Optimizer", "description": "Introducing a multi-swarm strategy with adaptive learning coefficients and chaotic maps for enhanced global search efficiency.", "code": "import numpy as np\n\nclass Advanced_MultiSwarm_Chaotic_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.num_swarms = 3\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n        self.swarms = self.initialize_swarms()\n\n    def initialize_swarms(self):\n        swarms = []\n        for _ in range(self.num_swarms):\n            particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            personal_best_positions = np.copy(particles)\n            personal_best_scores = np.full(self.population_size, float('inf'))\n            global_best_position = np.zeros(self.dim)\n            global_best_score = float('inf')\n            swarms.append({\n                'particles': particles,\n                'velocities': velocities,\n                'personal_best_positions': personal_best_positions,\n                'personal_best_scores': personal_best_scores,\n                'global_best_position': global_best_position,\n                'global_best_score': global_best_score\n            })\n        return swarms\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            x = np.random.rand()\n            x = self.chaotic_map(x)\n            for swarm in self.swarms:\n                dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n                adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n                for i in range(self.population_size):\n                    score = func(swarm['particles'][i])\n                    self.current_evals += 1\n                    if score < swarm['personal_best_scores'][i]:\n                        swarm['personal_best_scores'][i] = score\n                        swarm['personal_best_positions'][i] = swarm['particles'][i].copy()\n                    if score < swarm['global_best_score']:\n                        swarm['global_best_score'] = score\n                        swarm['global_best_position'] = swarm['particles'][i].copy()\n\n                    r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                    cognitive_velocity = self.cognitive_coeff * r1 * (swarm['personal_best_positions'][i] - swarm['particles'][i])\n                    social_velocity = self.social_coeff * r2 * (swarm['global_best_position'] - swarm['particles'][i])\n                    diversity_control = 0.5 * r3 * (swarm['particles'][np.random.randint(0, self.population_size)] - swarm['particles'][i])\n                    swarm['velocities'][i] = (dynamic_inertia_weight * swarm['velocities'][i] +\n                                              cognitive_velocity + social_velocity + diversity_control)\n                    swarm['particles'][i] += swarm['velocities'][i]\n                    swarm['particles'][i] = np.clip(swarm['particles'][i], self.lower_bound, self.upper_bound)\n\n                    dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                    if np.random.rand() < dynamic_mutation_rate:\n                        mutation_vector = np.random.normal(0, 0.1, self.dim)\n                        swarm['particles'][i] += mutation_vector\n                        swarm['particles'][i] = np.clip(swarm['particles'][i], self.lower_bound, self.upper_bound)\n\n                if self.current_evals % (self.population_size * 2) == 0:\n                    sorted_indices = np.argsort(swarm['personal_best_scores'])\n                    top_solutions = swarm['personal_best_positions'][sorted_indices[:3]]\n                    for other_swarm in self.swarms:\n                        if other_swarm != swarm:\n                            other_swarm['particles'][:3] = top_solutions\n\n                self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n                self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n                self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        global_best_position = None\n        global_best_score = float('inf')\n        for swarm in self.swarms:\n            if swarm['global_best_score'] < global_best_score:\n                global_best_score = swarm['global_best_score']\n                global_best_position = swarm['global_best_position']\n        return global_best_position, global_best_score", "configspace": "", "generation": 51, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {}}
{"id": "b31015b2-65cd-42ab-a574-aff75a14f05b", "fitness": 0.038449121069636195, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introducing dynamic elite diversification and stochastic variance reduction to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            stochastic_variance_reduction_factor = 1 - 0.5 * (self.current_evals / self.budget)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 * stochastic_variance_reduction_factor, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1 * stochastic_variance_reduction_factor, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n                additional_diversification = np.random.uniform(self.lower_bound, self.upper_bound, self.elite_positions.shape)\n                self.elite_positions += additional_diversification * stochastic_variance_reduction_factor\n            \n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 52, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03845 with standard deviation 0.04425.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.055309221362073946, 0.02496211321152686, 0.046338349906305365, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014515208373294453, 0.010000000000000009, 0.011150780572439456, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013697794299784127, 0.01007666262314455, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09240162640480565, 0.06381952541901836, 0.07763765418745283, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058346478705002536, 0.06638419578738308, 0.05443545187094356, 0.12747689697404507, 0.09772571275796638, 0.1083274071367265, 0.0787744944845431, 0.043440463108632366, 0.05539990647454185, 0.10169888831780616, 0.0805031580634501, 0.11007333539475195, 0.04814504669268005, 0.010000000000000009, 0.010000000000000009, 0.03197156395700007, 0.03474511184118745, 0.05357474220987768, 0.036130068272214655, 0.024554159312673685, 0.02660033846994936, 0.1337796015068995, 0.13579767363433082, 0.13572656619854262, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.007532514068885665, 0.00048813744443121365, 0.007415472874193529, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04010311691907942, 0.041987147882524445, 0.0313015271564564, 0.0, 0.0, 0.0, 0.03246909993403402, 0.04832539568382688, 0.04011043303894324, 0.0870237536339169, 0.08372460361611533, 0.08273461510049307, 0.027034067237133752, 0.029882594529717754, 0.027051094654851116, 0.08157063176881596, 0.08162469398152683, 0.0772681380383764, 0.0, 0.0, 0.0, 0.010948283286264293, 0.011441923340644311, 0.011314082435934791, 0.008812358526855246, 0.01025599705331981, 0.009485532930522234, 0.1112398058338967, 0.14071628587952523, 0.10644208257393795, 0.0, 0.0, 0.0]}}
{"id": "d98e4c65-594f-4540-89ae-cf63aefb534e", "fitness": -Infinity, "name": "Enhanced_PSO_GA_SA_Optimizer_Rotation", "description": "Introducing adaptive attraction-repulsion dynamics and a rotational search component to enhance convergence and exploration efficacy.", "code": "import numpy as np\n\nclass Enhanced_PSO_GA_SA_Optimizer_Rotation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.4\n        self.repulsion_coeff = 0.3  # Added repulsion coefficient\n        self.temperature = 100.0\n        self.cooling_rate = 0.95\n        self.mutation_rate = 0.1\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.03 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position with attraction-repulsion\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                repulsion_velocity = self.repulsion_coeff * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                rotational_component = np.cross(self.velocities[i], self.particles[np.random.randint(0, self.population_size)])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity - repulsion_velocity + 0.05 * rotational_component)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation rate\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Cool down the temperature with adaptive scaling\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            # Dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.3 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 53, "feedback": "An exception occurred: ValueError('incompatible dimensions for cross product\\n(dimension must be 2 or 3)').", "error": "ValueError('incompatible dimensions for cross product\\n(dimension must be 2 or 3)')", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {}}
{"id": "32b619c8-e445-471e-8420-47bfd672ed80", "fitness": 0.03845038769294124, "name": "Adaptive_Metaheuristic_Optimizer", "description": "Introducing a self-adaptive strategy with dynamic parameter tweaking based on convergence behavior for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass Adaptive_Metaheuristic_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n        self.prev_global_best_score = float('inf')\n        self.temperature = self.initial_temperature\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.global_best_score < self.prev_global_best_score:\n                self.temperature = max(self.temperature * adaptive_cooling_rate, 1.0)\n            else:\n                self.temperature = self.initial_temperature\n\n            self.prev_global_best_score = self.global_best_score\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.cos(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 54, "feedback": "The algorithm Adaptive_Metaheuristic_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03845 with standard deviation 0.04430.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.06033576399578766, 0.02640072450014397, 0.04414053143185015, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014630465634442702, 0.011524820678592396, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09803313584113282, 0.06733831009419589, 0.07736100526273082, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05525524066333898, 0.06147825531143891, 0.055892828646099235, 0.12737768063242216, 0.10055481813860312, 0.1083274071367265, 0.0787744944845431, 0.0481693135988529, 0.053936809511723194, 0.10166938594285857, 0.08518980628499706, 0.11007333539475195, 0.01373682011305899, 0.010000000000000009, 0.010000000000000009, 0.03474004559325494, 0.035617682465190925, 0.053940975000623115, 0.033909849778402945, 0.025951147203510883, 0.03302300264240132, 0.13141309820135194, 0.13194494949337954, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00939900157534923, 5.934563635179302e-05, 0.00698618088761338, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0424373881224378, 0.046013583183732054, 0.0315668986103429, 0.0, 0.0, 0.0, 0.0385555657129808, 0.04832539568382688, 0.04011043303894324, 0.08395148161298527, 0.08389132326936088, 0.08589003277448715, 0.028069147402188133, 0.029882594529717754, 0.026611394367503483, 0.08419184335284369, 0.08162469398152683, 0.07470311236901284, 0.0, 0.0, 0.0, 0.010933927445840208, 0.011441923340644311, 0.011434573529835568, 0.007498340756678656, 0.01066569816559304, 0.009343303974287509, 0.11361081097181835, 0.14071628587952523, 0.10769835205020173, 0.0, 0.0, 0.0]}}
{"id": "29806d9d-1aa6-41cb-9a23-3beb61224842", "fitness": 0.037749516376445844, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Incorporate a dual-layered adaptive inertia weight mechanism and dynamic multi-objective elitism to enhance global convergence and robustness.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:5])  # Expanded elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            # Dual-layered adaptive inertia\n            phase = self.current_evals / self.budget\n            if phase < 0.5:\n                dynamic_inertia_weight = 0.4 + 0.5 * (1 - 2 * phase)\n            else:\n                dynamic_inertia_weight = 0.9 - 0.5 * (2 * phase - 1)\n            \n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 5)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                accept_prob = np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature)\n                if candidate_score < self.personal_best_scores[i] or accept_prob > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:5]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            \n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 55, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03775 with standard deviation 0.04350.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.14669307951429045, 0.10493624064489637, 0.14515643273479428, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024571766957992236, 0.020000000000000018, 0.021983528613120473, 0.03248284524946532, 0.020000000000000018, 0.03657290138686364, 0.0775837423454564, 0.05240224447599029, 0.04956030618232932, 0.020000000000000018, 0.02286531931054836, 0.020000000000000018, 0.03086898661005788, 0.11674955372432239, 0.09247990046488042, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11714180126645313, 0.10170431013376857, 0.13859606387534784, 0.028249652898458044, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07394169406656148, 0.13796164393012078, 0.14264340914294682, 0.12925569181441188, 0.08179114176100999, 0.0849860345681498, 0.06766972601043275, 0.11860804736865704, 0.1264946679227914, 0.14134148248999667, 0.1225797697670703, 0.09852721955139654, 0.020000000000000018, 0.10819636878037442, 0.09230387672408313, 0.10586429603638559, 0.06527120746322768, 0.05125814275092977, 0.056492493752391515, 0.15282679015694245, 0.13589170657517036, 0.15475448018179316, 0.049731677378316075, 0.036332986721242855, 0.02756085701324329, 0.04863023447849779, 0.025462754914962304, 0.05712908536595296, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0368863440393844, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09042024597737808, 0.06685384646786152, 0.08582911966028473, 0.010000000000000009, 0.010000000000000009, 0.011245783658003994, 0.06459093547158434, 0.06526479847284772, 0.06189085726543597, 0.12332877201799208, 0.10515586763450346, 0.10526320130788791, 0.07356045526462862, 0.039712451751389044, 0.05622852899798658, 0.10607672484348551, 0.09776471970635625, 0.11127306512134927, 0.011221187435957347, 0.010000000000000009, 0.010000000000000009, 0.03702524151315534, 0.04738877182938783, 0.03179575734983475, 0.02904428760342692, 0.025792290588089073, 0.024902883959353694, 0.1330482139042498, 0.14155854020786118, 0.14079675051429996, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012735948686809495, 0.0, 0.004776864051823093, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04169540749679557, 0.03791413638498242, 0.03336286466170335, 0.0, 0.0, 0.0, 0.035372402763228616, 0.03753213255583987, 0.033985507747532506, 0.08454817546996607, 0.08393732286478284, 0.08257371080293341, 0.028787093483367276, 0.024634920722212295, 0.020814191321380848, 0.08469117765576417, 0.08617408199396781, 0.07809502739832053, 0.0, 0.0, 0.0, 0.012090833490593367, 0.010528156054503857, 0.013328663829338172, 0.007716771841120962, 0.010299803059967916, 0.009029003365890298, 0.12491767086714123, 0.1304161139054778, 0.11887315950701804, 0.0, 0.0, 0.0]}}
{"id": "616e5954-cf62-4be5-8d4e-1deaa76e22fc", "fitness": 0.036980297821209124, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced hybrid metaheuristic with dynamic control over swarm diversity, adaptive crossover, and elite re-initialization for improved convergence and exploration.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25  # Increased population size\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.97  # Adjusted cooling rate\n        self.mutation_rate = 0.1  # Reduced mutation rate\n        self.crossover_rate = 0.8  # Introduced crossover rate\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Crossover operation\n                if np.random.rand() < self.crossover_rate:\n                    parent2 = self.particles[np.random.randint(self.population_size)]\n                    crossover_point = np.random.randint(1, self.dim - 1)\n                    self.particles[i][:crossover_point] = parent2[:crossover_point]\n            \n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n            \n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            \n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 56, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03698 with standard deviation 0.04243.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.10177438092996172, 0.09935313043832172, 0.13828619043173263, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030825099017663393, 0.04086080691534444, 0.03361133506471825, 0.020502156896666457, 0.021062511672544137, 0.020293478262409237, 0.06610106236362867, 0.06923056102107406, 0.0499933971435218, 0.020000000000000018, 0.028110561365510045, 0.020000000000000018, 0.04121993011247138, 0.08594148016760361, 0.09038652367277544, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024133325246132098, 0.020000000000000018, 0.020000000000000018, 0.12249011507060004, 0.13018113750643667, 0.15537918836522346, 0.02775906363091518, 0.030692865938297897, 0.02355136177194228, 0.08232367710936839, 0.0863116411064907, 0.07015575039186472, 0.14290894652401076, 0.1441288615310239, 0.1400614455102891, 0.0827029318364646, 0.0889738145881549, 0.07153405176290817, 0.124386657660297, 0.12370498501722071, 0.13441655164808108, 0.10922383723976126, 0.020000000000000018, 0.09739260097842195, 0.10819636878037442, 0.0811421257405206, 0.0895133107273659, 0.0677162831653646, 0.04946707012091378, 0.056492493752391515, 0.15634962518148654, 0.13589170657517036, 0.15475448018179316, 0.045145735072944615, 0.04017868262094337, 0.032356443467093876, 0.04150168867411086, 0.032620852974821535, 0.04393221685940185, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027042657630785505, 0.011298364313758968, 0.011908302461705378, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010974171584908654, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07777792195726962, 0.07956913983189795, 0.07429520928699573, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05568663142727015, 0.12548721715052769, 0.09802750555204265, 0.10328237394947759, 0.06516063864038879, 0.03724296432018004, 0.053936809511723194, 0.0836030437088402, 0.09026854158039754, 0.10750426349769715, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02803951838058183, 0.03656913579776411, 0.07694549498980408, 0.025483549330511113, 0.02588213134489792, 0.024640285494433645, 0.139878404245536, 0.13123409970527322, 0.1362397668968629, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.006014151946854729, 0.00016163751923958802, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045378217783402786, 0.036886335852726826, 0.029812039431900916, 0.0, 0.0, 0.0, 0.033056916399911374, 0.040117386233979424, 0.0341022629596226, 0.08074132535561274, 0.0850697390203724, 0.08105017435694384, 0.024993635252824498, 0.027028398479324145, 0.022299995000962025, 0.07889449011394734, 0.06923768006902364, 0.06555496939932681, 0.0, 0.0, 0.0, 0.010495866776687013, 0.011229296911562714, 0.010035781145820821, 0.008699043405990037, 0.010051284513262426, 0.008276165291562165, 0.11862996172013707, 0.1304161139054778, 0.11023060965714426, 0.0, 0.0, 0.0]}}
{"id": "07b37758-76d5-4c98-bda8-a7d43308f70e", "fitness": 0.03861879989675403, "name": "Advanced_Adaptive_PSO_GA_SA_Optimizer", "description": "Introducing dynamic population resizing and entropy-driven exploration to enhance convergence and diversity in optimization.", "code": "import numpy as np\n\nclass Advanced_Adaptive_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def resize_population(self):\n        # Entropy measure to decide population resizing\n        diversity_score = np.mean(np.std(self.particles, axis=0))\n        if diversity_score < 0.1 and self.population_size > 10:\n            self.population_size -= 1\n        elif diversity_score > 0.5 and self.population_size < self.initial_population_size:\n            self.population_size += 1\n        self.particles = self.particles[:self.population_size]\n        self.velocities = self.velocities[:self.population_size]\n        self.personal_best_positions = self.personal_best_positions[:self.population_size]\n        self.personal_best_scores = self.personal_best_scores[:self.population_size]\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            self.resize_population()\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n            \n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            \n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 57, "feedback": "The algorithm Advanced_Adaptive_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03862 with standard deviation 0.04437.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.06057955339872889, 0.026276544973413807, 0.044237291479742424, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014694142849066338, 0.01154065116932157, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09837639713657498, 0.06726496685060024, 0.07747566141930695, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.061745986985642376, 0.05443545187094356, 0.12731111196137856, 0.09973071595557248, 0.1083274071367265, 0.0787744944845431, 0.04974074653682192, 0.053936809511723194, 0.09690108901703198, 0.0837184153140883, 0.11007333539475195, 0.03594270683607359, 0.010000000000000009, 0.010000000000000009, 0.03458052430791314, 0.03833348885516341, 0.05392873067202941, 0.03380430171150861, 0.025543579885116685, 0.03330211511487835, 0.13186619252479614, 0.13377526647088855, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009475522845508899, 0.00011775215007503448, 0.006821143229484239, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04260533019278423, 0.04582561413844877, 0.03160404920442228, 0.0, 0.0, 0.0, 0.039003340094371786, 0.04832539568382688, 0.04011043303894324, 0.08395148161298527, 0.08355908251755362, 0.08655342187059589, 0.026763174189230576, 0.029882594529717754, 0.026120386218198344, 0.08378628405285637, 0.08243077727502979, 0.07928683269457348, 0.0, 0.0, 0.0, 0.010872803072828008, 0.011441923340644311, 0.011197996563543033, 0.0075446188613785825, 0.010584537826002216, 0.00937559252455733, 0.12126207436352077, 0.14071628587952523, 0.11269529096061182, 0.0, 0.0, 0.0]}}
{"id": "a7f3b6d3-5caa-42c5-9915-92af8a10df71", "fitness": -Infinity, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced elite selection and alternative mutation strategy for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Slightly increased cognitive coefficient\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.mutation_rate = 0.15  # Slightly increased mutation rate\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])  # Elitist strategy\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)  # Adjusted cooling strategy\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                # Update velocity and position\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]  # Added momentum term\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                # Ensure particles are within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Alternative mutation strategy\n                if np.random.rand() < dynamic_mutation_rate:\n                    rand_idx = np.random.randint(0, self.dim)\n                    self.particles[i][rand_idx] += np.random.uniform(-0.1, 0.1)  # Mutation only on one dimension\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Simulated Annealing-like exploration\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            # Enhanced elite selection\n            self.elite_positions = self.personal_best_positions[np.argsort(self.personal_best_scores)[:3]]\n\n            # Cool down the temperature\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))  # Added adaptive scaling\n            \n            # Introduce dynamic control over cognitive and social coefficients\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.1 * np.sin(np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 58, "feedback": "An exception occurred: NameError(\"name 'dynamic_mutation_rate' is not defined\").", "error": "NameError(\"name 'dynamic_mutation_rate' is not defined\")", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {}}
{"id": "ecfcd854-6d42-486c-9625-2ea95ca8df04", "fitness": 0.03864154604606713, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introducing dynamic adaptive learning rates for cognitive and social coefficients with enhanced elite preservation for improved convergence.  ", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Enhanced adaptivity\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)      # Enhanced adaptivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 59, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03864 with standard deviation 0.04434.", "error": "", "parent_ids": ["9613a2d1-e500-4b1d-a4e7-b2109f170def"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.06077986061442742, 0.026216015098403433, 0.04428671539534079, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014679455713475842, 0.011525792639399679, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.098529380630351, 0.06708923978720005, 0.07764259437301779, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.062372855301301766, 0.05455095883930494, 0.1267725891337258, 0.10098880741277227, 0.1083274071367265, 0.0787744944845431, 0.043440463108632366, 0.053936809511723194, 0.10032791203158897, 0.08452048098491849, 0.11007333539475195, 0.05089975028509941, 0.010000000000000009, 0.010000000000000009, 0.03443571535207213, 0.039075180117418395, 0.054159095170966176, 0.03373533481373614, 0.025371201063553284, 0.03258169838882874, 0.13487108924589297, 0.13123409970527322, 0.13571401118497095, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009434171515893763, 0.00013543212222089096, 0.006809204880934061, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0427241120240659, 0.0457264855043259, 0.031785947309990625, 0.0, 0.0, 0.0, 0.039884022227493765, 0.04832539568382688, 0.04011043303894324, 0.08395148161298527, 0.08350041880885162, 0.08642088775564749, 0.026877209824498705, 0.029882594529717754, 0.025241614041491278, 0.08522213112308663, 0.08162469398152683, 0.07718471678323235, 0.0, 0.0, 0.0, 0.01086684757707057, 0.011441923340644311, 0.011191912069537402, 0.007543866015462752, 0.010527543724962785, 0.009398011249341476, 0.1112398058338967, 0.14071628587952523, 0.11214834803722051, 0.0, 0.0, 0.0]}}
{"id": "10778933-8e09-4da6-a540-fb7aba972666", "fitness": 0.013971580694253258, "name": "Enhanced_MultiSwarm_Adaptive_Optimizer", "description": "Introducing a multi-swarm interaction mechanism with adaptive exploration-exploitation balancing and enhanced local search via adaptive mutation strategies to boost convergence and performance.", "code": "import numpy as np\n\nclass Enhanced_MultiSwarm_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.num_swarms = 5\n        self.swarm_size = self.population_size // self.num_swarms\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles for each swarm\n        self.swarms = [np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim)) for _ in range(self.num_swarms)]\n        self.velocities = [np.random.uniform(-1, 1, (self.swarm_size, self.dim)) for _ in range(self.num_swarms)]\n        self.personal_best_positions = [np.copy(swarm) for swarm in self.swarms]\n        self.personal_best_scores = [np.full(self.swarm_size, float('inf')) for _ in range(self.num_swarms)]\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = [np.copy(swarm[:3]) for swarm in self.swarms]\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            \n            for s in range(self.num_swarms):\n                for i in range(self.swarm_size):\n                    score = func(self.swarms[s][i])\n                    self.current_evals += 1\n                    if score < self.personal_best_scores[s][i]:\n                        self.personal_best_scores[s][i] = score\n                        self.personal_best_positions[s][i] = self.swarms[s][i].copy()\n                    if score < self.global_best_score:\n                        self.global_best_score = score\n                        self.global_best_position = self.swarms[s][i].copy()\n\n                    r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                    cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[s][i] - self.swarms[s][i])\n                    social_velocity = self.social_coeff * r2 * (self.global_best_position - self.swarms[s][i])\n                    diversity_control = 0.5 * r3 * (self.elite_positions[s][np.random.randint(0, 3)] - self.swarms[s][i])\n                    momentum = 0.1 * self.velocities[s][i]\n                    self.velocities[s][i] = (dynamic_inertia_weight * self.velocities[s][i] +\n                                              cognitive_velocity + social_velocity + diversity_control + momentum)\n                    self.swarms[s][i] += self.velocities[s][i]\n\n                    self.swarms[s][i] = np.clip(self.swarms[s][i], self.lower_bound, self.upper_bound)\n\n                    dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                    if np.random.rand() < dynamic_mutation_rate:\n                        mutation_vector = np.random.normal(0, 0.1, self.dim)\n                        self.swarms[s][i] += mutation_vector\n                        self.swarms[s][i] = np.clip(self.swarms[s][i], self.lower_bound, self.upper_bound)\n\n                for i in range(self.swarm_size):\n                    if self.current_evals >= self.budget:\n                        break\n                    candidate_solution = self.swarms[s][i] + np.random.normal(0, 0.1, self.dim)\n                    candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_solution)\n                    self.current_evals += 1\n                    if candidate_score < self.personal_best_scores[s][i] or \\\n                       np.exp((self.personal_best_scores[s][i] - candidate_score) / self.temperature) > np.random.rand():\n                        self.swarms[s][i] = candidate_solution\n                        self.personal_best_scores[s][i] = candidate_score\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_solution\n\n            for s in range(self.num_swarms):\n                if self.current_evals % (self.swarm_size * 2) == 0:\n                    np.random.shuffle(self.elite_positions[s])\n\n                sorted_indices = np.argsort(self.personal_best_scores[s])\n                self.elite_positions[s] = self.personal_best_positions[s][sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 60, "feedback": "The algorithm Enhanced_MultiSwarm_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01397 with standard deviation 0.06745.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.1272481287685795, 0.1086936734905134, 0.1419766423218607, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04147413269372635, 0.026139073940405044, 0.021472058409717776, 0.030819947671820946, 0.026721452646102928, 0.04003465618555535, 0.07853346677417694, 0.053537471224312294, 0.04693364677089695, 0.020000000000000018, 0.04267283583115311, 0.020000000000000018, 0.04884438802004498, 0.08630564140250985, 0.07397593867812191, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02224050062673455, 0.02700209911335749, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1522954910923343, 0.11639886348733852, 0.16728169220938982, 0.029376894526001562, 0.023515208965233403, 0.031469521980646675, 0.07939996399402527, 0.08187623045028458, 0.09068255768333489, 0.14903662341471569, 0.16336006506090084, 0.12738787208998792, 0.0975381611542171, 0.08529678711309596, 0.06525040727025355, 0.13715751100127693, 0.12726477602223019, 0.13290785372237313, 0.1287534360257928, 0.042566592151185856, 0.10143382357239605, 0.1141840601513826, 0.13853520947273779, 0.08955919558946435, 0.06282166758345908, 0.06022037234742139, 0.06544769912547044, 0.1438526290318487, 0.15633257607314588, 0.15222387110930313, 0.05316037775567095, 0.046134476809506664, 0.03623957257123944, 0.058462335830701595, 0.040485197852891064, 0.07032281727345535, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02629326136302257, 0.012398598567462171, 0.017969711102039154, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010078788486199475, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08328294555273141, 0.07223938717152156, 0.08461062105554917, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05651645990818921, 0.06124871403960286, 0.06405212674406113, 0.1199346301152504, 0.10211999647559467, 0.10394432461514458, 0.06783889298184809, 0.04852546592749074, 0.05505639213352964, 0.10034482929397126, 0.09925104164216392, 0.1136616303816359, 0.08480680246042172, 0.010000000000000009, 0.010000000000000009, 0.04001770103935953, 0.044204726041078835, 0.054964309125391964, 0.036938772789415264, 0.03951074024859591, 0.028075982702446378, 0.14377393381927728, 0.12911719506376684, 0.1384102612609024, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.05614382177992394, -0.07403470687694269, -0.0697890841254829, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.02612146473181931, -0.018624617451732384, -0.03198585212525118, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.044664321776438864, -0.039766313273680964, -0.045158654183645064, 0.018046835306441578, 0.012091761946324331, 0.012721791864956589, -0.04371446001387036, -0.05098014555967234, -0.05309114861068753, 0.0259972942667821, 0.015198547877068203, 0.017058061756961007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.0630093891946637, -0.06664409781442893, -0.06702205070620004, -0.0657745507661689, -0.06638159173530944, -0.06869526364469047, 0.04431420538860653, 0.06030599715395357, 0.04168208052625333, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007]}}
{"id": "7b70a593-df6b-4ce6-929b-272889196fda", "fitness": 0.03864154604606713, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced elite selection strategy to improve convergence by preserving diverse top performers.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:5]]  # Change size of elite positions\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Enhanced adaptivity\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)      # Enhanced adaptivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 61, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03864 with standard deviation 0.04434.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.06077986061442742, 0.026216015098403433, 0.04428671539534079, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014679455713475842, 0.011525792639399679, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.098529380630351, 0.06708923978720005, 0.07764259437301779, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.062372855301301766, 0.05455095883930494, 0.1267725891337258, 0.10098880741277227, 0.1083274071367265, 0.0787744944845431, 0.043440463108632366, 0.053936809511723194, 0.10032791203158897, 0.08452048098491849, 0.11007333539475195, 0.05089975028509941, 0.010000000000000009, 0.010000000000000009, 0.03443571535207213, 0.039075180117418395, 0.054159095170966176, 0.03373533481373614, 0.025371201063553284, 0.03258169838882874, 0.13487108924589297, 0.13123409970527322, 0.13571401118497095, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009434171515893763, 0.00013543212222089096, 0.006809204880934061, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0427241120240659, 0.0457264855043259, 0.031785947309990625, 0.0, 0.0, 0.0, 0.039884022227493765, 0.04832539568382688, 0.04011043303894324, 0.08395148161298527, 0.08350041880885162, 0.08642088775564749, 0.026877209824498705, 0.029882594529717754, 0.025241614041491278, 0.08522213112308663, 0.08162469398152683, 0.07718471678323235, 0.0, 0.0, 0.0, 0.01086684757707057, 0.011441923340644311, 0.011191912069537402, 0.007543866015462752, 0.010527543724962785, 0.009398011249341476, 0.1112398058338967, 0.14071628587952523, 0.11214834803722051, 0.0, 0.0, 0.0]}}
{"id": "b66e6a78-1093-45d0-9443-76b8d078becf", "fitness": 0.038383120807881886, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhanced adaptivity with exponential decay for the inertia weight to improve convergence stability.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * np.exp(-3 * self.current_evals / self.budget)  # Changed line\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Enhanced adaptivity\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)      # Enhanced adaptivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 62, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03838 with standard deviation 0.04433.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.061034412243424874, 0.026301515766239625, 0.04413314255296541, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013655764693901618, 0.010813416293444789, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09702414218627309, 0.062174533693577505, 0.07833224055215127, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0629146280555476, 0.05443545187094356, 0.126841383535095, 0.10159066382936588, 0.110797313819744, 0.0787744944845431, 0.04660026163342723, 0.0568868523656737, 0.09856892085874325, 0.0846763889935278, 0.11007333539475195, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0335132129652187, 0.03773928886834721, 0.05357474220987768, 0.0358309215846242, 0.026056625086871454, 0.026315678406472975, 0.13141309820135194, 0.13416450268203406, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009932567914375579, 6.400672804218743e-05, 0.007455452201061363, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.042805981588386444, 0.04527541950605085, 0.03339518231063121, 0.0, 0.0, 0.0, 0.03246909993403402, 0.04832539568382688, 0.04011043303894324, 0.08395148161298527, 0.0847907269312752, 0.08720615423277622, 0.025538797860099383, 0.030174489154145667, 0.025355626790846908, 0.08293027089521043, 0.08180579892196083, 0.07948122461745466, 0.0, 0.0, 0.0, 0.011723503339022612, 0.011441923340644311, 0.011221863723788639, 0.008027670810230814, 0.010219662817691821, 0.009316306413774678, 0.1112398058338967, 0.14071628587952523, 0.10801267065036069, 0.0, 0.0, 0.0]}}
{"id": "79a7ec5a-5774-4927-ab0b-c82700960bb8", "fitness": 0.037613243195473434, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introducing a stochastic subgroup framework to enhance search space exploration while maintaining adaptive learning rates and elite preservation. ", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            subgroup_size = 5  # New subgroup size\n            np.random.shuffle(self.particles)  # Shuffle particles\n            for subgroup in range(0, self.population_size, subgroup_size):\n                group = self.particles[subgroup:subgroup+subgroup_size]\n                group_best_score = float('inf')\n                for i in range(subgroup_size):\n                    index = subgroup + i\n                    if index >= self.population_size:\n                        break\n                    score = func(group[i])\n                    self.current_evals += 1\n                    if score < self.personal_best_scores[index]:\n                        self.personal_best_scores[index] = score\n                        self.personal_best_positions[index] = group[i].copy()\n                    if score < group_best_score:\n                        group_best_score = score\n                        group_best_position = group[i].copy()\n                    if score < self.global_best_score:\n                        self.global_best_score = score\n                        self.global_best_position = group[i].copy()\n                    \n                    r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                    cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[index] - group[i])\n                    social_velocity = self.social_coeff * r2 * (group_best_position - group[i])\n                    diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - group[i])\n                    momentum = 0.1 * self.velocities[index]\n                    self.velocities[index] = (dynamic_inertia_weight * self.velocities[index] +\n                                              cognitive_velocity + social_velocity + diversity_control + momentum)\n                    group[i] += self.velocities[index]\n                    group[i] = np.clip(group[i], self.lower_bound, self.upper_bound)\n\n                    dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                    if np.random.rand() < dynamic_mutation_rate:\n                        mutation_vector = np.random.normal(0, 0.1, self.dim)\n                        group[i] += mutation_vector\n                        group[i] = np.clip(group[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 63, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03761 with standard deviation 0.04282.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.11379767594863555, 0.07521633151254759, 0.1671617665643924, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03131614817013717, 0.03970447179544212, 0.0421932710606987, 0.020000000000000018, 0.020000000000000018, 0.021291423134427667, 0.07166580679765477, 0.04511815120507345, 0.05594772456904651, 0.020000000000000018, 0.055539905905367726, 0.025155101495917487, 0.03432600001491759, 0.08408530998212482, 0.07567278619502604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14572599305165823, 0.12299340307047402, 0.1418418499184958, 0.020000000000000018, 0.03325827142601756, 0.03808053352105023, 0.1029983181936871, 0.08456033527873974, 0.08830941399268111, 0.13074537475306303, 0.13323277534341382, 0.1228123758642582, 0.07395977326093117, 0.08949276175770537, 0.06147308586150435, 0.1369240594558434, 0.13021357025779934, 0.14183542598934307, 0.020000000000000018, 0.020000000000000018, 0.0968805714993356, 0.11217087032304873, 0.1099295572367851, 0.10265404361820285, 0.08422759641942079, 0.06741501938702155, 0.060325813202511736, 0.1422547629413734, 0.14184282820280003, 0.15672900353267327, 0.04659868562294267, 0.04404033140389729, 0.04044946828677243, 0.04286140625560053, 0.03577695840438333, 0.05156762796033432, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02917025605136403, 0.01175123981786752, 0.016397309079476896, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07612848914350212, 0.060615152242912806, 0.07606538274183872, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06053850407527406, 0.060018467435674516, 0.05467417360702487, 0.11852934395128789, 0.11439973639451806, 0.10225505889490616, 0.05789294414867241, 0.04701958501276138, 0.05222837032797234, 0.09527323479765071, 0.08578644199472563, 0.10481834084463004, 0.03295150809217484, 0.010000000000000009, 0.010000000000000009, 0.030465730489926957, 0.04642080874514454, 0.030173864073434253, 0.03478537240718371, 0.026838558381388822, 0.02702253130244925, 0.14460979674348007, 0.13902356505421953, 0.13364035111970085, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004051361988694047, 0.0, 0.004636511641853969, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0041474353258798, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038925492510384574, 0.03692692587813984, 0.040796741943460835, 0.0, 0.0, 0.0, 0.03649244263749507, 0.03821254380428096, 0.03615588932304481, 0.08791511003607966, 0.08681572377882729, 0.08423428131581001, 0.027204828514715174, 0.03093844696394432, 0.03256796016433683, 0.08204027359873312, 0.07702456585096751, 0.07641558563086337, 0.0, 0.0, 0.0, 0.012132777634612957, 0.009859515130644203, 0.012274081641619028, 0.008181328890766615, 0.01015599346592777, 0.00895363623275569, 0.12014639284133521, 0.1304725867484834, 0.11491424011226326, 0.0, 0.0, 0.0]}}
{"id": "44219f2c-91fc-4a16-a7d1-eee8dd2c67cc", "fitness": 0.034879196553856885, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Enhancing diversity and exploration by introducing a chaotic map-based perturbation to improve convergence.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n        self.chaos_factor = 0.7\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                chaotic_perturbation = self.chaos_factor * np.sin(np.pi * r3) * (self.upper_bound - self.lower_bound)\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control +\n                                      momentum + chaotic_perturbation)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Enhanced adaptivity\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)      # Enhanced adaptivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 64, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03488 with standard deviation 0.04176.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.09615137771235505, 0.1000415991792587, 0.1467065123828567, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10220572035906184, 0.09720880603674542, 0.08514537039488201, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.08594148016760361, 0.06095665907611758, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13971541353863448, 0.14073690968981312, 0.13084903150896143, 0.022326311648403152, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.10575769003390978, 0.07015575039186472, 0.12990506644848054, 0.13323277534341382, 0.13024219991914776, 0.0712037135166329, 0.07990382579724953, 0.05714299894929353, 0.11205586464406281, 0.11536185146472122, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.1565265323245859, 0.0895133107273659, 0.06527120746322768, 0.04616535580723691, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.03420029944318459, 0.03595347760899348, 0.033912455390770146, 0.026524049240434944, 0.04103867724634436, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01779543912190007, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07594451593840734, 0.06306381612646672, 0.0706144439130888, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05480975681268485, 0.06468336337751712, 0.05395939349942802, 0.11869262382913237, 0.09655732086344637, 0.10853238018826261, 0.06012750371184883, 0.04188450751668593, 0.053936809511723194, 0.08849795789547565, 0.09176130194337384, 0.08807105303750307, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025153750300603073, 0.029043163533977734, 0.03448999793017704, 0.024895242935785933, 0.02328679064865158, 0.024640285494433645, 0.13141309820135194, 0.13335088112915638, 0.13897535040686815, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.567924920086732e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026699896500181675, 0.030163622104217414, 0.023970240460582937, 0.0, 0.0, 0.0, 0.03293367387768631, 0.03753213255583987, 0.029423126664811172, 0.08072778292416571, 0.08796662518363019, 0.07037484042883169, 0.020213094208609728, 0.024192448856156457, 0.018449874749746464, 0.06501016208547095, 0.05793117324922947, 0.0659499355305112, 0.0, 0.0, 0.0, 0.009667148535201786, 0.00969639748392992, 0.01095921798521926, 0.007354325247402649, 0.010051284513262426, 0.007259537265468574, 0.1112398058338967, 0.1304161139054778, 0.10567573819525033, 0.0, 0.0, 0.0]}}
{"id": "a1014b27-2194-4f75-bf41-efba257d5fa3", "fitness": 0.03650615868294998, "name": "Chaotic_Levy_Flight_Optimizer", "description": "Introducing a hybrid adaptive strategy that combines chaotic maps for parameter tuning and levy-flight-based exploration to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass Chaotic_Levy_Flight_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n        self.chaotic_seq = np.random.rand(self.population_size)\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v)**(1/L)\n        return step\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + self.levy_flight()\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            self.chaotic_seq = self.chaotic_map(self.chaotic_seq)\n            self.cognitive_coeff = 1.5 + 0.2 * self.chaotic_seq.mean()\n            self.social_coeff = 1.4 + 0.2 * self.chaotic_seq.mean()\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 65, "feedback": "The algorithm Chaotic_Levy_Flight_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03651 with standard deviation 0.04290.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.09816479353783603, 0.081435239875284, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.031228793222839446, 0.02765085909630638, 0.03322950468290087, 0.021283379849074913, 0.020000000000000018, 0.020000000000000018, 0.07884175205859234, 0.05522452289282853, 0.0606654638883819, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.08594148016760361, 0.0830247491866567, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1316974697015959, 0.11556182508950275, 0.14182325917475513, 0.021930319730850023, 0.020000000000000018, 0.02154238841557743, 0.14439851300613793, 0.11509934265679234, 0.07015575039186472, 0.12990506644848054, 0.14099777991995632, 0.1231472267095467, 0.06431230961657475, 0.10029810124744754, 0.1189572562200083, 0.1250048506329452, 0.10718132362137878, 0.14603658588342017, 0.020000000000000018, 0.03431699632652907, 0.020000000000000018, 0.11483507654558056, 0.08711865523814422, 0.0895133107273659, 0.06527120746322768, 0.1062389956384453, 0.056492493752391515, 0.1565608533022501, 0.13589170657517036, 0.19288640488578368, 0.051403424349518945, 0.05315216532731215, 0.034839486153064425, 0.03428323416603052, 0.027503114920104377, 0.050090418881811316, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020499515314552186, 0.01680402577474116, 0.014209781459234683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011953731285670122, 0.010000000000000009, 0.013618990597700442, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.060616309220277054, 0.07371058210566961, 0.07453096754356825, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06154671853623972, 0.07504893679379365, 0.12180943569990521, 0.09754411579240652, 0.10281775224528589, 0.05964263790493263, 0.04230871699765748, 0.053936809511723194, 0.08091738591744013, 0.08480270709262794, 0.09214964270627579, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.035012925425880304, 0.041079541095283556, 0.030774609404692788, 0.027282323938373265, 0.02340197064757521, 0.03353789585193889, 0.15131277379078367, 0.13123409970527322, 0.1365297767940441, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0008634042908668427, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005843786168795884, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04634650789623562, 0.03938391760121618, 0.04037981510106259, 0.0, 0.0, 0.0, 0.03887539533757556, 0.03753213255583987, 0.03338318680209862, 0.08337071551181963, 0.08937574632147294, 0.07481362722775886, 0.020588311995012987, 0.026337684824562002, 0.01927035316571335, 0.06501016208547095, 0.0657205801254912, 0.05862161384494824, 0.0, 0.0, 0.0, 0.01153456416184051, 0.008502924991994676, 0.010428554430353398, 0.01019208424212703, 0.010051284513262426, 0.007875251485234602, 0.11853391984785233, 0.13619693730369886, 0.11356732713051232, 0.0, 0.0, 0.0]}}
{"id": "52709580-ead0-4ed7-ab15-657f90b219be", "fitness": 0.0379524426237067, "name": "Adaptive_Clustering_PSO_Optimizer", "description": "Introducing adaptive particle clustering and periodic reinitialization to improve exploration and convergence stability in dynamic landscapes.", "code": "import numpy as np\n\nclass Adaptive_Clustering_PSO_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.cluster_coeff = 0.3\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                cluster_center = self.elite_positions.mean(axis=0)\n                cluster_velocity = self.cluster_coeff * r3 * (cluster_center - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + cluster_velocity + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 10) == 0:\n                self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Enhanced adaptivity\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)      # Enhanced adaptivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 66, "feedback": "The algorithm Adaptive_Clustering_PSO_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03795 with standard deviation 0.04314.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.11426534651387532, 0.08860472252535545, 0.12303078891605912, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03905749683134618, 0.027936553625993565, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07885992899184613, 0.05227964544448871, 0.054685800478919466, 0.020000000000000018, 0.04708598794891772, 0.020000000000000018, 0.023245346750239593, 0.08594148016760361, 0.10439668704938787, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02923139824028309, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11723402170220643, 0.11201893112840511, 0.13084903150896143, 0.038679009589019375, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08004703302624738, 0.13498507898322543, 0.14628170816706954, 0.1207788684030876, 0.08856930321996093, 0.07990382579724953, 0.0663471172383302, 0.12248278155826453, 0.11931537717468488, 0.14264024705099954, 0.020000000000000018, 0.12293571674924064, 0.05205225404774838, 0.10819636878037442, 0.11105396364488263, 0.0991230380989504, 0.08229982574642636, 0.1438505099732389, 0.056492493752391515, 0.1438526290318487, 0.15014454245757036, 0.15475448018179316, 0.052307769869905485, 0.0344464680717087, 0.027555856691003133, 0.05713579034005423, 0.03703138849088006, 0.05765657859550444, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.022533873243843816, 0.010000000000000009, 0.01073971752323688, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010992064423909098, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011350862824133445, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09481518900865693, 0.07009536689748042, 0.08500789860847702, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06189597594247176, 0.05395939349942802, 0.1441846206052252, 0.0992461175303585, 0.10453443150585795, 0.08538243406247448, 0.045623474487759275, 0.05944950360088186, 0.10229577109011867, 0.09497473244460153, 0.09983590201236392, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02805914408420951, 0.03987824243681115, 0.04792554383085901, 0.02588843081405412, 0.0278943986764838, 0.02854172869575311, 0.13141309820135194, 0.141071403842984, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013787008964611491, 0.0003481124515215539, 0.010455160616258063, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04828610188302973, 0.05352643999275353, 0.03446404338800335, 0.0, 0.0, 0.0, 0.03537334324132202, 0.03753213255583987, 0.031774143606221994, 0.09186767630410786, 0.08820842892830127, 0.08264352718537049, 0.025128213536624866, 0.03345094372486557, 0.0218663522335657, 0.08552107549651733, 0.08207776356154706, 0.07228128145903145, 0.0, 0.0, 0.0, 0.011248280887211748, 0.011838395711212701, 0.012425747048317004, 0.007869881069229812, 0.010051284513262426, 0.008874746113205711, 0.11945048097769018, 0.1304161139054778, 0.10430661964779409, 0.0, 0.0, 0.0]}}
{"id": "0e42bf68-7496-4c60-8ac9-7dbc30d16d48", "fitness": 0.03652456131147086, "name": "Enhanced_Synergy_PSO_GA_SA_Optimizer", "description": "Enhanced synergy through novel adaptive velocity limits and elite propagation strategy to improve exploration-exploitation balance and convergence.", "code": "import numpy as np\n\nclass Enhanced_Synergy_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n        self.velocity_limit = (self.upper_bound - self.lower_bound) * 0.2\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            adaptive_velocity_limit = self.velocity_limit * (1 - self.current_evals / self.budget)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n\n                # Apply adaptive velocity limits\n                self.velocities[i] = np.clip(self.velocities[i], -adaptive_velocity_limit, adaptive_velocity_limit)\n\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 67, "feedback": "The algorithm Enhanced_Synergy_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03652 with standard deviation 0.04189.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.106090894077436, 0.09288289580775144, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03156891307003917, 0.03484447417507186, 0.027957627618148018, 0.020000000000000018, 0.020000000000000018, 0.020214744492558445, 0.05052618674595921, 0.0421167823445987, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05174484540818147, 0.09283434576358929, 0.0798301355821529, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13727734517907553, 0.09117001901013655, 0.1381133303870502, 0.02276131200158904, 0.020000000000000018, 0.02457839444543053, 0.0831461748955522, 0.0863116411064907, 0.08523916230587714, 0.13109214421215998, 0.13323277534341382, 0.12282173224175341, 0.0856398759278858, 0.07990382579724953, 0.06789814999586896, 0.12160080992222566, 0.12243812451838354, 0.1397767583761117, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.07892814979610752, 0.09028597864044541, 0.08098462195127132, 0.07492487363719802, 0.056538752043488794, 0.15398412117925286, 0.13589170657517036, 0.15475448018179316, 0.05076329372538113, 0.04698799188144831, 0.03167216197595024, 0.04891848157758916, 0.03341252474384104, 0.06481175186612798, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012128556949598468, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09482586408382365, 0.07714084890343043, 0.0829027425214387, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05909033321386692, 0.12888989728572942, 0.10520741918765186, 0.10281775224528589, 0.06978460874594605, 0.05568475477147061, 0.05436367258919628, 0.09934343091942499, 0.09538819688045863, 0.10631830495319283, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025542556407802786, 0.04483115467470311, 0.042659925162522594, 0.031741892215832235, 0.029805381914348006, 0.02875656627379586, 0.13141309820135194, 0.14704083232423892, 0.13669394755063413, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009715106073754587, 0.0, 0.003917412448501412, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.052903468688612176, 0.03945432314330166, 0.03317024327552798, 0.0, 0.0, 0.0, 0.03688632480581033, 0.03881287201830819, 0.03986335051104617, 0.08520055171271634, 0.08727657982831127, 0.09060411271071545, 0.029920426749670104, 0.027956846847975614, 0.021964766374377942, 0.0837103107007654, 0.07685218673434879, 0.08390783344259689, 0.0, 0.0, 0.0, 0.012472870790620871, 0.01130625289884546, 0.012833016118119822, 0.008320961493036072, 0.010051284513262426, 0.009956063997243247, 0.11434827311220463, 0.1304161139054778, 0.11214878900306335, 0.0, 0.0, 0.0]}}
{"id": "352467ff-d05c-4c61-896a-51835715950a", "fitness": 0.03829350738311364, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introduce adaptive inertia weight oscillation for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (np.cos(2 * np.pi * self.current_evals / self.budget)) # Changed line\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Enhanced adaptivity\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)      # Enhanced adaptivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 68, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03829 with standard deviation 0.04424.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09443133014492788, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03598153682609595, 0.026667418802945986, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05258913370298668, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.08200167077052045, 0.07370639862388895, 0.14617131634436842, 0.11214134916057328, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10712505895004942, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.05121307666997421, 0.035918645671978, 0.05899809997028105, 0.02738451995284008, 0.04795490885350906, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011369978622802202, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09107531985820072, 0.06697656889221748, 0.07798893294383535, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05974466988162219, 0.06147825531143891, 0.055593012007606246, 0.1252582999907953, 0.09772571275796638, 0.1083274071367265, 0.0787744944845431, 0.043440463108632366, 0.05581024340432039, 0.10123353069030616, 0.0821851953501137, 0.11007333539475195, 0.014925049559477821, 0.010000000000000009, 0.010000000000000009, 0.029387290226113305, 0.03262532412465757, 0.05357474220987768, 0.032064551897328486, 0.026764073324292537, 0.026605484172005256, 0.13141309820135194, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.007532514068885665, 0.0, 0.009661692946657863, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04112926100887082, 0.04532371733596363, 0.03320185954491617, 0.0, 0.0, 0.0, 0.03246909993403402, 0.04832539568382688, 0.04011043303894324, 0.08395148161298527, 0.08505374913070951, 0.08126167362540615, 0.030742972466269114, 0.029882594529717754, 0.025728933304551838, 0.08410705685444642, 0.08162469398152683, 0.07353587589588162, 0.0, 0.0, 0.0, 0.010833476059291303, 0.011441923340644311, 0.011747329098646286, 0.007657453309616757, 0.010383143923185956, 0.009133261298700401, 0.11229068070191095, 0.14071628587952523, 0.11463496837127107, 0.0, 0.0, 0.0]}}
{"id": "d93b2b47-4004-4ab4-878c-bc47b3905dba", "fitness": 0.02391607652589935, "name": "Enhanced_Hybrid_PSO_SADL_Optimizer", "description": "Enhanced self-tuning mechanism for parameters and dynamic hybridization of PSO with self-adaptive differential learning for robust convergence.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_PSO_SADL_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Self-adaptive differential learning\n                if np.random.rand() < 0.05:\n                    r1, r2, r3 = np.random.randint(0, self.population_size, 3)\n                    mutant_vector = (self.particles[r1] + \n                                     0.8 * (self.particles[r2] - self.particles[r3]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    mutant_score = func(mutant_vector)\n                    self.current_evals += 1\n                    if mutant_score < self.personal_best_scores[i]:\n                        self.particles[i] = mutant_vector\n                        self.personal_best_scores[i] = mutant_score\n                        if mutant_score < self.global_best_score:\n                            self.global_best_score = mutant_score\n                            self.global_best_position = mutant_vector\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 69, "feedback": "The algorithm Enhanced_Hybrid_PSO_SADL_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02392 with standard deviation 0.05630.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.1137942469930684, 0.10944484939901367, 0.1593763256350581, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03449569802377783, 0.02155293474539799, 0.027576994049489767, 0.022582328823979148, 0.025323710017892243, 0.020000000000000018, 0.07533369935185585, 0.06253165344637435, 0.06181725838018859, 0.030639352381801044, 0.032121450823122455, 0.020000000000000018, 0.07930165848344062, 0.10349912664464822, 0.07457853047246121, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03744917721946106, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1323590647215761, 0.11779524378234774, 0.1580353596669174, 0.0202861688341478, 0.028784633637623736, 0.02097554072575003, 0.08072694858327945, 0.0857627249058015, 0.07224561866997936, 0.1368998493092788, 0.14478335056565106, 0.12376741685173664, 0.0814377529441701, 0.07939626195890837, 0.06333012607645827, 0.16255070363297142, 0.11770527271715481, 0.13519713333195482, 0.07901391282563741, 0.020000000000000018, 0.11128497381966396, 0.10819636878037442, 0.07355107907497493, 0.08997282795808448, 0.07002634917841954, 0.09121324747712234, 0.057209751678833576, 0.1438526290318487, 0.1761555045672928, 0.16794527713763163, 0.06279743678255234, 0.04206056086758703, 0.042040770928633675, 0.03828098080093201, 0.026109338368762947, 0.060366980420594185, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.043248792202536745, 0.019861256326653365, 0.02357775833610143, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01727464814990587, 0.013743137043622955, 0.014630801886355349, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011064288904193753, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07730603164917282, 0.06870186793878286, 0.08266170929494299, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.062125978530838344, 0.06098403836914201, 0.05736204912609044, 0.13238101251541412, 0.1042877247507138, 0.10620093521962592, 0.06997465563992888, 0.0491126035622359, 0.05494090462198398, 0.09722109684853164, 0.08675986063240382, 0.09913645088092082, 0.11180386032516865, 0.010000000000000009, 0.010000000000000009, 0.02734592817130377, 0.04826104881834359, 0.05875957046311886, 0.03463209034378023, 0.02731545530264423, 0.03046675703545365, 0.13148561606679754, 0.13891113663330146, 0.14037264102543678, 0.014625691823337506, 0.010000000000000009, 0.010000000000000009, -0.039587027881299086, -0.057912083155548855, -0.023651993640847913, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.04724974119452874, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.004946614739210986, -0.015664493005667968, 0.006306456234168589, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.016755556202784128, -0.02026669226165656, 0.004191582275494987, 0.043540380767970954, 0.03150475155953658, 0.062176946213230444, -0.02382730783814746, -0.03191766851182365, -0.005385735141896664, 0.03703514465924718, 0.01864943579905809, 0.05115240237569596, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027, -0.03744137132399383, -0.04771827965964981, -0.01876429463648499, -0.041429128648515556, -0.048741012922421945, -0.018536859140233952, 0.0740730479442685, 0.0780817919834712, 0.09888289574236198, -0.050000000000000044, -0.06000000000000005, -0.030000000000000027]}}
{"id": "50fa1941-1a6f-4fc6-b291-316a4edce6ba", "fitness": 0.038756882298291516, "name": "Refined_Enhanced_PSO_GA_SA_Optimizer", "description": "Introducing a dynamic mutation strategy that incorporates a diversity-oriented approach for improved exploration.", "code": "import numpy as np\n\nclass Refined_Enhanced_PSO_GA_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.5 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                momentum = 0.1 * self.velocities[i]\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control + momentum)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_solution = self.particles[i] + np.random.normal(0, 0.1, self.dim)\n                candidate_solution = np.clip(candidate_solution, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_solution)\n                self.current_evals += 1\n                if candidate_score < self.personal_best_scores[i] or \\\n                   np.exp((self.personal_best_scores[i] - candidate_score) / self.temperature) > np.random.rand():\n                    self.particles[i] = candidate_solution\n                    self.personal_best_scores[i] = candidate_score\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_solution\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Enhanced adaptivity\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)      # Enhanced adaptivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 70, "feedback": "The algorithm Refined_Enhanced_PSO_GA_SA_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03876 with standard deviation 0.04462.", "error": "", "parent_ids": ["ecfcd854-6d42-486c-9625-2ea95ca8df04"], "operator": null, "metadata": {"aucs": [0.1322765340171388, 0.09408310322956193, 0.14265596943276604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.036642041908293566, 0.02421209541843017, 0.02372716547067677, 0.02638983913846049, 0.020000000000000018, 0.020000000000000018, 0.07029284487105825, 0.05257227950621324, 0.05305302365509301, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0247005191513614, 0.1104909853457291, 0.08184826557659075, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13418754880386985, 0.11726522272216244, 0.13084903150896143, 0.033254368699775494, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08523916230587714, 0.1371411441309246, 0.15868731458036978, 0.12282173224175341, 0.07918304035357526, 0.09393917189624201, 0.07370639862388895, 0.14617131634436842, 0.12859167920732972, 0.1397767583761117, 0.020000000000000018, 0.11286293640443845, 0.11424191506568127, 0.10819636878037442, 0.10658004353628203, 0.0895133107273659, 0.08136447482843667, 0.14198424302836077, 0.07918032162244881, 0.17770100941375744, 0.14473201832564708, 0.15475448018179316, 0.038669801718039354, 0.04332808921861675, 0.035918645671978, 0.06077986061442742, 0.026216015098403433, 0.04428671539534079, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014691350068966824, 0.011464275051139339, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011959589278455529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.098529380630351, 0.06707709322352884, 0.0778872234200706, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.061491136669112656, 0.05568814917275888, 0.1267725891337258, 0.10101828992492234, 0.1083274071367265, 0.0787744944845431, 0.043440463108632366, 0.05656383464991843, 0.10032791203158897, 0.08254869489299399, 0.1097821945321229, 0.05089975028509941, 0.010000000000000009, 0.010000000000000009, 0.03443571535207213, 0.03908235516309799, 0.0541385263274049, 0.03373533481373614, 0.025524330289249386, 0.03258169838882874, 0.13487108924589297, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009441491123554635, 0.00013543212222089096, 0.006910528129863369, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0427241120240659, 0.045737731276821125, 0.03179504150538004, 0.0, 0.0, 0.0, 0.0396479494825529, 0.04832539568382688, 0.04011043303894324, 0.08403144017571806, 0.08350041880885162, 0.08303591008386813, 0.02415874118934025, 0.029882594529717754, 0.025241614041491278, 0.08540015542082002, 0.08162469398152683, 0.07808755360283537, 0.0, 0.0, 0.0, 0.010895499591192848, 0.011728312414598374, 0.011191912069537402, 0.007543866015462752, 0.010527543724962785, 0.009385634170202661, 0.11991197387467745, 0.14071628587952523, 0.10745673407280376, 0.0, 0.0, 0.0]}}
{"id": "7357e908-191c-4709-9217-41e14994a988", "fitness": -0.029490890706727616, "name": "Enhanced_Swarm_Coordination_Optimizer", "description": "Introduce multi-swarm coordination with adaptive communication to enhance diversity and convergence.", "code": "import numpy as np\n\nclass Enhanced_Swarm_Coordination_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_count = 3\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize swarms\n        self.swarms = [np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim)) for _ in range(self.swarm_count)]\n        self.velocities = [np.random.uniform(-1, 1, (self.population_size, self.dim)) for _ in range(self.swarm_count)]\n        self.personal_best_positions = [np.copy(swarm) for swarm in self.swarms]\n        self.personal_best_scores = [np.full(self.population_size, float('inf')) for _ in range(self.swarm_count)]\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            for swarm_index in range(self.swarm_count):\n                swarm = self.swarms[swarm_index]\n                for i in range(self.population_size):\n                    score = func(swarm[i])\n                    self.current_evals += 1\n                    if score < self.personal_best_scores[swarm_index][i]:\n                        self.personal_best_scores[swarm_index][i] = score\n                        self.personal_best_positions[swarm_index][i] = swarm[i].copy()\n                    if score < self.global_best_score:\n                        self.global_best_score = score\n                        self.global_best_position = swarm[i].copy()\n\n                    r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                    cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[swarm_index][i] - swarm[i])\n                    social_velocity = self.social_coeff * r2 * (self.global_best_position - swarm[i])\n                    diversity_control = 0.5 * r3 * (np.mean(self.swarms, axis=0)[i] - swarm[i])\n                    momentum = 0.1 * self.velocities[swarm_index][i]\n                    self.velocities[swarm_index][i] = (self.inertia_weight * self.velocities[swarm_index][i] +\n                                                       cognitive_velocity + social_velocity + diversity_control + momentum)\n                    swarm[i] += self.velocities[swarm_index][i]\n                    swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n\n                    dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                    if np.random.rand() < dynamic_mutation_rate:\n                        mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                        swarm[i] += mutation_vector\n                        swarm[i] = np.clip(swarm[i], self.lower_bound, self.upper_bound)\n\n                # Inter-swarm communication\n                if swarm_index < self.swarm_count - 1:\n                    self.swarms[swarm_index + 1][:] = 0.9 * self.swarms[swarm_index + 1][:] + 0.1 * self.swarms[swarm_index][:]\n                    \n            # Adaptive parameter adjustments\n            self.inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.temperature *= self.cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 71, "feedback": "The algorithm Enhanced_Swarm_Coordination_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02949 with standard deviation 0.11315.", "error": "", "parent_ids": ["50fa1941-1a6f-4fc6-b291-316a4edce6ba"], "operator": null, "metadata": {"aucs": [0.09663918895293444, 0.11651969787208316, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024074813905062387, 0.029946662769024912, 0.020000000000000018, 0.022981666262275713, 0.020000000000000018, 0.020000000000000018, 0.057357234782004385, 0.053230285936569754, 0.05279986701433659, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.08594148016760361, 0.05812038364586147, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09994410407015442, 0.10920448414469153, 0.13936229384819387, 0.028934461085090346, 0.03205897119325196, 0.020000000000000018, 0.10685662593279743, 0.10306420037492559, 0.0705176939496881, 0.13796303097348028, 0.13323277534341382, 0.13591328204329245, 0.07030435852219397, 0.08297334367055542, 0.0801020088691089, 0.1251311985114808, 0.10171196656099735, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.08576179843148712, 0.09668009348309836, 0.06527120746322768, 0.0475329597340558, 0.056492493752391515, 0.16755024058214474, 0.1362907208298012, 0.16094607490307733, 0.04058865248665566, 0.03470731414991146, 0.04053999369889483, 0.03866135118460945, 0.042742504314446705, 0.05237958932550857, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012194770883296124, 0.01125326752659217, 0.017135594220336947, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012486170294949694, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08060147590173938, 0.08545709314333694, 0.07676988191191336, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05475068142090023, 0.06157260737930759, 0.054495967152649705, 0.12045714725315548, 0.10071651522440561, 0.10514388092435956, 0.06152528794763823, 0.04860894672173899, 0.053936809511723194, 0.0939407717574473, 0.08863599842913894, 0.10009482349248022, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03405465707131983, 0.04159922506867386, 0.031315147614440986, 0.03072701186853355, 0.028746559812433792, 0.02580375694926118, 0.1344200250346863, 0.14149423602501243, 0.14592636204372322, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19045144793384927, -0.19341654342042092, -0.19297127409307424, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.13816696265010253, -0.150977012493281, -0.1540988700649406, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14206266131789813, -0.15254431595450035, -0.15236776798627694, -0.09247399516632848, -0.09643308799267647, -0.09295897476025128, -0.1643449915659907, -0.16338322750016143, -0.15815503858445812, -0.10613824844587283, -0.11208294568344068, -0.10939235025773208, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18670904272529687, -0.18536156758516786, -0.18643780900878326, -0.18930689293745395, -0.1874316035312722, -0.18941735363926737, -0.062371585957346376, -0.043207726894507026, -0.056739375004100756, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "e630f7a9-7d07-4318-9a46-9c13ca78b2c0", "fitness": 0.03953575121287481, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Integrate a hybrid approach with dynamic parameter adaptation and elite-based exploitation to enhance global search capabilities.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 72, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03954 with standard deviation 0.04524.", "error": "", "parent_ids": ["50fa1941-1a6f-4fc6-b291-316a4edce6ba"], "operator": null, "metadata": {"aucs": [0.1601631366352365, 0.10025431228704462, 0.1523509013571831, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022136508042922554, 0.020335480020915675, 0.022065704099236694, 0.028496105882609535, 0.020953232900905894, 0.037535678022066366, 0.07685081785786763, 0.05605042777025049, 0.053480369779725034, 0.020000000000000018, 0.03404327949737218, 0.020000000000000018, 0.05308567518304974, 0.09139056232014464, 0.09054122132914388, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07372269343054716, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12570722910366894, 0.11523193503772033, 0.14336009306166886, 0.032622178511695354, 0.02519120590176005, 0.021802887688825767, 0.09683347288894428, 0.09121851294074967, 0.11214591036450516, 0.13628675058544149, 0.15426766061402786, 0.12156605300208667, 0.07462260503059237, 0.08833752190843602, 0.07349652705579657, 0.1395021256527974, 0.11054621593773861, 0.17319971645417265, 0.020000000000000018, 0.020000000000000018, 0.10020222240199506, 0.14756024201167117, 0.08700531071856943, 0.10126650518867908, 0.10427239987441628, 0.14338748643304744, 0.07298976175804317, 0.1438526290318487, 0.13589170657517036, 0.15519814615254934, 0.05551404324073561, 0.03392426887360889, 0.0342912110696616, 0.052866227553661216, 0.03087179991716338, 0.07252629241590247, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.037454265063117, 0.017519994049828513, 0.019800657629473473, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013026870236944044, 0.010000000000000009, 0.01011965779352697, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09138870163830348, 0.07541741667223978, 0.09048103910443739, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061526412998358926, 0.06147825531143891, 0.061849770924578995, 0.12432243557000566, 0.10189253111038166, 0.10656336337224359, 0.06758569096144573, 0.05015884734130216, 0.05792790187444663, 0.10732903630420343, 0.08357791119572344, 0.10605137019893418, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030100732383132267, 0.0351425712194563, 0.04552586575582107, 0.04480350634390651, 0.031579193166607844, 0.026256357037291567, 0.13260380707912234, 0.13123409970527322, 0.15571417790326136, 0.010104421486395232, 0.010000000000000009, 0.010000000000000009, 0.010773797865829549, 0.00023167291965786596, 0.0021080555541592716, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04377101870523614, 0.045301091188178044, 0.033339766840135066, 0.0, 0.0, 0.0, 0.03542695015600206, 0.05361135671232742, 0.03692449319338509, 0.08666171416718393, 0.09179141180517347, 0.08040472444138702, 0.027961077727222783, 0.034331419951253994, 0.02594460713105118, 0.08539288240977272, 0.07837997670927843, 0.07488201577031983, 0.0, 0.0, 0.0, 0.010677324717016878, 0.011443913995579424, 0.011208258597572573, 0.00859521728408097, 0.010942649440046304, 0.011036968067516861, 0.11737043999234886, 0.13691283995603787, 0.11474479387842973, 0.0, 0.0, 0.0]}}
{"id": "b66a3c02-c13b-440b-a99f-46ecd6e368b0", "fitness": 0.039988247497567415, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Implements minor enhancements to the velocity update equation for improved convergence speed.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                # Modified line for minor improvement\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.8 * cognitive_velocity + 0.8 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 73, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03999 with standard deviation 0.04569.", "error": "", "parent_ids": ["e630f7a9-7d07-4318-9a46-9c13ca78b2c0"], "operator": null, "metadata": {"aucs": [0.16953475501892767, 0.09267168078412114, 0.15805918697681332, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03161044600604834, 0.020000000000000018, 0.022421517191950735, 0.03880705815779484, 0.020000000000000018, 0.03244706490251337, 0.0742207486997899, 0.056522384430417905, 0.05084518113198688, 0.020000000000000018, 0.041557289748747506, 0.020000000000000018, 0.04475705031972477, 0.10001032869362292, 0.08849669200121835, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14882800644495697, 0.10364130116366677, 0.14669585221470216, 0.03204763119990672, 0.029389843233689983, 0.02985841980653814, 0.08072694858327945, 0.0863116411064907, 0.11214591036450516, 0.14686068638953942, 0.17472324479851264, 0.13344285629828923, 0.08470701942509151, 0.12578627532085973, 0.06928559259812739, 0.1313863312086858, 0.1431760221027275, 0.12587709846724093, 0.08379507982591572, 0.020000000000000018, 0.1080365223806794, 0.15357352390847723, 0.08549128948413565, 0.10634335680525087, 0.08340917876342813, 0.08733680661145826, 0.06803998363120423, 0.1438526290318487, 0.1490694406584444, 0.15475448018179316, 0.0535188719302363, 0.03392426887360889, 0.030592415728652345, 0.053218872370745185, 0.034306091210992706, 0.07435924279348083, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0424935666214421, 0.013303960006928128, 0.01647030795370308, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010788284011852056, 0.01392499274156389, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01607213524299056, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08923466439598471, 0.07790650590886439, 0.08735292365490732, 0.010000000000000009, 0.010000000000000009, 0.01763223473726272, 0.05689161687652555, 0.06235532013334866, 0.05624438696787637, 0.1393082974461215, 0.106338776034821, 0.10281775224528589, 0.07086112404135125, 0.05786935326173004, 0.053936809511723194, 0.10493584686113078, 0.09318752975117695, 0.10428853222333545, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03226354041074886, 0.031236993933287827, 0.04030699368238533, 0.04529993360202478, 0.04557670120244839, 0.03213312603245244, 0.13610200592433097, 0.14065850603091123, 0.13665254929750448, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01346120577228982, 0.0005692240075287902, 0.004850265106363549, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0005655039136410744, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.044149090098113075, 0.04477393863382528, 0.03853939298932574, 0.0, 0.0, 0.0, 0.03777990003859388, 0.03753213255583987, 0.038874601457010716, 0.08834919184883461, 0.09123111009608276, 0.08271717716441596, 0.02700365650922687, 0.03485426256307089, 0.022818150348061672, 0.08827884676210107, 0.08151265615933512, 0.07892743607252117, 0.0, 0.0, 0.0, 0.012712470286376454, 0.012621486235539603, 0.012589804825594242, 0.007921023220798795, 0.010456941218448867, 0.010539128585974389, 0.11597837670172761, 0.1304161139054778, 0.12251898267158134, 0.0, 0.0, 0.0]}}
{"id": "f6237d2c-6857-4c6d-9bfd-d25e3082ce77", "fitness": 0.03918721720704039, "name": "Enhanced_Hybrid_Adaptive_Optimizer_Refined", "description": "Introduces adaptive exploration and exploitation balance with an enhanced dynamic velocity update for improved convergence.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n        self.exploration_exploitation_balance = 0.5\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = self.exploration_exploitation_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                # Enhanced dynamic velocity update\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            self.exploration_exploitation_balance = 0.5 + 0.5 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 74, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03919 with standard deviation 0.04423.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.14356326006890552, 0.10807710103839896, 0.14978504907294465, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03392556454506401, 0.03291705321464766, 0.022707403693219108, 0.027332705362756782, 0.020000000000000018, 0.020000000000000018, 0.08009354118282408, 0.05921213256392943, 0.05590953226900153, 0.02556760493573551, 0.033039159292137854, 0.020000000000000018, 0.03558708584806014, 0.11255886358602074, 0.09018376327541011, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023241472820334397, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13336662518493025, 0.12607098618888368, 0.14542969533755834, 0.023592567834525346, 0.025740806068885735, 0.035054578950645565, 0.08072694858327945, 0.0863116411064907, 0.11214591036450516, 0.14695055452676242, 0.14492366310120275, 0.11990389632974374, 0.07638025794279812, 0.09287059532472375, 0.07564699404091957, 0.13086052845600704, 0.115005333302999, 0.12683711817586807, 0.020000000000000018, 0.10430425607654581, 0.11276997460155369, 0.10910481857169185, 0.10355662463076099, 0.0895133107273659, 0.07500616590070674, 0.12469884721070879, 0.08779764727667283, 0.1438526290318487, 0.13921640344557007, 0.1584344207671231, 0.05979615996537635, 0.06226612260417963, 0.03497863719810457, 0.05310928235816237, 0.0289105487857233, 0.05035095715820748, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03405186199084853, 0.018332299314748446, 0.022142394565684898, 0.010000000000000009, 0.010000000000000009, 0.01060872912932842, 0.0115104607582307, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09243216240885088, 0.0630597163420451, 0.09613098498556161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05679256327179827, 0.06195859574194662, 0.05807414642426678, 0.1317984981009146, 0.10397400148764946, 0.10845718809190841, 0.06354517573598795, 0.04556022878862043, 0.05584339616739842, 0.10574595701997325, 0.08831397233554827, 0.10787825749652347, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02915142053388753, 0.04342223505860232, 0.05281856503081972, 0.03326062819505948, 0.025373386382002927, 0.028516047879470374, 0.13141309820135194, 0.13403058468352969, 0.138137823221669, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013146698332323625, 0.0, 0.005350767344453389, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0023624072665622275, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.039403936129738026, 0.04503316811125169, 0.03152078999621377, 0.0, 0.0, 0.0, 0.0328317921786363, 0.04688933092029923, 0.04374313925807738, 0.08434447145335111, 0.08456724817376715, 0.08256580390122592, 0.02940402286137389, 0.034656158025961226, 0.022200604706432925, 0.08234998047488806, 0.0791188140147514, 0.07488526420164066, 0.0, 0.0, 0.0, 0.011077920348794068, 0.011573446629092654, 0.011097394860188126, 0.008049050823986437, 0.011238035573343241, 0.009931326431678378, 0.11381782371201521, 0.13582685971310793, 0.11593148203291948, 0.0, 0.0, 0.0]}}
{"id": "ce09f9eb-c314-4006-8498-101c91e934a8", "fitness": 0.03966985980177468, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Refines the particle movement strategy by enhancing velocity calculation to improve convergence efficiency.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                # Modified lines for minor improvement\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.85 * cognitive_velocity + 0.85 * social_velocity + 0.85 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 75, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03967 with standard deviation 0.04489.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.17067906018367296, 0.09382768223575566, 0.1598475876237242, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.035830492840305816, 0.021160549722238686, 0.027396422163468825, 0.03418023461326303, 0.020000000000000018, 0.03052348912994718, 0.07453762456648894, 0.05764310670307371, 0.0525513870381803, 0.020000000000000018, 0.04189566036571013, 0.020000000000000018, 0.0538877448942483, 0.0978954400288532, 0.08961521618028345, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024237659316926008, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13364548420908084, 0.10412868549349907, 0.1405742446364069, 0.03115073177398142, 0.023016400461711828, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.11214591036450516, 0.14612779480988047, 0.16748099972956543, 0.1365558087923069, 0.08682484876604268, 0.1013508353239112, 0.07580331278551367, 0.12961050185929546, 0.1305025550608372, 0.1352404647434392, 0.08959783625182127, 0.020000000000000018, 0.08581758730023448, 0.15226521729461528, 0.10089469098490922, 0.09759684285289638, 0.09175868529640452, 0.10115875426248777, 0.06719631310506247, 0.15133979541422082, 0.13648040396429706, 0.15475448018179316, 0.07509374653245549, 0.03598081926342933, 0.028487784284049855, 0.053613860083249976, 0.03423173757387532, 0.06641714110859442, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03998103593884783, 0.013413097944951158, 0.016595046299490268, 0.010000000000000009, 0.010000000000000009, 0.010123184378243777, 0.01567740836474485, 0.010951326683405704, 0.010373809145033053, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08976562325038073, 0.077134651090489, 0.08676302518425605, 0.010000000000000009, 0.010000000000000009, 0.011268006625387295, 0.05722087202883985, 0.06451197769733286, 0.05741526528739582, 0.12343289529638468, 0.10133415759200459, 0.1042114427834302, 0.06929101496953938, 0.056695406724473596, 0.05608331232634911, 0.09987853658748547, 0.08699487120165161, 0.10293963337558187, 0.03105145448397706, 0.010000000000000009, 0.010000000000000009, 0.031204061698997143, 0.0310476929796476, 0.03808704078626102, 0.04531837448800646, 0.04599338435260625, 0.028911778000542787, 0.1351840881488111, 0.1346354932688315, 0.1366506178733391, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011681236543630735, 0.0, 0.0028090369584833352, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0006628029307887973, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04483024498804189, 0.044599204392701375, 0.03746365516229333, 0.0, 0.0, 0.0, 0.03400051019548367, 0.038740485859924734, 0.034676872814010995, 0.08975044953399192, 0.0899732462420143, 0.08242280425772364, 0.027848231217499797, 0.041384393859072, 0.024404243313231988, 0.08820201215909929, 0.08114815428724598, 0.07176127453200243, 0.0, 0.0, 0.0, 0.01255108472418176, 0.012601441924738443, 0.012461170156360502, 0.008537278413659477, 0.010051284513262426, 0.01058634636951794, 0.12713726927011437, 0.1304161139054778, 0.10825705994177615, 0.0, 0.0, 0.0]}}
{"id": "8d9adef2-9513-45c0-a695-b32133f0e1f9", "fitness": 0.03966985980177468, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduces a small modification in the velocity update to improve adaptive exploration-exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                # Modified lines for minor improvement\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.85 * cognitive_velocity + 0.85 * social_velocity + 0.85 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 76, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03967 with standard deviation 0.04489.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.17067906018367296, 0.09382768223575566, 0.1598475876237242, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.035830492840305816, 0.021160549722238686, 0.027396422163468825, 0.03418023461326303, 0.020000000000000018, 0.03052348912994718, 0.07453762456648894, 0.05764310670307371, 0.0525513870381803, 0.020000000000000018, 0.04189566036571013, 0.020000000000000018, 0.0538877448942483, 0.0978954400288532, 0.08961521618028345, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024237659316926008, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13364548420908084, 0.10412868549349907, 0.1405742446364069, 0.03115073177398142, 0.023016400461711828, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.11214591036450516, 0.14612779480988047, 0.16748099972956543, 0.1365558087923069, 0.08682484876604268, 0.1013508353239112, 0.07580331278551367, 0.12961050185929546, 0.1305025550608372, 0.1352404647434392, 0.08959783625182127, 0.020000000000000018, 0.08581758730023448, 0.15226521729461528, 0.10089469098490922, 0.09759684285289638, 0.09175868529640452, 0.10115875426248777, 0.06719631310506247, 0.15133979541422082, 0.13648040396429706, 0.15475448018179316, 0.07509374653245549, 0.03598081926342933, 0.028487784284049855, 0.053613860083249976, 0.03423173757387532, 0.06641714110859442, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03998103593884783, 0.013413097944951158, 0.016595046299490268, 0.010000000000000009, 0.010000000000000009, 0.010123184378243777, 0.01567740836474485, 0.010951326683405704, 0.010373809145033053, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08976562325038073, 0.077134651090489, 0.08676302518425605, 0.010000000000000009, 0.010000000000000009, 0.011268006625387295, 0.05722087202883985, 0.06451197769733286, 0.05741526528739582, 0.12343289529638468, 0.10133415759200459, 0.1042114427834302, 0.06929101496953938, 0.056695406724473596, 0.05608331232634911, 0.09987853658748547, 0.08699487120165161, 0.10293963337558187, 0.03105145448397706, 0.010000000000000009, 0.010000000000000009, 0.031204061698997143, 0.0310476929796476, 0.03808704078626102, 0.04531837448800646, 0.04599338435260625, 0.028911778000542787, 0.1351840881488111, 0.1346354932688315, 0.1366506178733391, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011681236543630735, 0.0, 0.0028090369584833352, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0006628029307887973, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04483024498804189, 0.044599204392701375, 0.03746365516229333, 0.0, 0.0, 0.0, 0.03400051019548367, 0.038740485859924734, 0.034676872814010995, 0.08975044953399192, 0.0899732462420143, 0.08242280425772364, 0.027848231217499797, 0.041384393859072, 0.024404243313231988, 0.08820201215909929, 0.08114815428724598, 0.07176127453200243, 0.0, 0.0, 0.0, 0.01255108472418176, 0.012601441924738443, 0.012461170156360502, 0.008537278413659477, 0.010051284513262426, 0.01058634636951794, 0.12713726927011437, 0.1304161139054778, 0.10825705994177615, 0.0, 0.0, 0.0]}}
{"id": "ea498979-d44c-49a1-a4ed-a793fd4f5bcb", "fitness": 0.03927708775033664, "name": "Enhanced_Adaptive_Elite_Optimizer", "description": "Employs a temperature-driven adaptive velocity control and elite-based diversification to enhance convergence and exploration.", "code": "import numpy as np\n\nclass Enhanced_Adaptive_Elite_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                \n                # Enhanced velocity update with temperature influence\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.8 * cognitive_velocity + 0.8 * social_velocity + 0.8 * diversity_control / self.temperature)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 77, "feedback": "The algorithm Enhanced_Adaptive_Elite_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03928 with standard deviation 0.04565.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.17265236664146555, 0.09052710840422917, 0.15020162656532132, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03243777202560694, 0.025001796494082407, 0.02307289208356389, 0.03592060181967527, 0.020000000000000018, 0.020000000000000018, 0.07456281493285455, 0.05452569586092948, 0.052768648574516464, 0.020000000000000018, 0.03017513247424275, 0.020000000000000018, 0.043227708402122866, 0.09942449785165508, 0.07669069561242536, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.17270315637001576, 0.10208912352481225, 0.14707597775454384, 0.03152082426041414, 0.02243100232634987, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.11214591036450516, 0.1514491922750597, 0.15247424990242875, 0.1294445727764736, 0.08021259101358835, 0.11033413026257877, 0.07108351062746321, 0.13749410394434902, 0.12237858260230638, 0.1252530957202529, 0.020000000000000018, 0.020000000000000018, 0.11978718645878983, 0.16252194716626012, 0.10031381270740813, 0.11064714512079998, 0.08270426893775717, 0.08697893213497065, 0.06885298658042471, 0.1438526290318487, 0.15857204582607343, 0.15475448018179316, 0.0546678183491659, 0.039083391638543796, 0.03592445297024094, 0.052306990670289544, 0.034771211511398836, 0.07263833877740211, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04130614946874245, 0.013021734288011566, 0.015109598569021054, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015063746339494921, 0.01173964506369829, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08908995454381652, 0.07683257368521823, 0.08126253167409825, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06982348401818894, 0.06886492424960011, 0.06127700238548184, 0.13924849907062808, 0.10810669460063038, 0.10327215242908183, 0.08022764908890034, 0.053063449030240295, 0.054273224369489115, 0.10545442557294604, 0.08119477851407197, 0.10834522382134892, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029792064716558264, 0.03536021318759808, 0.030907628215934846, 0.0311431114258931, 0.04663455154687757, 0.03354915785808066, 0.13141309820135194, 0.13421709265951165, 0.15172714511165453, 0.010000000000000009, 0.010000000000000009, 0.010046548596437166, 0.010393731646202164, 0.001101230311828405, 0.0036899747893427426, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0007493121148178794, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04019963055458231, 0.04151981670168314, 0.033804521598470916, 0.0, 0.0, 0.0, 0.035324617268716274, 0.03965185642380897, 0.04131817473245847, 0.0900187769380465, 0.09190981960235078, 0.0854012413935592, 0.027995811159733375, 0.03039101832485447, 0.026603376193217176, 0.08222732885373918, 0.07767366521896446, 0.06839347019634945, 0.0, 0.0, 0.0, 0.012737056428296922, 0.011342977993257675, 0.012429448376866659, 0.00803134766190039, 0.010051284513262426, 0.0100385999565471, 0.11272648790062034, 0.1304161139054778, 0.11164660179038033, 0.0, 0.0, 0.0]}}
{"id": "438996b0-3424-4e57-a706-b6eaeb1abe4f", "fitness": -Infinity, "name": "Quantum_Enhanced_Adaptive_Optimizer", "description": "Integrates a quantum-inspired search mechanism and stochastic local search for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass Quantum_Enhanced_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n        self.q_positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.1 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                \n                # Quantum-inspired update\n                q_factor = np.random.normal(0, 1, self.dim)\n                quantum_velocity = q_factor * (self.q_positions[i] - self.particles[i])\n\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.7 * cognitive_velocity + 0.7 * social_velocity + 0.7 * diversity_control + 0.05 * quantum_velocity)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Local stochastic search\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            # Update quantum positions based on new elite positions\n            self.q_positions = np.copy(self.elite_positions)\n\n            self.temperature *= self.cooling_rate\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.cos(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.cos(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 78, "feedback": "An exception occurred: IndexError('index 3 is out of bounds for axis 0 with size 3').", "error": "IndexError('index 3 is out of bounds for axis 0 with size 3')", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {}}
{"id": "a9e6950f-b8c9-47f7-9c2b-4e785b2845ee", "fitness": 0.014245435089828732, "name": "Refined_Adaptive_Optimizer", "description": "Introduces dynamic population resizing and an adaptive elite selection mechanism to improve exploration and exploitation balance for enhanced convergence.", "code": "import numpy as np\n\nclass Refined_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.dynamic_population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.initial_population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n\n            if self.current_evals % (self.budget // 5) == 0 and self.dynamic_population_size > 5:\n                self.dynamic_population_size = max(5, int(self.dynamic_population_size * 0.9))\n                sorted_indices = np.argsort(self.personal_best_scores)\n                self.particles = self.personal_best_positions[sorted_indices[:self.dynamic_population_size]]\n                self.velocities = self.velocities[sorted_indices[:self.dynamic_population_size]]\n                self.personal_best_positions = self.personal_best_positions[sorted_indices[:self.dynamic_population_size]]\n                self.personal_best_scores = self.personal_best_scores[sorted_indices[:self.dynamic_population_size]]\n\n            for i in range(self.dynamic_population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.8 * cognitive_velocity + 0.8 * social_velocity)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 79, "feedback": "The algorithm Refined_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01425 with standard deviation 0.06788.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.13960571946692824, 0.1090692785020021, 0.15204991110491395, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03594435053112677, 0.026290356635768175, 0.020597561802919606, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08223805997928535, 0.05823386761174221, 0.05260581832991906, 0.08065513671113322, 0.03257629667410267, 0.020000000000000018, 0.05475237386431642, 0.08459419422029002, 0.09333344167441626, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15122473661170144, 0.12344545930836825, 0.1314476774332869, 0.029891567637710947, 0.03818960005224792, 0.030308074811498553, 0.09755138342936387, 0.08941348143045902, 0.10054046024393815, 0.15044439303492996, 0.13737511121110768, 0.1263592425967982, 0.0856810232870635, 0.0852373233841055, 0.06434245399227845, 0.1263420867979116, 0.12249097503361772, 0.13161447401400583, 0.08800039946617122, 0.020000000000000018, 0.09886764917125912, 0.2009900204170293, 0.0966445935848107, 0.10641198647181749, 0.09319654501010399, 0.0876857352217888, 0.07362673851900492, 0.1447366108157011, 0.14349200704519882, 0.1572141671692293, 0.052716667974041176, 0.051930692038995696, 0.036652536131379865, 0.045226665557575485, 0.03237287260106858, 0.0674695457428871, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04460859688158447, 0.015811084194333525, 0.01921513965684596, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012076075928935004, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0789214987512018, 0.0790894634657876, 0.08531907466529143, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06338421539040451, 0.06871101975229732, 0.0659380639384527, 0.12364720509303806, 0.10973420521338129, 0.10156807180166672, 0.06636685320870006, 0.05019603414366747, 0.05109594091387548, 0.10148832498882543, 0.09596620128640154, 0.0965667512989028, 0.056624131373307574, 0.010000000000000009, 0.010000000000000009, 0.028010640636019102, 0.048508856299436354, 0.031685213082178754, 0.04008182010799033, 0.030748260272298045, 0.026853150874524667, 0.1397069990736136, 0.14416321596816528, 0.1452964137558116, 0.011271617966874148, 0.010000000000000009, 0.010000000000000009, -0.06760150577519264, -0.07615844782177672, -0.0655012307863172, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.07613800794484615, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.036246196200103054, -0.03252466663902842, -0.03145511806153012, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.04074854724518451, -0.01754333086392834, -0.03925133291364058, 0.016117148107319346, 0.024361336349907226, 0.019549024792783753, -0.04579429110043187, -0.03789638083469371, -0.050390172034341374, 0.00829844903377075, 0.012849587429046405, 0.007758918912737389, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007, -0.06434346238083943, -0.06622917553206409, -0.06545224249338788, -0.06979123905457518, -0.06787288321073603, -0.06987215907925126, 0.0517917001678575, 0.05879046887610884, 0.0539722713642139, -0.08000000000000007, -0.08000000000000007, -0.08000000000000007]}}
{"id": "3aaf02be-b6fe-44be-bd0c-f612a42cd61c", "fitness": -0.030417598498035096, "name": "Multi_Swarm_Stochastic_Optimizer", "description": "Introduces multi-swarm collaboration and a stochastic component to enhance exploration and convergence balance in high-dimensional spaces.", "code": "import numpy as np\n\nclass Multi_Swarm_Stochastic_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.num_swarms = 3\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles and divisions for multi-swarms\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size * self.num_swarms, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size * self.num_swarms, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size * self.num_swarms, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:self.num_swarms])\n    \n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.5 + 0.4 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for swarm in range(self.num_swarms):\n                for i in range(swarm * self.population_size, (swarm + 1) * self.population_size):\n                    score = func(self.particles[i])\n                    self.current_evals += 1\n                    if score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = score\n                        self.personal_best_positions[i] = self.particles[i].copy()\n                    if score < self.global_best_score:\n                        self.global_best_score = score\n                        self.global_best_position = self.particles[i].copy()\n\n                    r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                    cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                    social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                    diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, self.num_swarms)] - self.particles[i])\n                    # Enhanced velocity update\n                    self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                          0.8 * cognitive_velocity + 0.8 * social_velocity + 0.8 * diversity_control)\n                    self.particles[i] += self.velocities[i]\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                    dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                    if np.random.rand() < dynamic_mutation_rate:\n                        mutation_vector = np.random.normal(0, 0.1 + 0.1 * np.sin(np.pi * self.current_evals / self.budget), self.dim)\n                        self.particles[i] += mutation_vector\n                        self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * self.num_swarms * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:self.num_swarms]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 80, "feedback": "The algorithm Multi_Swarm_Stochastic_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.03042 with standard deviation 0.11281.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.08834408403525362, 0.1107978283792096, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02444539175305327, 0.020385699327755913, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02081619973448856, 0.059064959600467315, 0.05466612917080582, 0.05708317364446314, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023245346750239593, 0.08594148016760361, 0.057929235093625686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09994410407015442, 0.10805947352199585, 0.13084903150896143, 0.03512948583330133, 0.03129448469332852, 0.020000000000000018, 0.10348886801018864, 0.0863116411064907, 0.07861717558046533, 0.12990506644848054, 0.13323277534341382, 0.13694432871518825, 0.07359039023342162, 0.07990382579724953, 0.07571920487365913, 0.11796177208857017, 0.09328795631159725, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10819636878037442, 0.07959364514071898, 0.09346536453579757, 0.0677162831653646, 0.05729790989079797, 0.056492493752391515, 0.1438526290318487, 0.14243283588818745, 0.15475448018179316, 0.05158449799566678, 0.03547757673771412, 0.03724299351898164, 0.03269380706866665, 0.03503287767352059, 0.046135646697360366, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010578269203940782, 0.011020227560690765, 0.01886283553016388, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010325050164332938, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08068271093216628, 0.07747232029588913, 0.07295164899682693, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06809850084169322, 0.06309785285444347, 0.05408295557964171, 0.12302298128941236, 0.09808174643654399, 0.10401876641032515, 0.059599837805196065, 0.04679412537312533, 0.05749388892182428, 0.08930639019702225, 0.08642573774920781, 0.09739192417223763, 0.027765131280580113, 0.010000000000000009, 0.010000000000000009, 0.028787096308882543, 0.03298931799065696, 0.03492495557107189, 0.029819495737037127, 0.025942730337139897, 0.02561690655576554, 0.1331774993224224, 0.1387391153171349, 0.1362397668968629, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19238456346002586, -0.19863664021844452, -0.19859706602914118, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15128342666156946, -0.15160193433354885, -0.1605883340953198, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15517910128429957, -0.14243128262075455, -0.15382471136385156, -0.09617116426258554, -0.09924032290203, -0.09691414898267081, -0.1681384489078115, -0.16639114829780688, -0.1634569507475252, -0.1058333339821862, -0.11716903165461656, -0.11544974766415583, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18648319028056637, -0.18605831637110537, -0.186902028990928, -0.19089487100233216, -0.18675789698815004, -0.19008751368470955, -0.06432642977817493, -0.043207726894507026, -0.06746306924671353, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "b2723c11-2973-473c-b93b-ee462e546f65", "fitness": 0.038956730905749186, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduce a dynamic elite archiving and learning rate modulation to enhance convergence robustness and precision.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_archive = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            learning_rate_modulation = 0.1 + 0.8 * np.cos(2 * np.pi * self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_archive[np.random.randint(0, 3)] - self.particles[i])\n                # Updated velocity equation\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      learning_rate_modulation * (0.8 * cognitive_velocity + \n                                                                  0.8 * social_velocity + \n                                                                  0.8 * diversity_control))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_archive)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_archive = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 81, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03896 with standard deviation 0.04482.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.16975604290893243, 0.09498688813807277, 0.13781081970984244, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037645288048240966, 0.031221885779011083, 0.020000000000000018, 0.035565199996068775, 0.027500984074419144, 0.026928078947557332, 0.0646973650303252, 0.0495920959116799, 0.051566047133608905, 0.020000000000000018, 0.02857563221852555, 0.020000000000000018, 0.05099485171452667, 0.08594148016760361, 0.08849669200121835, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1366281516530694, 0.1014711850588137, 0.15985188179413345, 0.041010482065508724, 0.022713801612530893, 0.020000000000000018, 0.09040417063862749, 0.0863116411064907, 0.11214591036450516, 0.13985361911448768, 0.14830309306000133, 0.12910013101204532, 0.07839216349658695, 0.0922439760716387, 0.07851880225511987, 0.1524041968517531, 0.10989925803285328, 0.12515839588984645, 0.020000000000000018, 0.020000000000000018, 0.10699905715769342, 0.15534439446622716, 0.08606374949579165, 0.09030022769353874, 0.08379150636909116, 0.08083001176109372, 0.11318504753631853, 0.1438526290318487, 0.1370585866441406, 0.15475448018179316, 0.046508275864345916, 0.03392426887360889, 0.03666013607090657, 0.05344670749242708, 0.027231636111600288, 0.06020262843937818, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03007482378873161, 0.010921418565081331, 0.010568368840770836, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010110201020533394, 0.010085682432868781, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08700422512449313, 0.07493676816483319, 0.08008260817234925, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0556805909209277, 0.061604066057727724, 0.05441694639536909, 0.15347672832350323, 0.11552059622074229, 0.11108607790693104, 0.08684148525724988, 0.046877238840354885, 0.053936809511723194, 0.10063375081417991, 0.08991928795051995, 0.11763601776659427, 0.05555129804468906, 0.010000000000000009, 0.010000000000000009, 0.030541351505684267, 0.031071212534305115, 0.036496078731591663, 0.031193107439390633, 0.047194719651304395, 0.026038745502906746, 0.13755169203508555, 0.14195568085866195, 0.13481157732587146, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011166190747733507, 0.0, 0.008501630618326872, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04454521164499947, 0.04458419923300749, 0.02999784292175478, 0.0, 0.0, 0.0, 0.032900003016050894, 0.04325907620786085, 0.03312603484897192, 0.08787508642321651, 0.0871726892819179, 0.08493269578319129, 0.026076588851508653, 0.03119622026604929, 0.024853073078632493, 0.0857268975764417, 0.08066638383456182, 0.07320424168882567, 0.0, 0.0, 0.0, 0.012313331904075686, 0.011903645265288532, 0.012038341673464403, 0.009180071432966619, 0.010051284513262426, 0.009978533192437355, 0.11345030844261994, 0.1304161139054778, 0.11587546853675479, 0.0, 0.0, 0.0]}}
{"id": "eb458444-9862-4458-a142-67b9cabe42c6", "fitness": -Infinity, "name": "Refined_Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduce dual-phase exploration-exploitation with adaptive parameter tuning for enhanced performance across diverse landscapes.", "code": "import numpy as np\n\nclass Refined_Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n        self.phase_switch = budget // 2\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            adaptive_mutation_scale = 0.1 + 0.2 * np.cos(2 * np.pi * self.current_evals / self.budget)\n            \n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n\n                if self.current_evals <= self.phase_switch:\n                    # Exploration Phase\n                    self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                          cognitive_velocity + social_velocity + diversity_control)\n                else:\n                    # Exploitation Phase\n                    self.velocities[i] = (0.5 * dynamic_inertia_weight * self.velocities[i] +\n                                          1.2 * cognitive_velocity + 1.2 * social_velocity + 0.5 * diversity_control)\n\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.normal(0, adaptive_mutation_scale, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 82, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {}}
{"id": "794a04f9-d8d7-4306-a7cc-99b0691f10e7", "fitness": 0.03981719994490623, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduces a minor tweak in cognitive coefficient update for better exploitation-exploration balance.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                # Modified line for minor improvement\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.8 * cognitive_velocity + 0.8 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.3 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Slightly increased amplitude for better balance\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 83, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03982 with standard deviation 0.04541.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.16953475501892767, 0.09267168078412114, 0.15806211063638287, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03161044600604834, 0.020000000000000018, 0.02242943418566634, 0.03880705815779484, 0.020000000000000018, 0.03244706490251337, 0.0742207486997899, 0.056522384430417905, 0.05084518113198688, 0.020000000000000018, 0.041557289748747506, 0.020000000000000018, 0.04475705031972477, 0.10001032869362292, 0.08849669200121835, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14882800644495697, 0.10381854954363046, 0.14669585221470216, 0.03204763119990672, 0.03002124536325579, 0.030459764798281608, 0.08072694858327945, 0.0863116411064907, 0.11214591036450516, 0.14686068638953942, 0.17472324479851264, 0.13344285629828923, 0.08470701942509151, 0.12578627532085973, 0.07022944627913208, 0.1313863312086858, 0.1136773806364475, 0.12587709846724093, 0.08379507982591572, 0.020000000000000018, 0.10824618740641345, 0.15357352390847723, 0.09547529820323875, 0.10634335680525087, 0.08340917876342813, 0.08733680661145826, 0.06803998363120423, 0.1438526290318487, 0.1490694406584444, 0.15475448018179316, 0.0535188719302363, 0.03392426887360889, 0.030592415728652345, 0.05314172698881603, 0.034306091210992706, 0.07436129924064627, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0424935666214421, 0.013303960006928128, 0.01642774681939274, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010339722076975866, 0.013768739936869556, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08888277219555496, 0.0778843786605612, 0.0873615711231166, 0.010000000000000009, 0.010000000000000009, 0.01722005959254691, 0.056641615153221636, 0.06235532013334866, 0.05505616974933847, 0.13896021171279727, 0.10616686798589714, 0.10481226821292577, 0.06998015378188394, 0.05765139920785445, 0.053936809511723194, 0.10217428534508666, 0.09309971989737964, 0.10468649512931205, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031602643133003205, 0.03123672497451946, 0.04028301497816089, 0.0455544444684286, 0.04557661601635321, 0.029366464462469266, 0.13610200592433097, 0.13420117936789222, 0.13665254929750448, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013313528527616358, 0.0008417220086698318, 0.004804217445307346, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0005655039136410744, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04415626155989161, 0.04461128448184226, 0.03863716940580486, 0.0, 0.0, 0.0, 0.03777990003859388, 0.03753213255583987, 0.03892570731413414, 0.08869011336117294, 0.09129195971296056, 0.08270844595112126, 0.02799720763387481, 0.03485426256307089, 0.022790632225866525, 0.09162628885353474, 0.08232573060487491, 0.07808492390376909, 0.0, 0.0, 0.0, 0.012711520362855944, 0.012615699583823137, 0.012573661332917374, 0.007898577048180755, 0.01043923867029517, 0.010539128585974389, 0.11597837670172761, 0.1304161139054778, 0.11856765220988974, 0.0, 0.0, 0.0]}}
{"id": "414c7124-fce4-4f1e-9c11-b23bb5d6bea6", "fitness": 0.040053122004948344, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduced a slight alteration in the cognitive and social coefficients to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                # Modified line for minor improvement\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 84, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04005 with standard deviation 0.04570.", "error": "", "parent_ids": ["b66a3c02-c13b-440b-a99f-46ecd6e368b0"], "operator": null, "metadata": {"aucs": [0.17050562957457882, 0.0930467704834459, 0.15921426988541265, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03301090075904145, 0.020131408216074953, 0.023922301097015874, 0.03611462229680318, 0.020000000000000018, 0.03250688768172205, 0.07430637488967728, 0.05697881255757353, 0.05134646316660085, 0.020000000000000018, 0.04158455339082989, 0.020000000000000018, 0.05422024850977469, 0.10001032869362292, 0.08849669200121835, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14309872352062347, 0.10360186293549334, 0.14450091750004912, 0.03311637263388978, 0.03000261836396101, 0.02888795427314217, 0.09274809598959821, 0.0863116411064907, 0.11214591036450516, 0.14663408541496947, 0.17463359511602017, 0.13567415357249357, 0.0844086810232989, 0.1257348061290119, 0.06785709903277992, 0.14303726277786977, 0.13709156577036652, 0.14732382721709458, 0.08379507982591572, 0.020000000000000018, 0.09245533268478678, 0.15357352390847723, 0.0903494092089775, 0.10517998599329692, 0.08602096114989766, 0.09338787825226391, 0.0677347913922014, 0.14609563599033326, 0.14191271279048523, 0.15475448018179316, 0.05391656612931228, 0.042869759829072596, 0.0331343682335421, 0.05321730956047499, 0.03432530330271799, 0.06782604639092016, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04142287123024391, 0.0133314595642271, 0.01633167492540255, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014132311451025559, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011645817294819949, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08934097731480539, 0.07798915354132507, 0.0872231996262568, 0.010000000000000009, 0.010000000000000009, 0.013861260393772779, 0.05874878872442546, 0.06147825531143891, 0.05580838083859485, 0.13942214615895476, 0.1096882765466407, 0.10310281171683111, 0.07136994251484241, 0.056312958111261247, 0.05836544073162353, 0.10275425487971745, 0.08526744950127851, 0.10472964380428973, 0.016354322570323876, 0.010000000000000009, 0.010000000000000009, 0.031841121456544386, 0.03162109299808802, 0.040170903489582965, 0.045618428697637214, 0.045459676966981166, 0.031177825717434327, 0.13141309820135194, 0.13783341858273646, 0.14266028432443234, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012543543668276036, 0.0003814228405962794, 0.003007707472666876, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0007267835577693393, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04427533515230919, 0.04473727038847097, 0.038173583373389275, 0.0, 0.0, 0.0, 0.040636561837135154, 0.03753213255583987, 0.03590330952604448, 0.08861164016798395, 0.09201153138765017, 0.08038027274861781, 0.030717517530458482, 0.03603863433040477, 0.024628526443289056, 0.08388898331062256, 0.08231003040270735, 0.07179379044092771, 0.0, 0.0, 0.0, 0.012688226976331651, 0.0126856846101715, 0.012503164494679475, 0.007854506654332405, 0.010460143084041196, 0.010533899763607302, 0.1193092685173448, 0.1304161139054778, 0.10749293997128628, 0.0, 0.0, 0.0]}}
{"id": "50823e1f-429e-451e-a6f2-b0258caf8230", "fitness": 0.040043988639766936, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduced a sinusoidal variation to dynamically adjust the mutation rate and cooling rate for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                # Modified line for minor improvement\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) * (0.5 + 0.5 * np.cos(2 * np.pi * self.current_evals / self.budget))\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 85, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04004 with standard deviation 0.04567.", "error": "", "parent_ids": ["414c7124-fce4-4f1e-9c11-b23bb5d6bea6"], "operator": null, "metadata": {"aucs": [0.17385970404282403, 0.0930467704834459, 0.1498107921092281, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04968565624280319, 0.020131408216074953, 0.026477357607074148, 0.02442355504660898, 0.020000000000000018, 0.03250688768172205, 0.0743193614900648, 0.05697881255757353, 0.05134646316660085, 0.0349012630666361, 0.04158455339082989, 0.020000000000000018, 0.060386279383397135, 0.10001032869362292, 0.08849669200121835, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14189785712563885, 0.10360186293549334, 0.14552208312167836, 0.03311637263388978, 0.03000261836396101, 0.020000000000000018, 0.11521487695835775, 0.0863116411064907, 0.11214591036450516, 0.13967822074157343, 0.17463359511602017, 0.13466909890290624, 0.08050615279418405, 0.1257348061290119, 0.06785709903277992, 0.14303726277786977, 0.13709156577036652, 0.14732382721709458, 0.020000000000000018, 0.020000000000000018, 0.09382956668572584, 0.15357352390847723, 0.0903494092089775, 0.09312203852719503, 0.08602096114989766, 0.09338787825226391, 0.09657909263255504, 0.14609563599033326, 0.14191271279048523, 0.15475448018179316, 0.04799851549847034, 0.042869759829072596, 0.029843266423249637, 0.05298871608370814, 0.04109528050541977, 0.07320024562739458, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04327608588085785, 0.016379674483705586, 0.016341712764930016, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011048452658360741, 0.010131071067188469, 0.011227827058242545, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011645817294819949, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08947604026837441, 0.07890938379290735, 0.0915911478119057, 0.010000000000000009, 0.010000000000000009, 0.010255741577629873, 0.05874878872442546, 0.06361004896120304, 0.05755271865606881, 0.13942214615895476, 0.11137938847532813, 0.10959950358805715, 0.07218494919735918, 0.056647316927041946, 0.055643088745342295, 0.10438319932865314, 0.08543585093960915, 0.10795455776967255, 0.03226209746246067, 0.010000000000000009, 0.010000000000000009, 0.03192286040110559, 0.03511468528682615, 0.0417724502947634, 0.04518053554787027, 0.042888029919356696, 0.025975672147631856, 0.13141309820135194, 0.13301693228843714, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00994975599456216, 0.0014702780074035138, 0.008077076891938595, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0431916122016065, 0.043160970441522006, 0.03469699847552132, 0.0, 0.0, 0.0, 0.03704401405440949, 0.03758894125917844, 0.036457490038579676, 0.08861164016798395, 0.09070329461384385, 0.0826069951629701, 0.028486300081044247, 0.036567333337467756, 0.026821710476189198, 0.08388898331062256, 0.0811175688652438, 0.072397393192142, 0.0, 0.0, 0.0, 0.012688226976331651, 0.012656635055657395, 0.011772010949666734, 0.008635120155586318, 0.010071244422802383, 0.010828100049834477, 0.11752180159584158, 0.13086469280068713, 0.11151941195539583, 0.0, 0.0, 0.0]}}
{"id": "f55bad52-28d1-4f0d-ada2-619b784efe15", "fitness": 0.03960294582029375, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Improved dynamic adaptation of coefficients and diversity mechanisms in Enhanced_Hybrid_Adaptive_Optimizer to further enhance exploitation-exploration balance.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.01 * np.cos(2 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.2 + 0.8 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.85 * cognitive_velocity + 0.85 * social_velocity + 0.85 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.15 * (1 - self.current_evals / self.budget), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.25 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.25 * np.cos(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 86, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03960 with standard deviation 0.04423.", "error": "", "parent_ids": ["414c7124-fce4-4f1e-9c11-b23bb5d6bea6"], "operator": null, "metadata": {"aucs": [0.17014212532251805, 0.09196753038159755, 0.14600840939544313, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.032134538282626024, 0.026252454247896795, 0.024474794208879436, 0.03128017472499489, 0.020000000000000018, 0.02624110908534083, 0.0746487120796675, 0.057520439898557596, 0.05213728203726109, 0.020000000000000018, 0.04106317758509992, 0.020000000000000018, 0.0666954250017584, 0.09222762152042607, 0.08063787287771962, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022316275681931286, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13208126656283437, 0.11696604847392456, 0.14096051456201408, 0.030082052738220955, 0.035190040166372394, 0.03957202975354879, 0.0833514982050576, 0.0863116411064907, 0.11214591036450516, 0.13553659032587573, 0.1412711474650965, 0.13695556422918642, 0.08927249823397976, 0.09995009333830263, 0.06983394608137472, 0.1275638177462265, 0.12090287532502952, 0.14570794716627455, 0.08358088480096737, 0.020000000000000018, 0.09061747396421094, 0.1254022368172889, 0.09860538031586585, 0.10670316410723668, 0.07875789807601574, 0.101200731800829, 0.07084732667269011, 0.14436424614039622, 0.13589170657517036, 0.15475448018179316, 0.044012914830381056, 0.037101241264886675, 0.03860514656102476, 0.05390566010085518, 0.034954159260683015, 0.06735024843302995, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0442786571336975, 0.013781774456787188, 0.016927389404851945, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016121962152204627, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09045242954672883, 0.07736534700867725, 0.09091203138809945, 0.010000000000000009, 0.011381140142880164, 0.010000000000000009, 0.0642157510951552, 0.06873413959793528, 0.07012801728838935, 0.1259658971281361, 0.1050360208295209, 0.1072775178951677, 0.07222810647992806, 0.06087650403899658, 0.054267994545823095, 0.10997965676344679, 0.08127065044137527, 0.10542714204525572, 0.03313839249113226, 0.010000000000000009, 0.010000000000000009, 0.028390273019175516, 0.031235626564124153, 0.05352511473139143, 0.04517853155097673, 0.032627916225930975, 0.02655586938840704, 0.14125383089052124, 0.1452019821343623, 0.13552121638170378, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014303174632141813, 0.0007896785560549402, 0.004474864854549843, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0005139663782393056, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.043425472405659526, 0.04410614258460466, 0.038017987409347254, 0.0, 0.0, 0.0, 0.03775708205782946, 0.04076264454336842, 0.03467184144779234, 0.08592486661295051, 0.08944852982333062, 0.08211679781863668, 0.025021188224830238, 0.034213055173182405, 0.024133274659260406, 0.09097794783649238, 0.08207843591331065, 0.0732222711505719, 0.0, 0.0, 0.0, 0.012099977616195523, 0.013003284965197204, 0.013012605385865461, 0.009366257994544935, 0.010075919607817618, 0.010754603291033948, 0.12228488835191564, 0.1304161139054778, 0.11194821714310876, 0.0, 0.0, 0.0]}}
{"id": "c9afc3b8-d2cb-4f7c-b634-1fb09a63727f", "fitness": 0.03921649734490599, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Enhanced exploration and exploitation balance by incorporating dynamic diversity-promoting mechanisms.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            diversity_promotion = 0.5 * (1 - np.cos(2 * np.pi * self.current_evals / self.budget))\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                \n                # Enhanced line for better exploration-exploitation\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + \n                                      0.8 * diversity_control + diversity_promotion * np.random.uniform(-1, 1, self.dim))\n                \n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 87, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03922 with standard deviation 0.04367.", "error": "", "parent_ids": ["414c7124-fce4-4f1e-9c11-b23bb5d6bea6"], "operator": null, "metadata": {"aucs": [0.10876562913826004, 0.09721569626604831, 0.15460161799179528, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034872813612984666, 0.025960654618571666, 0.0292213599127078, 0.020000000000000018, 0.02711505684096538, 0.020000000000000018, 0.0743977100595763, 0.05141035666652949, 0.054780650982468315, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.059852930050129816, 0.09942449785165508, 0.08059475162781271, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1367284468594141, 0.10033948298883588, 0.14680173442765776, 0.030207987342938614, 0.024688449357629594, 0.023107907713192155, 0.08717770610824371, 0.0863116411064907, 0.08936933282278647, 0.1455216956976898, 0.16058346746952723, 0.12846024746896745, 0.07784352671365269, 0.11310144678078271, 0.0814962083899542, 0.12592872341922945, 0.1166489840167293, 0.12497174547944068, 0.09937100730670068, 0.020000000000000018, 0.11129808901829552, 0.14022583110783504, 0.10470415652272669, 0.0895133107273659, 0.06820789210951173, 0.08921682713076518, 0.08048298643183216, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.053256767872171595, 0.04078513120674676, 0.035994911476570635, 0.04794631949492978, 0.04081832860638668, 0.06593608044892052, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0319877037239128, 0.018325518392055318, 0.015969986284319226, 0.010000000000000009, 0.010265150641332044, 0.010000000000000009, 0.015094824197975587, 0.011017763272616166, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09115320194747967, 0.0685273553913115, 0.08327532188645936, 0.010000000000000009, 0.010000000000000009, 0.013252664162297645, 0.06310248368136773, 0.0655375609108042, 0.06871236566488481, 0.13270008804655464, 0.10835005140684162, 0.10707295114962467, 0.06436047799022593, 0.051317906443504646, 0.05975100082742657, 0.10653701596250342, 0.09584371787916235, 0.10826169462851742, 0.052538233066058426, 0.010000000000000009, 0.03473026547545288, 0.029730241819951986, 0.04450041287845152, 0.042718850527614594, 0.03397139986080833, 0.041252977078219843, 0.027030541293367794, 0.13224716837223727, 0.13446978309350588, 0.13478595309926422, 0.011533608412046314, 0.010000000000000009, 0.010000000000000009, 0.009639950377886675, 0.0040232746929437235, 0.00626981886783784, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0011123507942957245, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04210331770363185, 0.04843021735334829, 0.03456927003670396, 0.0, 0.0, 0.0, 0.0376647219493943, 0.03935100508470579, 0.03501395177438482, 0.08597977272984691, 0.08997516999983535, 0.07663113457944992, 0.03007250325599431, 0.03269649682368336, 0.026481118957345395, 0.08460218562976385, 0.08214828322646073, 0.0725448021258831, 0.0, 0.0, 0.0, 0.013181164001633161, 0.011613906091812565, 0.01215003582351537, 0.007831109918598145, 0.010051284513262426, 0.010297258315320912, 0.12358636210424112, 0.1307333161742632, 0.11232448909325621, 0.0, 0.0, 0.0]}}
{"id": "df856fea-761e-4d2b-aa33-1557fa77de0b", "fitness": 0.0401392816064277, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Enhanced exploration by adjusting elite position selection frequency to refine search dynamics.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        # Initialize particles\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 1.5) == 0:  # Adjusted line for enhanced exploration\n                np.random.shuffle(self.elite_positions)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 88, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04014 with standard deviation 0.04566.", "error": "", "parent_ids": ["414c7124-fce4-4f1e-9c11-b23bb5d6bea6"], "operator": null, "metadata": {"aucs": [0.17050562957457882, 0.0930467704834459, 0.15921426988541265, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03301090075904145, 0.020131408216074953, 0.023922301097015874, 0.03611462229680318, 0.020000000000000018, 0.03250688768172205, 0.07430637488967728, 0.05697881255757353, 0.05134646316660085, 0.020000000000000018, 0.04158455339082989, 0.020000000000000018, 0.05422024850977469, 0.10001032869362292, 0.08849669200121835, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14309872352062347, 0.10360186293549334, 0.14450091750004912, 0.03311637263388978, 0.03000261836396101, 0.02888795427314217, 0.09274809598959821, 0.0863116411064907, 0.11214591036450516, 0.14663408541496947, 0.17463359511602017, 0.13567415357249357, 0.0844086810232989, 0.1257348061290119, 0.06785709903277992, 0.14303726277786977, 0.13709156577036652, 0.14732382721709458, 0.08379507982591572, 0.020000000000000018, 0.09245533268478678, 0.15357352390847723, 0.0903494092089775, 0.10517998599329692, 0.08602096114989766, 0.09338787825226391, 0.0677347913922014, 0.14609563599033326, 0.14191271279048523, 0.15475448018179316, 0.05391656612931228, 0.042869759829072596, 0.0331343682335421, 0.05302272758327209, 0.03547807604819597, 0.07064142810035279, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04070917528019402, 0.01329747041884477, 0.019232649957137804, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010246550783399755, 0.0138563633661698, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08870528078533435, 0.07801972371832222, 0.08987311160370226, 0.010000000000000009, 0.010000000000000009, 0.013861260393772779, 0.05874878872442546, 0.06147825531143891, 0.05580838083859485, 0.13869975682503988, 0.1096882765466407, 0.10395771897629968, 0.07157745440540009, 0.056312958111261247, 0.05672454432525431, 0.10156320081149628, 0.08458716722611925, 0.10702168301520076, 0.03294575080722284, 0.010000000000000009, 0.010000000000000009, 0.031841121456544386, 0.035217894711984554, 0.044246181474520196, 0.036915996280514896, 0.04436323759724814, 0.025049750065655463, 0.13141309820135194, 0.13783341858273646, 0.14266028432443234, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012543543668276036, 0.0007145074257612904, 0.00886611122031633, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0007267835577693393, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0445948962670335, 0.0468520691406793, 0.03935927367261283, 0.0, 0.0, 0.0, 0.03704401405440949, 0.038560051889923175, 0.03590330952604448, 0.08871354046752256, 0.09029423814481485, 0.08070772112545355, 0.030717517530458482, 0.03603863433040477, 0.024242106709228994, 0.08388898331062256, 0.08426922774682533, 0.07281182115465645, 0.0, 0.0, 0.0, 0.012688226976331651, 0.012684056214134376, 0.012177961426038553, 0.007873082674791587, 0.010152479514824786, 0.010416782670062519, 0.11982924343609014, 0.1304161139054778, 0.10401387105432991, 0.0, 0.0, 0.0]}}
{"id": "979a4da4-176f-4a52-ad87-ba795d7133b3", "fitness": 0.04066179653878616, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduce dynamic elite replacement and adaptive mutation to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:  # Adjusted line for better elite replacement\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 89, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04066 with standard deviation 0.04585.", "error": "", "parent_ids": ["df856fea-761e-4d2b-aa33-1557fa77de0b"], "operator": null, "metadata": {"aucs": [0.13849399807169793, 0.09472662492905526, 0.1557285340725304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03394686589633755, 0.02243607078599441, 0.023579515157966302, 0.04123232004064392, 0.020000000000000018, 0.03141411898747004, 0.07803653840952274, 0.05096187518806006, 0.053494027428172886, 0.07024385333825256, 0.020000000000000018, 0.020000000000000018, 0.0880457416308803, 0.11608808321230579, 0.08389301504344615, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15063302820568936, 0.1049430267307514, 0.19289636372946972, 0.029546264944925182, 0.03276099922493925, 0.020000000000000018, 0.08072694858327945, 0.09256792471722308, 0.08857253039953639, 0.13912833318142281, 0.15759800573288718, 0.1266051483720132, 0.07986051406033401, 0.10779055171021523, 0.06954979192981914, 0.14919865840919555, 0.13845258627427026, 0.13441993656996143, 0.09223149662565788, 0.023026885343302328, 0.10036536971282084, 0.13434318067089634, 0.09361662650989533, 0.0895133107273659, 0.06597587995974419, 0.13926904394276218, 0.07891874031344281, 0.1438526290318487, 0.13589170657517036, 0.1651488877408207, 0.04898951052223721, 0.041754697293926, 0.03737136696794774, 0.04319955158767885, 0.03391320865114622, 0.06727775588053475, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.044642558786578634, 0.017901005829536465, 0.015701595969449644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010452453000101669, 0.018615288919944017, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08746711702483301, 0.06929272905241479, 0.1013830355203793, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057784352952080176, 0.0667250334668692, 0.06665057367183025, 0.12778368370209137, 0.11352596196355758, 0.10344354504831699, 0.07022559300371567, 0.05987226546196811, 0.053936809511723194, 0.09575677986995701, 0.09168337680270344, 0.10179686221486695, 0.09279455319037311, 0.010000000000000009, 0.010000000000000009, 0.032785262530773074, 0.03738133968843127, 0.05563353310988861, 0.04219223985549991, 0.04378562451332402, 0.03062159461459013, 0.15961153761430036, 0.13174411047080392, 0.1357049920068618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011223770061007388, 0.0008875396659370205, 0.014437584918575053, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0004793536782057295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04503412695698572, 0.04525871881250643, 0.04093890285009938, 0.0, 0.0, 0.0, 0.03288412862039436, 0.04190381522405784, 0.03366874488623506, 0.09170549306650744, 0.08833679672923767, 0.08176688525318487, 0.025223004476850885, 0.031097061173481433, 0.023845687313103103, 0.08085959195367376, 0.07695724967614948, 0.07688928774010362, 0.0, 0.0, 0.0, 0.012628021968939418, 0.011214351977713588, 0.012088368404870042, 0.007904744024399224, 0.012224131663464033, 0.010545068740471453, 0.11553059456084014, 0.1304161139054778, 0.10787186168210727, 0.0, 0.0, 0.0]}}
{"id": "0f1c770a-fc75-4e5d-ac66-1548743fc980", "fitness": 0.04074890843481652, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Slightly adjust cognitive and social coefficients for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:  # Adjusted line for better elite replacement\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Adjusted coefficient\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 90, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04075 with standard deviation 0.04605.", "error": "", "parent_ids": ["979a4da4-176f-4a52-ad87-ba795d7133b3"], "operator": null, "metadata": {"aucs": [0.13849399807169793, 0.09472662492905526, 0.1557285340725304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03394686589633755, 0.02243607078599441, 0.023579515157966302, 0.04123232004064392, 0.020000000000000018, 0.03141411898747004, 0.07803653840952274, 0.05096187518806006, 0.053494027428172886, 0.07024385333825256, 0.020000000000000018, 0.020000000000000018, 0.0880457416308803, 0.11608808321230579, 0.08389301504344615, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15063302820568936, 0.10491597157537702, 0.19289636372946972, 0.029546264944925182, 0.03276099922493925, 0.020000000000000018, 0.08072694858327945, 0.09256792471722308, 0.08857253039953639, 0.13912833318142281, 0.15759800573288718, 0.12802420979986007, 0.07986051406033401, 0.10779055171021523, 0.06954979192981914, 0.14919865840919555, 0.13845258627427026, 0.13441993656996143, 0.09223149662565788, 0.023026885343302328, 0.10036536971282084, 0.13434318067089634, 0.0940883033895753, 0.0895133107273659, 0.06658832684780092, 0.13926904394276218, 0.07891874031344281, 0.1438526290318487, 0.13589170657517036, 0.1651488877408207, 0.04898951052223721, 0.041754697293926, 0.03737136696794774, 0.04305411884249788, 0.033884668839542775, 0.0672311231334003, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.044642558786578634, 0.017901337119314076, 0.015701595969449644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010508676728154254, 0.018725383135440365, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08746711702483301, 0.06914760777750839, 0.1013830355203793, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05483021975150859, 0.06986103676151911, 0.0675178241491351, 0.12780443446985812, 0.11382748255770425, 0.1033481741692367, 0.07011603976088343, 0.05987226546196811, 0.053936809511723194, 0.09639327754005445, 0.09493564558174905, 0.1021290594324955, 0.09279455319037311, 0.010000000000000009, 0.010000000000000009, 0.032189458994924425, 0.036119196760965644, 0.05563353310988861, 0.04219003279538314, 0.04401476717261277, 0.029764257334770394, 0.15961153761430036, 0.13832652599212725, 0.14060789696817044, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01126375000443014, 0.000915818204790031, 0.014513225749654302, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0004793536782057295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04503412695698572, 0.04525951920657634, 0.04100255933113606, 0.0, 0.0, 0.0, 0.032240862229742984, 0.04190381522405784, 0.033656095767515826, 0.09113848687248816, 0.08831058137011027, 0.08182812678815976, 0.025175869911413518, 0.030739382208093913, 0.023847610871890246, 0.08158098398687441, 0.0764215565254599, 0.07682502385779211, 0.0, 0.0, 0.0, 0.012614076309891975, 0.011258995893079327, 0.012072620672169743, 0.007907091109851105, 0.012224131663464033, 0.010542445055142236, 0.11688199211092087, 0.13572632460771028, 0.10461128684799392, 0.0, 0.0, 0.0]}}
{"id": "ef607223-31fd-4e57-b128-9f5a010b30fc", "fitness": 0.04074890843481652, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Enhance global best position updates to improve convergence speed by integrating momentum.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n        self.global_momentum = np.zeros(self.dim)  # Added momentum variable\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n                    self.global_momentum = 0.2 * self.global_momentum + 0.8 * (self.global_best_position - self.particles[i])  # Adjusted line\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:  # Adjusted line for better elite replacement\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Adjusted coefficient\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 91, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04075 with standard deviation 0.04605.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.13849399807169793, 0.09472662492905526, 0.1557285340725304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03394686589633755, 0.02243607078599441, 0.023579515157966302, 0.04123232004064392, 0.020000000000000018, 0.03141411898747004, 0.07803653840952274, 0.05096187518806006, 0.053494027428172886, 0.07024385333825256, 0.020000000000000018, 0.020000000000000018, 0.0880457416308803, 0.11608808321230579, 0.08389301504344615, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15063302820568936, 0.10491597157537702, 0.19289636372946972, 0.029546264944925182, 0.03276099922493925, 0.020000000000000018, 0.08072694858327945, 0.09256792471722308, 0.08857253039953639, 0.13912833318142281, 0.15759800573288718, 0.12802420979986007, 0.07986051406033401, 0.10779055171021523, 0.06954979192981914, 0.14919865840919555, 0.13845258627427026, 0.13441993656996143, 0.09223149662565788, 0.023026885343302328, 0.10036536971282084, 0.13434318067089634, 0.0940883033895753, 0.0895133107273659, 0.06658832684780092, 0.13926904394276218, 0.07891874031344281, 0.1438526290318487, 0.13589170657517036, 0.1651488877408207, 0.04898951052223721, 0.041754697293926, 0.03737136696794774, 0.04305411884249788, 0.033884668839542775, 0.0672311231334003, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.044642558786578634, 0.017901337119314076, 0.015701595969449644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010508676728154254, 0.018725383135440365, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08746711702483301, 0.06914760777750839, 0.1013830355203793, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05483021975150859, 0.06986103676151911, 0.0675178241491351, 0.12780443446985812, 0.11382748255770425, 0.1033481741692367, 0.07011603976088343, 0.05987226546196811, 0.053936809511723194, 0.09639327754005445, 0.09493564558174905, 0.1021290594324955, 0.09279455319037311, 0.010000000000000009, 0.010000000000000009, 0.032189458994924425, 0.036119196760965644, 0.05563353310988861, 0.04219003279538314, 0.04401476717261277, 0.029764257334770394, 0.15961153761430036, 0.13832652599212725, 0.14060789696817044, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01126375000443014, 0.000915818204790031, 0.014513225749654302, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0004793536782057295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04503412695698572, 0.04525951920657634, 0.04100255933113606, 0.0, 0.0, 0.0, 0.032240862229742984, 0.04190381522405784, 0.033656095767515826, 0.09113848687248816, 0.08831058137011027, 0.08182812678815976, 0.025175869911413518, 0.030739382208093913, 0.023847610871890246, 0.08158098398687441, 0.0764215565254599, 0.07682502385779211, 0.0, 0.0, 0.0, 0.012614076309891975, 0.011258995893079327, 0.012072620672169743, 0.007907091109851105, 0.012224131663464033, 0.010542445055142236, 0.11688199211092087, 0.13572632460771028, 0.10461128684799392, 0.0, 0.0, 0.0]}}
{"id": "057ba150-1840-40db-afa7-c8c83034148b", "fitness": 0.03847804612534974, "name": "Refined_Adaptive_Optimizer", "description": "Introduce adaptive swarm parameters and hybridize momentum strategies for enhanced diversity and convergence.", "code": "import numpy as np\n\nclass Refined_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.momentum_weight = 0.1\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:5])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            momentum = self.momentum_weight * np.sin(2 * np.pi * self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.3 + 0.7 * (self.current_evals / self.budget)\n\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3, r4 = np.random.rand(), np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 5)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control +\n                                      momentum * r4 * (self.particles[np.random.randint(0, self.population_size)] - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.cos(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 5, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:5]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 92, "feedback": "The algorithm Refined_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03848 with standard deviation 0.04347.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.13254419589618904, 0.10502449725292995, 0.13549297108763425, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03126478210921635, 0.04631626593666793, 0.025450778252581463, 0.026570771400106108, 0.028568812140136957, 0.03361902339308298, 0.056377344401576046, 0.05494515446146897, 0.05209321916164311, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05522340070648335, 0.1138709366573647, 0.07439867998095484, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.031109970793269826, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12441369932316182, 0.11477985946571001, 0.1378440727024529, 0.03197385237018413, 0.020000000000000018, 0.02750411567914024, 0.09166487896648745, 0.0863116411064907, 0.08580710417003756, 0.13495044429024972, 0.15358821539884016, 0.13555041940299328, 0.07173677037329473, 0.08756241895422479, 0.09064164122852747, 0.1346246739943302, 0.1127333031784079, 0.13552483678288807, 0.04553506805242391, 0.020000000000000018, 0.11531290008758732, 0.10819636878037442, 0.0789836951306192, 0.10744083959746975, 0.0677162831653646, 0.05028689461311475, 0.056492493752391515, 0.17275240204757214, 0.13589170657517036, 0.15475448018179316, 0.05019462739485703, 0.04752131273159932, 0.029716778025373314, 0.04429308057658288, 0.038122153761581234, 0.055175537636782956, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031406305712882276, 0.018124244466898087, 0.015060141090101342, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01629771415502046, 0.010000000000000009, 0.011310817640370674, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09430223814313654, 0.08052028950725743, 0.09254818828031697, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05603099301128989, 0.06222675703458447, 0.05760265773917128, 0.1305088114541213, 0.10962502253128492, 0.10828959418592377, 0.07425477376311418, 0.04725762334676975, 0.061626936342468075, 0.10010056327260841, 0.09566959631456218, 0.10711160360234018, 0.013374942328153838, 0.010000000000000009, 0.010000000000000009, 0.035435810139546775, 0.04413910557224643, 0.04272290406777646, 0.03143188192138846, 0.039261377833555766, 0.026155733332166586, 0.13718414360482367, 0.1370735989135382, 0.1515663424887782, 0.010402239447385053, 0.010000000000000009, 0.010000000000000009, 0.010699307816319337, 0.005234806410861936, 0.005187515230015927, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0029293118135541585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.046477509139280615, 0.04792722176417419, 0.04041411480558399, 0.0, 0.0, 0.0, 0.030262202767467716, 0.03988856623308645, 0.03571732321340004, 0.08810056903665842, 0.08820860104165762, 0.08651535118232412, 0.027935679332594776, 0.030995918287983093, 0.024167791454474452, 0.08598688764575002, 0.08020496649116282, 0.07520729924266434, 0.0, 0.0, 0.0, 0.011630548114911599, 0.01115219072174356, 0.012042490503145764, 0.00787340577953033, 0.010513639112779694, 0.010637826713583376, 0.1142756423277893, 0.1304161139054778, 0.11356283861460237, 0.0, 0.0, 0.0]}}
{"id": "f08d9b25-bb28-40fe-ade9-0430a4af3f1b", "fitness": 0.03931255802645737, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduce slight randomness to the inertia weight to enhance exploration capabilities.  ", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget) + 0.05 * np.random.rand()  # Added randomness\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:  # Adjusted line for better elite replacement\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Adjusted coefficient\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 93, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03931 with standard deviation 0.04418.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.12193357084229972, 0.0984987394922805, 0.15545144888566642, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.040924254971687724, 0.020367216529572296, 0.0215052705316926, 0.020000000000000018, 0.021183012567214776, 0.024847990523232943, 0.07266253941196399, 0.058434286163613125, 0.0544185237470447, 0.020000000000000018, 0.06925037078915086, 0.020000000000000018, 0.05717200582611892, 0.08775920625184763, 0.08201396931681959, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12971002725347913, 0.10466459255880411, 0.19303133124833693, 0.039763586716075605, 0.02402216439498972, 0.027202764797022105, 0.08344912380804526, 0.11331053281026482, 0.09253048248553997, 0.13695313799771358, 0.13323277534341382, 0.12193996784405525, 0.07466797993016994, 0.07990382579724953, 0.07978610708548128, 0.12528524410672182, 0.1100213561865353, 0.14120311030955734, 0.020000000000000018, 0.020000000000000018, 0.10107276136167176, 0.11739360317078451, 0.10749063249822055, 0.0991679653586911, 0.07878876283167624, 0.07982704647456773, 0.06419371519008066, 0.1438526290318487, 0.14009180733592952, 0.15475448018179316, 0.04838525041510522, 0.036645015687361226, 0.03200113592052789, 0.04364730609715717, 0.03836656223650137, 0.06381859407895318, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.046332722329841536, 0.017868571239790354, 0.015849877292404724, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011683809297800551, 0.011767089142588394, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0862935923515592, 0.07051252670785557, 0.09566439156228879, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0637655911716054, 0.06269115954309834, 0.06152789208972098, 0.13698257305026884, 0.1133730962852042, 0.10416668083249203, 0.07633311067378246, 0.058860107633578074, 0.05790402858564592, 0.10233714674578609, 0.09252344340449337, 0.11364332250070741, 0.11765502300376496, 0.010000000000000009, 0.010000000000000009, 0.027845976210931433, 0.03844808060749183, 0.03931063587375505, 0.033017465954778835, 0.03772404254335626, 0.034174296687356165, 0.13141309820135194, 0.15189953180860882, 0.13848139190857378, 0.011200296908237983, 0.010000000000000009, 0.010000000000000009, 0.019323251267799546, 0.002145265674985075, 0.008258035809811437, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001915479033328893, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04465883126367998, 0.04680747547468711, 0.03504881257497683, 0.0, 0.0, 0.0, 0.0370500095084797, 0.03782285731844903, 0.034018465726935454, 0.08637923404197267, 0.08938602905977466, 0.07817905319417773, 0.032538419082108305, 0.035393181806891105, 0.025275738593904862, 0.0876986482441029, 0.07640559379277567, 0.07736139297123201, 0.0, 0.0, 0.0, 0.012280157180270423, 0.012476304865588483, 0.013408850357613189, 0.007995237769418795, 0.010377945860964077, 0.01064739550568905, 0.11679970503580572, 0.13053456237821848, 0.11347824377789917, 0.0, 0.0, 0.0]}}
{"id": "395193e4-88e6-43c0-9dc8-ad681e38dca8", "fitness": 0.03892863544623523, "name": "Dynamic_Elite_Adaptive_Optimizer", "description": "Introduce dynamic learning coefficients and adaptive elite selection to enhance convergence efficiency and diversity in solution exploration.", "code": "import numpy as np\n\nclass Dynamic_Elite_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 3) == 0:\n                sorted_indices = np.argsort(self.personal_best_scores)\n                self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.4 + 0.2 * np.cos(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.3 + 0.3 * np.cos(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 94, "feedback": "The algorithm Dynamic_Elite_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03893 with standard deviation 0.04396.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.143765725667791, 0.09972785322832256, 0.14044036792065728, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03295051817763195, 0.02624096126895592, 0.024597882441977137, 0.02321955421829558, 0.028476647309304326, 0.024539746341079027, 0.08123763330629918, 0.05328744828529408, 0.05343365685277068, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05270278521903515, 0.08594148016760361, 0.09077186284268746, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.142387606877324, 0.10852458401399045, 0.15638929744845342, 0.028023603761989202, 0.023755575649969995, 0.020000000000000018, 0.08509918930789528, 0.0863116411064907, 0.08997282834654075, 0.13591078171484894, 0.14463516006589827, 0.13261982751086232, 0.0767873922187422, 0.08184861330782811, 0.08729601691401967, 0.12093735692936713, 0.11789681270198638, 0.13628214366653668, 0.10014188498023036, 0.020000000000000018, 0.11275193471995704, 0.12523520729886684, 0.0866407290885104, 0.0895133107273659, 0.06888505376696041, 0.0767440634052724, 0.0675000720920681, 0.16267169985431695, 0.1405969828111583, 0.15475448018179316, 0.05722655997704895, 0.03858549513655973, 0.04569091946991821, 0.04148893391914299, 0.025615490594339096, 0.07023029257746927, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04135709141480215, 0.01452345170083058, 0.01421035786011926, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01214835271435577, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018772648316497276, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08359651859513972, 0.06457112205042492, 0.1017719906242146, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06645423679396711, 0.0704608570398666, 0.05444960530723464, 0.13594217564194688, 0.11612600742950518, 0.10703845309415538, 0.06852907397846875, 0.06118982142371365, 0.054121129282938774, 0.09662930121524127, 0.10040875496458579, 0.10543116667044361, 0.01053025000522323, 0.010000000000000009, 0.010000000000000009, 0.029280888539493732, 0.03799576386682835, 0.04019168227553427, 0.0347493962626747, 0.04387355073189669, 0.04016573427340764, 0.13610820262141243, 0.13132285322544845, 0.13675951482666493, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00964831852031045, 0.00022924629274145847, 0.014949862967653771, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0011763579210355424, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04518913070214092, 0.03997264654003685, 0.04242807739640175, 0.0, 0.0, 0.0, 0.03605737334273573, 0.04468407009248465, 0.03564999270497171, 0.08904138288025532, 0.08946545572471931, 0.08464070528128642, 0.029493632352823207, 0.029157657344447308, 0.024570893183266773, 0.08486447641977601, 0.07846737467077924, 0.07424812604326914, 0.0, 0.0, 0.0, 0.011644461144390883, 0.011577613027233591, 0.012364220477488752, 0.008781874926945377, 0.010494140663061646, 0.009182765136754534, 0.12934581141764412, 0.1304161139054778, 0.1118478571682141, 0.0, 0.0, 0.0]}}
{"id": "2635f8f8-714f-479c-bad1-68302074d822", "fitness": 0.04012300036386026, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Implement a dynamically adjusted velocity control mechanism and enhance the balance between exploration and exploitation through temperature-based perturbation.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.2\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                velocity_update_factor = 0.8 + 0.2 * np.sin(np.pi * self.current_evals / self.budget)\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] * velocity_update_factor +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n                if np.random.rand() < dynamic_mutation_rate:\n                    perturbation = np.random.normal(0, 0.1 + 0.05 * (np.sin(2 * np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += perturbation\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 5) == 0:\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.4 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.3 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 95, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04012 with standard deviation 0.04501.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.15620300533070974, 0.10821798597440135, 0.15267660946754313, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03609835617061308, 0.035250209446945124, 0.023069846388576454, 0.03260313312752261, 0.02379338774801365, 0.028870444765292103, 0.0696787225016311, 0.058149492952605075, 0.05536071428823275, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06668769444549183, 0.09958341715249786, 0.09674238736288254, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0204438171697785, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13186224219949427, 0.11059730434499437, 0.14911473504883754, 0.03242897625457686, 0.02335767372027031, 0.020000000000000018, 0.10326613896198378, 0.0863116411064907, 0.09071769473556257, 0.12990506644848054, 0.13962257911267373, 0.1338799415206411, 0.07296990093967282, 0.08291134500943653, 0.07685666493629073, 0.1429600988009767, 0.10672285432725914, 0.12895848769618656, 0.10147475356054825, 0.04882762641714633, 0.10404004274243273, 0.14300564799037063, 0.09384806648753663, 0.09892655820511298, 0.10759216345686351, 0.11821116605455317, 0.07134796387032682, 0.16908052018102038, 0.15569267659218455, 0.15475448018179316, 0.04974193738006305, 0.04025700857373293, 0.03201272741387473, 0.051813297056791496, 0.03671356843326212, 0.07079857098138975, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03391616102563488, 0.0140393479339751, 0.014460019001557467, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01250004063838872, 0.0156201817811783, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09100293028816198, 0.07718831560079731, 0.0848637942326591, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06232332440656796, 0.06147825531143891, 0.07027345269640994, 0.12375088840215609, 0.1094558014386352, 0.10638982248775919, 0.07262335982290313, 0.051113440239327845, 0.057314711338134594, 0.10289992817579985, 0.10039918872032882, 0.10808076652689635, 0.027813418542325552, 0.010000000000000009, 0.010000000000000009, 0.03266536158332234, 0.053616792070796504, 0.044568625514898486, 0.040232981490569975, 0.03523530097307981, 0.030870043225497357, 0.13406784321184906, 0.13761325301918392, 0.13693606222391508, 0.010000000000000009, 0.010000000000000009, 0.011353379896109184, 0.011580542523814463, 0.0005449254877839538, 0.008382092478223857, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.003378168517677693, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045018268931594, 0.0449001704301315, 0.03937306994819556, 0.0, 0.0, 0.0, 0.03463702615467201, 0.04861643873394794, 0.031433986166163774, 0.08956362615396518, 0.08967945196056615, 0.0808735751882188, 0.028016486813799535, 0.033968170214386695, 0.02916664949516301, 0.08538819100253614, 0.07933361281068496, 0.0804878332159652, 0.0, 0.0, 0.0, 0.011043729603767205, 0.011787644814665876, 0.01209876881792682, 0.008527993088533914, 0.010194023159458387, 0.009898075104142423, 0.12057326782239519, 0.1304161139054778, 0.11900803919413017, 0.0, 0.0, 0.0]}}
{"id": "7e23a27c-ee0a-4c1d-84af-ef96e280e5fb", "fitness": 0.040045196484664945, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Enhance convergence by slightly tweaking the inertia weight formula for better adaptability over iterations.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * np.sin(np.pi * self.current_evals / self.budget)  # Modified line\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 96, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04005 with standard deviation 0.04532.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.12500049449570272, 0.08712981262730268, 0.15892869314767977, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.049034313985745204, 0.022910253830371707, 0.0236050917363394, 0.030154119840239857, 0.02980801506433972, 0.025640922715877257, 0.07686678497396582, 0.05187885255228797, 0.05257778485664166, 0.06848427820880443, 0.020000000000000018, 0.020000000000000018, 0.05109131319014293, 0.10655657711433664, 0.09495057297214515, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1512099627984944, 0.11045613521765207, 0.17524833719100996, 0.03382149009265367, 0.020306608095890688, 0.020000000000000018, 0.08344668022592483, 0.0863116411064907, 0.0811825415176739, 0.1373872374763917, 0.16447811535813717, 0.14290314086333156, 0.06836122646246567, 0.11291488704324737, 0.08029358499738193, 0.14156468326187577, 0.10706176286672364, 0.13272663103324345, 0.09973485547229866, 0.020000000000000018, 0.11875003334019962, 0.11762629689934345, 0.09531712484349186, 0.09741030869570866, 0.06603289442496107, 0.08448409109866961, 0.0864326577237492, 0.16323346046169807, 0.15077543266233218, 0.164104447629843, 0.06390196869798725, 0.034225055937531, 0.03258674828728292, 0.04172238886011759, 0.03427723674934169, 0.06359611993477754, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04075548835654541, 0.017631174147515805, 0.014965137183607924, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01923152887958335, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09372073762893618, 0.07520922831720445, 0.0973295659739759, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06432777344633989, 0.05421734077863016, 0.13194933118606567, 0.1159871371745137, 0.10402331024927436, 0.07752195829915254, 0.0597090492279122, 0.053936809511723194, 0.09823104269354099, 0.09702597122442735, 0.10945200755586115, 0.06093466357452715, 0.010000000000000009, 0.010000000000000009, 0.0384851720911118, 0.03757103466303224, 0.04426267871747025, 0.03391012964122009, 0.02955479053588972, 0.026333195223201544, 0.1353807561422371, 0.1333541173826407, 0.13659287010359678, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012834126214274266, 0.0010714927657364814, 0.015786187139386287, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0005359317928830265, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04644902161565512, 0.03844257150776076, 0.04124730905197449, 0.0, 0.0, 0.0, 0.037427277287265914, 0.043047123386235064, 0.03674532885325876, 0.08827494228218968, 0.08905928622212445, 0.08119605960522325, 0.02611731718293242, 0.029549736070101584, 0.027358927340663586, 0.0823434716013004, 0.0842003083981342, 0.07357541646471599, 0.0, 0.0, 0.0, 0.012071057877403035, 0.011209262057426783, 0.012113924666298459, 0.007743475964517299, 0.011806827097559536, 0.009852514373101529, 0.13124529622781944, 0.1304161139054778, 0.11333451201659361, 0.0, 0.0, 0.0]}}
{"id": "ea7396e9-6105-44e2-a94f-d63d43cdcc37", "fitness": 0.04049855572094692, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Enhance the convergence by slightly modifying the velocity update to increase social influence over time.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.85 * social_velocity + 0.8 * diversity_control)  # Adjusted coefficient\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:  # Adjusted line for better elite replacement\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Adjusted coefficient\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 97, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04050 with standard deviation 0.04528.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.14085027434508046, 0.0959022734310585, 0.15375513259851503, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02267587068766974, 0.02243607078599441, 0.028121684316798845, 0.03610149306672594, 0.026957062812996035, 0.0315484058289357, 0.07852877393639801, 0.05068927088228592, 0.05347639062044385, 0.06742693462032745, 0.020000000000000018, 0.020000000000000018, 0.07455487931912952, 0.10096364384649259, 0.0867260274263757, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14759310156218386, 0.1059072151659951, 0.1906697600907521, 0.027168951215147952, 0.029899991493412492, 0.020000000000000018, 0.08072694858327945, 0.09280986753127118, 0.09950566968500951, 0.13996232224069505, 0.14815232517790833, 0.13113269281055873, 0.07987917946003886, 0.1083985204635034, 0.07601695511208528, 0.12536984915544536, 0.1207728325978209, 0.14337965078288528, 0.09080993150657468, 0.020000000000000018, 0.10310132208322675, 0.13434318067089634, 0.09902178464989775, 0.0895133107273659, 0.06626078982166161, 0.1305191830210387, 0.0713155069517386, 0.1498652120611571, 0.13589170657517036, 0.16272380256910002, 0.04802075288356722, 0.03587993298717007, 0.044914657290805016, 0.04284480408669267, 0.034047206580618994, 0.06424084043481226, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04442947160112043, 0.017905829007719087, 0.015992736909854033, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011445557920989669, 0.019502188348944238, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08701747572265173, 0.06703316802709491, 0.10144719626718468, 0.010000000000000009, 0.010107170192856674, 0.010000000000000009, 0.062043756205204526, 0.06921906515722431, 0.05883675812044398, 0.12895644729866207, 0.11750120367817762, 0.10695795392536755, 0.06958689564200593, 0.0617873233238071, 0.05825733790277299, 0.1044841106236335, 0.09756780180011859, 0.1029941421222681, 0.08952787000087825, 0.010000000000000009, 0.010000000000000009, 0.03205409851182739, 0.04068283367514203, 0.059252770443943614, 0.041104881214054534, 0.04686358475089225, 0.035626292892754874, 0.1317091442174474, 0.13123409970527322, 0.1441583674945115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010821789135838866, 0.0006577145665357387, 0.014411073496793603, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0006982203899661421, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04526451236687601, 0.04549801126016606, 0.04065004976667841, 0.0, 0.0, 0.0, 0.03598884231905486, 0.039675837294576244, 0.03694877308242528, 0.0884815434796492, 0.08828958924313635, 0.08256030309346385, 0.02432942006382699, 0.03327392825910591, 0.03095907665572195, 0.08126678185382008, 0.07992745935565249, 0.07705636326904952, 0.0, 0.0, 0.0, 0.012667659335409143, 0.011310130203835866, 0.011984552975350393, 0.007640347226799404, 0.011866986569530003, 0.010539029838930847, 0.11823235900840101, 0.1304161139054778, 0.10961008844892017, 0.0, 0.0, 0.0]}}
{"id": "d3f13eec-fb00-43a1-9db6-d825c52cb92b", "fitness": 0.04098258542294318, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Fine-tune the inertia weight adaptation to enhance convergence speed and stability.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_rate = 0.15\n        self.current_evals = 0\n\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            dynamic_inertia_weight = 0.5 + 0.5 * np.cos(np.pi * self.current_evals / self.budget)  # Changed for better convergence\n            adaptive_cooling_rate = self.cooling_rate + 0.02 * np.sin(3 * np.pi * self.current_evals / self.budget)\n            exploration_balance = 0.1 + 0.9 * (self.current_evals / self.budget)\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = exploration_balance * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (dynamic_inertia_weight * self.velocities[i] +\n                                      0.82 * cognitive_velocity + 0.82 * social_velocity + 0.8 * diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget) + 0.1 * np.random.rand()\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1 + 0.1 * (np.sin(np.pi * self.current_evals / self.budget)), self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.current_evals % (self.population_size * 2) == 0:  # Adjusted line for better elite replacement\n                self.elite_positions = self.personal_best_positions[np.random.choice(self.population_size, 3, replace=False)]\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate * (1 + 0.1 * np.cos(np.pi * self.current_evals / self.budget))\n\n            self.cognitive_coeff = 1.5 + 0.1 * np.sin(2 * np.pi * self.current_evals / self.budget)  # Adjusted coefficient\n            self.social_coeff = 1.4 + 0.2 * np.sin(2 * np.pi * self.current_evals / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 98, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04098 with standard deviation 0.04593.", "error": "", "parent_ids": ["0f1c770a-fc75-4e5d-ac66-1548743fc980"], "operator": null, "metadata": {"aucs": [0.1408636649928965, 0.09724367139947376, 0.15456980516054275, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.040832150358342534, 0.020859944718229162, 0.024380047222396728, 0.03546847251629659, 0.02723195250531718, 0.030890215551171996, 0.07816891785760105, 0.05184130294698075, 0.05368101627992827, 0.06658539509911099, 0.020000000000000018, 0.020000000000000018, 0.07949233990719873, 0.11608808321230579, 0.08776985403984383, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13609185325605577, 0.1068335742215788, 0.19305349938622351, 0.024859601266263076, 0.023863685401270485, 0.024695034634987567, 0.08616956128413722, 0.08722378235610517, 0.08362998305570724, 0.1381064323582747, 0.15485426796230517, 0.12786509751778452, 0.08848320164146461, 0.09944471570918434, 0.07372403503283698, 0.14757496459547892, 0.11971705143327382, 0.1371952946911914, 0.10092273604098911, 0.03260507557187664, 0.10406561163493111, 0.13562013377788307, 0.09383042635341043, 0.0895133107273659, 0.06658548578549439, 0.12283296267001931, 0.0774441025098912, 0.1438526290318487, 0.15623619947864287, 0.15475448018179316, 0.043104572818484566, 0.04207517520727688, 0.032802718069788406, 0.043070928159052335, 0.03351224442448608, 0.06713019332769155, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.046857326701880475, 0.018279335374165817, 0.016366437197550043, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010182260394806075, 0.022924929424227303, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08692188203654838, 0.06967403347616907, 0.10295228246978694, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06678353762879852, 0.06113640445910884, 0.131660331204429, 0.11482701036969245, 0.10737801271375913, 0.07891522711197463, 0.06257269054934156, 0.05658069840426139, 0.10314393338880734, 0.09255590218648324, 0.11011565142749735, 0.08913816787418338, 0.010000000000000009, 0.010000000000000009, 0.03008570606438088, 0.03899079199510813, 0.06442107974764344, 0.04204982954368086, 0.05357397863262303, 0.035472677763775495, 0.16235621737698436, 0.1373198195093116, 0.1384489635493591, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010419359290564811, 0.0014161598048199053, 0.013723664967399518, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00048135087425760226, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04701672658369871, 0.04535335802565488, 0.04437769198614716, 0.0, 0.0, 0.0, 0.03476196259755282, 0.04901632687613966, 0.03468271084626495, 0.09062182865724577, 0.08900843241164869, 0.07968903069203459, 0.025500300613372273, 0.030371880180721345, 0.027353858589863167, 0.08203280262894197, 0.07483998313207418, 0.07882462479515484, 0.0, 0.0, 0.0, 0.012639738941778056, 0.011519950398626522, 0.012140027517066554, 0.007959418028756438, 0.012241828642127306, 0.010694919022985139, 0.12382020176076969, 0.1304161139054778, 0.11571767249552811, 0.0, 0.0, 0.0]}}
{"id": "21b11f45-4c64-406e-8020-0e90190b7897", "fitness": 0.03972332707337657, "name": "Enhanced_Hybrid_Adaptive_Optimizer", "description": "Introduce self-adaptive strategy for dynamic parameter tuning to improve convergence and exploration balance.", "code": "import numpy as np\n\nclass Enhanced_Hybrid_Adaptive_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.current_evals = 0\n        \n        # Initialize particles, velocities, and personal bests\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.elite_positions = np.copy(self.particles[:3])\n        \n        # Initial parameters\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6\n        self.social_coeff = 1.5\n        self.mutation_rate = 0.15\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        while self.current_evals < self.budget:\n            # Self-adaptive parameters\n            self.inertia_weight = 0.4 + 0.5 * (1 - self.current_evals / self.budget)\n            self.cognitive_coeff = 1.4 + 0.3 * (np.cos(2 * np.pi * self.current_evals / self.budget))\n            self.social_coeff = 1.7 + 0.3 * (np.sin(2 * np.pi * self.current_evals / self.budget))\n            dynamic_mutation_rate = self.mutation_rate * (1 - self.current_evals / self.budget)\n            adaptive_cooling_rate = self.cooling_rate * (0.9 + 0.1 * np.cos(3 * np.pi * self.current_evals / self.budget))\n            \n            # Update particles\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                self.current_evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i].copy()\n\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_velocity = self.social_coeff * r2 * (self.global_best_position - self.particles[i])\n                diversity_control = 0.1 * r3 * (self.elite_positions[np.random.randint(0, 3)] - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_velocity + social_velocity + diversity_control)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < dynamic_mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    self.particles[i] += mutation_vector\n                    self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            # Update elite positions\n            sorted_indices = np.argsort(self.personal_best_scores)\n            self.elite_positions = self.personal_best_positions[sorted_indices[:3]]\n\n            self.temperature *= adaptive_cooling_rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 99, "feedback": "The algorithm Enhanced_Hybrid_Adaptive_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03972 with standard deviation 0.04496.", "error": "", "parent_ids": ["d3f13eec-fb00-43a1-9db6-d825c52cb92b"], "operator": null, "metadata": {"aucs": [0.13909074275411593, 0.09902705697165448, 0.15651267069022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.035686891962047995, 0.03025185190842339, 0.03127763546549156, 0.025404744897386755, 0.027026943150865734, 0.026975019644537745, 0.07857949050340352, 0.06348594087241655, 0.0543467857990072, 0.023326887816076614, 0.020000000000000018, 0.020000000000000018, 0.0467033809343369, 0.12374604926636434, 0.09042634551441775, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12570722910366894, 0.11040635193205106, 0.1584210876761758, 0.02744569795691265, 0.02071801427368114, 0.0216245337928741, 0.08072694858327945, 0.0863116411064907, 0.11214591036450516, 0.1405876991412398, 0.1433598411779511, 0.12701323081781213, 0.06778413976737785, 0.08982824182404758, 0.07417372443233683, 0.1428474879615388, 0.12423990014692676, 0.1456945213598465, 0.020000000000000018, 0.035738379574233314, 0.09690901175172273, 0.14756024201167117, 0.09163810826673824, 0.10982935117352388, 0.08976255735408667, 0.1347889504106391, 0.08927000461068413, 0.1538494968002152, 0.13794632617218994, 0.15475448018179316, 0.055848711608553314, 0.045298988026324594, 0.029240630581782612, 0.0504043822960043, 0.03548724290698091, 0.06711106951830803, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03653328697936231, 0.01936440073943746, 0.019639561779463133, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016528431161555557, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08991016572681987, 0.07400162028867252, 0.08657189866856696, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06463255186471539, 0.05681360966319815, 0.12484809420693876, 0.10441860811449233, 0.11545840419073994, 0.0637135233349998, 0.04292742980802444, 0.06925301116716254, 0.10036520094796275, 0.08761960225252974, 0.10200378445139568, 0.09146504630316399, 0.010000000000000009, 0.010000000000000009, 0.03498687880332085, 0.04111889080874365, 0.049498007790109155, 0.03421312168930413, 0.039823299198794904, 0.02713001680510474, 0.13444479814810817, 0.13181229512026849, 0.13945754537759059, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010201126438390662, 0.0003623634135955234, 0.003246019745932971, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0017078766683391589, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04469102498164956, 0.04072978462304888, 0.03689343311183246, 0.0, 0.0, 0.0, 0.037068951314999654, 0.04143070371196489, 0.035446561195070725, 0.08588917047368483, 0.09381213386235654, 0.07825670088711645, 0.026161459556803712, 0.031249659606771618, 0.028563605830491667, 0.08688315371737532, 0.07575200549543526, 0.07602096355704957, 0.0, 0.0, 0.0, 0.01102496905756456, 0.011546738628469444, 0.011900946483600183, 0.010134615328267205, 0.011368665247095455, 0.009547707342524747, 0.11782159025282224, 0.1304161139054778, 0.1226149920360976, 0.0, 0.0, 0.0]}}
