{"id": "7f462118-fa22-4132-9736-46f407ecdf5c", "fitness": 0.0210979609786704, "name": "ACPO", "description": "Adaptive Crossover Particle Optimization (ACPO) - combines particle swarm optimization with adaptive crossover from genetic algorithms to explore and exploit the search space efficiently.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 0, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04664781873201562, 0.04664781873201562, 0.04664781873201562, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.043667189400349526, 0.043667189400349526, 0.043667189400349526, 0.08610154941890658, 0.08610154941890658, 0.08610154941890658, 0.028176920004124528, 0.028176920004124528, 0.028176920004124528, 0.0678571842583997, 0.0678571842583997, 0.0678571842583997, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01730384604193136, 0.01730384604193136, 0.01730384604193136, 0.013009992291965755, 0.013009992291965755, 0.013009992291965755, 0.13402134594909254, 0.13402134594909254, 0.13402134594909254, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "44fbf90d-b14b-41a0-b4a0-809bfba97c25", "fitness": 0.021398817650772322, "name": "ACPO", "description": "Adaptive Crossover Particle Optimization with Chaotic Inertia (ACPO-CI) - enhances exploration by introducing a chaotic variation to the inertia weight for dynamic adaptation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations))  # Introduce chaotic variation\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 1, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["7f462118-fa22-4132-9736-46f407ecdf5c"], "operator": null, "metadata": {"aucs": [0.007095317976977378, 0.007095317976977378, 0.007095317976977378, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04936685747208425, 0.04936685747208425, 0.04936685747208425, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044786805598095225, 0.044786805598095225, 0.044786805598095225, 0.08518239096254765, 0.08518239096254765, 0.08518239096254765, 0.031664937468244836, 0.031664937468244836, 0.031664937468244836, 0.07262534926762831, 0.07262534926762831, 0.07262534926762831, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018536392240104393, 0.018536392240104393, 0.018536392240104393, 0.013351465083271008, 0.013351465083271008, 0.013351465083271008, 0.1257447162452352, 0.1257447162452352, 0.1257447162452352, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6acbbdba-193d-4d1d-8bb4-acc41c87dc83", "fitness": 0.021344055298589057, "name": "ACPO", "description": "Improved particle exploration by dynamically adjusting the crossover probability based on inertia weight.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations))  # Introduce chaotic variation\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.4 * self.inertia_weight  # Dynamically adjust crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 2, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["44fbf90d-b14b-41a0-b4a0-809bfba97c25"], "operator": null, "metadata": {"aucs": [0.007095317976977378, 0.007095317976977378, 0.007095317976977378, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.048957839571327155, 0.048957839571327155, 0.048957839571327155, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044786805598095225, 0.044786805598095225, 0.044786805598095225, 0.08518239096254765, 0.08518239096254765, 0.08518239096254765, 0.030804237671892887, 0.030804237671892887, 0.030804237671892887, 0.07262534926762831, 0.07262534926762831, 0.07262534926762831, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018511794474784238, 0.018511794474784238, 0.018511794474784238, 0.01333148409330187, 0.01333148409330187, 0.01333148409330187, 0.1257447162452352, 0.1257447162452352, 0.1257447162452352, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "107002c6-81f3-42b1-96ab-8f0290f7a7d0", "fitness": 0.021592028027139026, "name": "ACPO", "description": "Introduce a damping factor to inertia weight in ACPO to improve convergence stability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 3, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["44fbf90d-b14b-41a0-b4a0-809bfba97c25"], "operator": null, "metadata": {"aucs": [0.004434260378751054, 0.004434260378751054, 0.004434260378751054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.049138541059824625, 0.049138541059824625, 0.049138541059824625, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450125414435294, 0.0450125414435294, 0.0450125414435294, 0.08508404332814767, 0.08508404332814767, 0.08508404332814767, 0.03071287026947589, 0.03071287026947589, 0.03071287026947589, 0.07313684047406643, 0.07313684047406643, 0.07313684047406643, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018433074349177847, 0.018433074349177847, 0.018433074349177847, 0.013350707701351605, 0.013350707701351605, 0.013350707701351605, 0.13368840234266466, 0.13368840234266466, 0.13368840234266466, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9e874d0d-c65f-4448-b326-5d8712685927", "fitness": 0.020792080256906882, "name": "ACPO", "description": "Introduce adaptive inertia weight modulation using a cosine function to enhance convergence in ACPO.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.cos(evaluations)) * 0.95  # Introduce adaptive modulation\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 4, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04664781873201562, 0.04664781873201562, 0.04664781873201562, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046981122817075005, 0.046981122817075005, 0.046981122817075005, 0.08398245014574335, 0.08398245014574335, 0.08398245014574335, 0.026391193594616502, 0.026391193594616502, 0.026391193594616502, 0.0678571842583997, 0.0678571842583997, 0.0678571842583997, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017091164429742456, 0.017091164429742456, 0.017091164429742456, 0.013009992291965755, 0.013009992291965755, 0.013009992291965755, 0.12748378250490278, 0.12748378250490278, 0.12748378250490278, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9c16e2e9-94aa-489d-9c2e-ee01fd0a1322", "fitness": 0.021046383209356322, "name": "ACPO", "description": "Introduce a dynamic cognitive and social coefficient adjustment to enhance exploration and exploitation balance in ACPO.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                # Adjust coefficients\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(evaluations / 100) \n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 5, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.004701355441959154, 0.004701355441959154, 0.004701355441959154, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04838141565084375, 0.04838141565084375, 0.04838141565084375, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360781119769852, 0.04360781119769852, 0.04360781119769852, 0.08508404332814767, 0.08508404332814767, 0.08508404332814767, 0.029106019282709505, 0.029106019282709505, 0.029106019282709505, 0.07184386710009005, 0.07184386710009005, 0.07184386710009005, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018137773226622578, 0.018137773226622578, 0.018137773226622578, 0.013358519320240347, 0.013358519320240347, 0.013358519320240347, 0.12567500117189268, 0.12567500117189268, 0.12567500117189268, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9fc49ce6-1937-46e2-bbe5-bce245db6cf4", "fitness": 0.021180556532464565, "name": "ACPO", "description": "Introduce a dynamic crossover probability to enhance exploration-exploitation balance in ACPO.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.1 + 0.6 * (1 - (evaluations / self.budget))  # Dynamic crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 6, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.0067601060785710265, 0.0067601060785710265, 0.0067601060785710265, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047252252914501525, 0.047252252914501525, 0.047252252914501525, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04366034706005184, 0.04366034706005184, 0.04366034706005184, 0.08508404332814767, 0.08508404332814767, 0.08508404332814767, 0.029348421253913903, 0.029348421253913903, 0.029348421253913903, 0.07235837045964477, 0.07235837045964477, 0.07235837045964477, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017224077158381257, 0.017224077158381257, 0.017224077158381257, 0.014194766212650478, 0.014194766212650478, 0.014194766212650478, 0.12723358100893967, 0.12723358100893967, 0.12723358100893967, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ab083c88-a288-4e60-b445-5ac8ba693f78", "fitness": 0.020413379338856008, "name": "ACPO", "description": "Enhance ACPO's convergence by employing a mutation strategy and adaptive crossover probability to maintain diversity and avoid premature convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Mutation strategy to maintain diversity\n            mutation_probability = 0.1\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_probability:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    population[i] += mutation_vector\n                    population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Adaptive crossover probability based on evaluations\n            self.crossover_probability = 0.5 + 0.5 * (evaluations / self.budget)\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 7, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.00652660667727889, 0.00652660667727889, 0.00652660667727889, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04635849029739736, 0.04635849029739736, 0.04635849029739736, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03912274096257473, 0.03912274096257473, 0.03912274096257473, 0.08214026467502433, 0.08214026467502433, 0.08214026467502433, 0.02643734420365451, 0.02643734420365451, 0.02643734420365451, 0.06714845553255089, 0.06714845553255089, 0.06714845553255089, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01762384081823465, 0.01762384081823465, 0.01762384081823465, 0.013372608059713187, 0.013372608059713187, 0.013372608059713187, 0.1259733616017682, 0.1259733616017682, 0.1259733616017682, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3dbd76ad-c53b-4f23-beea-838b2ed6d747", "fitness": 0.02147699181416835, "name": "ACPO", "description": "Enhance ACPO by introducing a dynamic crossover probability based on evaluations.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.5 + 0.5 * (1 - evaluations / self.budget)  # Dynamic crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 8, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.007654475325487797, 0.007654475325487797, 0.007654475325487797, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04687274989718182, 0.04687274989718182, 0.04687274989718182, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.037614159725207985, 0.037614159725207985, 0.037614159725207985, 0.08649720950086348, 0.08649720950086348, 0.08649720950086348, 0.03301893961394853, 0.03301893961394853, 0.03301893961394853, 0.0712712710425829, 0.0712712710425829, 0.0712712710425829, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018232132403170342, 0.018232132403170342, 0.018232132403170342, 0.013387471708191656, 0.013387471708191656, 0.013387471708191656, 0.13568200301905842, 0.13568200301905842, 0.13568200301905842, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c6f5d79c-0557-4ada-b76d-fe15c21c9e7e", "fitness": 0.021169286431531834, "name": "ACPO", "description": "Utilize a decaying crossover probability to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.7 * (1.0 - evaluations / self.budget)  # Decaying crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 9, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.006380020049999602, 0.006380020049999602, 0.006380020049999602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04695590542511818, 0.04695590542511818, 0.04695590542511818, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360781119769852, 0.04360781119769852, 0.04360781119769852, 0.08527814736499906, 0.08527814736499906, 0.08527814736499906, 0.029513647724134673, 0.029513647724134673, 0.029513647724134673, 0.0727113885460492, 0.0727113885460492, 0.0727113885460492, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016956280123860967, 0.016956280123860967, 0.016956280123860967, 0.014208701611616692, 0.014208701611616692, 0.014208701611616692, 0.12723358100893967, 0.12723358100893967, 0.12723358100893967, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "081c2eb6-b1d4-493f-b98e-993c6a7cc3a2", "fitness": 0.02084222274151697, "name": "ACPO", "description": "Improve ACPO by tweaking the damping factor formula for better exploitation-exploration balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations * 0.1)) * 0.95  # Tweaked damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 10, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04686668031103025, 0.04686668031103025, 0.04686668031103025, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360781119769852, 0.04360781119769852, 0.04360781119769852, 0.08487505104325488, 0.08487505104325488, 0.08487505104325488, 0.0288682807357874, 0.0288682807357874, 0.0288682807357874, 0.07051445758260055, 0.07051445758260055, 0.07051445758260055, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017616473249994602, 0.017616473249994602, 0.017616473249994602, 0.013009992291965755, 0.013009992291965755, 0.013009992291965755, 0.1252893819927714, 0.1252893819927714, 0.1252893819927714, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "980068c6-1e0d-4f5b-978e-ef1157d0e025", "fitness": 0.02076000159577138, "name": "ACPO", "description": "Refine the damping factor formula to stabilize the convergence more effectively.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.cos(evaluations / self.budget * np.pi)) * 0.95  # Adjusted damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 11, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.005030160826382524, 0.005030160826382524, 0.005030160826382524, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04686648729925791, 0.04686648729925791, 0.04686648729925791, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360781119769852, 0.04360781119769852, 0.04360781119769852, 0.08659017686619663, 0.08659017686619663, 0.08659017686619663, 0.027489953349518426, 0.027489953349518426, 0.027489953349518426, 0.0678571842583997, 0.0678571842583997, 0.0678571842583997, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01729799338272775, 0.01729799338272775, 0.01729799338272775, 0.013132089588559603, 0.013132089588559603, 0.013132089588559603, 0.12515079022542464, 0.12515079022542464, 0.12515079022542464, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "aa12e2d9-6b21-4b24-b317-64d0112c667f", "fitness": 0.021193530982702786, "name": "ACPO", "description": "Introduce randomness in crossover mask to enhance exploration in ACPO.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.random.rand()  # Introduce randomness in mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 12, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.014413779560017992, 0.014413779560017992, 0.014413779560017992, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04520514193677605, 0.04520514193677605, 0.04520514193677605, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360781119769852, 0.04360781119769852, 0.04360781119769852, 0.08145388810623877, 0.08145388810623877, 0.08145388810623877, 0.02461158341844427, 0.02461158341844427, 0.02461158341844427, 0.07005364036813588, 0.07005364036813588, 0.07005364036813588, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018209366649530878, 0.018209366649530878, 0.018209366649530878, 0.013778614219300711, 0.013778614219300711, 0.013778614219300711, 0.13209352682437636, 0.13209352682437636, 0.13209352682437636, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "94dea6ed-c3aa-4e0f-9eb1-e7d493bd66fc", "fitness": 0.021153495596527516, "name": "ACPO", "description": "Adjust crossover probability adaptively based on the evaluation count to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            self.crossover_probability = 0.7 - 0.4 * (evaluations / self.budget)  # Adjust crossover probability\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 13, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.005850158838587638, 0.005850158838587638, 0.005850158838587638, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046757708475738124, 0.046757708475738124, 0.046757708475738124, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04636781353392916, 0.04636781353392916, 0.04636781353392916, 0.08508404332814767, 0.08508404332814767, 0.08508404332814767, 0.02938029254297536, 0.02938029254297536, 0.02938029254297536, 0.07029632941631714, 0.07029632941631714, 0.07029632941631714, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019846786164641306, 0.019846786164641306, 0.019846786164641306, 0.013732580486551904, 0.013732580486551904, 0.013732580486551904, 0.12515079022542464, 0.12515079022542464, 0.12515079022542464, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cf5fa4be-8862-40e9-ad9b-dd650413a649", "fitness": 0.02070628224646288, "name": "ACPO", "description": "Refine the damping factor for inertia weight by introducing a phase shift for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations + np.pi/4)) * 0.95  # Introduce phase shift\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 14, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04680038658236796, 0.04680038658236796, 0.04680038658236796, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04366633655066565, 0.04366633655066565, 0.04366633655066565, 0.0842931816577912, 0.0842931816577912, 0.0842931816577912, 0.02808979728640293, 0.02808979728640293, 0.02808979728640293, 0.0678571842583997, 0.0678571842583997, 0.0678571842583997, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017298883962663436, 0.017298883962663436, 0.017298883962663436, 0.013187607198248186, 0.013187607198248186, 0.013187607198248186, 0.1261921790272661, 0.1261921790272661, 0.1261921790272661, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "669a49b1-9591-4b86-836a-4d55e53c4b55", "fitness": 0.021161979041158536, "name": "ACPO", "description": "Introduce dynamic crossover probability based on evaluations to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.5 + 0.5 * np.sin(np.pi * evaluations / self.budget)  # Dynamic crossover\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 15, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.01148466704971074, 0.01148466704971074, 0.01148466704971074, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04464979606525432, 0.04464979606525432, 0.04464979606525432, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360781119769852, 0.04360781119769852, 0.04360781119769852, 0.08128948692098537, 0.08128948692098537, 0.08128948692098537, 0.028398442674931523, 0.028398442674931523, 0.028398442674931523, 0.07066498693983503, 0.07066498693983503, 0.07066498693983503, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01850202473191853, 0.01850202473191853, 0.01850202473191853, 0.01355519507687275, 0.01355519507687275, 0.01355519507687275, 0.13051769502625066, 0.13051769502625066, 0.13051769502625066, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "153e2b16-514e-48fa-9ea5-3d6a923eb0e5", "fitness": 0.021592028027139026, "name": "ACPO", "description": "Adjust ACPO's cognitive coefficient dynamically for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 16, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.004434260378751054, 0.004434260378751054, 0.004434260378751054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.049138541059824625, 0.049138541059824625, 0.049138541059824625, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450125414435294, 0.0450125414435294, 0.0450125414435294, 0.08508404332814767, 0.08508404332814767, 0.08508404332814767, 0.03071287026947589, 0.03071287026947589, 0.03071287026947589, 0.07313684047406643, 0.07313684047406643, 0.07313684047406643, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018433074349177847, 0.018433074349177847, 0.018433074349177847, 0.013350707701351605, 0.013350707701351605, 0.013350707701351605, 0.13368840234266466, 0.13368840234266466, 0.13368840234266466, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "834178ef-67bb-47c3-8c20-25e4aaabb086", "fitness": 0.021160056296007368, "name": "ACPO", "description": "Introduce a sinusoidal damping factor to the cognitive coefficient to enhance adaptability in ACPO.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(evaluations)  # Introduce sinusoidal damping factor\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 17, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.004689923228463955, 0.004689923228463955, 0.004689923228463955, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.048810661783713516, 0.048810661783713516, 0.048810661783713516, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044393496374563024, 0.044393496374563024, 0.044393496374563024, 0.08508404332814767, 0.08508404332814767, 0.08508404332814767, 0.02847110595673119, 0.02847110595673119, 0.02847110595673119, 0.07213128855190709, 0.07213128855190709, 0.07213128855190709, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0185323184433549, 0.0185323184433549, 0.0185323184433549, 0.013245443581780703, 0.013245443581780703, 0.013245443581780703, 0.12726567855116733, 0.12726567855116733, 0.12726567855116733, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4d172c7e-2405-4b27-bd63-832f93608280", "fitness": 0.021169286431531834, "name": "ACPO", "description": "Introduce a decaying crossover probability to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.7 * (1 - evaluations / self.budget)  # Decaying crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 18, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.006380020049999602, 0.006380020049999602, 0.006380020049999602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04695590542511818, 0.04695590542511818, 0.04695590542511818, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360781119769852, 0.04360781119769852, 0.04360781119769852, 0.08527814736499906, 0.08527814736499906, 0.08527814736499906, 0.029513647724134673, 0.029513647724134673, 0.029513647724134673, 0.0727113885460492, 0.0727113885460492, 0.0727113885460492, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016956280123860967, 0.016956280123860967, 0.016956280123860967, 0.014208701611616692, 0.014208701611616692, 0.014208701611616692, 0.12723358100893967, 0.12723358100893967, 0.12723358100893967, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "efeb4479-9506-4f2c-bb11-9b6ecf32ab02", "fitness": 0.020830390247453312, "name": "ACPO", "description": "Enhance diversity by adding Gaussian noise to velocities for improved exploration.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity \n                                 + np.random.normal(0, 0.1, self.dim)) # Add Gaussian noise\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 19, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05068023030347768, 0.05068023030347768, 0.05068023030347768, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04398584993425303, 0.04398584993425303, 0.04398584993425303, 0.07921602751950718, 0.07921602751950718, 0.07921602751950718, 0.025773008070438586, 0.025773008070438586, 0.025773008070438586, 0.0726444230371317, 0.0726444230371317, 0.0726444230371317, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01604218346368458, 0.01604218346368458, 0.01604218346368458, 0.01337049911396715, 0.01337049911396715, 0.01337049911396715, 0.12865192710511564, 0.12865192710511564, 0.12865192710511564, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "127bc445-cebc-44a0-8f62-925e6c07bde6", "fitness": 0.0217624745065776, "name": "ACPO", "description": "Introduce adaptive crossover probability and improve velocity update for better convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * 0.9  # Improved velocity update\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 20, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["107002c6-81f3-42b1-96ab-8f0290f7a7d0"], "operator": null, "metadata": {"aucs": [0.011134642524610827, 0.011134642524610827, 0.011134642524610827, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0511347845604323, 0.0511347845604323, 0.0511347845604323, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04061696470204301, 0.04061696470204301, 0.04061696470204301, 0.08514978062066136, 0.08514978062066136, 0.08514978062066136, 0.02779779884120548, 0.02779779884120548, 0.02779779884120548, 0.07866196938202807, 0.07866196938202807, 0.07866196938202807, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017498680900372654, 0.017498680900372654, 0.017498680900372654, 0.01356777112064489, 0.01356777112064489, 0.01356777112064489, 0.13151960420151632, 0.13151960420151632, 0.13151960420151632, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9803397e-3aab-4d49-986e-214660e2dd26", "fitness": 0.020716567647749113, "name": "ACPO", "description": "Fine-tune the inertia weight to enhance convergence for varied problem landscapes.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                # Adjusted inertia weight calculation for better convergence\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations * np.pi / self.budget)) * 0.95  \n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * 0.9  # Improved velocity update\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 21, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["127bc445-cebc-44a0-8f62-925e6c07bde6"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04916580034556728, 0.04916580034556728, 0.04916580034556728, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04061696470204301, 0.04061696470204301, 0.04061696470204301, 0.08020833661625026, 0.08020833661625026, 0.08020833661625026, 0.025166524088159004, 0.025166524088159004, 0.025166524088159004, 0.07095704727538221, 0.07095704727538221, 0.07095704727538221, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015250561670704488, 0.015250561670704488, 0.015250561670704488, 0.012933093456598321, 0.012933093456598321, 0.012933093456598321, 0.1333340779999702, 0.1333340779999702, 0.1333340779999702, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a096203d-b907-4c08-a0c9-b2def68e5bc0", "fitness": 0.02184336937814686, "name": "ACPO", "description": "Enhance exploration by dynamically adjusting the cognitive coefficient using a sinusoidal function.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * 0.9  # Improved velocity update\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 22, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["127bc445-cebc-44a0-8f62-925e6c07bde6"], "operator": null, "metadata": {"aucs": [0.01127724384085782, 0.01127724384085782, 0.01127724384085782, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05232890769077325, 0.05232890769077325, 0.05232890769077325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04163289046230845, 0.04163289046230845, 0.04163289046230845, 0.08514978062066136, 0.08514978062066136, 0.08514978062066136, 0.027880180855749614, 0.027880180855749614, 0.027880180855749614, 0.07819801093650802, 0.07819801093650802, 0.07819801093650802, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017488643551140215, 0.017488643551140215, 0.017488643551140215, 0.013548211611662087, 0.013548211611662087, 0.013548211611662087, 0.13151960420151632, 0.13151960420151632, 0.13151960420151632, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1f03d51c-0dcf-4e6b-9026-9857c011f1e6", "fitness": 0.021550315120704423, "name": "ACPO", "description": "Further enhance the adaptive crossover by dynamically adjusting the crossover probability using a sinusoidal function.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.95  # Introduce damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * 0.9  # Improved velocity update\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.sin(0.1 * evaluations)  # Dynamic crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 23, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a096203d-b907-4c08-a0c9-b2def68e5bc0"], "operator": null, "metadata": {"aucs": [0.00490038195275555, 0.00490038195275555, 0.00490038195275555, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04984736778158405, 0.04984736778158405, 0.04984736778158405, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04048233880559149, 0.04048233880559149, 0.04048233880559149, 0.08713872736544903, 0.08713872736544903, 0.08713872736544903, 0.030177097419969545, 0.030177097419969545, 0.030177097419969545, 0.07358899600259416, 0.07358899600259416, 0.07358899600259416, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01844135177476558, 0.01844135177476558, 0.01844135177476558, 0.013884789769421757, 0.013884789769421757, 0.013884789769421757, 0.13352912072042755, 0.13352912072042755, 0.13352912072042755, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "fcf0161e-b2c3-4d7d-bbe4-3e5c259d9f97", "fitness": 0.020970367947574776, "name": "ACPO", "description": "Introduce a dynamic inertia weight to enhance convergence speed by adjusting with a cosine function.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + 0.45 * np.cos(0.05 * evaluations)  # Dynamic inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * 0.9  # Improved velocity update\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 24, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a096203d-b907-4c08-a0c9-b2def68e5bc0"], "operator": null, "metadata": {"aucs": [0.004365667069577861, 0.004365667069577861, 0.004365667069577861, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.049599601354863854, 0.049599601354863854, 0.049599601354863854, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04101962603785381, 0.04101962603785381, 0.04101962603785381, 0.08170261068742368, 0.08170261068742368, 0.08170261068742368, 0.027187471816050968, 0.027187471816050968, 0.027187471816050968, 0.07338562218393707, 0.07338562218393707, 0.07338562218393707, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01631821421090096, 0.01631821421090096, 0.01631821421090096, 0.012973021875322677, 0.012973021875322677, 0.012973021875322677, 0.13151960420151632, 0.13151960420151632, 0.13151960420151632, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "de19ce23-fadc-473c-b8b0-85b2ee280773", "fitness": 0.022044975883375013, "name": "ACPO", "description": "Enhance exploration by modifying the dynamic cognitive coefficient using a sinusoidal function and fine-tuning inertia weight.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * 0.9  # Improved velocity update\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 25, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a096203d-b907-4c08-a0c9-b2def68e5bc0"], "operator": null, "metadata": {"aucs": [0.011593677338084807, 0.011593677338084807, 0.011593677338084807, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05246396930367858, 0.05246396930367858, 0.05246396930367858, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04194175340946349, 0.04194175340946349, 0.04194175340946349, 0.08575812922181558, 0.08575812922181558, 0.08575812922181558, 0.03083778079152799, 0.03083778079152799, 0.03083778079152799, 0.0786581879977728, 0.0786581879977728, 0.0786581879977728, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0175196007356776, 0.0175196007356776, 0.0175196007356776, 0.013569326897115652, 0.013569326897115652, 0.013569326897115652, 0.13151960420151632, 0.13151960420151632, 0.13151960420151632, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0638ad12-270f-49cf-87a8-f5300851cb63", "fitness": 0.022112509473737597, "name": "ACPO", "description": "Enhance exploitation by introducing an adaptive learning factor for velocity updates based on iteration count.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 26, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["de19ce23-fadc-473c-b8b0-85b2ee280773"], "operator": null, "metadata": {"aucs": [0.010167266055434943, 0.010167266055434943, 0.010167266055434943, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052755784848100395, 0.052755784848100395, 0.052755784848100395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03991834307878683, 0.03991834307878683, 0.03991834307878683, 0.08655467480765922, 0.08655467480765922, 0.08655467480765922, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08314454391150472, 0.08314454391150472, 0.08314454391150472, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01715409790694533, 0.01715409790694533, 0.01715409790694533, 0.014344874663306806, 0.014344874663306806, 0.014344874663306806, 0.12979158968584936, 0.12979158968584936, 0.12979158968584936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f5fefbb8-d58c-467c-924e-867f2d15ac82", "fitness": 0.022112509473737597, "name": "ACPO", "description": "Introduce a dynamic inertia weight decreasing linearly over evaluations to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 27, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010167266055434943, 0.010167266055434943, 0.010167266055434943, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052755784848100395, 0.052755784848100395, 0.052755784848100395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03991834307878683, 0.03991834307878683, 0.03991834307878683, 0.08655467480765922, 0.08655467480765922, 0.08655467480765922, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08314454391150472, 0.08314454391150472, 0.08314454391150472, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01715409790694533, 0.01715409790694533, 0.01715409790694533, 0.014344874663306806, 0.014344874663306806, 0.014344874663306806, 0.12979158968584936, 0.12979158968584936, 0.12979158968584936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4aacf103-0a51-4516-846e-fecd6edde79b", "fitness": 0.021058012227159417, "name": "ACPO", "description": "Improve exploitation by modifying the adaptive learning factor to use a cosine function for more gradual changes.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.cos(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 28, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.007225225158441151, 0.007225225158441151, 0.007225225158441151, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047699859077665385, 0.047699859077665385, 0.047699859077665385, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04239251096611785, 0.04239251096611785, 0.04239251096611785, 0.08314040431535052, 0.08314040431535052, 0.08314040431535052, 0.02538350292005931, 0.02538350292005931, 0.02538350292005931, 0.076302687845898, 0.076302687845898, 0.076302687845898, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019103503438871128, 0.019103503438871128, 0.019103503438871128, 0.01320591663736781, 0.01320591663736781, 0.01320591663736781, 0.1257212917877074, 0.1257212917877074, 0.1257212917877074, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "48f0b20f-d22d-4fa5-bbf0-557751060181", "fitness": 0.02093656489698185, "name": "ACPO", "description": "Refine velocity updates by introducing an adaptive inertia weight based on the number of evaluations.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.cos(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 29, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04957851933001722, 0.04957851933001722, 0.04957851933001722, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044443751522381225, 0.044443751522381225, 0.044443751522381225, 0.08163400773378449, 0.08163400773378449, 0.08163400773378449, 0.028916510683289598, 0.028916510683289598, 0.028916510683289598, 0.07140216727675686, 0.07140216727675686, 0.07140216727675686, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015870236597029352, 0.015870236597029352, 0.015870236597029352, 0.013132954370731698, 0.013132954370731698, 0.013132954370731698, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9b060654-1855-43c0-b029-805a26f27a7e", "fitness": 0.021910739902981646, "name": "ACPO", "description": "Enhance exploitation by tuning the dynamic cognitive coefficient to improve convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.7 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient adjusted\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 30, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.009841107485391798, 0.009841107485391798, 0.009841107485391798, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05249553553198283, 0.05249553553198283, 0.05249553553198283, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03986025051630915, 0.03986025051630915, 0.03986025051630915, 0.08701994953100944, 0.08701994953100944, 0.08701994953100944, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08067736699165207, 0.08067736699165207, 0.08067736699165207, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016857968152019898, 0.016857968152019898, 0.016857968152019898, 0.014302334428809571, 0.014302334428809571, 0.014302334428809571, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "314ecd59-10fe-4c9b-9f75-2b973c9f3c10", "fitness": 0.02092582850228668, "name": "ACPO", "description": "Introduce a dynamic inertia weight that stabilizes towards the end of the optimization to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Updated dynamic inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 31, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04957851933001722, 0.04957851933001722, 0.04957851933001722, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.038496507388956935, 0.038496507388956935, 0.038496507388956935, 0.08240346198262527, 0.08240346198262527, 0.08240346198262527, 0.030507138018450952, 0.030507138018450952, 0.030507138018450952, 0.07418520161857212, 0.07418520161857212, 0.07418520161857212, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01650636942086292, 0.01650636942086292, 0.01650636942086292, 0.013043276281821004, 0.013043276281821004, 0.013043276281821004, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f0bfb86f-1550-4eaa-b86a-0b25ebb485ce", "fitness": 0.021695719268957376, "name": "ACPO", "description": "Tweak the adaptive learning factor to enhance convergence by adding a cosine component.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations) + 0.05 * np.cos(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 32, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.01053510268269664, 0.01053510268269664, 0.01053510268269664, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052873497240647716, 0.052873497240647716, 0.052873497240647716, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.037920263535968224, 0.037920263535968224, 0.037920263535968224, 0.08459747824766328, 0.08459747824766328, 0.08459747824766328, 0.03248139064673239, 0.03248139064673239, 0.03248139064673239, 0.07905587526878877, 0.07905587526878877, 0.07905587526878877, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01741173753513925, 0.01741173753513925, 0.01741173753513925, 0.014228605181815346, 0.014228605181815346, 0.014228605181815346, 0.126375920811178, 0.126375920811178, 0.126375920811178, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4a1b3f3e-5e6c-407e-b87c-ba7c9282dc75", "fitness": 0.022016469145272322, "name": "ACPO", "description": "Introduce a dynamic social coefficient to enhance the exploration-exploitation balance using a sinusoidal function over the evaluation cycle.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                self.social_coefficient = 1.5 + 0.5 * np.sin(0.1 * evaluations)  # Dynamic social coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 33, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.019110581525600523, 0.019110581525600523, 0.019110581525600523, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057941251750028955, 0.057941251750028955, 0.057941251750028955, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04122947227959417, 0.04122947227959417, 0.04122947227959417, 0.07956220264827374, 0.07956220264827374, 0.07956220264827374, 0.02313262547060868, 0.02313262547060868, 0.02313262547060868, 0.08477096796062777, 0.08477096796062777, 0.08477096796062777, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016587013740888445, 0.016587013740888445, 0.016587013740888445, 0.014258427926187478, 0.014258427926187478, 0.014258427926187478, 0.12658532488037855, 0.12658532488037855, 0.12658532488037855, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9b32b128-0043-4fe5-8a34-379d9226de61", "fitness": 0.022112509473737597, "name": "ACPO", "description": "Introduce a time-varying adaptive learning factor to refine exploration and exploitation balance over iterations.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 34, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010167266055434943, 0.010167266055434943, 0.010167266055434943, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052755784848100395, 0.052755784848100395, 0.052755784848100395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03991834307878683, 0.03991834307878683, 0.03991834307878683, 0.08655467480765922, 0.08655467480765922, 0.08655467480765922, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08314454391150472, 0.08314454391150472, 0.08314454391150472, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01715409790694533, 0.01715409790694533, 0.01715409790694533, 0.014344874663306806, 0.014344874663306806, 0.014344874663306806, 0.12979158968584936, 0.12979158968584936, 0.12979158968584936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "18e3a39d-be64-4c0d-b808-289b126efac0", "fitness": 0.022112509473737597, "name": "ACPO", "description": "Introduce adaptive social and cognitive coefficients based on the evaluation count to enhance convergence speed.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 35, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010167266055434943, 0.010167266055434943, 0.010167266055434943, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052755784848100395, 0.052755784848100395, 0.052755784848100395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03991834307878683, 0.03991834307878683, 0.03991834307878683, 0.08655467480765922, 0.08655467480765922, 0.08655467480765922, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08314454391150472, 0.08314454391150472, 0.08314454391150472, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01715409790694533, 0.01715409790694533, 0.01715409790694533, 0.014344874663306806, 0.014344874663306806, 0.014344874663306806, 0.12979158968584936, 0.12979158968584936, 0.12979158968584936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "554c8b4d-9e05-43ea-9165-fb6a433f099f", "fitness": 0.020803007534984208, "name": "ACPO", "description": "Enhance exploitation by refining the damping factor of the inertia weight for improved convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.cos(evaluations * 0.01)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 36, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004614233459294459, 0.004614233459294459, 0.004614233459294459, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04957851933001722, 0.04957851933001722, 0.04957851933001722, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0379316355142032, 0.0379316355142032, 0.0379316355142032, 0.08356625860396094, 0.08356625860396094, 0.08356625860396094, 0.028679178981878883, 0.028679178981878883, 0.028679178981878883, 0.07150057313650282, 0.07150057313650282, 0.07150057313650282, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016430181909849684, 0.016430181909849684, 0.016430181909849684, 0.013069297841669436, 0.013069297841669436, 0.013069297841669436, 0.1286849107578969, 0.1286849107578969, 0.1286849107578969, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4c7616a5-9bd0-4e48-861f-985cd8d54dfa", "fitness": 0.021919690358152284, "name": "ACPO", "description": "Introduce exponential decay in the cognitive coefficient for improved convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 * np.exp(-0.0005 * evaluations)  # Exponential decay\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 37, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010178144061609884, 0.010178144061609884, 0.010178144061609884, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05239241246403259, 0.05239241246403259, 0.05239241246403259, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.040170961633914315, 0.040170961633914315, 0.040170961633914315, 0.08633682172748691, 0.08633682172748691, 0.08633682172748691, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08048645050034009, 0.08048645050034009, 0.08048645050034009, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017385578097000254, 0.017385578097000254, 0.017385578097000254, 0.014318955076885964, 0.014318955076885964, 0.014318955076885964, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ef217a42-7b0d-4195-8f8e-589915900e7a", "fitness": 0.021256956003588262, "name": "ACPO", "description": "Enhance the algorithm's exploration by introducing a randomized inertia weight oscillation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations + np.random.rand())) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 38, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004880401242839838, 0.004880401242839838, 0.004880401242839838, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04620229121185793, 0.04620229121185793, 0.04620229121185793, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.036929422866453065, 0.036929422866453065, 0.036929422866453065, 0.08539418232883456, 0.08539418232883456, 0.08539418232883456, 0.033831693126399665, 0.033831693126399665, 0.033831693126399665, 0.08148827841433093, 0.08148827841433093, 0.08148827841433093, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019707185415680617, 0.019707185415680617, 0.019707185415680617, 0.013314950749733434, 0.013314950749733434, 0.013314950749733434, 0.12320114742564081, 0.12320114742564081, 0.12320114742564081, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9da9c7ab-26ba-4a4d-a7ca-95ec1973ae5b", "fitness": 0.022112509473737597, "name": "ACPO", "description": "Implement dynamic inertia weight adjustment to further enhance exploitation and exploration balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 39, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010167266055434943, 0.010167266055434943, 0.010167266055434943, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052755784848100395, 0.052755784848100395, 0.052755784848100395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03991834307878683, 0.03991834307878683, 0.03991834307878683, 0.08655467480765922, 0.08655467480765922, 0.08655467480765922, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08314454391150472, 0.08314454391150472, 0.08314454391150472, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01715409790694533, 0.01715409790694533, 0.01715409790694533, 0.014344874663306806, 0.014344874663306806, 0.014344874663306806, 0.12979158968584936, 0.12979158968584936, 0.12979158968584936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2786e045-52f5-48a6-ab3a-62d07ee2f59a", "fitness": 0.02158294725975641, "name": "ACPO", "description": "Introduce a dynamic adjustment to the social coefficient based on the evaluation count to enhance convergence speed.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                self.social_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic social coefficient\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 40, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.008500372690831481, 0.008500372690831481, 0.008500372690831481, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052529892582572124, 0.052529892582572124, 0.052529892582572124, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0375157363192149, 0.0375157363192149, 0.0375157363192149, 0.0862680329822475, 0.0862680329822475, 0.0862680329822475, 0.029221570490836513, 0.029221570490836513, 0.029221570490836513, 0.08097349044977153, 0.08097349044977153, 0.08097349044977153, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017939398829506237, 0.017939398829506237, 0.017939398829506237, 0.013554640989481781, 0.013554640989481781, 0.013554640989481781, 0.12627020759534424, 0.12627020759534424, 0.12627020759534424, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a7b003b6-f5ce-4bb6-ba42-afd07850b1e2", "fitness": 0.020925828502286414, "name": "ACPO", "description": "Introduce a dynamic inertia weight formula to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.9 - 0.4 * (evaluations / self.budget)  # Dynamic inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 41, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04957851933001722, 0.04957851933001722, 0.04957851933001722, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.038496507388950496, 0.038496507388950496, 0.038496507388950496, 0.08240346198262527, 0.08240346198262527, 0.08240346198262527, 0.030507138018450952, 0.030507138018450952, 0.030507138018450952, 0.07418520161857212, 0.07418520161857212, 0.07418520161857212, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01650636942086292, 0.01650636942086292, 0.01650636942086292, 0.013043276281821004, 0.013043276281821004, 0.013043276281821004, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1f71593e-c9f7-4fe7-91b8-6e8ba9d85a90", "fitness": 0.022112509473737597, "name": "ACPO", "description": "Introduce a dynamic component to the social coefficient to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 42, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010167266055434943, 0.010167266055434943, 0.010167266055434943, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052755784848100395, 0.052755784848100395, 0.052755784848100395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03991834307878683, 0.03991834307878683, 0.03991834307878683, 0.08655467480765922, 0.08655467480765922, 0.08655467480765922, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08314454391150472, 0.08314454391150472, 0.08314454391150472, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01715409790694533, 0.01715409790694533, 0.01715409790694533, 0.014344874663306806, 0.014344874663306806, 0.014344874663306806, 0.12979158968584936, 0.12979158968584936, 0.12979158968584936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4c655b8e-8336-407c-a4ec-3d8ac2ab1f97", "fitness": 0.02180190333783537, "name": "ACPO", "description": "Enhance exploration by dynamically adjusting cognitive and social coefficients based on a decaying sinusoidal function.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations * (1 - evaluations/self.budget))  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 43, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010303966746970317, 0.010303966746970317, 0.010303966746970317, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052304119344774525, 0.052304119344774525, 0.052304119344774525, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03986025051630915, 0.03986025051630915, 0.03986025051630915, 0.08399942075239741, 0.08399942075239741, 0.08399942075239741, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08050618336451221, 0.08050618336451221, 0.08050618336451221, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017215286305413136, 0.017215286305413136, 0.017215286305413136, 0.014253208043287335, 0.014253208043287335, 0.014253208043287335, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9d64f91e-6fff-43e9-b06b-10db4ac66884", "fitness": 0.02128837862735104, "name": "ACPO", "description": "Introduce a dynamic mutation factor to enhance exploration capabilities and improve convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                mutation_factor = 0.1 + 0.1 * np.sin(0.2 * evaluations)  # Introduce dynamic mutation factor\n                population[i] += velocities[i] + mutation_factor * np.random.randn(self.dim)\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 44, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.006526600018174622, 0.006526600018174622, 0.006526600018174622, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05261953686163057, 0.05261953686163057, 0.05261953686163057, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03954967153729294, 0.03954967153729294, 0.03954967153729294, 0.08206476431287268, 0.08206476431287268, 0.08206476431287268, 0.02464116668304972, 0.02464116668304972, 0.02464116668304972, 0.08453952461352598, 0.08453952461352598, 0.08453952461352598, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0164071253447039, 0.0164071253447039, 0.0164071253447039, 0.014092803448106594, 0.014092803448106594, 0.014092803448106594, 0.12526250293272045, 0.12526250293272045, 0.12526250293272045, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1aa4d893-456b-43df-9eba-9d00febfe81e", "fitness": 0.020925828502286414, "name": "ACPO", "description": "Use a dynamic inertia weight that decreases over time for better convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.9 - (0.4 * (evaluations / self.budget))  # Decreasing inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 45, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04957851933001722, 0.04957851933001722, 0.04957851933001722, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.038496507388950496, 0.038496507388950496, 0.038496507388950496, 0.08240346198262527, 0.08240346198262527, 0.08240346198262527, 0.030507138018450952, 0.030507138018450952, 0.030507138018450952, 0.07418520161857212, 0.07418520161857212, 0.07418520161857212, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01650636942086292, 0.01650636942086292, 0.01650636942086292, 0.013043276281821004, 0.013043276281821004, 0.013043276281821004, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c05c9fa8-84b3-4bf4-aeec-fc76070fec54", "fitness": 0.02093656489698185, "name": "ACPO", "description": "Adjust inertia weight dynamically to improve exploitation and exploration balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.cos(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 46, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04957851933001722, 0.04957851933001722, 0.04957851933001722, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044443751522381225, 0.044443751522381225, 0.044443751522381225, 0.08163400773378449, 0.08163400773378449, 0.08163400773378449, 0.028916510683289598, 0.028916510683289598, 0.028916510683289598, 0.07140216727675686, 0.07140216727675686, 0.07140216727675686, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015870236597029352, 0.015870236597029352, 0.015870236597029352, 0.013132954370731698, 0.013132954370731698, 0.013132954370731698, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "80953361-bc42-4592-adeb-5bea14a0fd40", "fitness": 0.022112509473737597, "name": "ACPO", "description": "Introduce a dynamic personal best weight oscillator to improve convergence speed.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 47, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010167266055434943, 0.010167266055434943, 0.010167266055434943, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052755784848100395, 0.052755784848100395, 0.052755784848100395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03991834307878683, 0.03991834307878683, 0.03991834307878683, 0.08655467480765922, 0.08655467480765922, 0.08655467480765922, 0.03165166110776729, 0.03165166110776729, 0.03165166110776729, 0.08314454391150472, 0.08314454391150472, 0.08314454391150472, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01715409790694533, 0.01715409790694533, 0.01715409790694533, 0.014344874663306806, 0.014344874663306806, 0.014344874663306806, 0.12979158968584936, 0.12979158968584936, 0.12979158968584936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "30d7b3f3-28cc-4882-8d9b-d09f29597eb6", "fitness": 0.02093656489698185, "name": "ACPO", "description": "Introduce an adaptive inertia weight with a sinusoidal damping factor to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.cos(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 48, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04957851933001722, 0.04957851933001722, 0.04957851933001722, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044443751522381225, 0.044443751522381225, 0.044443751522381225, 0.08163400773378449, 0.08163400773378449, 0.08163400773378449, 0.028916510683289598, 0.028916510683289598, 0.028916510683289598, 0.07140216727675686, 0.07140216727675686, 0.07140216727675686, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015870236597029352, 0.015870236597029352, 0.015870236597029352, 0.013132954370731698, 0.013132954370731698, 0.013132954370731698, 0.12793419262227002, 0.12793419262227002, 0.12793419262227002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "01c16819-792b-48f1-b27a-4fae8ec20e9b", "fitness": 0.01850337317770286, "name": "ACPO", "description": "Enhance exploration by modifying the social velocity calculation in PSO based on a logarithmic decay function.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * np.log(1 + evaluations) * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 49, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.008030236400355717, 0.008030236400355717, 0.008030236400355717, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0348334377919699, 0.0348334377919699, 0.0348334377919699, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04162890273567044, 0.04162890273567044, 0.04162890273567044, 0.07292966596187755, 0.07292966596187755, 0.07292966596187755, 0.015564247030301792, 0.015564247030301792, 0.015564247030301792, 0.05654576016435653, 0.05654576016435653, 0.05654576016435653, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.013577074024737623, 0.013577074024737623, 0.013577074024737623, 0.011245948053187682, 0.011245948053187682, 0.011245948053187682, 0.12450829279806397, 0.12450829279806397, 0.12450829279806397, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9543ed7e-2d72-470f-8b19-57cefd2ef25b", "fitness": 0.022055277134844814, "name": "ACPO", "description": "Introduce a small change in the adaptive learning factor to subtly enhance exploration without disrupting existing dynamics.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.35 * np.sin(0.1 * evaluations)  # Slightly increased adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 50, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.010955886641975776, 0.010955886641975776, 0.010955886641975776, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057452756570886665, 0.057452756570886665, 0.057452756570886665, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03859779000697128, 0.03859779000697128, 0.03859779000697128, 0.08648629560240173, 0.08648629560240173, 0.08648629560240173, 0.03144482882236865, 0.03144482882236865, 0.03144482882236865, 0.07817512446230168, 0.07817512446230168, 0.07817512446230168, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017238554340585188, 0.017238554340585188, 0.017238554340585188, 0.014274886243041962, 0.014274886243041962, 0.014274886243041962, 0.12948313724139515, 0.12948313724139515, 0.12948313724139515, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2b9d8269-971d-4301-a6b5-2fcaa62d6f2c", "fitness": 0.021818022907200852, "name": "ACPO", "description": "Introducing frequency-modulated crossover probability for better exploration via adaptive learning.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(0.1 * evaluations)  # Frequency-modulated crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 51, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.00937936637137693, 0.00937936637137693, 0.00937936637137693, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05337625288955583, 0.05337625288955583, 0.05337625288955583, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04410772186333589, 0.04410772186333589, 0.04410772186333589, 0.08434483299626616, 0.08434483299626616, 0.08434483299626616, 0.02738913497441897, 0.02738913497441897, 0.02738913497441897, 0.07768723820321721, 0.07768723820321721, 0.07768723820321721, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01970229795124534, 0.01970229795124534, 0.01970229795124534, 0.013916429994869084, 0.013916429994869084, 0.013916429994869084, 0.1285118832241876, 0.1285118832241876, 0.1285118832241876, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3f2817bc-847a-43fd-b779-8a9d13988a1d", "fitness": 0.02104167640090049, "name": "ACPO", "description": "Integrate a non-linear time-varying inertia weight and mutation strategy for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.9  # Modified initial inertia weight\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.9 - (0.5 * evaluations / self.budget)  # Non-linear time-varying inertia weight\n                adaptive_learning_factor = 1.0 + 0.3 * np.sin(0.1 * evaluations)\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover and mutation\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.6 + 0.2 * np.cos(evaluations)\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n                \n                # Mutation strategy\n                mutation_scale = 0.1 * (1 - evaluations / self.budget)  # Decreases over time\n                if np.random.rand() < 0.1:\n                    mutation_vector = np.random.normal(0, mutation_scale, self.dim)\n                    population[i] += mutation_vector\n                    population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 52, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054700161666131564, 0.054700161666131564, 0.054700161666131564, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.040379553963383774, 0.040379553963383774, 0.040379553963383774, 0.08459560643785036, 0.08459560643785036, 0.08459560643785036, 0.026022806868445048, 0.026022806868445048, 0.026022806868445048, 0.07356128851198218, 0.07356128851198218, 0.07356128851198218, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017846233035202608, 0.017846233035202608, 0.017846233035202608, 0.014093121037137002, 0.014093121037137002, 0.014093121037137002, 0.12423624471017525, 0.12423624471017525, 0.12423624471017525, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3264065b-5d0a-40e7-bfb7-883fd552dc5f", "fitness": 0.02252061304767181, "name": "ACPO", "description": "Refine adaptive learning and crossover strategies for enhanced convergence efficiency.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, parent2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 53, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0638ad12-270f-49cf-87a8-f5300851cb63"], "operator": null, "metadata": {"aucs": [0.011836509219523395, 0.011836509219523395, 0.011836509219523395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05898348149606025, 0.05898348149606025, 0.05898348149606025, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.055238302511275705, 0.055238302511275705, 0.055238302511275705, 0.08696112751061003, 0.08696112751061003, 0.08696112751061003, 0.023589667328681507, 0.023589667328681507, 0.023589667328681507, 0.08094864761474829, 0.08094864761474829, 0.08094864761474829, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017202687729592214, 0.017202687729592214, 0.017202687729592214, 0.01457077666791129, 0.01457077666791129, 0.01457077666791129, 0.12594612176137332, 0.12594612176137332, 0.12594612176137332, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6d08e6e2-8b8a-48a6-81cc-7f692941422c", "fitness": 0.022698735621226013, "name": "ACPO", "description": "Enhance velocity update and crossover strategies for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 54, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["3264065b-5d0a-40e7-bfb7-883fd552dc5f"], "operator": null, "metadata": {"aucs": [0.012618351795094518, 0.012618351795094518, 0.012618351795094518, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.059397047065309794, 0.059397047065309794, 0.059397047065309794, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.055238302511275705, 0.055238302511275705, 0.055238302511275705, 0.0831741196198641, 0.0831741196198641, 0.0831741196198641, 0.02474156176342479, 0.02474156176342479, 0.02474156176342479, 0.08894129441551968, 0.08894129441551968, 0.08894129441551968, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018349333676154322, 0.018349333676154322, 0.018349333676154322, 0.013932921151789346, 0.013932921151789346, 0.013932921151789346, 0.1231593316066446, 0.1231593316066446, 0.1231593316066446, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6312623d-15c9-4457-9884-2dd49f7ef6a8", "fitness": 0.021232642950580066, "name": "ACPO", "description": "Improve adaptive learning factor and crossover probability for better convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.1 + 0.3 * np.sin(0.12 * evaluations)  # Adjusted adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.68 + 0.12 * np.cos(evaluations)  # Adjusted crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 55, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["6d08e6e2-8b8a-48a6-81cc-7f692941422c"], "operator": null, "metadata": {"aucs": [0.007306751671410705, 0.007306751671410705, 0.007306751671410705, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.048272734916426585, 0.048272734916426585, 0.048272734916426585, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04369589107524596, 0.04369589107524596, 0.04369589107524596, 0.08429891932126687, 0.08429891932126687, 0.08429891932126687, 0.026125364548423735, 0.026125364548423735, 0.026125364548423735, 0.07939524568746348, 0.07939524568746348, 0.07939524568746348, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018326224088496712, 0.018326224088496712, 0.018326224088496712, 0.01318133714083125, 0.01318133714083125, 0.01318133714083125, 0.12376357106000879, 0.12376357106000879, 0.12376357106000879, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "36c5d332-9c16-4ec2-b157-21ddea46d4ec", "fitness": 0.022075359833471826, "name": "ACPO", "description": "Introduce dynamic inertia weight adjustment based on cosine decay to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + 0.5 * np.cos(np.pi * evaluations / self.budget)  # Cosine decay for inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 56, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["6d08e6e2-8b8a-48a6-81cc-7f692941422c"], "operator": null, "metadata": {"aucs": [0.006270703301604397, 0.006270703301604397, 0.006270703301604397, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054469794569109165, 0.054469794569109165, 0.054469794569109165, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.055238302511275705, 0.055238302511275705, 0.055238302511275705, 0.0855214631851301, 0.0855214631851301, 0.0855214631851301, 0.025491867312497196, 0.025491867312497196, 0.025491867312497196, 0.08338366278794873, 0.08338366278794873, 0.08338366278794873, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017547123421846056, 0.017547123421846056, 0.017547123421846056, 0.01373120779690118, 0.01373120779690118, 0.01373120779690118, 0.12293711981266386, 0.12293711981266386, 0.12293711981266386, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "72de7ba8-a1f4-4a15-b0f8-4d0b52006f60", "fitness": 0.02157816149884529, "name": "ACPO", "description": "Utilize dynamic inertia and cognitive coefficients for enhanced adaptive learning.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations / 30.0)) * 0.98  # Modified damping factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity)\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 57, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["6d08e6e2-8b8a-48a6-81cc-7f692941422c"], "operator": null, "metadata": {"aucs": [0.009012548762478811, 0.009012548762478811, 0.009012548762478811, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04958184159472023, 0.04958184159472023, 0.04958184159472023, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0442507522114477, 0.0442507522114477, 0.0442507522114477, 0.08447739587287473, 0.08447739587287473, 0.08447739587287473, 0.02375586905428373, 0.02375586905428373, 0.02375586905428373, 0.07939955694191614, 0.07939955694191614, 0.07939955694191614, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017176225216087193, 0.017176225216087193, 0.017176225216087193, 0.013269777112869363, 0.013269777112869363, 0.013269777112869363, 0.13173451790126156, 0.13173451790126156, 0.13173451790126156, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "32c7f838-71ad-40d8-b31d-23c9c28f92b6", "fitness": 0.022200305510418905, "name": "ACPO", "description": "Implement a non-linear inertia weight adjustment and introduce elite selection to enhance convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.9 - (0.9 * np.exp(-0.01 * evaluations))  # Non-linear inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n            \n            # Elite selection (added line)\n            elite_idx = np.argmin(personal_best_scores)\n            population[0] = personal_best_positions[elite_idx]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 58, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["6d08e6e2-8b8a-48a6-81cc-7f692941422c"], "operator": null, "metadata": {"aucs": [0.0054950201829016, 0.0054950201829016, 0.0054950201829016, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05496784176162983, 0.05496784176162983, 0.05496784176162983, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056099668156347704, 0.056099668156347704, 0.056099668156347704, 0.08528726603112158, 0.08528726603112158, 0.08528726603112158, 0.022807857022637323, 0.022807857022637323, 0.022807857022637323, 0.08365004006898724, 0.08365004006898724, 0.08365004006898724, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01756588713299867, 0.01756588713299867, 0.01756588713299867, 0.013254030992892685, 0.013254030992892685, 0.013254030992892685, 0.12846232959618964, 0.12846232959618964, 0.12846232959618964, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3e216a19-ab52-4043-b816-c53121cf4699", "fitness": 0.021942233462428143, "name": "ACPO", "description": "Slightly adjust inertia weight's dynamic factor for improved convergence stability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations * 0.95)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < 0.5\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 59, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["6d08e6e2-8b8a-48a6-81cc-7f692941422c"], "operator": null, "metadata": {"aucs": [0.004496817768180561, 0.004496817768180561, 0.004496817768180561, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.053265511329852466, 0.053265511329852466, 0.053265511329852466, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.055238302511275705, 0.055238302511275705, 0.055238302511275705, 0.08262113665458082, 0.08262113665458082, 0.08262113665458082, 0.024851105184853117, 0.024851105184853117, 0.024851105184853117, 0.08304177658787482, 0.08304177658787482, 0.08304177658787482, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017528723141991942, 0.017528723141991942, 0.017528723141991942, 0.013558488464843532, 0.013558488464843532, 0.013558488464843532, 0.12679435015047502, 0.12679435015047502, 0.12679435015047502, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "546ad7d8-e414-4c9d-b972-a904e2e26f2f", "fitness": 0.022765913121248316, "name": "ACPO", "description": "Introduce a non-linear damping factor and a dynamic crossover mask to improve convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 60, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["6d08e6e2-8b8a-48a6-81cc-7f692941422c"], "operator": null, "metadata": {"aucs": [0.010355643679844984, 0.010355643679844984, 0.010355643679844984, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05787561983399614, 0.05787561983399614, 0.05787561983399614, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054632431486027366, 0.054632431486027366, 0.054632431486027366, 0.08402327975966994, 0.08402327975966994, 0.08402327975966994, 0.028082843919482015, 0.028082843919482015, 0.028082843919482015, 0.08904774793816939, 0.08904774793816939, 0.08904774793816939, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018861340697986395, 0.018861340697986395, 0.018861340697986395, 0.014175530183996088, 0.014175530183996088, 0.014175530183996088, 0.12411008610643981, 0.12411008610643981, 0.12411008610643981, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cc67a00e-3d71-46a1-8410-063a832f23e9", "fitness": 0.021898246624313326, "name": "ACPO", "description": "Introduce adaptive harmonic oscillation in inertia weight and crossover probability for improved convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + 0.5 * np.sin(0.1 * evaluations)  # 1st change for improved adaptive harmonic oscillation\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(0.1 * evaluations)  # 2nd change for harmonic oscillation\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 61, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["546ad7d8-e414-4c9d-b972-a904e2e26f2f"], "operator": null, "metadata": {"aucs": [0.008094836286616225, 0.008094836286616225, 0.008094836286616225, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0043570971132456116, 0.0043570971132456116, 0.0043570971132456116, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05811848556780164, 0.05811848556780164, 0.05811848556780164, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04142814318442445, 0.04142814318442445, 0.04142814318442445, 0.08232334707182198, 0.08232334707182198, 0.08232334707182198, 0.025961870927245223, 0.025961870927245223, 0.025961870927245223, 0.08607390067035592, 0.08607390067035592, 0.08607390067035592, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019545931740697964, 0.019545931740697964, 0.019545931740697964, 0.013683335861121249, 0.013683335861121249, 0.013683335861121249, 0.12510140534279868, 0.12510140534279868, 0.12510140534279868, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "de797e07-4bf2-4886-80a5-a81bece8231d", "fitness": 0.02267486379033103, "name": "ACPO", "description": "Introduce a non-linear damping factor and a dynamic crossover mask to improve convergence with increased population diversity control.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < (0.5 + 0.5 * np.sin(0.05 * evaluations))  # Modified dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 62, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["546ad7d8-e414-4c9d-b972-a904e2e26f2f"], "operator": null, "metadata": {"aucs": [0.01065529853918934, 0.01065529853918934, 0.01065529853918934, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05835482519862867, 0.05835482519862867, 0.05835482519862867, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054632431486027366, 0.054632431486027366, 0.054632431486027366, 0.08376936661530543, 0.08376936661530543, 0.08376936661530543, 0.031152164636478852, 0.031152164636478852, 0.031152164636478852, 0.08420627720037088, 0.08420627720037088, 0.08420627720037088, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019094522453608542, 0.019094522453608542, 0.019094522453608542, 0.014177333721324348, 0.014177333721324348, 0.014177333721324348, 0.12293711981266386, 0.12293711981266386, 0.12293711981266386, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2efec674-b75e-4eca-b013-7bdcada6822f", "fitness": 0.02030723270161941, "name": "ACPO", "description": "Refine inertia weight and learning factor dynamics for enhanced adaptability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.cos(evaluations * 0.01)) * 0.98  # Refined damping factor\n                adaptive_learning_factor = 1.0 + 0.5 * np.sin(0.05 * evaluations)  # Altered adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 63, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["546ad7d8-e414-4c9d-b972-a904e2e26f2f"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03958685440000831, 0.03958685440000831, 0.03958685440000831, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04192910146627704, 0.04192910146627704, 0.04192910146627704, 0.07703040523129168, 0.07703040523129168, 0.07703040523129168, 0.02548375895684596, 0.02548375895684596, 0.02548375895684596, 0.07481471105023008, 0.07481471105023008, 0.07481471105023008, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015863295948761125, 0.015863295948761125, 0.015863295948761125, 0.012563714630132283, 0.012563714630132283, 0.012563714630132283, 0.13053652576401542, 0.13053652576401542, 0.13053652576401542, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2740fcd9-f1b4-4dfa-a241-153140135dbc", "fitness": -Infinity, "name": "ACPO", "description": "Enhance exploration by dynamically adjusting population size based on evaluations.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            self.population_size = int(50 + 30 * np.sin(0.05 * evaluations))  # Dynamic population size\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 64, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_ids": ["546ad7d8-e414-4c9d-b972-a904e2e26f2f"], "operator": null, "metadata": {}}
{"id": "9eef223a-1165-48e9-be49-18ad489bda8f", "fitness": 0.02262162571730758, "name": "ACPO", "description": "Introduce a non-linear damping factor, dynamic crossover mask, and adaptive mutation strategy to improve convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations)  # Dynamic cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    # Introduce adaptive mutation\n                    mutation_probability = 0.01 + 0.01 * np.sin(0.1 * evaluations) # Adaptive mutation strategy\n                    offspring2 += mutation_probability * np.random.randn(self.dim)  # Apply mutation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 65, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["546ad7d8-e414-4c9d-b972-a904e2e26f2f"], "operator": null, "metadata": {"aucs": [0.007837038161480625, 0.007837038161480625, 0.007837038161480625, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052207319888064596, 0.052207319888064596, 0.052207319888064596, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05440990707470361, 0.05440990707470361, 0.05440990707470361, 0.0878636094596198, 0.0878636094596198, 0.0878636094596198, 0.026747228821180302, 0.026747228821180302, 0.026747228821180302, 0.0883240196738474, 0.0883240196738474, 0.0883240196738474, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019537466697055694, 0.019537466697055694, 0.019537466697055694, 0.014127792895012536, 0.014127792895012536, 0.014127792895012536, 0.12664724324006993, 0.12664724324006993, 0.12664724324006993, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "71082aef-2ad8-4173-9835-77205f672cfb", "fitness": 0.022114464359088162, "name": "ACPO", "description": "Refine the adaptive components for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.99  # Modified damping factor\n                self.cognitive_coefficient = 1.6 + 0.4 * np.sin(0.1 * evaluations)  # Refined cognitive coefficient\n                adaptive_learning_factor = 1.05 + 0.35 * np.sin(0.1 * evaluations)  # Refined adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.7 + 0.1 * np.cos(evaluations)  # Refined crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 66, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["546ad7d8-e414-4c9d-b972-a904e2e26f2f"], "operator": null, "metadata": {"aucs": [0.010191938379453092, 0.010191938379453092, 0.010191938379453092, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05337212418283066, 0.05337212418283066, 0.05337212418283066, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045887871502372835, 0.045887871502372835, 0.045887871502372835, 0.08551268146889901, 0.08551268146889901, 0.08551268146889901, 0.029322933460652068, 0.029322933460652068, 0.029322933460652068, 0.08549626208089878, 0.08549626208089878, 0.08549626208089878, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018749863885233475, 0.018749863885233475, 0.018749863885233475, 0.014058958540764666, 0.014058958540764666, 0.014058958540764666, 0.12293711981266386, 0.12293711981266386, 0.12293711981266386, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "5390943b-6433-400e-88d4-4fed5d7f3583", "fitness": 0.02277163309025175, "name": "ACPO", "description": "Enhance cognitive and social attraction with a learning factor to improve convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 67, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["546ad7d8-e414-4c9d-b972-a904e2e26f2f"], "operator": null, "metadata": {"aucs": [0.010355643679844984, 0.010355643679844984, 0.010355643679844984, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057916629536496456, 0.057916629536496456, 0.057916629536496456, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054632431486027366, 0.054632431486027366, 0.054632431486027366, 0.08435585969019588, 0.08435585969019588, 0.08435585969019588, 0.02819652239604087, 0.02819652239604087, 0.02819652239604087, 0.08904774793816939, 0.08904774793816939, 0.08904774793816939, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018861340697986395, 0.018861340697986395, 0.018861340697986395, 0.014175530183996088, 0.014175530183996088, 0.014175530183996088, 0.12376009725293713, 0.12376009725293713, 0.12376009725293713, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "853a1d93-b088-4fa3-8c5a-ca42c976e493", "fitness": 0.02202523094321616, "name": "ACPO", "description": "Introduced a dynamic inertia weight to enhance exploration and exploitation balance.  ", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations / self.budget * np.pi))  # Dynamic inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 68, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["5390943b-6433-400e-88d4-4fed5d7f3583"], "operator": null, "metadata": {"aucs": [0.004393508500281085, 0.004393508500281085, 0.004393508500281085, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004459978697933242, 0.004459978697933242, 0.004459978697933242, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05214652360981331, 0.05214652360981331, 0.05214652360981331, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05506036800549141, 0.05506036800549141, 0.05506036800549141, 0.08246749612332238, 0.08246749612332238, 0.08246749612332238, 0.02237150453631409, 0.02237150453631409, 0.02237150453631409, 0.08904774793816939, 0.08904774793816939, 0.08904774793816939, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01741296602131459, 0.01741296602131459, 0.01741296602131459, 0.013420748786005188, 0.013420748786005188, 0.013420748786005188, 0.1269551352011522, 0.1269551352011522, 0.1269551352011522, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cf3d2069-c100-405d-be0c-f4bab59a5f6d", "fitness": 0.021848432652004725, "name": "ACPO", "description": "Introduce a dynamic adjustment in the inertia weight and adapt the crossover mask for improved convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations / 50)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.1 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 69, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["5390943b-6433-400e-88d4-4fed5d7f3583"], "operator": null, "metadata": {"aucs": [0.009377166408562787, 0.009377166408562787, 0.009377166408562787, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04905572469144859, 0.04905572469144859, 0.04905572469144859, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054632431486027366, 0.054632431486027366, 0.054632431486027366, 0.08345429360272005, 0.08345429360272005, 0.08345429360272005, 0.025708430668876514, 0.025708430668876514, 0.025708430668876514, 0.07796971745683368, 0.07796971745683368, 0.07796971745683368, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017601281245745004, 0.017601281245745004, 0.017601281245745004, 0.013318914121180359, 0.013318914121180359, 0.013318914121180359, 0.1280270326623716, 0.1280270326623716, 0.1280270326623716, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e991cf5a-f2f7-469e-9071-22732b772a3c", "fitness": 0.0225990046495407, "name": "ACPO", "description": "Enhance ACPO by implementing a dynamic personal best strategy based on function evaluations.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i] * (1 - 0.1 * np.sin(0.05 * evaluations))  # Dynamic personal best\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 70, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["5390943b-6433-400e-88d4-4fed5d7f3583"], "operator": null, "metadata": {"aucs": [0.010269454381050869, 0.010269454381050869, 0.010269454381050869, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05846468844028507, 0.05846468844028507, 0.05846468844028507, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04277047494836639, 0.04277047494836639, 0.04277047494836639, 0.08856097892960979, 0.08856097892960979, 0.08856097892960979, 0.033218082909813984, 0.033218082909813984, 0.033218082909813984, 0.08694072293272359, 0.08694072293272359, 0.08694072293272359, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018893763747284575, 0.018893763747284575, 0.018893763747284575, 0.014067341733161487, 0.014067341733161487, 0.014067341733161487, 0.1239732122623336, 0.1239732122623336, 0.1239732122623336, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "178dd6ea-c31c-46f2-8695-5d18ca83ffb6", "fitness": 0.022777928699998548, "name": "ACPO", "description": "Introduce adaptive mutation rate to enhance exploration in ACPO.  ", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate  # New: Mutation mask\n            population = np.where(mutation_mask, population + np.random.normal(0, 0.1, population.shape), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 71, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["5390943b-6433-400e-88d4-4fed5d7f3583"], "operator": null, "metadata": {"aucs": [0.008684231557671174, 0.008684231557671174, 0.008684231557671174, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06012602376114906, 0.06012602376114906, 0.06012602376114906, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05462737171190679, 0.05462737171190679, 0.05462737171190679, 0.08244513986952251, 0.08244513986952251, 0.08244513986952251, 0.02490567674487265, 0.02490567674487265, 0.02490567674487265, 0.08416878644412717, 0.08416878644412717, 0.08416878644412717, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019570786512701832, 0.019570786512701832, 0.019570786512701832, 0.014553936953627833, 0.014553936953627833, 0.014553936953627833, 0.13237094394003868, 0.13237094394003868, 0.13237094394003868, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d4ded64a-8d80-4a0f-a605-1073a04fbda2", "fitness": 0.022866594099146497, "name": "ACPO", "description": "Enhance adaptive mutation with context-sensitive learning for better exploration.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 72, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["178dd6ea-c31c-46f2-8695-5d18ca83ffb6"], "operator": null, "metadata": {"aucs": [0.0112637308095771, 0.0112637308095771, 0.0112637308095771, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05655511674760649, 0.05655511674760649, 0.05655511674760649, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05424022510604254, 0.05424022510604254, 0.05424022510604254, 0.08535650318988297, 0.08535650318988297, 0.08535650318988297, 0.02521884921343831, 0.02521884921343831, 0.02521884921343831, 0.08905887055937778, 0.08905887055937778, 0.08905887055937778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01900143482116423, 0.01900143482116423, 0.01900143482116423, 0.014663845950115051, 0.014663845950115051, 0.014663845950115051, 0.12822229067796398, 0.12822229067796398, 0.12822229067796398, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "8dff64e4-7b7a-423a-ba1b-f6a7dc0dc29d", "fitness": 0.022866594099146497, "name": "ACPO", "description": "Strategic inertia weight adjustment to enhance convergence stability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 73, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["d4ded64a-8d80-4a0f-a605-1073a04fbda2"], "operator": null, "metadata": {"aucs": [0.0112637308095771, 0.0112637308095771, 0.0112637308095771, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05655511674760649, 0.05655511674760649, 0.05655511674760649, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05424022510604254, 0.05424022510604254, 0.05424022510604254, 0.08535650318988297, 0.08535650318988297, 0.08535650318988297, 0.02521884921343831, 0.02521884921343831, 0.02521884921343831, 0.08905887055937778, 0.08905887055937778, 0.08905887055937778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01900143482116423, 0.01900143482116423, 0.01900143482116423, 0.014663845950115051, 0.014663845950115051, 0.014663845950115051, 0.12822229067796398, 0.12822229067796398, 0.12822229067796398, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "95ce7598-7f2b-41ca-809f-b0d0cc364bb1", "fitness": 0.022863012398409235, "name": "ACPO", "description": "Fine-tune the cognitive coefficient adaptation to enhance global search capability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.6 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 74, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["d4ded64a-8d80-4a0f-a605-1073a04fbda2"], "operator": null, "metadata": {"aucs": [0.011112527761835578, 0.011112527761835578, 0.011112527761835578, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05655511674760649, 0.05655511674760649, 0.05655511674760649, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05424022510604254, 0.05424022510604254, 0.05424022510604254, 0.0854217454199302, 0.0854217454199302, 0.0854217454199302, 0.02521884921343831, 0.02521884921343831, 0.02521884921343831, 0.08905887055937778, 0.08905887055937778, 0.08905887055937778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01900143482116423, 0.01900143482116423, 0.01900143482116423, 0.014663845950115051, 0.014663845950115051, 0.014663845950115051, 0.12822229067796398, 0.12822229067796398, 0.12822229067796398, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "224b392e-981e-4503-8a15-213af3671f71", "fitness": 0.02205021465908588, "name": "ACPO", "description": "Introduce dynamic inertia scaling to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations / self.budget * np.pi)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 75, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["d4ded64a-8d80-4a0f-a605-1073a04fbda2"], "operator": null, "metadata": {"aucs": [0.006566751539677784, 0.006566751539677784, 0.006566751539677784, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05326358226809935, 0.05326358226809935, 0.05326358226809935, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05424022510604254, 0.05424022510604254, 0.05424022510604254, 0.08161932700966323, 0.08161932700966323, 0.08161932700966323, 0.021012442624880112, 0.021012442624880112, 0.021012442624880112, 0.08905887055937778, 0.08905887055937778, 0.08905887055937778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017076982543646868, 0.017076982543646868, 0.017076982543646868, 0.012927288184362062, 0.012927288184362062, 0.012927288184362062, 0.12822229067796398, 0.12822229067796398, 0.12822229067796398, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "17632bfa-e567-4a5f-ac61-f71d099cf1ce", "fitness": 0.023211550726862512, "name": "ACPO", "description": "Introduce a dynamic scaling factor in velocity update for better convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 76, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["d4ded64a-8d80-4a0f-a605-1073a04fbda2"], "operator": null, "metadata": {"aucs": [0.010421571327406731, 0.010421571327406731, 0.010421571327406731, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06010583641258105, 0.06010583641258105, 0.06010583641258105, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08954941480870904, 0.08954941480870904, 0.08954941480870904, 0.03007142354561232, 0.03007142354561232, 0.03007142354561232, 0.0876120088980682, 0.0876120088980682, 0.0876120088980682, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019205437243627332, 0.019205437243627332, 0.019205437243627332, 0.014663561117505108, 0.014663561117505108, 0.014663561117505108, 0.13296542932086086, 0.13296542932086086, 0.13296542932086086, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b14e2c99-9ca2-4c12-b437-05dae3560fc0", "fitness": 0.022855787650070545, "name": "ACPO", "description": "Utilize a slightly more aggressive dynamic scaling factor to enhance convergence in the velocity update.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.95 + 0.05 * np.cos(0.1 * evaluations)  # New aggressive dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 77, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.01075812502185114, 0.01075812502185114, 0.01075812502185114, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0592060298036553, 0.0592060298036553, 0.0592060298036553, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04730280226516759, 0.04730280226516759, 0.04730280226516759, 0.08318836222209358, 0.08318836222209358, 0.08318836222209358, 0.023477537220893407, 0.023477537220893407, 0.023477537220893407, 0.0889248889612887, 0.0889248889612887, 0.0889248889612887, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019312127831347503, 0.019312127831347503, 0.019312127831347503, 0.0147855107413295, 0.0147855107413295, 0.0147855107413295, 0.13636612822971894, 0.13636612822971894, 0.13636612822971894, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9f7d4baa-eb9a-4251-82ef-464a7c058166", "fitness": 0.022658204729929625, "name": "ACPO", "description": "Refine the adaptive learning factor to improve convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.5 * np.sin(0.1 * evaluations)  # New adaptive learning factor adjustment\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 78, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.008687473707810534, 0.008687473707810534, 0.008687473707810534, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.061967809341088476, 0.061967809341088476, 0.061967809341088476, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04360590417432997, 0.04360590417432997, 0.04360590417432997, 0.08100061551493065, 0.08100061551493065, 0.08100061551493065, 0.028339081317711012, 0.028339081317711012, 0.028339081317711012, 0.09257001454208058, 0.09257001454208058, 0.09257001454208058, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019506837789331932, 0.019506837789331932, 0.019506837789331932, 0.013949514097671423, 0.013949514097671423, 0.013949514097671423, 0.12895227172900903, 0.12895227172900903, 0.12895227172900903, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "83ee9c4a-588f-40e2-a3f1-95bf4f9e6244", "fitness": 0.022497406724794184, "name": "ACPO", "description": "Introduce a more pronounced dynamic scaling factor for velocity update to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.8 + 0.2 * np.cos(0.1 * evaluations)  # More pronounced dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 79, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.013714616458272655, 0.013714616458272655, 0.013714616458272655, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05995336053393563, 0.05995336053393563, 0.05995336053393563, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04734756632232229, 0.04734756632232229, 0.04734756632232229, 0.07844238684544214, 0.07844238684544214, 0.07844238684544214, 0.02582794566391111, 0.02582794566391111, 0.02582794566391111, 0.08802313681164398, 0.08802313681164398, 0.08802313681164398, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019656665211119417, 0.019656665211119417, 0.019656665211119417, 0.014288492900335625, 0.014288492900335625, 0.014288492900335625, 0.12746619934373016, 0.12746619934373016, 0.12746619934373016, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e72cc725-cd38-47ef-9ba8-307870c04583", "fitness": 0.0230694865157896, "name": "ACPO", "description": "Refine adaptive mutation rate to enhance exploration balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.02 + 0.1 * np.sin(0.05 * evaluations)  # New: Adjusted adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 80, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.010412750121175929, 0.010412750121175929, 0.010412750121175929, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06014568101389317, 0.06014568101389317, 0.06014568101389317, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08954436269553567, 0.08954436269553567, 0.08954436269553567, 0.03008593866760023, 0.03008593866760023, 0.03008593866760023, 0.08772579998528607, 0.08772579998528607, 0.08772579998528607, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01919620304586034, 0.01919620304586034, 0.01919620304586034, 0.0146720415240007, 0.0146720415240007, 0.0146720415240007, 0.12940236455526866, 0.12940236455526866, 0.12940236455526866, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "639e060c-36fc-42d4-8b9c-c0710d7c5721", "fitness": 0.02313716574115076, "name": "ACPO", "description": "Refine the dynamic scaling factor to improve adaptive control in velocity updates.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.92 + 0.08 * np.cos(0.1 * evaluations)  # Refined dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 81, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.010589119170537287, 0.010589119170537287, 0.010589119170537287, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.059891178741061646, 0.059891178741061646, 0.059891178741061646, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05033080358149156, 0.05033080358149156, 0.05033080358149156, 0.08624872578673703, 0.08624872578673703, 0.08624872578673703, 0.028342280457486435, 0.028342280457486435, 0.028342280457486435, 0.08871099884216094, 0.08871099884216094, 0.08871099884216094, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019303864937388338, 0.019303864937388338, 0.019303864937388338, 0.014706347999479119, 0.014706347999479119, 0.014706347999479119, 0.1319512669669285, 0.1319512669669285, 0.1319512669669285, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "92ef16b0-9d50-4b01-ac25-a47fa8685b8a", "fitness": 0.02276106529167543, "name": "ACPO", "description": "Introduce a dynamic scaling factor in velocity update and refine adaptive mutation for better convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.1], size=population.shape, p=[0.7, 0.3])  # Adjusted mutation context\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 82, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.01045460074005633, 0.01045460074005633, 0.01045460074005633, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06024851661372632, 0.06024851661372632, 0.06024851661372632, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04654150647607569, 0.04654150647607569, 0.04654150647607569, 0.08961520597237171, 0.08961520597237171, 0.08961520597237171, 0.026591537469015325, 0.026591537469015325, 0.026591537469015325, 0.086005889983095, 0.086005889983095, 0.086005889983095, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019205895287397023, 0.019205895287397023, 0.019205895287397023, 0.014656541837934411, 0.014656541837934411, 0.014656541837934411, 0.12772848131619108, 0.12772848131619108, 0.12772848131619108, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "90269816-e2e0-4a0f-9bcb-618787c077a7", "fitness": 0.022460574102581597, "name": "ACPO", "description": "Introduce a dynamic inertia weight that increases linearly to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.5 * (evaluations / self.budget))  # Linear increase of inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 83, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.008767312408785366, 0.008767312408785366, 0.008767312408785366, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.055821404869178415, 0.055821404869178415, 0.055821404869178415, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08520928602914302, 0.08520928602914302, 0.08520928602914302, 0.02731767841975541, 0.02731767841975541, 0.02731767841975541, 0.08782081442812895, 0.08782081442812895, 0.08782081442812895, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018397834002005897, 0.018397834002005897, 0.018397834002005897, 0.013834548979362982, 0.013834548979362982, 0.013834548979362982, 0.12940236455526866, 0.12940236455526866, 0.12940236455526866, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ea40b2b4-f3fe-47de-8e05-9f60219a77fd", "fitness": 0.02330252569385959, "name": "ACPO", "description": "Fine-tune the inertia weight sinusoidal scaling for enhanced exploration capability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 84, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["17632bfa-e567-4a5f-ac61-f71d099cf1ce"], "operator": null, "metadata": {"aucs": [0.010216724061205551, 0.010216724061205551, 0.010216724061205551, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05987078214758523, 0.05987078214758523, 0.05987078214758523, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.09047095679621742, 0.09047095679621742, 0.09047095679621742, 0.031019873239831797, 0.031019873239831797, 0.031019873239831797, 0.09006329752375741, 0.09006329752375741, 0.09006329752375741, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019087677494830313, 0.019087677494830313, 0.019087677494830313, 0.014717630322869435, 0.014717630322869435, 0.014717630322869435, 0.13133114029600335, 0.13133114029600335, 0.13133114029600335, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ee96ede6-db57-4bad-9f9d-55bd0b9d684b", "fitness": 0.023032623204275644, "name": "ACPO", "description": "Enhance the cognitive coefficient dynamics for improved exploitation in the adaptive learning process.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98\n                self.cognitive_coefficient = 1.6 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient for improved exploitation\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 85, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.010216724061205551, 0.010216724061205551, 0.010216724061205551, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05985973557047153, 0.05985973557047153, 0.05985973557047153, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08584920659894901, 0.08584920659894901, 0.08584920659894901, 0.028559141978742875, 0.028559141978742875, 0.028559141978742875, 0.09006329752375741, 0.09006329752375741, 0.09006329752375741, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019087677494830313, 0.019087677494830313, 0.019087677494830313, 0.014717630322869435, 0.014717630322869435, 0.014717630322869435, 0.1319470085814597, 0.1319470085814597, 0.1319470085814597, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2e7c95a1-c1b0-4457-8a75-b27540a31cc4", "fitness": 0.0225806099104832, "name": "ACPO", "description": "Introduce a fine-grained inertia weight adjustment to improve overall convergence speed.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations * 0.01)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 86, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.009433501526114108, 0.009433501526114108, 0.009433501526114108, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054905219795751026, 0.054905219795751026, 0.054905219795751026, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08212506373647888, 0.08212506373647888, 0.08212506373647888, 0.02574120689481829, 0.02574120689481829, 0.02574120689481829, 0.08954081861087915, 0.08954081861087915, 0.08954081861087915, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018035584221599343, 0.018035584221599343, 0.018035584221599343, 0.013542233076066279, 0.013542233076066279, 0.013542233076066279, 0.13612847521956006, 0.13612847521956006, 0.13612847521956006, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "fd7867e8-80c4-4d36-890d-67ba9c3618dd", "fitness": 0.02330252569385959, "name": "ACPO", "description": "Fine-tune the inertia weight sinusoidal scaling with adaptive cognitive and social coefficients for enhanced exploration capability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 87, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.010216724061205551, 0.010216724061205551, 0.010216724061205551, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05987078214758523, 0.05987078214758523, 0.05987078214758523, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.09047095679621742, 0.09047095679621742, 0.09047095679621742, 0.031019873239831797, 0.031019873239831797, 0.031019873239831797, 0.09006329752375741, 0.09006329752375741, 0.09006329752375741, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019087677494830313, 0.019087677494830313, 0.019087677494830313, 0.014717630322869435, 0.014717630322869435, 0.014717630322869435, 0.13133114029600335, 0.13133114029600335, 0.13133114029600335, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d1cb486b-43a0-47cf-8b5d-41d54c352275", "fitness": 0.02113148430779953, "name": "ACPO", "description": "Introduce a random restart mechanism to escape local optima in ACPO.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n            \n            # Random restart mechanism\n            if np.random.rand() < 0.01:  # small probability to trigger a restart\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 88, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.007183393779577774, 0.007183393779577774, 0.007183393779577774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.043805724551878145, 0.043805724551878145, 0.043805724551878145, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.042697789220005, 0.042697789220005, 0.042697789220005, 0.08394807785670244, 0.08394807785670244, 0.08394807785670244, 0.02707738455607167, 0.02707738455607167, 0.02707738455607167, 0.0786806159228981, 0.0786806159228981, 0.0786806159228981, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017178435014442606, 0.017178435014442606, 0.017178435014442606, 0.013750843324445539, 0.013750843324445539, 0.013750843324445539, 0.12761596785682006, 0.12761596785682006, 0.12761596785682006, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "737e5529-6089-4bac-9276-5c39e24b5cd4", "fitness": 0.023061401993793307, "name": "ACPO", "description": "Introduce a random restart mechanism to escape local optima and enhance global search capabilities in ACPO.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n        \n            # Random restart mechanism\n            if evaluations % 100 == 0:\n                population[np.random.randint(self.population_size)] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 89, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.010316172714748162, 0.010316172714748162, 0.010316172714748162, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.060461664586427544, 0.060461664586427544, 0.060461664586427544, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08906055807197788, 0.08906055807197788, 0.08906055807197788, 0.026529912441466075, 0.026529912441466075, 0.026529912441466075, 0.08958184137109448, 0.08958184137109448, 0.08958184137109448, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01918020033229828, 0.01918020033229828, 0.01918020033229828, 0.014529623266693936, 0.014529623266693936, 0.014529623266693936, 0.13133114029600335, 0.13133114029600335, 0.13133114029600335, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "19b23968-3fd8-4570-acbb-e12b33cb5ea9", "fitness": 0.022379087703549468, "name": "ACPO", "description": "Enhance ACPO by integrating dynamic differential mutation and adaptive elitism for intensified exploration and exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            diff_individuals = np.random.choice(self.population_size, size=(self.population_size, 2))\n            differential_mutation = 0.8 * (population[diff_individuals[:, 0]] - population[diff_individuals[:, 1]])\n            population = np.where(mutation_mask, population + differential_mutation, population)\n            elite_fraction = int(0.1 * self.population_size)\n            sorted_indices = np.argsort(personal_best_scores)\n            elite_indices = sorted_indices[:elite_fraction]\n            population[elite_indices] = personal_best_positions[elite_indices]\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 90, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.012893209787918525, 0.012893209787918525, 0.012893209787918525, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05630726905870764, 0.05630726905870764, 0.05630726905870764, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03682311103089464, 0.03682311103089464, 0.03682311103089464, 0.08364783615189997, 0.08364783615189997, 0.08364783615189997, 0.029829852007130064, 0.029829852007130064, 0.029829852007130064, 0.08678553713295745, 0.08678553713295745, 0.08678553713295745, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020386877431737394, 0.020386877431737394, 0.020386877431737394, 0.014224074684021981, 0.014224074684021981, 0.014224074684021981, 0.13098294629557206, 0.13098294629557206, 0.13098294629557206, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "27d82bf8-5660-4a8b-aad8-7bd8c1ab44d9", "fitness": 0.02313196627485854, "name": "ACPO", "description": "Enhance ACPO by introducing a dynamic update mechanism for inertia weight, utilizing cosine modulation for improved diversity.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.cos(evaluations * 0.02)) * 0.98  # Modified: Cosine modulation for inertia weight\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 91, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.010168543087836546, 0.010168543087836546, 0.010168543087836546, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.059254294683118824, 0.059254294683118824, 0.059254294683118824, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.09006630507563917, 0.09006630507563917, 0.09006630507563917, 0.03154315376542183, 0.03154315376542183, 0.03154315376542183, 0.0883376772654042, 0.0883376772654042, 0.0883376772654042, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01925707545831712, 0.01925707545831712, 0.01925707545831712, 0.014655241935268903, 0.014655241935268903, 0.014655241935268903, 0.12940236455526866, 0.12940236455526866, 0.12940236455526866, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e845c373-58cc-4abc-b37d-371d8fb8fe8e", "fitness": 0.02259051184892923, "name": "ACPO", "description": "Fine-tune adaptive crossover and mutation rates to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations * 0.05)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 92, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.01601680914632464, 0.01601680914632464, 0.01601680914632464, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05819528551763031, 0.05819528551763031, 0.05819528551763031, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04348014852438642, 0.04348014852438642, 0.04348014852438642, 0.08387909218488065, 0.08387909218488065, 0.08387909218488065, 0.024517255896011392, 0.024517255896011392, 0.024517255896011392, 0.08703518409982436, 0.08703518409982436, 0.08703518409982436, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018466299797417318, 0.018466299797417318, 0.018466299797417318, 0.01434520272009776, 0.01434520272009776, 0.01434520272009776, 0.13101961518338123, 0.13101961518338123, 0.13101961518338123, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "bca2b10c-5726-4beb-93cc-5d8f198a5dfc", "fitness": 0.022543635308896963, "name": "ACPO", "description": "Enhance dynamic scaling and crossover mechanisms with more adaptive parameters for improved convergence.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations) + 0.05  # Strengthened dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(0.1 * evaluations)  # Adjusted adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 93, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.010705799792676829, 0.010705799792676829, 0.010705799792676829, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05935445411930096, 0.05935445411930096, 0.05935445411930096, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.043451392602907424, 0.043451392602907424, 0.043451392602907424, 0.08340491168591524, 0.08340491168591524, 0.08340491168591524, 0.028855659982587434, 0.028855659982587434, 0.028855659982587434, 0.08503278453178287, 0.08503278453178287, 0.08503278453178287, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.021220728915604115, 0.021220728915604115, 0.021220728915604115, 0.014341277214265258, 0.014341277214265258, 0.014341277214265258, 0.1294628472641396, 0.1294628472641396, 0.1294628472641396, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "5fedd5f9-2acf-4401-845c-8b2e93e3e678", "fitness": 0.020018220169278424, "name": "ACPO", "description": "Fine-tune the inertia weight sinusoidal scaling for enhanced exploration and introduce an early stopping condition for efficiency.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        epsilon = 1e-5  # Early stopping threshold\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Early stopping condition\n            if global_best_score < epsilon:\n                break\n\n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 94, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.003894825242896971, 0.003894825242896971, 0.003894825242896971, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03063422310966668, 0.03063422310966668, 0.03063422310966668, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03206291664775207, 0.03206291664775207, 0.03206291664775207, 0.06666256175689833, 0.06666256175689833, 0.06666256175689833, 0.026765620363660148, 0.026765620363660148, 0.026765620363660148, 0.09006329752375741, 0.09006329752375741, 0.09006329752375741, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019087677494830313, 0.019087677494830313, 0.019087677494830313, 0.014717630322869435, 0.014717630322869435, 0.014717630322869435, 0.13133114029600335, 0.13133114029600335, 0.13133114029600335, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "5f15e8f4-45b6-4c4e-b8d1-3d5fdac7f501", "fitness": 0.022247997574210827, "name": "ACPO", "description": "Enhance convergence by introducing adaptive dynamic inertia weight adjustment based on cosine function.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.cos(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 95, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.009486393580374841, 0.009486393580374841, 0.009486393580374841, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05484565001868613, 0.05484565001868613, 0.05484565001868613, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08440570169941186, 0.08440570169941186, 0.08440570169941186, 0.02623788279017414, 0.02623788279017414, 0.02623788279017414, 0.08553099551528776, 0.08553099551528776, 0.08553099551528776, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018023765195483654, 0.018023765195483654, 0.018023765195483654, 0.013536653656043174, 0.013536653656043174, 0.013536653656043174, 0.12940236455526866, 0.12940236455526866, 0.12940236455526866, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7bc2d999-69b4-4e2a-bc7e-cff22b9f03d8", "fitness": 0.023037729301150136, "name": "ACPO", "description": "Fine-tune the inertia weight sinusoidal scaling for dynamic adaptive capabilities.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.35 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 96, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.009767872869327454, 0.009767872869327454, 0.009767872869327454, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05931625758805781, 0.05931625758805781, 0.05931625758805781, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.08873516819828509, 0.08873516819828509, 0.08873516819828509, 0.0315409155119617, 0.0315409155119617, 0.0315409155119617, 0.08801823543002418, 0.08801823543002418, 0.08801823543002418, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018862376797088798, 0.018862376797088798, 0.018862376797088798, 0.014779777507259895, 0.014779777507259895, 0.014779777507259895, 0.12940236455526866, 0.12940236455526866, 0.12940236455526866, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "720e5091-64e8-4a83-bfd9-99ce97810923", "fitness": 0.022611070289952344, "name": "ACPO", "description": "Enhance the convergence by adjusting the dynamic scaling factor for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.8 + 0.2 * np.cos(0.1 * evaluations)  # Adjusted dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 97, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.013694132757052557, 0.013694132757052557, 0.013694132757052557, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06003770600406788, 0.06003770600406788, 0.06003770600406788, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04742458548728945, 0.04742458548728945, 0.04742458548728945, 0.0786108618596465, 0.0786108618596465, 0.0786108618596465, 0.02647680085783033, 0.02647680085783033, 0.02647680085783033, 0.09002722223490256, 0.09002722223490256, 0.09002722223490256, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01955369641561555, 0.01955369641561555, 0.01955369641561555, 0.014378142928382687, 0.014378142928382687, 0.014378142928382687, 0.12724514710972135, 0.12724514710972135, 0.12724514710972135, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e74dbb0f-b00c-44e7-9c8b-e52a97c109a5", "fitness": 0.01946802963075616, "name": "ACPO", "description": "Fine-tune the inertia weight sinusoidal scaling and integration of adaptive acceleration for enhanced exploration capability.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                adaptive_acceleration = 0.1 * np.cos(0.05 * evaluations)  # New: Adaptive acceleration factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor * adaptive_acceleration\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.01 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 98, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0348334377919699, 0.0348334377919699, 0.0348334377919699, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0431362801471159, 0.0431362801471159, 0.0431362801471159, 0.07203834487682015, 0.07203834487682015, 0.07203834487682015, 0.01634536330709313, 0.01634536330709313, 0.01634536330709313, 0.07354674117646054, 0.07354674117646054, 0.07354674117646054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014406321562767777, 0.014406321562767777, 0.014406321562767777, 0.011382885068116244, 0.011382885068116244, 0.011382885068116244, 0.13197811981650032, 0.13197811981650032, 0.13197811981650032, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "549f19f5-8178-4f80-add2-978228b37e69", "fitness": 0.023310543441859812, "name": "ACPO", "description": "Slightly increase the adaptive mutation rate to enhance exploration capabilities.", "code": "import numpy as np\n\nclass ACPO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.crossover_probability = 0.7\n\n    def __call__(self, func):\n        np.random.seed(42)  # for reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = np.full(self.population_size, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate the population\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                score = func(population[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = population[i]\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = population[i]\n            \n            # Update velocities and positions\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_velocity = self.cognitive_coefficient * r1 * (personal_best_positions[i] - population[i])\n                social_velocity = self.social_coefficient * r2 * (global_best_position - population[i])\n                self.inertia_weight = 0.5 + (0.45 * np.sin(evaluations)) * 0.98  # Modified damping factor\n                self.cognitive_coefficient = 1.5 + 0.5 * np.sin(0.05 * evaluations) + 0.1  # Adjusted cognitive coefficient\n                adaptive_learning_factor = 1.0 + 0.4 * np.sin(0.1 * evaluations)  # New adaptive learning factor\n                dynamic_scaling_factor = 0.9 + 0.1 * np.cos(0.1 * evaluations)  # New dynamic scaling factor\n                velocities[i] = (self.inertia_weight * velocities[i] + cognitive_velocity + social_velocity) * adaptive_learning_factor * dynamic_scaling_factor\n                population[i] += velocities[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n            \n            # Perform adaptive crossover\n            for i in range(0, self.population_size, 2):\n                if evaluations >= self.budget:\n                    break\n                self.crossover_probability = 0.65 + 0.15 * np.cos(evaluations)  # Adaptive crossover probability\n                if np.random.rand() < self.crossover_probability:\n                    parent1, parent2 = population[i], population[(i+1) % self.population_size]\n                    mask = np.random.rand(self.dim) < np.sin(0.05 * evaluations)  # Dynamic crossover mask\n                    offspring1 = np.where(mask, parent1, parent2)\n                    offspring2 = np.where(mask, (parent1 + parent2) / 2, parent1)  # Modified offspring creation\n                    population[i], population[(i+1) % self.population_size] = offspring1, offspring2\n\n            # Introduce adaptive mutation\n            mutation_rate = 0.02 + 0.1 * np.sin(0.05 * evaluations)  # New: Adaptive mutation rate\n            mutation_context = np.random.choice([0.05, 0.15], size=population.shape, p=[0.7, 0.3])  # New: Context-sensitive learning\n            mutation_mask = np.random.rand(self.population_size, self.dim) < mutation_rate\n            population = np.where(mutation_mask, population + np.random.normal(0, mutation_context), population)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 99, "feedback": "The algorithm ACPO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["ea40b2b4-f3fe-47de-8e05-9f60219a77fd"], "operator": null, "metadata": {"aucs": [0.010207962345042065, 0.010207962345042065, 0.010207962345042065, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05990851873235348, 0.05990851873235348, 0.05990851873235348, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04726514346598221, 0.04726514346598221, 0.04726514346598221, 0.09046649557387298, 0.09046649557387298, 0.09046649557387298, 0.030971211701883106, 0.030971211701883106, 0.030971211701883106, 0.09027842347682968, 0.09027842347682968, 0.09027842347682968, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019080385330565774, 0.019080385330565774, 0.019080385330565774, 0.014726370377755371, 0.014726370377755371, 0.014726370377755371, 0.13133114029600335, 0.13133114029600335, 0.13133114029600335, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
