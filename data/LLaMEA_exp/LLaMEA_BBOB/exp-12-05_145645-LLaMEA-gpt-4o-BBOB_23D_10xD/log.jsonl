{"id": "16c433ec-d115-4704-a475-00cac8f2c9ea", "fitness": 0.019865452856289326, "name": "AQIDE", "description": "Adaptive Quantum-Inspired Differential Evolution (AQIDE) using probabilistic population dynamics to explore the search space effectively.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                if np.random.rand() < self.prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.023555033649904522, 0.04801400310818327, 0.03567522270100598, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04343653132160763, 0.04226484521534868, 0.03780180861439042, 0.07873599760320227, 0.08213655218843341, 0.07865919321862824, 0.02308672111519139, 0.028448743065233706, 0.018657772523801963, 0.06378564672478404, 0.07422504769968552, 0.05905195259058904, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014190365120143933, 0.014365448605513698, 0.014012173670730932, 0.013285949073251091, 0.012645296536607398, 0.01318625840600307, 0.12825972540527053, 0.14582786686394755, 0.12830879845746135, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e5d90734-b34a-4a9c-b800-459bcaf73d4d", "fitness": 0.019627775621546953, "name": "AQIDE", "description": "Improved AQIDE by introducing dynamic scaling factor adjustment based on the evaluation budget to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Dynamic scaling factor adjustment\n                self.F = 0.4 + 0.1 * (1 - self.budget_used / self.budget)\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                if np.random.rand() < self.prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["16c433ec-d115-4704-a475-00cac8f2c9ea"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02512306245016127, 0.04695753399180136, 0.0387101995150092, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04282292423072409, 0.045026841736557466, 0.03652035702992096, 0.08578140809475321, 0.07959449977099353, 0.07916371182701587, 0.022744881458559463, 0.025710350893288436, 0.020181755927312417, 0.06718533530542159, 0.07422390557217251, 0.05979733131603948, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01460648245540297, 0.014696221213524208, 0.013669155937899746, 0.012842994044130474, 0.012225965798830174, 0.011963141875869332, 0.12310206132691848, 0.12389202831764823, 0.1279620424875142, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "67779da6-8051-4dc2-b8c8-c18ded6a87bf", "fitness": 0.02045795353101944, "name": "AQIDE", "description": "Enhanced AQIDE by optimizing crossover and mutation strategies for improved performance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.random.uniform(0.8, 1.0)  # slight modification here\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                if np.random.rand() < np.random.uniform(0.05, 0.15):  # slight modification here\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["16c433ec-d115-4704-a475-00cac8f2c9ea"], "operator": null, "metadata": {"aucs": [0.006685273862305108, 0.017111661921397903, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03155476564487791, 0.052616137603575086, 0.036227169794514014, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04775429486491778, 0.04773980267563649, 0.046113887350923366, 0.08626173868870601, 0.08322255137169732, 0.08475124769538023, 0.028407069054124268, 0.030011580697092977, 0.027965787237783313, 0.0634166192676009, 0.0611499993846123, 0.06336008623441802, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015224627911782584, 0.01401062971768452, 0.014452818559733016, 0.012446821834631638, 0.01345537602821234, 0.012077328994204328, 0.12676254662039876, 0.12768483055150937, 0.12250800066568146, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d6451ff3-2605-4610-980b-680bc61abead", "fitness": 0.019907180656042515, "name": "AQIDE", "description": "Further enhance crossover dynamics and mutation adaptation for AQIDE.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_rate = np.random.uniform(0.85, 1.0)  # modified line\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                if np.random.rand() < np.random.uniform(0.04, 0.12):  # modified line\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["67779da6-8051-4dc2-b8c8-c18ded6a87bf"], "operator": null, "metadata": {"aucs": [0.004479295543650896, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.031838616056964586, 0.039260091149222576, 0.03791981652583554, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04414657720550419, 0.04958527864553253, 0.04312750166751822, 0.08135035660029011, 0.07888957156920406, 0.08244061927794089, 0.021325633468903593, 0.02136255888304217, 0.02638672019895294, 0.06104129064973285, 0.06883782858961296, 0.07038835451504144, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014405412553301633, 0.015603057168983248, 0.014253583304242756, 0.013060392513552732, 0.013665163378113854, 0.012897659080998713, 0.12927835164204193, 0.12978604677858296, 0.12363940418133845, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0504c22f-59a6-4273-9143-c9878270b163", "fitness": 0.01984363199772098, "name": "AQIDE", "description": "Improved AQIDE by adjusting mutation strategy parameters and introducing elitism for enhanced convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.7  # Changed scaling factor F\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n        best_idx = np.argmin(fitness)  # Initialize best solution tracking\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.random.uniform(0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:  # Update best solution\n                        best_idx = i\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                if np.random.rand() < np.random.uniform(0.05, 0.15):\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            # Elitism: Ensure best individual is retained\n            new_population[0] = population[best_idx]\n            fitness[0] = fitness[best_idx]\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 4, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["67779da6-8051-4dc2-b8c8-c18ded6a87bf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.030275940328022166, 0.03917244759553362, 0.02989176527983073, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0431323480724044, 0.046119075277303745, 0.05096676284748458, 0.08387156298157716, 0.08458210743711492, 0.08410842138978825, 0.015275337752628793, 0.022558881160293365, 0.021108817847128925, 0.06445976995282543, 0.061886795597978494, 0.06908234059519858, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015224627911782584, 0.013697111238349713, 0.014273298842717774, 0.012403494466121101, 0.012918558120355694, 0.012126850332028205, 0.1395100933031097, 0.12281366187262699, 0.13058578145979383, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "526e7d02-2c4f-4efc-bbd7-20f03da6eb1d", "fitness": 0.020551480014037955, "name": "AQIDE", "description": "Introduce dynamic mutation scaling and adaptive probabilistic updates to improve exploration in AQIDE.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 - self.budget_used / self.budget)  # dynamic mutation scaling\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.random.uniform(0.8, 1.0)  # slight modification here\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:  # adaptive probabilistic update\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["67779da6-8051-4dc2-b8c8-c18ded6a87bf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.005317525864824257, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03822739475817938, 0.04297078990904757, 0.03910756234978563, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04450605715560774, 0.039358372146963916, 0.045456519762851144, 0.08339688470969386, 0.0883752928451409, 0.08878961294595644, 0.02522901010531642, 0.02494451950439147, 0.027906214626146286, 0.06658678709105748, 0.07006794371047986, 0.07551175865919246, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014906872923750702, 0.015860464263767193, 0.015781898172220532, 0.014178816486679735, 0.013675190419484728, 0.012019092765449213, 0.12499539987604857, 0.13244327338433615, 0.12574548048740564, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "12d47e50-4316-42ec-85cd-ff23c97248af", "fitness": 0.020297192692002863, "name": "AQIDE", "description": "Improve AQIDE by refining crossover probability and mutation strategy to enhance convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 - self.budget_used / self.budget)  # dynamic mutation scaling\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.random.uniform(0.85, 1.0)  # enhanced crossover probability\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.03, 0.12) * (1 - self.budget_used / self.budget)  # refined mutation range\n                if np.random.rand() < adaptive_prob_mutate:  # adaptive probabilistic update\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["526e7d02-2c4f-4efc-bbd7-20f03da6eb1d"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0289875654292181, 0.04731863042960949, 0.033257068895733766, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04277098640734778, 0.04569826838579161, 0.042023954920407225, 0.08440823440965517, 0.08226291400495978, 0.07914771137207954, 0.023424522478614818, 0.027580210212139633, 0.02511209647708379, 0.06684580489175729, 0.07067680985286451, 0.07586739959874134, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014504114756770714, 0.01439568573754857, 0.01464002912819029, 0.014164327215931416, 0.014399152406426086, 0.012876077939815045, 0.12776719792780555, 0.14117044138151347, 0.12340301739028936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c7103917-d323-40e7-9186-a18cffa9bd3a", "fitness": 0.020904778851973508, "name": "AQIDE", "description": "Enhance AQIDE by tweaking crossover probability for a better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 - self.budget_used / self.budget)  # dynamic mutation scaling\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)  # tweak crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:  # adaptive probabilistic update\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["526e7d02-2c4f-4efc-bbd7-20f03da6eb1d"], "operator": null, "metadata": {"aucs": [0.006868082290381605, 0.004347826086956497, 0.004382385976466785, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03761616301302395, 0.04239662312572168, 0.026248310623836812, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04539921884031917, 0.04148099690845741, 0.04716462079715433, 0.08797225181478563, 0.09054280841619589, 0.08557689353072839, 0.02738103242492973, 0.02701125092978729, 0.025693727881522577, 0.05979076026050234, 0.07961571642796672, 0.07946675987540497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0145120841668549, 0.014919377104683273, 0.018777978084199787, 0.012749438251297152, 0.012549881647294536, 0.01282393914476343, 0.1445083990727264, 0.1317171973837492, 0.12797817934933975, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "dd81aa2b-0a43-45f0-babd-6db05e3e0fb9", "fitness": -Infinity, "name": "AQIDE", "description": "Enhance AQIDE by incorporating a learning rate for mutation scaling and dynamic population size adjustment.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.learning_rate = 0.05\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 - (self.budget_used / self.budget)**self.learning_rate)\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            # Dynamic population size adjustment\n            if np.random.rand() < 0.2 and self.budget_used < self.budget:\n                self.population_size = min(int(self.initial_population_size * (1 + np.random.rand())), self.budget - self.budget_used)\n                new_population = np.vstack((new_population, self.lower_bound + np.random.rand(self.population_size - len(new_population), self.dim) * (self.upper_bound - self.lower_bound)))\n                fitness = np.hstack((fitness, np.array([func(ind) for ind in new_population[len(fitness):]])))\n                self.budget_used += self.population_size - len(fitness)\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 8, "feedback": "An exception occurred: ValueError('negative dimensions are not allowed').", "error": "ValueError('negative dimensions are not allowed')", "parent_ids": ["c7103917-d323-40e7-9186-a18cffa9bd3a"], "operator": null, "metadata": {}}
{"id": "883ef465-6d01-4af1-85e7-d8aa7f5575b3", "fitness": 0.020739707855754533, "name": "AQIDE", "description": "Introduce a slight increase in the crossover probability range for more diverse exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 - self.budget_used / self.budget)  # dynamic mutation scaling\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.85, 1.0)  # tweak crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:  # adaptive probabilistic update\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c7103917-d323-40e7-9186-a18cffa9bd3a"], "operator": null, "metadata": {"aucs": [0.004594430546304373, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03766995347276936, 0.041870289791232196, 0.026248310623836812, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04536759672724899, 0.04174724538097774, 0.04716462079715433, 0.0876521754451195, 0.09047525944417079, 0.08135789628265067, 0.027418091257665478, 0.026922247685497336, 0.02529340071522357, 0.06123942188453435, 0.08015843366301256, 0.07566495256972305, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014171088044948599, 0.014864596809849195, 0.018777978084199787, 0.013689618667640291, 0.012525899617228498, 0.01282647051830721, 0.1445083990727264, 0.1317171973837492, 0.12498556504160052, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "17257070-af31-4f70-b0c3-0e2edd5a94a4", "fitness": -Infinity, "name": "AQIDE", "description": "Improve AQIDE by introducing adaptive population size and enhanced selection criteria for dynamic optimization.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.base_population_size = 20  # Base population size\n        self.population_size = self.base_population_size\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = self.base_population_size + int((1 - self.budget_used / self.budget) * 10)  # Adaptive population size\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 - self.budget_used / self.budget)  # dynamic mutation scaling\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Enhanced Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i] or np.random.rand() < 0.1:  # Add stochastic component\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.base_population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 10, "feedback": "An exception occurred: IndexError('index 26 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 26 is out of bounds for axis 0 with size 20')", "parent_ids": ["c7103917-d323-40e7-9186-a18cffa9bd3a"], "operator": null, "metadata": {}}
{"id": "950af73a-f49f-488e-9105-85d440579ff5", "fitness": 0.02035964526208668, "name": "AQIDE", "description": "Refine AQIDE by adjusting the dynamic mutation scaling to enhance convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                \n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 - (self.budget_used / self.budget) ** 2)  # dynamic mutation scaling\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)  # tweak crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:  # adaptive probabilistic update\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c7103917-d323-40e7-9186-a18cffa9bd3a"], "operator": null, "metadata": {"aucs": [0.005230493815008841, 0.004347826086956497, 0.004452500546530125, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.039343363072332216, 0.04602399839709448, 0.028942790640757776, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04421893439994562, 0.04405594141954006, 0.04693740198390517, 0.08736839037677668, 0.08654168662005113, 0.08205709532277572, 0.028677723904984465, 0.030957829153463567, 0.024445403635074525, 0.061131882070448174, 0.08086882163382059, 0.07023020670255053, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014348137271687933, 0.014529686661327146, 0.015147532507176709, 0.012740673777022038, 0.012508956265113724, 0.012898120795648116, 0.12549264982957264, 0.12112753975030666, 0.12561669831732747, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "30310f50-409f-4ee2-86b1-948250f2bc4c", "fitness": 0.02108099381957361, "name": "AQIDE", "description": "Incorporate adaptive scaling of mutation factor and dynamic population size adjustments to enhance exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.4, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c7103917-d323-40e7-9186-a18cffa9bd3a"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.008774176291796443, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04888894971437596, 0.05475313028632278, 0.03923991822257, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04369154661603214, 0.046771599981905165, 0.04954454690768895, 0.08755109908601444, 0.08553768665488659, 0.08102117139386511, 0.029137703224607403, 0.02712318833244909, 0.02436307025434281, 0.0774049608882843, 0.07997779417203976, 0.07262058742095556, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014667417821309425, 0.016109667578007136, 0.014494200106452304, 0.012768298979296544, 0.01373063621095827, 0.01178164135797033, 0.12568407663750913, 0.12408726593901187, 0.12375939484369292, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "81ea8780-b037-48eb-b6ac-97b167fe7aa5", "fitness": 0.02108099381957361, "name": "AQIDE", "description": "Introduce a slight improvement by adjusting the selection mechanism to better exploit promising solutions.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.4, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["30310f50-409f-4ee2-86b1-948250f2bc4c"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.008774176291796443, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04888894971437596, 0.05475313028632278, 0.03923991822257, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04369154661603214, 0.046771599981905165, 0.04954454690768895, 0.08755109908601444, 0.08553768665488659, 0.08102117139386511, 0.029137703224607403, 0.02712318833244909, 0.02436307025434281, 0.0774049608882843, 0.07997779417203976, 0.07262058742095556, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014667417821309425, 0.016109667578007136, 0.014494200106452304, 0.012768298979296544, 0.01373063621095827, 0.01178164135797033, 0.12568407663750913, 0.12408726593901187, 0.12375939484369292, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6ae5ef48-b039-43d1-95e9-2b50a9d2087e", "fitness": 0.020257164519688696, "name": "AQIDE", "description": "Introduce a dynamic crossover probability to enhance diversity and adaptability in the search process.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.4, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0) * (1 - self.budget_used / self.budget) + 0.5 * (self.budget_used / self.budget)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["30310f50-409f-4ee2-86b1-948250f2bc4c"], "operator": null, "metadata": {"aucs": [0.012001784490666245, 0.004369475102959042, 0.00519571185105594, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03637033397787848, 0.045855824834681314, 0.02748822695284925, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04494593109867906, 0.04338988126843224, 0.040283090417002065, 0.08935146978252484, 0.08742866646108427, 0.08509128589511517, 0.034646604084613064, 0.027969135492892594, 0.02875497280900019, 0.06803828300216397, 0.06248663213364969, 0.06384426448677905, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014315813765930607, 0.014194763130281007, 0.015425255079257849, 0.01339379385381212, 0.013609702626594444, 0.012086694450459845, 0.12777249140620883, 0.12325555821802292, 0.12129802483194974, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e4e6ca3e-32dc-438c-8496-992c9af1ba5d", "fitness": 0.021420147335650525, "name": "AQIDE", "description": "Improved adaptive mutation factor scaling to enhance convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["30310f50-409f-4ee2-86b1-948250f2bc4c"], "operator": null, "metadata": {"aucs": [0.008130142742086344, 0.004347826086956497, 0.0053889391894964556, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04983334826628438, 0.054667873288654856, 0.042035469110091706, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04618651168518695, 0.0493068328984152, 0.041070790199722595, 0.0885479337587074, 0.08853833681917422, 0.08181355959830239, 0.032050393842203095, 0.028185848494836407, 0.02502238900963394, 0.0827702992167586, 0.08282281734720442, 0.0695324992088604, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015489672381268527, 0.01842220192686883, 0.014500902291753603, 0.012970751060289665, 0.013389227983061414, 0.011904894284947232, 0.12264352707291348, 0.1334153432356191, 0.12361010325449795, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "25de989d-495b-4c37-80b3-52ad38fa1c4d", "fitness": 0.02055557406212989, "name": "AQIDE", "description": "Improved adaptive mutation factor scaling with dynamic crossover probability to enhance convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0) * (1 - self.budget_used / self.budget)  # Dynamic crossover probability\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e4e6ca3e-32dc-438c-8496-992c9af1ba5d"], "operator": null, "metadata": {"aucs": [0.0053822759591144465, 0.0048180125045176325, 0.004533702288676222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03567022278362353, 0.04903289717247339, 0.030465319844426464, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0453416465771852, 0.05194546731381111, 0.03826544525516751, 0.089850707576968, 0.08438571459357558, 0.08269852343417006, 0.03171329584448801, 0.027499217293697975, 0.025401682265934755, 0.07013460037772412, 0.06887956786097116, 0.05952377630909411, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015268938409942479, 0.014726333483835563, 0.01622095936009127, 0.014104202074506023, 0.01247191646135093, 0.01257889486048791, 0.13504466095715983, 0.1349168715410779, 0.12347430615623878, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ff2c50c7-2319-4601-8e55-ddb2433e687a", "fitness": 0.02134764730273084, "name": "AQIDE", "description": "Enhanced convergence through refined adaptive mutation probability.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                # Adjusted the mutation probability formula to improve convergence\n                adaptive_prob_mutate = np.random.uniform(0.03, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e4e6ca3e-32dc-438c-8496-992c9af1ba5d"], "operator": null, "metadata": {"aucs": [0.008130142742086344, 0.004890389770133452, 0.0053889391894964556, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04983334826628438, 0.05232978793219156, 0.042035469110091706, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04618651168518695, 0.0485337568648222, 0.041070790199722595, 0.0885479337587074, 0.0914320017488065, 0.08181355959830239, 0.032050393842203095, 0.026982233071839445, 0.02502238900963394, 0.0827702992167586, 0.08220933057975788, 0.0695324992088604, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015489672381268527, 0.016575851177818568, 0.014500902291753603, 0.012970751060289665, 0.01339523025377698, 0.011904894284947232, 0.12264352707291348, 0.13152772431142679, 0.12361010325449795, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6870ee5b-50df-4426-994c-24afd582de94", "fitness": 0.021420147335650525, "name": "AQIDE", "description": "Enhance adaptive mutation strategy with dynamic crossover rates.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e4e6ca3e-32dc-438c-8496-992c9af1ba5d"], "operator": null, "metadata": {"aucs": [0.008130142742086344, 0.004347826086956497, 0.0053889391894964556, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04983334826628438, 0.054667873288654856, 0.042035469110091706, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04618651168518695, 0.0493068328984152, 0.041070790199722595, 0.0885479337587074, 0.08853833681917422, 0.08181355959830239, 0.032050393842203095, 0.028185848494836407, 0.02502238900963394, 0.0827702992167586, 0.08282281734720442, 0.0695324992088604, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015489672381268527, 0.01842220192686883, 0.014500902291753603, 0.012970751060289665, 0.013389227983061414, 0.011904894284947232, 0.12264352707291348, 0.1334153432356191, 0.12361010325449795, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1ee8a584-cd97-43dd-8f81-6eecd795e4f7", "fitness": 0.021112155580444873, "name": "AQIDE", "description": "Fine-tuned crossover probability for enhanced exploration in later stages.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 0.8 + 0.2 * (1 - self.budget_used/self.budget)) # Fine-tuned crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e4e6ca3e-32dc-438c-8496-992c9af1ba5d"], "operator": null, "metadata": {"aucs": [0.0062937353851876265, 0.004633166469743322, 0.0044181982911709605, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04984420211086682, 0.04716445129426616, 0.04411042802516996, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047413073354304, 0.0485337568648222, 0.04156957645741499, 0.0882771091900374, 0.08705632610551606, 0.08078906627913796, 0.03341019793688782, 0.024064813892249348, 0.02452406046899913, 0.07926054745153754, 0.07860125079425151, 0.07171877092358092, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014907637189562895, 0.017474868937127797, 0.016132276917426247, 0.01253597921958205, 0.01426155831027709, 0.0128796959493237, 0.12049499398618058, 0.13152772431142679, 0.12252556176293761, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c098e5fc-7cef-42fd-8d7c-f2af3e14ff9c", "fitness": 0.021029524634415257, "name": "AQIDE", "description": "Adaptive Crossover Rate: Introduce dynamic adjustment for the crossover rate based on the budget used to enhance convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_rate = np.clip(0.9 - 0.5 * (self.budget_used / self.budget), 0.1, 1.0)  # Dynamic CR\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e4e6ca3e-32dc-438c-8496-992c9af1ba5d"], "operator": null, "metadata": {"aucs": [0.00927397969636945, 0.00819183861771211, 0.010585934047038115, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03459704800140717, 0.052899275628212616, 0.04100285151360428, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04273663354238744, 0.04476699959189567, 0.03647315566753695, 0.09049842225085791, 0.08243449345427001, 0.08624910846733191, 0.031923019390157736, 0.02811965929446547, 0.029942745877055477, 0.07415660111179456, 0.06993330202837256, 0.07270574982440448, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014372099781264969, 0.01596776048887205, 0.015179220030040685, 0.01610110669072573, 0.013637491984798356, 0.01621585442935447, 0.12221998490957808, 0.1296451370446705, 0.12864412640067735, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "61855f30-b5c0-4bac-b7a9-f429c779f35a", "fitness": 0.021479786420788582, "name": "AQIDE", "description": "Refine adaptive mutation factor scaling by reducing its lower bound for more diverse search.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e4e6ca3e-32dc-438c-8496-992c9af1ba5d"], "operator": null, "metadata": {"aucs": [0.007183952487614054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05187900269422252, 0.05019696693335218, 0.038717979607290065, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04290914206180718, 0.049215375076212986, 0.051132825302322105, 0.08879636506144117, 0.0892337436030699, 0.07928042885890896, 0.03614910723486686, 0.02391225320361945, 0.023416442575050933, 0.08058337486042277, 0.07493623471109745, 0.07636057508799143, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015020741804892213, 0.017363567942033975, 0.015671148237085597, 0.012972043633612707, 0.014411535466988923, 0.011773088337879045, 0.1262908882887286, 0.12777160749149696, 0.13701840564781442, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "463c739f-c02c-4766-adb6-03a92739b879", "fitness": 0.02091087075130342, "name": "AQIDE", "description": "Enhance adaptive mutation factor by including current best fitness influence to improve convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                best_fitness = np.min(fitness)  # Obtain the best fitness so far\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget) * (1 - best_fitness / np.max(fitness))  # Modified adaptive F\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.0043521602971442475, 0.004388885565907441, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05249401453178548, 0.052114559189178955, 0.039058387312583376, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.051516987468896436, 0.04150763621471909, 0.042256808691059744, 0.08290510912258786, 0.08818351132298097, 0.0818997383129434, 0.030144760988351726, 0.032314134881410994, 0.024186095236183536, 0.06833271328955792, 0.07285615126624301, 0.07712328832439452, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01421142195258529, 0.016739824321577723, 0.01594347163144172, 0.012850658656980207, 0.013347284925084857, 0.012170641411606842, 0.12253207024721313, 0.12339875845032111, 0.12875362048110806, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b1e059d3-b545-4643-8685-d580675e0bec", "fitness": 0.020989145308280308, "name": "AQIDE", "description": "Fine-tune the crossover strategy by dynamically adjusting the normal distribution's mean for more effective exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9 - 0.1 * (self.budget_used / self.budget), 0.05), 0.8, 1.0)  # Adjusted mean for exploration\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.0052163662747983786, 0.004664761544670992, 0.005921156532975647, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04697489163218471, 0.051923017395109294, 0.043762980127023954, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.042908535408939796, 0.04678842153678153, 0.04398214166174008, 0.0905807461932544, 0.08613927107159369, 0.0835243568677595, 0.030452436840174735, 0.023605833353953498, 0.02348597118890905, 0.07569528334430908, 0.07187432241715463, 0.07507718801507635, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014932572645589892, 0.016249681860678877, 0.016938418875920402, 0.013788104526454181, 0.01373591132841312, 0.012871217413601643, 0.12700465643055836, 0.12562468795731807, 0.12184335583819594, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6c98af99-84de-4ef3-985c-f6b3159d18c9", "fitness": 0.02085738204687434, "name": "AQIDE", "description": "Adjust the crossover probability range to enhance exploration and diversification.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.85, 0.1), 0.7, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 24, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.005555179650962194, 0.004543807185834026, 0.006208045508177218, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04545892771878601, 0.050764282221916535, 0.04386551043367537, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04501865086044643, 0.04089621423893175, 0.040384341140232594, 0.08775472061896561, 0.08359615562624145, 0.08154469347384463, 0.03237634804496148, 0.023992111951768313, 0.02426920793594023, 0.07703720077203313, 0.07367095926838352, 0.07349629876911168, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01550524894202776, 0.014419941521293445, 0.01738716390781092, 0.013091596778202597, 0.012761801595430056, 0.012120528092059657, 0.1298509421657752, 0.12287683914436698, 0.1276326158947313, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c11b89c9-4c83-4837-a272-044e79f05a6d", "fitness": 0.021356483957970202, "name": "AQIDE", "description": "AQIDE with refined adaptive probability mutation for improved exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.2) * (1 - self.budget_used / self.budget)  # Slightly adjusted upper bound\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.007183952487614054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05187900269422252, 0.05019696693335218, 0.03635048944653696, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04290914206180718, 0.049215375076212986, 0.04119910414973915, 0.08879636506144117, 0.0892337436030699, 0.0821943297058666, 0.03614910723486686, 0.02391225320361945, 0.024668961753682495, 0.08058337486042277, 0.07493623471109745, 0.07469318559119642, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015020741804892213, 0.017363567942033975, 0.0156601881823335, 0.012972043633612707, 0.014411535466988923, 0.012708451854249736, 0.1262908882887286, 0.12777160749149696, 0.13701840564781442, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4056fd3c-1909-4c04-912f-7c767bb80ae3", "fitness": 0.021479786420788582, "name": "AQIDE", "description": "Enhance AQIDE by increasing exploitative pressure through dynamic CR adaptation for improved convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n            self.CR = 0.9 * (1 - self.budget_used / self.budget) + 0.1  # Adaptive CR to enhance exploitation\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.007183952487614054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05187900269422252, 0.05019696693335218, 0.038717979607290065, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04290914206180718, 0.049215375076212986, 0.051132825302322105, 0.08879636506144117, 0.0892337436030699, 0.07928042885890896, 0.03614910723486686, 0.02391225320361945, 0.023416442575050933, 0.08058337486042277, 0.07493623471109745, 0.07636057508799143, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015020741804892213, 0.017363567942033975, 0.015671148237085597, 0.012972043633612707, 0.014411535466988923, 0.011773088337879045, 0.1262908882887286, 0.12777160749149696, 0.13701840564781442, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "bd565b0f-3951-432f-b079-4d6ce6e978ec", "fitness": 0.02105147618636375, "name": "AQIDE", "description": "Enhance exploration by dynamically adjusting mutation factor scaling throughout the budget usage.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.1, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.007103542837309185, 0.004352069794753222, 0.005963440751970195, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.054389007219482255, 0.04997654884961189, 0.03074750277325855, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04664770644990446, 0.045516412078639656, 0.043960105705815655, 0.08953102916605993, 0.08977858177878817, 0.08131475748082584, 0.02987005015382216, 0.025308448664646988, 0.025438163078575826, 0.0797526991470463, 0.07560099899552175, 0.06943943046351286, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014456846748867491, 0.017254111599251054, 0.014775866957151718, 0.012890157438917083, 0.01376932123152419, 0.011847690591711979, 0.12346739185528455, 0.1348001042091701, 0.12210212548372457, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "bb451f7c-cb5f-434e-9a67-61b79075c117", "fitness": 0.021409646204788104, "name": "AQIDE", "description": "Refine adaptive mutation factor scaling by further enhancing dynamic population adjustment for improved exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            # Change: Enhanced dynamic population reduction\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.012123418531849284, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047843248403705685, 0.0500118774287488, 0.04093216819341594, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04407100706897449, 0.04600203413373127, 0.04313969012716712, 0.08956157273102594, 0.0904755761704219, 0.08158671412459095, 0.03659867871476463, 0.02741094782140996, 0.021377707898759257, 0.08233102309376561, 0.07343546590425132, 0.07316033786626941, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014978574440261738, 0.016548695622262022, 0.015092431975072818, 0.012403494466121101, 0.013419968657041093, 0.011932553062723672, 0.12650789538105534, 0.1291832131925844, 0.13701840564781442, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "10289f34-cc9c-4772-8f15-43b957079c77", "fitness": 0.021173768497877728, "name": "AQIDE", "description": "Slightly increase crossover probability to enhance exploration of the search space.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.95, 0.05), 0.8, 1.0)  # Slight increase in crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.005024094913117172, 0.008660306575560495, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04176702629943818, 0.047681152375003144, 0.03536139808592309, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.043574179777460365, 0.041862122359139775, 0.04402055325209875, 0.08953503429187604, 0.08287463889105595, 0.077121885317192, 0.031471598139513945, 0.02771912002382415, 0.022549771249596562, 0.07866858851481717, 0.07188165471575314, 0.07068632575559153, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.013946625835037807, 0.01565740730373122, 0.016672394459696815, 0.012966828562306687, 0.01310345795883705, 0.01202222783039486, 0.12909911310408018, 0.13275325660752668, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "effe8fac-d6db-4a78-ad0e-a3f661c2dd2d", "fitness": 0.02027988205177876, "name": "AQIDE", "description": "Introduce adaptive crossover rate scaling to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_rate = np.clip(np.random.normal(1 - (self.budget_used / self.budget) * 0.1, 0.05), 0.8, 1.0)  # Adaptive CR\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.008323386136766753, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.035512942646348966, 0.04870845820409442, 0.028172360372033634, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044437789264503924, 0.038754781315147646, 0.037430236959151375, 0.08567422236329747, 0.08675084498152574, 0.07894626690059181, 0.024903629401122562, 0.031617828455057784, 0.02260385211082938, 0.07268585319967913, 0.07415082304115439, 0.073371239207219, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01473678095451525, 0.01455835072368572, 0.015268703476737477, 0.012627990077343165, 0.012403078989468685, 0.011800030583770327, 0.1267470802357804, 0.1340663726309106, 0.12155077941037995, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "8080739f-4bd2-419e-a540-d437946bff78", "fitness": 0.018492640804341827, "name": "AQIDE", "description": "Enhance diversity by dynamically adjusting mutation factor scaling based on the fitness variance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget) * np.var(fitness)  # Adjusted\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004449193888318326, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01884107965664028, 0.03917244759553362, 0.023833338225407563, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046809883517078266, 0.039466457237578356, 0.04336108693136553, 0.0774964761256085, 0.071789976563569, 0.07029400652870976, 0.019157534368976492, 0.01715337864788724, 0.012409634588545493, 0.05865828353587832, 0.05768546936878938, 0.055955503509828586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014382843451098859, 0.015197112635930599, 0.01435711900255543, 0.013411265466821587, 0.013597214463303309, 0.01237551908582446, 0.13144594728677483, 0.13235571931286383, 0.12346582083076851, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "12c33fa1-48a6-4838-b9e4-b2745df898e9", "fitness": 0.02138397861819686, "name": "AQIDE", "description": "Improve diversity and convergence by adjusting mutation factor scaling parameters slightly.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.25, 0.75) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.005472375780156358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05367180528822624, 0.05365459544092521, 0.05409492553926254, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04274031383063415, 0.04148220605946973, 0.042801807733136576, 0.08867035559348424, 0.08697392456172659, 0.0804037952612644, 0.03641578308567883, 0.025448833951984606, 0.025713056440188287, 0.08316856296613384, 0.07545128613913243, 0.07221992384207221, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01455923046251717, 0.017060129059637053, 0.014716819695025696, 0.01258154393488331, 0.014658228100257964, 0.011978736464595019, 0.1301082344716349, 0.12533019109321908, 0.12592196962797197, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a7b10edc-a76c-4b13-a348-c23e29b69f33", "fitness": 0.021420147335650525, "name": "AQIDE", "description": "Adjust the range of F_dynamic to enhance the exploration capability towards the end of the budget.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.9, 0.05), 0.8, 1.0)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.008130142742086344, 0.004347826086956497, 0.0053889391894964556, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04983334826628438, 0.054667873288654856, 0.042035469110091706, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04618651168518695, 0.0493068328984152, 0.041070790199722595, 0.0885479337587074, 0.08853833681917422, 0.08181355959830239, 0.032050393842203095, 0.028185848494836407, 0.02502238900963394, 0.0827702992167586, 0.08282281734720442, 0.0695324992088604, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015489672381268527, 0.01842220192686883, 0.014500902291753603, 0.012970751060289665, 0.013389227983061414, 0.011904894284947232, 0.12264352707291348, 0.1334153432356191, 0.12361010325449795, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "183f669b-d064-42a9-b5b5-e63bd19256cf", "fitness": 0.02157006657983386, "name": "AQIDE", "description": "Adjust the crossover probability to enhance exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 34, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["61855f30-b5c0-4bac-b7a9-f429c779f35a"], "operator": null, "metadata": {"aucs": [0.007986401520239772, 0.004930884123142909, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04225276330027328, 0.04828551233879963, 0.03844338745465936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04707827707136003, 0.040904387103542605, 0.044914907281739636, 0.08758440721018912, 0.08653763115696744, 0.08289226798112936, 0.028698885755343184, 0.0280889532102665, 0.027907332983404975, 0.08106897164809279, 0.08296591169842849, 0.07357140011104968, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014391040737227523, 0.016821710620938624, 0.014792560961482959, 0.013028710801913368, 0.012668085649902072, 0.012106055209214595, 0.12194579938599859, 0.13534797878410787, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6f08ad24-cc80-4c92-8efb-c6b1778eb32d", "fitness": 0.020907466712117902, "name": "AQIDE", "description": "Adjust the mutation strategy dynamically to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["183f669b-d064-42a9-b5b5-e63bd19256cf"], "operator": null, "metadata": {"aucs": [0.007781367795440142, 0.0066795085895149375, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04198673860533897, 0.052041898576423495, 0.045403559014155936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04527077433316351, 0.04507163457330243, 0.040678906784149205, 0.08650175862357101, 0.08324127319897667, 0.08078819843621321, 0.0256886683049109, 0.027294794318416526, 0.025605946867099383, 0.07715786670074654, 0.07493439346752606, 0.08113502074195877, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014239585602331517, 0.015517568363778267, 0.01608911948772751, 0.012844194659656138, 0.013466731811125454, 0.011628409134085804, 0.12272567163859094, 0.1260141692376292, 0.12554984440665762, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "dcad47ff-84f9-4780-85a9-9eb394872a74", "fitness": 0.0213413979805163, "name": "AQIDE", "description": "Refine the crossover mechanism by introducing a dynamic range to the crossover probability for enhanced exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0 - (0.5 * self.budget_used / self.budget), 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - self.budget_used / self.budget)\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["183f669b-d064-42a9-b5b5-e63bd19256cf"], "operator": null, "metadata": {"aucs": [0.005842386095973429, 0.007062622376313388, 0.012643506494089629, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04622743685877584, 0.04640537608681505, 0.046735649208914154, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04448916502603417, 0.04588268940401419, 0.044097753755054536, 0.09381596956486882, 0.08460829326165253, 0.08225044715846119, 0.03394934451303, 0.029045550202555837, 0.022308012214581008, 0.07699543994420877, 0.06611876783667081, 0.0687606645128519, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014421030090529974, 0.01658414464869795, 0.01629728433877886, 0.013288229978727584, 0.013897214247715728, 0.011705514196219124, 0.1205891378120657, 0.11907628120790614, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4e210c42-b00c-4183-8957-f35a1e71a448", "fitness": 0.021762362787666044, "name": "AQIDE", "description": "Refine the adaptive mutation probability to enhance explorative capabilities.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["183f669b-d064-42a9-b5b5-e63bd19256cf"], "operator": null, "metadata": {"aucs": [0.0044304449066040474, 0.004941437335764354, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04979612484017282, 0.04837337137177955, 0.04603096293350539, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04407445554196776, 0.040904387103542605, 0.04929051307984722, 0.08115386426100513, 0.08651308690159865, 0.08788076648861487, 0.024930218839557372, 0.027557777122241278, 0.03389294671129095, 0.07189937439348348, 0.08316605338536787, 0.0760478234183769, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015016115376038863, 0.016861379335887827, 0.015701245908061545, 0.014716778188418989, 0.012673555922332769, 0.013593422098756247, 0.12426546681500716, 0.13534797878410787, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "46fdc017-4bdc-448f-a5b0-df173f66ee38", "fitness": 0.021583883514509343, "name": "AQIDE", "description": "Enhance convergence by adjusting crossover strategy and adaptive mutation probabilities.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.3) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.009773248737366846, 0.004946312586667001, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.061807993854197774, 0.047785779244256976, 0.0313665245554402, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04347768617744929, 0.044103897698587136, 0.03849024538605894, 0.08601384445892812, 0.08976812337282103, 0.08418563981457561, 0.02685895002033789, 0.03165360265369699, 0.024716774000690833, 0.0742731994054937, 0.07304175497015097, 0.07898991850998249, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01636539903310341, 0.015691213655695146, 0.01563772474314251, 0.013790127334126212, 0.015730190514256948, 0.012717036817844751, 0.12371415187095736, 0.1313097039802208, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "fce128d4-6aed-41ed-a301-47dc029635f4", "fitness": 0.020279253441257385, "name": "AQIDE", "description": "Incrementally adapt mutation strength and introduce a memory mechanism for selective trial acceptance. ", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n        self.memory = np.inf  # Additional memory for best fitness\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * ((1 - self.budget_used / self.budget) + 0.1 * (self.memory / min(fitness)))  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n            self.memory = min(self.memory, np.min(fitness))  # Update memory with the best observed fitness\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.0045612375660605275, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.029704559938027453, 0.04839907020615797, 0.03160387659541297, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04401855334285143, 0.04137072607899084, 0.04539411387398373, 0.08105542994410353, 0.08179184298336506, 0.08110317448060511, 0.029884767486251684, 0.031671416344406955, 0.026078664832211107, 0.06396382598225137, 0.06992257472648622, 0.07683286181534388, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015795586411434193, 0.01572705779848249, 0.016090789337830147, 0.015502839723497641, 0.014695497134374569, 0.012733443585957294, 0.11929111250720437, 0.12781520185071926, 0.13075019713756653, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "372cfd58-4c7e-474d-b8d9-2645b1a42279", "fitness": 0.021640144101531367, "name": "AQIDE", "description": "Enhance exploration by dynamically adjusting crossover and mutation rates based on budget usage.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7, 0.95)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.3) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 40, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.016733147788898006, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06393508320743457, 0.04510460698478014, 0.03519198406436208, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044677164373678635, 0.04588268940401419, 0.04033795127395112, 0.08532324210659314, 0.08952317895007256, 0.09118412155581124, 0.031336058956547896, 0.03482149194932982, 0.031329149547485, 0.07391647210611985, 0.0763295338300769, 0.07661365582564272, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015505718948534253, 0.01695827404118322, 0.015691132863086987, 0.013706408089899424, 0.012601508379723625, 0.01366233787098936, 0.1286128835335466, 0.12608595100713937, 0.12867880256440223, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "bb63ee71-6573-4288-82f7-7b755584704a", "fitness": 0.02112016648683894, "name": "AQIDE", "description": "Introduce a more aggressive adaptive mutation probability strategy to boost exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.15, 0.3) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 41, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.005031929962739379, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05309001989123052, 0.04335924505092814, 0.032307562071193785, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044132812571976876, 0.04055249295975527, 0.04542966440287133, 0.0853547063024791, 0.08241593063781294, 0.07967087189112254, 0.029346585841758532, 0.02971514204704373, 0.024866316042604697, 0.07732424314751785, 0.07383389708380061, 0.07173607400403847, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015303613246708592, 0.01555265742781009, 0.01587059139444713, 0.014517955443473674, 0.01382536902354703, 0.013457597370422292, 0.12455621183810439, 0.12722210166343662, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "27658824-2b2d-4539-a795-7608b9aff574", "fitness": 0.021762362787666044, "name": "AQIDE", "description": "Adjust the dynamic population size decay to enhance exploration in early stages.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.05 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.0044304449066040474, 0.004941437335764354, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04979612484017282, 0.04837337137177955, 0.04603096293350539, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04407445554196776, 0.040904387103542605, 0.04929051307984722, 0.08115386426100513, 0.08651308690159865, 0.08788076648861487, 0.024930218839557372, 0.027557777122241278, 0.03389294671129095, 0.07189937439348348, 0.08316605338536787, 0.0760478234183769, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015016115376038863, 0.016861379335887827, 0.015701245908061545, 0.014716778188418989, 0.012673555922332769, 0.013593422098756247, 0.12426546681500716, 0.13534797878410787, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c7452ed1-4b12-4855-8573-092f5d7af5db", "fitness": 0.021583883514509343, "name": "AQIDE", "description": "Refine the adaptive mutation probability and crossover strategy for improved diversity and performance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.3) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 43, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.009773248737366846, 0.004946312586667001, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.061807993854197774, 0.047785779244256976, 0.0313665245554402, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04347768617744929, 0.044103897698587136, 0.03849024538605894, 0.08601384445892812, 0.08976812337282103, 0.08418563981457561, 0.02685895002033789, 0.03165360265369699, 0.024716774000690833, 0.0742731994054937, 0.07304175497015097, 0.07898991850998249, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01636539903310341, 0.015691213655695146, 0.01563772474314251, 0.013790127334126212, 0.015730190514256948, 0.012717036817844751, 0.12371415187095736, 0.1313097039802208, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "87772a32-df38-4323-9f10-5db4c6299b4f", "fitness": 0.021513997138961696, "name": "AQIDE", "description": "Introduce additional adaptive mutation strategies for improved diversity.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.25) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.00943689446849516, 0.004794347157836998, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.053723114358541935, 0.0444005253383587, 0.04651913489151904, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04449873641609414, 0.0389300687079871, 0.039164776167470716, 0.08536809263669132, 0.08448027707522221, 0.0917044524721784, 0.028970481938342285, 0.02579667632005267, 0.03162766201356604, 0.07654963514419255, 0.07609397907182569, 0.07878670606178428, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015377460015440492, 0.01566483918517947, 0.015901575385260602, 0.01442500537503566, 0.01271415009842558, 0.012717124015990677, 0.12025224951494184, 0.12327926052618465, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "63ea233c-00a9-47c4-abc9-29f3cc72e431", "fitness": 0.021352604755326424, "name": "AQIDE", "description": "Enhance exploration by augmenting crossover probability dynamics.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004550712777637744, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05473287167881824, 0.047643797468738924, 0.03063757308345727, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04600591411723842, 0.03754986078782829, 0.04911209336264988, 0.08180995968639482, 0.08603900534069986, 0.08459750014824208, 0.029087271913790347, 0.0281330369906162, 0.023088911839686976, 0.06416827873579867, 0.08486128664975812, 0.07466827463559822, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01527761716951237, 0.01770973630459327, 0.015829942118296914, 0.014872223914189853, 0.014162964901845543, 0.012718503470916964, 0.12803384932933404, 0.12991796022227908, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "88be3ea6-2029-43f7-9eaf-4f53cb862df3", "fitness": 0.020663033682819538, "name": "AQIDE", "description": "Enhance AQIDE by making crossover probability dynamically adaptive based on budget usage.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(np.random.normal(1.0, 0.05) * (1 - self.budget_used / self.budget), 0.8, 1.0)  # Dynamic crossover probability\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 46, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005372028199034484, 0.006172053559921675, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03892331064943155, 0.044039622190850336, 0.03524419041484439, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04578732167088395, 0.047364501900601486, 0.03838755830995966, 0.08808383122741759, 0.08648139135219779, 0.08401739904498717, 0.03034320476063712, 0.027559537538319745, 0.027205004375331576, 0.06284489815192296, 0.07138452658843408, 0.08335818016513041, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015246155823846474, 0.015073607187246929, 0.016365880570031632, 0.012470045966102905, 0.014160387450331768, 0.01371987121014906, 0.11886939828117882, 0.1299737695094102, 0.1292907490648042, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "940299ad-50c6-4b4d-8931-5c5df5032413", "fitness": 0.02044738145732916, "name": "AQIDE", "description": "Introduced an adaptive crossover probability to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                adaptive_CR = np.clip(np.random.normal(1.0 - self.budget_used / self.budget, 0.05), 0.8, 1.0)  # Adaptive crossover\n                crossover = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 47, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005366266237049722, 0.006172053559921675, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03892331064943155, 0.03992146045744993, 0.03524419041484439, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04323562918237178, 0.047364501900601486, 0.03838755830995966, 0.08808383122741759, 0.08772864020970272, 0.08401739904498717, 0.02781748157495645, 0.027941756057154765, 0.027205004375331576, 0.06111584776612078, 0.07138452658843408, 0.08335818016513041, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015246155823846474, 0.015073607187246929, 0.016365880570031632, 0.012470045966102905, 0.014160387450331768, 0.01371987121014906, 0.1194266326685074, 0.12319049726581466, 0.1292907490648042, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f27cfaf1-49fa-45f2-bbab-b0b26e8a38f5", "fitness": 0.021556164073673865, "name": "AQIDE", "description": "Introduce a dynamic adjustment of crossover probability to elevate exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05 + 0.1 * (self.budget_used / self.budget)), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 48, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004784393851530622, 0.007314676178931334, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05098090011936596, 0.047681187478085696, 0.04289473065583149, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04470856834570658, 0.044177068073095294, 0.049285639052352614, 0.08072500396314608, 0.08311161381088839, 0.09127900998779792, 0.0258056153104953, 0.026620480863519425, 0.03555966389759424, 0.06767151990665621, 0.0822176612488612, 0.07690070481329314, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01530230352873485, 0.017736001787149847, 0.016362621405243027, 0.015329488237785793, 0.012613929578469407, 0.01295734517085878, 0.11946893631439959, 0.12272418007610164, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2509fc9c-09c7-4de6-881c-9de82045f23c", "fitness": 0.021762362787666044, "name": "AQIDE", "description": "Enhance exploration and convergence by adjusting population size decay and introducing budget-aware diversity injection.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.05 * (self.budget_used / self.budget))))  # Adjust population decay\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.0044304449066040474, 0.004941437335764354, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04979612484017282, 0.04837337137177955, 0.04603096293350539, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04407445554196776, 0.040904387103542605, 0.04929051307984722, 0.08115386426100513, 0.08651308690159865, 0.08788076648861487, 0.024930218839557372, 0.027557777122241278, 0.03389294671129095, 0.07189937439348348, 0.08316605338536787, 0.0760478234183769, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015016115376038863, 0.016861379335887827, 0.015701245908061545, 0.014716778188418989, 0.012673555922332769, 0.013593422098756247, 0.12426546681500716, 0.13534797878410787, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "040f5739-c2c2-4b52-9857-08e0531234f6", "fitness": 0.02064455302987653, "name": "AQIDE", "description": "Adding enhanced adaptability through dynamic crossover rate and early stopping for performance improvement.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                dynamic_cr = np.clip(np.random.normal(1.0, 0.05), 0.6, 1.0)  # Enhanced dynamic crossover probability\n                crossover = np.random.rand(self.dim) < dynamic_cr\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n            \n            # Early stopping based on convergence\n            if np.std(fitness) < 1e-8:\n                break\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 50, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004449935871191912, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03185097847642737, 0.045917607384181935, 0.039810679604423416, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04466964529402029, 0.04236344450741725, 0.04151640197752493, 0.09108862210243684, 0.08265774808700832, 0.08190437509710213, 0.030869862450218277, 0.0263112494846911, 0.021184881085007712, 0.06645811242947397, 0.07625394863718538, 0.08351871038872594, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01491047211103036, 0.014431448837249117, 0.014725092788266947, 0.012921602657217535, 0.01243861986293815, 0.012572077534256265, 0.1301042437586365, 0.13016665371116898, 0.12896357792635416, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "426f3367-f5a4-44cf-8c9e-c7fc7cfad171", "fitness": 0.021127687880296713, "name": "AQIDE", "description": "Introduce a small tweak to mutation probability adaptation to further enhance convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.15, 0.25) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.006199965984797107, 0.005577693762835234, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.053234954572252025, 0.040879028543215234, 0.03892493889578719, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04449873641609414, 0.03909355157609762, 0.04530071952486314, 0.0847420895720552, 0.0872643881049413, 0.07503029868067601, 0.027755705917472895, 0.025759839705490006, 0.021970407886258703, 0.07901875873242903, 0.07563582865930607, 0.07414788944701622, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015377458394154386, 0.015056299417738339, 0.015838174889113543, 0.014677255788122623, 0.01309878564108713, 0.014722958280655285, 0.12628962070772598, 0.12326760863255526, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2141a9e2-4cf5-4865-a95a-1778d8dd1557", "fitness": 0.020475549584430524, "name": "AQIDE", "description": "Enhance convergence by adapting crossover probability based on budget utilization.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                CR_dynamic = np.clip(self.CR - 0.5 * (self.budget_used / self.budget), 0.7, 1.0)  # Adaptive crossover probability\n                crossover = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.006188720973605011, 0.005999519633826278, 0.009323333199943162, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03314343966094402, 0.04692751851765353, 0.029899261417542844, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.043235198574827605, 0.04171113091446965, 0.038301253036292615, 0.08192463204086131, 0.0836311726510065, 0.08386373446793638, 0.03019773655240432, 0.030489372220619093, 0.026633324242268608, 0.07308911523986072, 0.061381899570169374, 0.06942674167403073, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017607929395121125, 0.01585355553753587, 0.015380224423498179, 0.014368211735460878, 0.013712168960820725, 0.016621972367824034, 0.1308357824485722, 0.1263164866975155, 0.13252396001134492, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6f61685a-981b-42bf-9e5b-81c0ff058e4f", "fitness": 0.02145803784485936, "name": "AQIDE", "description": "Adjust the mutation scaling factor and population size more dynamically to enhance exploration and convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Adjusted dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.7) * (1 - 0.5 * (self.budget_used / self.budget))  # Adjusted adaptive F\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005935278246609443, 0.009753511151150307, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04897032497968279, 0.05175648871919436, 0.04533468975117039, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04592172609718881, 0.04220967774857676, 0.036455215153915366, 0.08477613373159842, 0.08606024183463623, 0.09589662929855158, 0.029734568261677197, 0.03202704733900863, 0.03269108990895775, 0.07387171651103874, 0.07848988088987074, 0.07092193014170056, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016792681824455702, 0.01684531682787238, 0.015072134375104795, 0.016065359182436234, 0.012909967238814324, 0.013050957813053432, 0.12215348118183478, 0.12654792795684644, 0.13473474866492896, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "db1cccc1-a5d5-4d3c-9fab-f605eab8f1dc", "fitness": 0.020009401841046708, "name": "AQIDE", "description": "Introduce dynamic adjustment to crossover probability and enhance mutation diversity to improve exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(np.random.normal(1.0, 0.1), 0.5, 1.0) * (1 - self.budget_used / self.budget)  # New dynamic crossover\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.3) * (1 - self.budget_used / self.budget)  # Increased mutation diversity\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005022521492416887, 0.00760058823404508, 0.006257994739577444, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03766675533989028, 0.039302917372400215, 0.02650126825275534, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04569979903658461, 0.04780168448949418, 0.04302925217124187, 0.08620173383541951, 0.08347585551925563, 0.07505429522717322, 0.023888506743648175, 0.026283688154108975, 0.019938648768689116, 0.06824003091261621, 0.06498308137901598, 0.07058993366796229, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016089266910165434, 0.013975459360444309, 0.01794669537897453, 0.01444490702546053, 0.013378887915478588, 0.011715937283163447, 0.12511494188020955, 0.1268666051294769, 0.12795350242265247, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3fc7631b-c8e1-4df6-a7a5-dfb2fd450cad", "fitness": 0.020806225196429454, "name": "AQIDE", "description": "Utilize dynamic control of crossover probability to further fine-tune exploration and exploitation balance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0 - self.budget_used / self.budget, 0.05), 0.5, 1.0)  # Dynamic crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 55, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.009477265594901585, 0.006238676257253717, 0.004459442868079977, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05251358189175659, 0.043585528096481974, 0.029309370967647408, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04273663354238744, 0.041460491283158096, 0.041405583012514735, 0.08707421627104228, 0.08548628453131912, 0.08247390149781109, 0.028773690263536267, 0.02539686308245581, 0.026669754367661724, 0.06688925288923375, 0.07229110137674233, 0.06537298742005926, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016271463665132657, 0.014165049151396936, 0.015102360776477752, 0.018735124462533004, 0.013932112991650869, 0.012969679141812018, 0.1311048208247534, 0.13263549890363213, 0.1358653050984462, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6ccaca96-29e4-4ee6-a840-989eb8bdecf3", "fitness": 0.021231981241422893, "name": "AQIDE", "description": "Enhance adaptive crossover probability to improve exploitation phase.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.95, 0.05), 0.8, 1.0)  # Enhanced crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 56, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005796651572405387, 0.008770662865447698, 0.004521389610534388, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04417308666185915, 0.04725356596623709, 0.03465858797266441, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04408424446145809, 0.04104616825678664, 0.04111455996756819, 0.08384608267255167, 0.08301907822592514, 0.09311200852922141, 0.03230638408565334, 0.027864388897872572, 0.0316653806620687, 0.060257008901505094, 0.07188165471575314, 0.07196703764501111, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015733422638702588, 0.01561980616526093, 0.01518922694902003, 0.013789199043215294, 0.01310215465629927, 0.012699331516224821, 0.12899556657400835, 0.13275325660752668, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3cd7a502-7318-493c-9b72-e3acb36ee671", "fitness": 0.020921307768438174, "name": "AQIDE", "description": "Fine-tune dynamic mutation scaling and crossover probability to enhance convergence while adhering to the budget.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.85, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.009445524958095586, 0.007093420252062721, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05567990831568903, 0.051501732140143974, 0.04433040071271621, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04370061106195189, 0.04914263793567741, 0.04030050804951779, 0.08225224431737999, 0.08388204850186398, 0.0802649909466383, 0.02405364788271369, 0.02836635649212904, 0.024306189261642852, 0.06288575731318835, 0.07230671718464488, 0.06932498546579702, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015489327916484164, 0.016686365957332305, 0.015600758835638051, 0.016070276114415916, 0.014440731575231958, 0.013315428564649179, 0.1286017417897336, 0.12700590916571208, 0.13028593861649973, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "96e6e623-70f8-477d-973b-a2cc074583c1", "fitness": 0.02111384981534891, "name": "AQIDE", "description": "Introduce dynamic crossover and mutation adaptation based on fitness variance to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                fitness_variance = np.var(fitness)  # Calculate fitness variance\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05 + 0.5 * fitness_variance), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.007796003435267429, 0.005326653467948139, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04712394385801322, 0.041529814059356074, 0.04579927487267088, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04447294402496338, 0.04239886519509861, 0.04274013482754213, 0.08148673771160375, 0.08130059420482916, 0.08987124372285904, 0.026615965946531706, 0.02414095392785265, 0.029972864674105093, 0.06865592229283535, 0.07473619469566217, 0.07032854481356221, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015152428752879366, 0.017252898375619052, 0.017459593387659234, 0.01437938176862752, 0.013692987179921623, 0.013271877877563676, 0.12237728841243822, 0.12448350557108812, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "39941e8c-b442-43d7-bfa7-3cc172dde2a2", "fitness": 0.020828080420153505, "name": "AQIDE", "description": "Introduce dynamic crossover rate to enhance solution diversity and adaptability.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0 - (self.budget_used / self.budget), 0.05), 0.8, 1.0)  # Dynamic crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.006353778007540667, 0.005841744088567191, 0.0044860137150595225, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04441073359481995, 0.04756237573992761, 0.03876114920881368, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.043509436675763236, 0.048215572613712565, 0.03525074734658129, 0.0840978552069539, 0.08507011922649976, 0.08691470799235523, 0.021471697100296505, 0.023377477697534177, 0.030998521608745055, 0.07334565968902063, 0.0751727364072563, 0.06893644495553308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01612445391425943, 0.01602662660650689, 0.016621461972260776, 0.015656758721393826, 0.01458415014095149, 0.013683754507526014, 0.12778005560148586, 0.12811637140681809, 0.13159921259182716, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "922f054f-755f-4d15-a43b-6285a4d08052", "fitness": 0.021352604755326424, "name": "AQIDE", "description": "Refine the AQIDE algorithm by optimizing mutation and crossover parameters for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7, 1.0)  # Modified crossover probability range\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004550712777637744, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05473287167881824, 0.047643797468738924, 0.03063757308345727, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04600591411723842, 0.03754986078782829, 0.04911209336264988, 0.08180995968639482, 0.08603900534069986, 0.08459750014824208, 0.029087271913790347, 0.0281330369906162, 0.023088911839686976, 0.06416827873579867, 0.08486128664975812, 0.07466827463559822, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01527761716951237, 0.01770973630459327, 0.015829942118296914, 0.014872223914189853, 0.014162964901845543, 0.012718503470916964, 0.12803384932933404, 0.12991796022227908, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "559c9651-0ea1-4ae0-b2e8-ab777c477a19", "fitness": 0.021374532930774317, "name": "AQIDE", "description": "Enhance adaptive mutation probability by introducing dynamic crossover rates tuned to population diversity.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic rates based on diversity\n                diversity = np.std(population, axis=0).mean()\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05) + diversity, 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.00884609520998425, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.048479180283422685, 0.04933729659365482, 0.04239427878490598, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0454541218177249, 0.042914577442896396, 0.04530795204679827, 0.07983565707328133, 0.08574886896963219, 0.08387303557001347, 0.02694121993843257, 0.028678594602986718, 0.026088722326444214, 0.06364951243473083, 0.07294906289624847, 0.08112493582088431, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015006834794942248, 0.01731495847507658, 0.015694863214895327, 0.013986429094297592, 0.012925291098024316, 0.013427870703642042, 0.12477832447854609, 0.13203029160870516, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9d92b60d-4ea6-4775-a650-44ae4a2055e4", "fitness": 0.02163505733682761, "name": "AQIDE", "description": "Enhance mutation diversity by altering dynamic factors.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.4, 0.9) * (1 - self.budget_used / self.budget)  # Adjusted adaptive F, extended range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004978404921245461, 0.007841646029435267, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04410467049433775, 0.051526359907577146, 0.047537554866413534, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04631803401360002, 0.04933179733414006, 0.0424458007009223, 0.08742495268763373, 0.08298771288890172, 0.09042398090910597, 0.029075472232854005, 0.02946349700046702, 0.03372146569661716, 0.06457106122106615, 0.07517672956016397, 0.07138328721665399, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015868649500980547, 0.016391390677930717, 0.015204657026836932, 0.015459044642157194, 0.012876922893954257, 0.012963883444906843, 0.12356967591875101, 0.14484633831733285, 0.14223113814760335, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4e2fcf4e-3342-4623-9b1b-3c867da50fe6", "fitness": 0.021705836373418497, "name": "AQIDE", "description": "Introduce a decaying factor for mutation probability to maintain diversity throughout the search.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                adaptive_prob_mutate *= (1 - self.budget_used / (2 * self.budget))  # Decaying factor for mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.007986401520239772, 0.004930884123142909, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04225276330027328, 0.04828551233879963, 0.03770129952230683, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04707827707136003, 0.040904387103542605, 0.044914907281739636, 0.08758440721018912, 0.08653763115696744, 0.08365657298900009, 0.028698885755343184, 0.0280889532102665, 0.029436116624669495, 0.08106897164809279, 0.08296591169842849, 0.08053627075595848, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014391040737227523, 0.016821710620938624, 0.015899467866155814, 0.013028710801913368, 0.012668085649902072, 0.012258702080943817, 0.12194579938599859, 0.13534797878410787, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d2d7ab8e-32e7-48cb-98d1-d1e461e3c213", "fitness": 0.021513997138961696, "name": "AQIDE", "description": "Implement slight increase to the explorative mutation probability to enhance diversification.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.25) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.00943689446849516, 0.004794347157836998, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.053723114358541935, 0.0444005253383587, 0.04651913489151904, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04449873641609414, 0.0389300687079871, 0.039164776167470716, 0.08536809263669132, 0.08448027707522221, 0.0917044524721784, 0.028970481938342285, 0.02579667632005267, 0.03162766201356604, 0.07654963514419255, 0.07609397907182569, 0.07878670606178428, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015377460015440492, 0.01566483918517947, 0.015901575385260602, 0.01442500537503566, 0.01271415009842558, 0.012717124015990677, 0.12025224951494184, 0.12327926052618465, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "eb1e8d5d-a4b0-4a69-9881-4d7b77a21515", "fitness": 0.020321895760098654, "name": "AQIDE", "description": "Enhance AQIDE by adjusting crossover probability dynamically based on the budget used.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(0.8 + 0.2 * (self.budget_used / self.budget), 0.8, 1.0)  # Dynamic crossover probability\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 65, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.032645128318605, 0.04201688809006743, 0.039500491616614175, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0447121490467941, 0.03973270424638797, 0.03825862712860373, 0.08608707653964032, 0.08154024980003172, 0.07876521997819008, 0.029866270693321595, 0.03259025997139964, 0.021954446010809425, 0.07194508388169951, 0.06832142043152578, 0.0765137465125808, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016990625067494713, 0.016895198590542115, 0.01621139695599738, 0.013361424199865524, 0.013698895095358599, 0.01657468542923346, 0.12408036138249312, 0.12678456132423643, 0.12543393224169852, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "dedb1683-6fd2-4de9-86e7-30d7107c332a", "fitness": 0.020828839800124295, "name": "AQIDE", "description": "Introduce adaptive crossover probability and dynamic mutation range to enhance exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.1, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005165698093072657, 0.004910447839665766, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05333555362242226, 0.047916047114480276, 0.03504266566138614, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04276599314007978, 0.04479787391351253, 0.042394074823675854, 0.08113726337238902, 0.08729570578021018, 0.08710754927268993, 0.02486773810936338, 0.025402543546099055, 0.023790318460574666, 0.06526750532682057, 0.07701730507319426, 0.07775119488569293, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01528620270908232, 0.017020494369966, 0.01579915128176068, 0.015094053252211359, 0.013652349996179591, 0.01263868296509385, 0.12823413843454334, 0.12533176533306079, 0.13065414923172314, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "72830c9e-3724-4328-ba8b-18347932d9ee", "fitness": 0.020662691355115247, "name": "AQIDE", "description": "Enhance exploration by modifying the dynamic scaling factor F and ensuring all dimensions are considered in crossover.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                crossover = np.ones(self.dim, dtype=bool)  # Ensure all dimensions are considered\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04813715905595428, 0.05131572026303821, 0.038838743460097414, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04301283805094158, 0.04061695644651675, 0.04452149795640459, 0.08203952480159249, 0.08566024462962207, 0.08136296197119997, 0.02474925540095063, 0.025626577917143623, 0.02585847820160203, 0.06594556894751813, 0.07630317871157677, 0.07733105952395214, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014987850743940379, 0.015667315644890323, 0.01519796345553659, 0.015074097501853068, 0.013128404848925634, 0.012591956587304165, 0.12981524061135463, 0.12094959204597078, 0.13028593861649973, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b57b0bb5-a57d-4eb0-aafa-dba853f3b7ee", "fitness": 0.02149961433624432, "name": "AQIDE", "description": "Enhance exploration by adjusting population and mutation dynamics adaptively.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.7) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.3) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.008411700191935045, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05298697028786681, 0.0516238443922441, 0.0438518750560567, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04484232250841047, 0.04116871382486398, 0.04147564122486469, 0.08594669575478153, 0.0898297993992655, 0.09119224704139095, 0.024576204871573526, 0.028808192775312547, 0.03115183672485966, 0.07619060705803082, 0.07990113745370453, 0.07100943600239429, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015394831304256451, 0.014680872569610814, 0.015701498705256944, 0.014734761218414216, 0.013029222365253612, 0.01370430387344157, 0.13509332707481514, 0.12997005414081253, 0.12834831030321925, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6096ede9-4400-4271-a648-fd91ca36ccc9", "fitness": 0.021659722723565002, "name": "AQIDE", "description": "Utilize a more dynamic crossover adaptation to enhance both exploration and exploitation.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.95, 0.02), 0.85, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 69, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005845905557913422, 0.005618029836631178, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06398437969028592, 0.0523713811264126, 0.03363930682434968, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05343181524665497, 0.04588268940401419, 0.04496164694291738, 0.08408500141043251, 0.08378041122125657, 0.09574518572168467, 0.027327927139638275, 0.022822270199764794, 0.03652161274127119, 0.06264853805720905, 0.07643713213166892, 0.07354132736119567, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01614079701398974, 0.015325609985601507, 0.015199615340063088, 0.013903333985743171, 0.012993392781903812, 0.013206345548467557, 0.12285326127013607, 0.12340254990885047, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d3948a0b-4fe6-4481-ac98-b7b42725b41d", "fitness": 0.02064455302987653, "name": "AQIDE", "description": "Introduce a stochastic element to the crossover process to enhance diversity.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(np.random.normal(1.0, 0.05), 0.7, 1.0)  # Modified crossover probability\n                crossover = np.random.rand(self.dim) < crossover_prob  # Introduce stochastic element\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 70, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004449935871191912, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03185097847642737, 0.045917607384181935, 0.039810679604423416, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04466964529402029, 0.04236344450741725, 0.04151640197752493, 0.09108862210243684, 0.08265774808700832, 0.08190437509710213, 0.030869862450218277, 0.0263112494846911, 0.021184881085007712, 0.06645811242947397, 0.07625394863718538, 0.08351871038872594, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01491047211103036, 0.014431448837249117, 0.014725092788266947, 0.012921602657217535, 0.01243861986293815, 0.012572077534256265, 0.1301042437586365, 0.13016665371116898, 0.12896357792635416, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "69034fd5-8e6d-4433-add8-075a536d32e1", "fitness": 0.02142994638704795, "name": "AQIDE", "description": "Adjust the crossover probability to enhance diversity and convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.15), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.00812299202905531, 0.004593570151092186, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05437164252830762, 0.0445860500919103, 0.032029475617358805, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046356706099222045, 0.04411933735101947, 0.04361677789755891, 0.08159833926792726, 0.08422643067779456, 0.08220336108353787, 0.026829632897245936, 0.030195430332735973, 0.02650893422569156, 0.07112665182599365, 0.07967666396890105, 0.06932720293756134, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016689215668740487, 0.016729513672755658, 0.01600857801507194, 0.014795820064007814, 0.013060017331728346, 0.012574045200123729, 0.13340685571581368, 0.13237232556767342, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e14e6204-9451-4b36-97c6-1268e4599671", "fitness": 0.021222387720453446, "name": "AQIDE", "description": "Refine adaptive crossover mechanics to improve convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.95, 0.05), 0.85, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005796651572405387, 0.008770662865447698, 0.004521389610534388, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04417308666185915, 0.04725356596623709, 0.03465858797266441, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04408424446145809, 0.04104616825678664, 0.04111455996756819, 0.08384608267255167, 0.08301907822592514, 0.09311200852922141, 0.03230638408565334, 0.027377797154424344, 0.0316653806620687, 0.060257008901505094, 0.07188165471575314, 0.07196703764501111, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015733422638702588, 0.015569411101203356, 0.01518922694902003, 0.013789199043215294, 0.012948407954004981, 0.012699331516224821, 0.12899556657400835, 0.13275325660752668, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0a7dff1b-efda-4cef-8e58-32a4f2c225a2", "fitness": 0.021211579764484678, "name": "AQIDE", "description": "Further tune mutation and crossover for enhanced adaptability.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.7) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.95, 0.05), 0.85, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.008658602359656875, 0.008618032695081101, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044019099151563434, 0.04939538040379765, 0.03912254235021795, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04805346206593131, 0.04486725613835685, 0.04364423968350606, 0.08813313513026655, 0.09127838537882382, 0.08787081443672817, 0.026685952902025134, 0.03073276258760338, 0.028841849546113463, 0.06659931589884793, 0.072354050162312, 0.069075602095228, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015452372774786172, 0.015544108623858577, 0.015974763085345733, 0.013941660571094916, 0.01340558448984841, 0.0126724677058766, 0.13509332707481514, 0.12690030769596183, 0.13029866803525103, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1de381eb-ccf2-4d09-832c-c9a6f54b8501", "fitness": 0.0208653948992046, "name": "AQIDE", "description": "Enhance diversity by refining the mutation strategy and improving crossover influence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.00944551170965291, 0.006263044020875075, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05567990831568903, 0.051501887038981065, 0.04433040071271621, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04595232219103351, 0.04061703092946234, 0.04030050804951779, 0.08225224431737999, 0.08874868423493909, 0.07988988148029563, 0.022105413536077645, 0.025252862787960906, 0.024306189261642852, 0.06288575731318835, 0.07268122380714048, 0.06932498546579702, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015493499459996785, 0.016686365957332305, 0.015735274310036962, 0.01607045130166751, 0.014504674921338556, 0.013315717285330986, 0.1291632080244315, 0.129515447693748, 0.13028593861649973, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b79006d9-becd-425f-8142-7b389b5f1512", "fitness": 0.020996116966475888, "name": "AQIDE", "description": "Adjust mutation factor and crossover probability to enhance exploration and convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.00944551170965291, 0.0073458585408461285, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05567990831568903, 0.051501887038981065, 0.04433040071271621, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04595232219103351, 0.04914263793567741, 0.04030050804951779, 0.08225224431737999, 0.08874868423493909, 0.0802649909466383, 0.022105413536077645, 0.02609096741482453, 0.024306189261642852, 0.06288575731318835, 0.07230671718464488, 0.06932498546579702, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015493499459996785, 0.016686365957332305, 0.015600758835638051, 0.01607045130166751, 0.014504674921338556, 0.013315428564649179, 0.1291632080244315, 0.1286151117354647, 0.13028593861649973, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "222f33fc-37f9-4fc0-a412-6e296b9ae983", "fitness": 0.020484384769605696, "name": "AQIDE", "description": "Incorporate a self-adaptive learning rate in mutation to enhance convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                F_dynamic *= np.random.uniform(0.9, 1.1)  # Self-adaptive learning rate\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.010436052717796351, 0.004549351414019465, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04097945734318609, 0.04547965616199734, 0.03428800832609502, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0447287506231312, 0.039387858263523756, 0.05143420327731307, 0.08990576423654584, 0.08855114697767619, 0.07752212700026306, 0.027952945759055492, 0.023931874430146438, 0.020696462837007212, 0.0666766846311565, 0.06859810154041424, 0.07249408512265842, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016392704113070478, 0.01497582763663885, 0.015639485059740776, 0.016447550321034954, 0.012834013033775293, 0.012424297963725017, 0.11927137306139568, 0.1307691211378772, 0.12850880042236756, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "02138a05-8e8e-4d62-91eb-825f0994fff0", "fitness": 0.021224905811465713, "name": "AQIDE", "description": "Introduce adaptive crossover probability and a new dynamic scaling factor to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.9) * (1 - self.budget_used / self.budget)  # Adjusted dynamic F range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05 + 0.1 * (self.budget_used / self.budget)), 0.8, 1.0)  # Adaptive crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.008877202968633924, 0.009960373242610898, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05332346038975888, 0.051400860508866275, 0.042716558762957324, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04394343923010724, 0.04928909406799975, 0.037867586769304906, 0.08297287146530696, 0.08610585734761589, 0.08588122969964429, 0.022352482255335482, 0.02589047611970341, 0.03207407268364959, 0.06717451045016343, 0.08149514187808182, 0.06990872294427886, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015658458558156507, 0.015844802221754217, 0.015511885312150309, 0.01724403440365696, 0.012985299573606501, 0.013279586994391024, 0.12882784005530923, 0.127321431905989, 0.13028593861649973, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1b85a906-f0a4-450a-a09a-798bf4f109d8", "fitness": 0.020803691726482672, "name": "AQIDE", "description": "Modify the adaptive mutation and dynamic population size scaling to improve convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)**2  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.0045091295623024275, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046029947041017594, 0.0501931559604335, 0.039111850903349676, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046385861019312746, 0.03939100627091352, 0.047910550004853225, 0.08471739013753488, 0.08153419618699453, 0.08741125970243024, 0.02701227141178697, 0.025539043981149145, 0.032108221521662594, 0.0664954804903024, 0.06992417579293242, 0.0786088644308871, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015221419663405511, 0.01615667804003329, 0.015393429539739878, 0.01450315690559456, 0.013638163465492847, 0.013346760067881935, 0.12510588185658478, 0.12235586365467088, 0.1309142206085302, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f69df894-1277-4b24-a726-69ca0d9a6a60", "fitness": 0.0212760530242625, "name": "AQIDE", "description": "Enhance exploration with adaptive mutation scaling and diversified crossover strategies.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.3, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7, 0.95)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 79, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.0061398960428279414, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05956552255972014, 0.04948467497813214, 0.041366026539399026, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05445415442237944, 0.039336390639604035, 0.0438562368544837, 0.08795353351033941, 0.08475901737789926, 0.08856167729692976, 0.028836191219070995, 0.029996636019424594, 0.03297121675982273, 0.06312113215231818, 0.07162496745858526, 0.07843638637122374, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015399586750752037, 0.015581625223304862, 0.015821870479031053, 0.014326912613751741, 0.012726917139374128, 0.012381908510406325, 0.1266481888023232, 0.12221804543800763, 0.1319592765008334, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "72e8e09b-2dd0-45cb-892f-36f3ae7619c1", "fitness": 0.021222387720453446, "name": "AQIDE", "description": "Refine the adaptive crossover mechanism to enhance exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.95, 0.05), 0.85, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005796651572405387, 0.008770662865447698, 0.004521389610534388, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04417308666185915, 0.04725356596623709, 0.03465858797266441, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04408424446145809, 0.04104616825678664, 0.04111455996756819, 0.08384608267255167, 0.08301907822592514, 0.09311200852922141, 0.03230638408565334, 0.027377797154424344, 0.0316653806620687, 0.060257008901505094, 0.07188165471575314, 0.07196703764501111, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015733422638702588, 0.015569411101203356, 0.01518922694902003, 0.013789199043215294, 0.012948407954004981, 0.012699331516224821, 0.12899556657400835, 0.13275325660752668, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c89f515b-9e27-4759-ae6d-c7c50a171443", "fitness": 0.020920512142310818, "name": "AQIDE", "description": "Enhance AQIDE by dynamically adjusting crossover rates to improve exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                dynamic_CR = np.clip(np.random.normal(0.5, 0.05), 0.4, 0.6)  # Dynamically adjusted crossover probability\n                crossover = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.00453259658167493, 0.010809465632973914, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004350058866962381, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0477791610277567, 0.0395415051190372, 0.02888834994404521, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.049411153869819646, 0.05060327921428709, 0.04558346729433127, 0.09121570254663847, 0.08817457229072234, 0.08331646183499009, 0.0343696194023454, 0.02421020754816361, 0.02438732109401487, 0.07018771764911624, 0.07827768203457197, 0.07020911852627465, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014515031209117568, 0.015351113300262287, 0.01648798310363042, 0.014415798759521148, 0.013308685164466483, 0.012340163322644537, 0.12304357529174403, 0.12662218801114, 0.128692721693084, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ff2c6979-3b18-432d-8558-f374693f3cfd", "fitness": 0.02076504091337235, "name": "AQIDE", "description": "Introduce an additional adaptive strategy to tweak crossover probabilities for enhanced performance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(np.random.normal(1.0 - 0.1 * (self.budget_used / self.budget), 0.05), 0.8, 1.0)  # Adaptive crossover probability\n                crossover = np.random.rand(self.dim) < crossover_prob  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.005338105460952258, 0.005462511644551915, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.038573820346606946, 0.04686099034766866, 0.044287577145385004, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04923636866274417, 0.04211386970500697, 0.04150796940078416, 0.08835316066114307, 0.08091816190663548, 0.08184882954138306, 0.02950588606176474, 0.026474218189541876, 0.02132383140995686, 0.07058813209077686, 0.07023735804463227, 0.08446018911274877, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015497567375218568, 0.015301186206968631, 0.01514185908379706, 0.01272894152921522, 0.013285772959607645, 0.01311936628534005, 0.12776262299652807, 0.12324405827566964, 0.13191059131818206, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "63361a11-ea7e-471b-92b7-c810d6cb5fa1", "fitness": 0.0219955623642927, "name": "AQIDE", "description": "Slightly increase the exploration by changing the dynamic population factor to enhance adaptability.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["4e210c42-b00c-4183-8957-f35a1e71a448"], "operator": null, "metadata": {"aucs": [0.0050202140481037105, 0.004670363583221371, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04979612484017282, 0.049313615196053484, 0.04519788998562757, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04311063042958019, 0.04082769661413577, 0.04929051307984722, 0.08474329364964639, 0.08477981387327072, 0.09412389164798951, 0.02787392634498964, 0.029018809871878326, 0.03804113265882236, 0.07868706580387674, 0.07708930020351523, 0.07380855342667758, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016028068828277786, 0.017445486442280722, 0.01496277326047668, 0.014332393472043403, 0.01284482589354552, 0.013366736489719533, 0.1257335393110015, 0.13574261654506137, 0.15783121472926054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "06c651e3-3b3c-4b67-b8e7-c6a04b527a7f", "fitness": 0.02151162184555027, "name": "AQIDE", "description": "Enhance AQIDE by refining population dynamics and crossover probability for improved exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  \n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.9) * (1 - self.budget_used / self.budget)  # Adjusted F range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7, 1.0)  # Adjusted crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  \n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["63361a11-ea7e-471b-92b7-c810d6cb5fa1"], "operator": null, "metadata": {"aucs": [0.008958158441985997, 0.005364120020384222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05649782791400482, 0.04820945825688305, 0.03743841298966499, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0493323750781427, 0.049261762568170164, 0.0474136739484583, 0.08546318638804107, 0.0828059633951378, 0.08434554147985396, 0.02855934946041605, 0.027280739845316537, 0.02609330019968914, 0.06805138109116204, 0.07713688796551255, 0.06852514872197157, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018080289820073703, 0.01828578550595994, 0.015272202277930469, 0.0151939479881128, 0.014172353072928412, 0.013110265906276841, 0.1376979010448629, 0.1273350168652011, 0.13895172263347966, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "20ae3388-0a3c-4e31-ab25-8c629a672b00", "fitness": 0.020052329252209376, "name": "AQIDE", "description": "Refine AQIDE by introducing dynamic scaling for mutation vectors to enhance diversity.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c) * (1 + 0.5 * np.random.randn(self.dim))  # Dynamic scaling for mutation vectors\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.8, 1.0)  # Modified crossover probability\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["63361a11-ea7e-471b-92b7-c810d6cb5fa1"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004580457816203531, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.034426455672528, 0.04332074285963783, 0.02990343651521854, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045503475205249, 0.046970317357061586, 0.04520845846194088, 0.0872799431476986, 0.08041284319485897, 0.07761660575404716, 0.026152531736025608, 0.022780287148492673, 0.02753837951690352, 0.06162363474861876, 0.06873240903398692, 0.06480997814681033, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017834570224312563, 0.013865718867343668, 0.018705086486362488, 0.012450877616088096, 0.013880076760014903, 0.013838490102456191, 0.12412238800323705, 0.13076806191240642, 0.12709465378461626, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "33abf116-f121-4d3e-a0fb-714fdd80432b", "fitness": 0.022015721332041407, "name": "AQIDE", "description": "Enhance convergence by introducing a dynamic crossover operator and adaptive mutation scale.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["63361a11-ea7e-471b-92b7-c810d6cb5fa1"], "operator": null, "metadata": {"aucs": [0.0050190676958306035, 0.004661758839477392, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04979612484017282, 0.04938575316476157, 0.04517281544268337, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04311063042958019, 0.04322481695859348, 0.04929051307984722, 0.08473237602283124, 0.08477918353760694, 0.09412371684235066, 0.027897725153422814, 0.028764008494911564, 0.03804125390094115, 0.07868706580387674, 0.07711962165347319, 0.07359553582891065, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01602684648075281, 0.01744549508051807, 0.014962774580262295, 0.014331713001215718, 0.012573877447255022, 0.013360426719084662, 0.1257335393110015, 0.13546408086836026, 0.15783121472926054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "572eb616-5123-4826-a6f4-a6dd7b2097e8", "fitness": 0.021555544342339895, "name": "AQIDE", "description": "Introduce a dynamic trial replacement strategy and adjust mutation probability based on success rate.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            success_count = 0  # Track successful trials\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1  # Increment success count\n\n            # Probabilistic population update\n            succ_rate = success_count / self.population_size  # Success rate\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.05, 0.15) * (1 - succ_rate)  # Adjusted mutation probability based on success rate\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004587526630558503, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04045049325598049, 0.04938575316476157, 0.03971577877537302, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046867377042062675, 0.04082769661413577, 0.044914907281739636, 0.0872986850367371, 0.0837000928049132, 0.08342101614290742, 0.028862963764932803, 0.029588081113420373, 0.03093067743179967, 0.0798647818953041, 0.07704358093980512, 0.07740109683912877, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014364848474594294, 0.01744787282432081, 0.015101033992402924, 0.014330482272359779, 0.012814661053158538, 0.01198717789420023, 0.12356623288418755, 0.13534797878410787, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d537f2b9-35fd-4433-9e8a-9c6b2316aede", "fitness": 0.022015721332041407, "name": "AQIDE", "description": "Adaptive dynamic population size scaling and mutation enhancement for improved convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population size scaling enhanced\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.0050190676958306035, 0.004661758839477392, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04979612484017282, 0.04938575316476157, 0.04517281544268337, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04311063042958019, 0.04322481695859348, 0.04929051307984722, 0.08473237602283124, 0.08477918353760694, 0.09412371684235066, 0.027897725153422814, 0.028764008494911564, 0.03804125390094115, 0.07868706580387674, 0.07711962165347319, 0.07359553582891065, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01602684648075281, 0.01744549508051807, 0.014962774580262295, 0.014331713001215718, 0.012573877447255022, 0.013360426719084662, 0.1257335393110015, 0.13546408086836026, 0.15783121472926054, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "8a5595b2-8da6-4262-ba28-7c43d3605687", "fitness": 0.021008228084401767, "name": "AQIDE", "description": "Refine AQIDE by modifying selection pressure and dynamic crossover behavior for enhanced exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.5 + 0.5 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover change\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness * 1.01 < fitness[i]:  # Modified selection pressure\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.008903569680353995, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05473287167881824, 0.048524089120769776, 0.03752543277099829, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044347276644753575, 0.039606324301359574, 0.04914453194364088, 0.08143404045353453, 0.08493899914402792, 0.08534306809174785, 0.028751446889632937, 0.02375354760067061, 0.021632781529119405, 0.06674527864629787, 0.07654073875726886, 0.06628726387730521, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01516921700533358, 0.015468545435585956, 0.015486977640235211, 0.01324712046447607, 0.01394766653876256, 0.012120404345551172, 0.1259767971092156, 0.12078603667188736, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "5613cca2-4bbe-41d5-8fc1-4ffaeb07bfbd", "fitness": 0.02123175357202354, "name": "AQIDE", "description": "Enhance adaptive mutation and crossover strategies by dynamically adjusting based on convergence speed.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(0.95, 0.05), 0.8 + 0.2 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.012022497718576886, 0.005962170436976666, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04544268530793072, 0.05032097185647244, 0.04598454178510014, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04445791527099585, 0.041666885918143715, 0.043637795613169605, 0.08566645467593681, 0.08439178954861049, 0.0934769359236296, 0.029428275085467193, 0.03349336743319087, 0.02857049580491422, 0.07078415886732292, 0.06632486516464375, 0.07868365844421987, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015817789681404792, 0.01567874767161037, 0.015045923721831223, 0.014338393855516274, 0.013135422750032988, 0.014164905091048619, 0.12502928969214522, 0.12471669699526156, 0.1304436228715431, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a5f76451-ea18-4f92-91e6-fd24714a8fb4", "fitness": 0.0214845752232583, "name": "AQIDE", "description": "Introduce a nonlinear dynamic adjustment to the mutation factor and crossover probability to enhance exploration and convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - (self.budget_used / self.budget)**2)  # Nonlinear Adaptive F\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), (0.7 + 0.3 * (self.budget_used / self.budget)**2), 1.0)  # Nonlinear Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.006681084675623006, 0.007872412698737286, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04863278376067315, 0.05283916652790188, 0.04849864709987728, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04273663354238744, 0.04081475118075173, 0.04118950141193767, 0.08113729633341416, 0.08585540538357794, 0.09800107556900184, 0.02518035771548377, 0.0310322977044849, 0.04240429318838723, 0.07632299007982313, 0.07905664839149373, 0.07212366516307578, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01569153460327677, 0.016585406084252963, 0.01563189516593344, 0.01437547215950663, 0.012911475192281752, 0.013149199455924743, 0.12224977674756798, 0.123531407128052, 0.1323842391111706, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b6a09681-e6af-4d89-ab1d-3c9c5d5d2839", "fitness": 0.02039179652461382, "name": "AQIDE", "description": "Integrate a learning rate for F and modify crossover distribution to enhance exploration.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget) + 0.1 * np.random.randn()  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.5 + 0.5 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.005117731368421419, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.039364642475881007, 0.04136575725100278, 0.025995224408773332, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05727062598196897, 0.0474776129085811, 0.04746343712707224, 0.0885852006984077, 0.07231189015125028, 0.07917464312488887, 0.030100115827479845, 0.017631428464323418, 0.01971027874080744, 0.07147660553117019, 0.06460338572723712, 0.08026257492482058, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014866214810383638, 0.015104328447815174, 0.01389194010574657, 0.014556661551677341, 0.01435875231186956, 0.012427868381106877, 0.13268414932502637, 0.12393559023676237, 0.13412486380276556, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e4377c00-e906-4fbe-9b55-f791817394ac", "fitness": 0.02171205830738229, "name": "AQIDE", "description": "Enhance AQIDE by introducing an elitism strategy and improved population scaling.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.1 * (self.budget_used / self.budget))))  # Adjusted scaling\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Elitism strategy\n            best_idx = np.argmin(fitness)\n            new_population[0] = population[best_idx]  # Keep the best individual\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.0067470982027707516, 0.006534585065890441, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05283540102864881, 0.047855952056988116, 0.049558357807834796, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04565662319492769, 0.039817262059192116, 0.04958727840374877, 0.08305899478125911, 0.08384144968891505, 0.08714681841307337, 0.02336278187440488, 0.02676869209653132, 0.0340466308431534, 0.07006821186559209, 0.07926143162085408, 0.07547535630811064, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0154041043034151, 0.016066639292105722, 0.01567601288130438, 0.014437533526156177, 0.012610426338565794, 0.013508449491894114, 0.12076355855345666, 0.13534797878410787, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f11dd06a-2879-4fbf-b395-75ec942caf3b", "fitness": 0.022737459948785694, "name": "AQIDE", "description": "Improve convergence by refining mutation strategy and enhancing selection pressure.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    population[i] = 0.5 * (population[i] + trial)  # Enhance selection pressure\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["33abf116-f121-4d3e-a0fb-714fdd80432b"], "operator": null, "metadata": {"aucs": [0.008824527233089796, 0.008201908375110034, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04538160006270808, 0.05978396940225572, 0.040204230260903806, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04833121927353623, 0.04090691318469719, 0.04652331982391855, 0.09515147914057032, 0.09513972508868329, 0.09187759553034736, 0.03202586751253822, 0.03267205193550615, 0.03294147908080902, 0.08855580329358459, 0.08967479320508365, 0.08767879614164964, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01582466251471404, 0.01642055515016272, 0.016249101740028138, 0.014317621355684373, 0.015677916079822607, 0.01286482858176985, 0.11977615199611291, 0.12426043070066017, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a81fb67c-dd1a-4ccd-b514-f7b7c498a101", "fitness": 0.022027777098963714, "name": "AQIDE", "description": "Further refine mutation dynamics and introduce elitism for enhanced solution retention.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.9) * (1 - self.budget_used / (2 * self.budget))  # Adjusted F range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    population[i] = 0.5 * (population[i] + trial)  # Enhance selection pressure\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            # Elitism: retain the best solution found\n            best_idx = np.argmin(fitness)\n            new_population[0] = population[best_idx]  # Ensure best solution survives\n            fitness[0] = fitness[best_idx]\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f11dd06a-2879-4fbf-b395-75ec942caf3b"], "operator": null, "metadata": {"aucs": [0.010350843540935739, 0.005123498801445248, 0.006395952917559233, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047735286171149305, 0.047473618215706836, 0.03744489480079449, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04347796629058065, 0.050028867478909333, 0.05085733616746846, 0.09200995152036162, 0.09209527288345798, 0.09187810961809861, 0.02917206996744348, 0.03258332948797871, 0.03167436307935412, 0.08389820188998842, 0.09103383904058493, 0.08337043554108459, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015598921009460365, 0.015427179564001414, 0.01542836256393365, 0.012977762822980021, 0.01300359799429307, 0.01372108113093573, 0.12675726450586877, 0.12054383159147075, 0.13028593861649973, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "19f91941-1db2-4d6e-982d-403838dd3b79", "fitness": 0.022055855428303114, "name": "AQIDE", "description": "Further refine mutation and crossover strategies while maintaining selective pressure.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.9) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.1), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    population[i] = 0.5 * (population[i] + trial)  # Enhance selection pressure\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f11dd06a-2879-4fbf-b395-75ec942caf3b"], "operator": null, "metadata": {"aucs": [0.010288865712112849, 0.004349490264219491, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004668422915550807, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04935040591619666, 0.056444845007633804, 0.049082603335039554, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045113266489614445, 0.037753846813694314, 0.03979422445914005, 0.08760287429788494, 0.0927228730135351, 0.08661921482224255, 0.031679275338828417, 0.03308150439923718, 0.02901451428962676, 0.0864327795816574, 0.08541204452861284, 0.09496280966284198, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016946826379420354, 0.018053769452069712, 0.014853145900606934, 0.014846817374603583, 0.014326673449692073, 0.014260160165136426, 0.1251333434848242, 0.11913106055081502, 0.13044375931994434, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1906ffa1-bb9b-4912-b071-c5ed062190b5", "fitness": 0.02144869412494916, "name": "AQIDE", "description": "Introduce a more adaptive mutation and crossover strategy to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.9) * (1 - self.budget_used / self.budget)  # Slightly extended range for F\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = np.clip(np.random.normal(1.0, 0.05), 0.6 + 0.3 * (self.budget_used / self.budget), 1.0)  # Adjusted crossover probability range\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    population[i] = 0.5 * (population[i] + trial)  # Enhance selection pressure\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f11dd06a-2879-4fbf-b395-75ec942caf3b"], "operator": null, "metadata": {"aucs": [0.0049126590070442955, 0.004409643984309319, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03302346622841168, 0.048047563567994445, 0.04815486380231515, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04596186005225422, 0.040763566182056565, 0.04156174426982906, 0.09011962856537026, 0.09277240923324825, 0.08402937328387672, 0.030794754746111597, 0.02945557248826025, 0.02515417166629652, 0.08027929004334489, 0.09211735731873594, 0.08793065688263302, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015515949072058, 0.01582938313191229, 0.01582487309356151, 0.013009123151345392, 0.015567476177613004, 0.012550306494985453, 0.129362518790043, 0.1233126290798291, 0.12384513668290065, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4b755208-b372-436a-ae89-b417cd5ab0dd", "fitness": 0.022009997677323374, "name": "AQIDE", "description": "Introduce a small randomness factor to the selection process to diversify exploration and avoid premature convergence.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.2, 0.8) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n\n                # Introduce small randomness in selection, changing exactly one line\n                if trial_fitness < fitness[i] or np.random.rand() < 0.05:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    population[i] = 0.5 * (population[i] + trial)  # Enhance selection pressure\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 98, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f11dd06a-2879-4fbf-b395-75ec942caf3b"], "operator": null, "metadata": {"aucs": [0.007900327180275113, 0.004347826086956497, 0.005128521027683686, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0386463534955348, 0.04453138373438659, 0.032524568409429744, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04456700120179202, 0.04183543725695382, 0.04131417671192383, 0.08870445042933095, 0.08283140946354661, 0.09252609806320578, 0.029145863380135473, 0.02945995789276623, 0.02991892078865288, 0.08933173574336806, 0.09363992665585419, 0.08296772674738961, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015923547687184403, 0.01557151533252532, 0.015903887547909168, 0.014125918575770724, 0.014557151943308755, 0.013092475590492536, 0.13680798059213295, 0.12593292766710606, 0.15783056964862485, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "dab67e38-91a0-4db2-8495-0e1f1f39f3fc", "fitness": 0.021779119096879938, "name": "AQIDE", "description": "Enhance exploration by increasing mutation range dynamically.", "code": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.prob_mutate = 0.1\n        self.F = 0.5\n        self.CR = 0.9\n        self.budget_used = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        self.budget_used += self.population_size\n\n        # Main loop\n        while self.budget_used < self.budget:\n            new_population = np.copy(population)\n            self.population_size = max(5, int(self.population_size * (1 - 0.15 * (self.budget_used / self.budget))))  # Dynamic population\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n\n                # Mutation\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = np.random.uniform(0.4, 1.2) * (1 - self.budget_used / self.budget)  # Adaptive F, adjusted range\n                mutant = a + F_dynamic * (b - c)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < np.clip(np.random.normal(1.0, 0.05), 0.7 + 0.3 * (self.budget_used / self.budget), 1.0)  # Dynamic crossover\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.budget_used += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    population[i] = 0.5 * (population[i] + trial)  # Enhance selection pressure\n\n            # Probabilistic population update\n            for i in range(self.population_size):\n                if self.budget_used >= self.budget:\n                    break\n                adaptive_prob_mutate = np.random.uniform(0.1, 0.2) * (1 - self.budget_used / self.budget)  # Adjusted mutation probability\n                if np.random.rand() < adaptive_prob_mutate:\n                    new_population[i] = self.lower_bound + np.random.rand(self.dim) * (self.upper_bound - self.lower_bound)\n                    fitness[i] = func(new_population[i])\n                    self.budget_used += 1\n\n            population = new_population\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f11dd06a-2879-4fbf-b395-75ec942caf3b"], "operator": null, "metadata": {"aucs": [0.010270101950961119, 0.004347826086956497, 0.004654037365337094, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04311514578072262, 0.05390489943881294, 0.040465579131547025, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047102722115954676, 0.03754986078782829, 0.043054220517365294, 0.08705205455883291, 0.0887273734216224, 0.08533045851164356, 0.026687504022219644, 0.03236762214306255, 0.02514615437800627, 0.0806111210757271, 0.08890600110995683, 0.07940099095217812, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01603389979862202, 0.01543274454256105, 0.015135731194283686, 0.014411994882940538, 0.014515138491752788, 0.013430375923161764, 0.1350345991236841, 0.13898338036095215, 0.13077286339562, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
