{"id": "11f510a5-3c1d-470e-b6f7-a8708a7fc649", "fitness": 0.018880592190320376, "name": "HybridDELevy", "description": "Hybrid Differential Evolution with Adaptive Lévy Flight for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutated = (self.population[a] + \n                   self.mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.036551154780987694, 0.043029554350311416, 0.03935136689681795, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05172542904963573, 0.05948156204849431, 0.0550665230013041, 0.08110033086324953, 0.08498882968839727, 0.0890405486920236, 0.029285698878642852, 0.032760997119857915, 0.03292674523945449, 0.06542603314356676, 0.06775021772757794, 0.07314316763851092, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01554201221678242, 0.01152169141941295, 0.011648292280076133, 0.008988638504218494, 0.011558336200114594, 0.010254206688703804, 0.145296819381171, 0.146360877936758, 0.13573403873960488, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "147cb84e-cf8f-4493-88af-b24da95745fc", "fitness": 0.019567711087107, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Factor for improved diversification and convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["11f510a5-3c1d-470e-b6f7-a8708a7fc649"], "operator": null, "metadata": {"aucs": [0.005579821859540868, 0.00048356611021205254, 0.004240989359108327, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04231029122185015, 0.04036823002242762, 0.04149836702890197, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05009982814155656, 0.061166595270570445, 0.050262007772771344, 0.08870000976387138, 0.08950221241954892, 0.08817762801303541, 0.033037345211115565, 0.035472900474261104, 0.03391789479116858, 0.06803644878363069, 0.0659623318707987, 0.07540155692121475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013858678215577958, 0.012730262654396252, 0.012517050869338298, 0.010756484156130175, 0.010234098880007925, 0.011338583758689014, 0.14409174474526776, 0.1556625510526698, 0.1439025015127372, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "54c5c46e-ef06-494f-982a-cd908e7aa021", "fitness": 0.01911754498784131, "name": "HybridDELevy", "description": "Refined Hybrid Differential Evolution with Chaotic Search for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaos_factor = 0.01  # Added\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] +\n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        chaotic_term = self.chaos_factor * np.random.rand(self.dim)  # Added\n        mutated = np.clip(mutated + chaotic_term, self.lower_bound, self.upper_bound)  # Modified\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 2, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.003971408522355557, 0.00047798861025749595, 0.002004143871502495, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03761348439783019, 0.04272436730851281, 0.03553067973625179, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.046510493689828514, 0.05938396486280906, 0.048850543843593885, 0.08981324996599849, 0.08879722987712557, 0.09570099310285096, 0.03308725446336591, 0.034717669639712345, 0.03357459531388174, 0.06753258432055054, 0.06603870945255985, 0.07304276512857977, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013697888822517656, 0.011799755183276917, 0.014721058744084803, 0.009743393042983328, 0.010043659878397171, 0.010260887202344637, 0.14330535160683788, 0.1437535726369067, 0.14020032850835307, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "62f1c4ff-e6f7-418d-9338-be03cca395dc", "fitness": 0.019465404252072445, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with Adaptive Gradient-Based Levy Adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01, gradient=None):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        if gradient is not None:\n            step = np.sign(gradient) * np.abs(step)\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    gradient = trial - self.population[i]\n                    levy_step = self.levy_flight(gradient=gradient)\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 3, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.0027365306009832224, 0.00115652982869896, 0.005243019781522196, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04797931301799374, 0.040910486604139096, 0.044385082559573186, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048174955468852865, 0.06364449990181031, 0.05319144424706912, 0.08777858211177592, 0.08839645893276726, 0.090488932939771, 0.03391304163050479, 0.03580614948066718, 0.03264814536842664, 0.06670603482294923, 0.07083773443905972, 0.07437392760320805, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.017103528245205335, 0.012279970837748455, 0.012504279678026475, 0.00888434587799214, 0.011052487359299978, 0.011375416533914495, 0.14124775749224994, 0.14383567878964, 0.13528955460406145, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3b1a829e-ca88-4ede-be30-a4770338e21d", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with Lévy Flight and Adaptive Crossover Probability for improved search efficiency.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 4, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d51f407f-a0c7-4a15-963a-ccb42e67c3a3", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Introduced adaptive crossover probability to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9  # Original line\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        # Modified line for adaptive crossover probability\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 5, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "1f040f26-a615-4587-997e-1c8ba0d85ab2", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Factor using Adaptive Crossover Probability for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)  # Changed line\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 6, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f6226d0b-c6d4-41dd-a30e-06f7d4f60c48", "fitness": 0.019010964277288142, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with Adaptive Mutation Strategy for improved exploration and convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        if np.random.rand() < 0.5:  # Adaptive change: random factor for exploration\n            dynamic_mutation_factor *= 1.2\n        mutated = (self.population[a] + dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 7, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.0009562678893630938, 0.00043478260869567187, 0.0005561949339845107, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03901252342060435, 0.04987660104314129, 0.03661821490896, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0476413967443029, 0.058525534852800654, 0.05244428062515416, 0.08264290615806247, 0.08640877081435139, 0.08907298206351022, 0.02975208148546249, 0.03287960440277049, 0.035545601644027314, 0.06689571838741992, 0.07141717492971067, 0.0765012385366356, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01382574520245905, 0.012037785114548227, 0.011768962558186935, 0.009575678561161816, 0.010406244280649624, 0.01085303341319721, 0.1448987800554905, 0.14076381325708143, 0.1379122926817089, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e6e2b74c-6852-4e58-8d5e-650b84752106", "fitness": 0.019333838873801985, "name": "HybridDELevy", "description": "Added a mutation strategy adapting the crossover probability based on fitness improvement to refine convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.crossover_prob = min(1.0, self.crossover_prob + 0.1)  # Modified line\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 8, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.003292849165558387, 0.0015411007377977848, 0.0012228603743444921, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04577937228031037, 0.039023831124463504, 0.038031544569870346, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050616642538762524, 0.06001986312720908, 0.049671443048381336, 0.09060606846580477, 0.09536547798012451, 0.09031176663061158, 0.029481939771789034, 0.03743604360114794, 0.03688675953749698, 0.06809954865929346, 0.06765499144054044, 0.07319982121491486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01372550935123773, 0.013483148362296471, 0.012146088651116105, 0.010062039236583553, 0.010794405437806298, 0.010397777479963732, 0.1438686822911378, 0.14131526942992578, 0.13843633701394875, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4328434c-8bb1-4e21-a61f-4f5d112c09e2", "fitness": 0.019494852535721873, "name": "HybridDELevy", "description": "Introduced adaptive crossover probability to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (0.5 + 0.5 * (self.budget_used / self.budget))  # Modified line\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 9, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.001440968066006687, 0.003023642111222191, 0.001645565576423369, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050143422270616855, 0.043684815050518355, 0.04500213377016671, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04689798041826476, 0.059904640066651416, 0.049654746408909656, 0.08388709898837254, 0.09309660348430937, 0.08612223956680676, 0.02940673448246678, 0.03947622784614413, 0.03603442096244758, 0.07058174516723248, 0.06875934020780361, 0.07879104572750273, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014265507951339074, 0.012140425886398187, 0.012224670660026749, 0.009630295594426297, 0.011170019935070385, 0.011336152774993224, 0.14124775749224994, 0.1414983769969581, 0.1429975877173416, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "44fe0f86-3dbe-4977-8001-9683b3705503", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Improved Hybrid Differential Evolution with Adaptive Crossover Probability for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)  # Changed line\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:  # Changed line\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 10, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "85e62a08-3ed3-48af-a322-b473e48fb63a", "fitness": 0.018962953804882037, "name": "HybridDELevy", "description": "Introduced dynamic crossover probability adjustment for improved exploration.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        dynamic_crossover_prob = self.crossover_prob * (1 + 0.1 * np.sin(np.pi * self.budget_used / self.budget))\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < dynamic_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 11, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0005804359119223612, 0.003824136317877036, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03664607375604334, 0.04157061623020131, 0.0339624912312525, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05233896557879192, 0.06284820582922812, 0.05112899949507821, 0.08293725300371912, 0.08837962480921147, 0.08740880090262493, 0.03372363083745389, 0.03386523589321866, 0.034039464028122635, 0.06622896584057603, 0.0682216227966248, 0.07224729019758624, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014268512413161072, 0.012479234835200415, 0.012772306594407423, 0.009546423219712996, 0.009709566559574445, 0.011090471466494556, 0.14124775749224994, 0.1419773702063285, 0.14228921850484366, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ec1cef34-b731-40c7-af85-f4b4b493542d", "fitness": 0.019278576814737082, "name": "HybridDELevy", "description": "Further diversifies search by randomly adjusting mutation factor within a specified range.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        \n        # Allowing mutation factor to vary within a range for added diversification\n        dynamic_mutation_factor *= np.random.uniform(0.9, 1.1)  # Change made here\n  \n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 12, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.001555255055849858, 0.0005900409366175197, 0.0015334289859627592, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04018872502785287, 0.043286589816724064, 0.040389364468956024, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0498957570763805, 0.0645696184059239, 0.049356746182203426, 0.08561420295512145, 0.0866064786137144, 0.09352806084688026, 0.03286504943774238, 0.03548528843778098, 0.03302765150266074, 0.07139071800700725, 0.0672639736889371, 0.07580216816819496, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014154210580229698, 0.012233288613717308, 0.011793058202113404, 0.009448595408179994, 0.010095526472273186, 0.010292645241683163, 0.14524075678967108, 0.1445664714557071, 0.13771864289167923, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "79a51a7c-1446-4f1a-b0ba-97eb97d8061f", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Improved exploration by adapting the crossover probability based on budget consumption for better convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 13, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "730beda3-6aab-40c7-b3cf-cf3bcf288fd9", "fitness": 0.01952803543267207, "name": "HybridDELevy", "description": "Improved exploration by adjusting the Levy flight step size using a dynamic scheme based on remaining budget.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        # Adjust step size based on remaining budget\n        dynamic_step_size = step_size * (1 - self.budget_used / self.budget)\n        return dynamic_step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 14, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00556155197007957, 0.0004624714474444902, 0.004208413792637478, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.043344620157446556, 0.042835675169078824, 0.041481127549137575, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052001559154685184, 0.06244561630151524, 0.0504799624920198, 0.08865668801687421, 0.08801034657026241, 0.09083833589340073, 0.03224324871612916, 0.03601516802405813, 0.034784583568087, 0.06771297838168189, 0.06563125168528505, 0.07466186276491638, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013851998807638655, 0.012720071451951864, 0.012510426514468986, 0.011050508456339148, 0.010905896785011415, 0.010449576881302436, 0.14307694029743923, 0.15524517515045688, 0.13526727776173553, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "23de2747-12f1-49a3-a05d-eb7feb3cec16", "fitness": 0.019470320282340883, "name": "HybridDELevy", "description": "Slightly modified Enhanced Hybrid Differential Evolution using dynamic mutation factor and Levy flight for better convergence speed.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight(step_size=0.015)  # Slightly increased step size\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 15, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.000999994785824243, 0.0015991633883886136, 0.0016682584848829451, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04076696214138609, 0.0440633532967899, 0.03875221464410461, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048749451941967226, 0.0594212574841575, 0.05259345137206839, 0.08592250313286731, 0.08765775867964987, 0.08801782174197881, 0.031148790256126824, 0.03410420465567732, 0.03668588401356909, 0.07852505016772526, 0.06969891124652727, 0.07669270382023752, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014851949679913434, 0.011624091097027667, 0.013145974635079938, 0.010870448547384282, 0.012210923702121845, 0.012962179833022835, 0.14573560638283678, 0.1507260840282384, 0.1331028497776845, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a17d77e7-1670-4c8b-b5bf-405c4b90380e", "fitness": 0.019380423759328302, "name": "HybridDELevy", "description": "Refined Hybrid Differential Evolution with Adaptive Population Size for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.population_size = max(5, int(self.population_size * 0.99))  # Adaptive population size\n        return self.population[self.select_best()]", "configspace": "", "generation": 16, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.001655702942698345, 0.0028935079356302573, 0.006316874714778153, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03947269137160758, 0.04469985479919514, 0.0426065961316936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04897996091510637, 0.0589845194624683, 0.051657965382895465, 0.0832488444438666, 0.09258009202367745, 0.08735957781114945, 0.03471160955657937, 0.03504353606756572, 0.03352143076590042, 0.06518491082812627, 0.07004183200484848, 0.07514271330771205, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013717242789638151, 0.013117021946636442, 0.012388573808988168, 0.010070753135435151, 0.010450794126299678, 0.012461199444188331, 0.14124775749224994, 0.14228890717794984, 0.14598082289344771, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4cafffc6-606a-4c35-a01e-3451c0bb7210", "fitness": 0.01925090088078358, "name": "HybridDELevy", "description": "Introduce adaptive crossover probability and enhanced Levy flight to boost exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step * (1.0 + 0.3 * np.random.randn())\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        self.crossover_prob = 0.9 - (0.5 * (self.budget_used / self.budget))  # Adaptive\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 17, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.0007425065204765824, 0.0027960754877206506, 0.0005028389321650728, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0484401427822343, 0.045391629252277466, 0.042243953047117144, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05155115773613472, 0.059770797440765744, 0.04687816406247414, 0.08366998244663848, 0.08823627210315743, 0.08668258930005857, 0.02969917841599934, 0.033559623901877944, 0.0308974428486527, 0.06868014000530143, 0.06796203477304619, 0.07789412857839051, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013678001712946308, 0.012098301234600872, 0.011601160070196515, 0.011149602926040947, 0.011656490360387184, 0.010212676931307785, 0.14910450749921011, 0.14087541116951918, 0.14052483648641523, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "320fd315-b8b0-4fa6-b049-b662ad690e99", "fitness": 0.01952803543267207, "name": "HybridDELevy", "description": "Improved exploration by incorporating an adaptive step size for Levy flights, enhancing convergence speed.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=None):\n        if step_size is None:\n            step_size = 0.01 * (1 - self.budget_used / self.budget)  # Adaptive step size\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 18, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00556155197007957, 0.0004624714474444902, 0.004208413792637478, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.043344620157446556, 0.042835675169078824, 0.041481127549137575, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052001559154685184, 0.06244561630151524, 0.0504799624920198, 0.08865668801687421, 0.08801034657026241, 0.09083833589340073, 0.03224324871612916, 0.03601516802405813, 0.034784583568087, 0.06771297838168189, 0.06563125168528505, 0.07466186276491638, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013851998807638655, 0.012720071451951864, 0.012510426514468986, 0.011050508456339148, 0.010905896785011415, 0.010449576881302436, 0.14307694029743923, 0.15524517515045688, 0.13526727776173553, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a5055d54-4134-4188-a175-6f4ec30d0f67", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Further optimized Hybrid Differential Evolution using adaptive crossover probability for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)  # Changed here\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:  # Changed here\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 19, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d0375676-be5d-4cd2-bf5a-29e19f104310", "fitness": 0.019263433699185796, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with dynamic population size adjustment for improved adaptability and convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(10 * dim * (1 + np.sin(budget)))  # Changed line\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 20, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.0008501868755265152, 0.003916047762913655, 0.006607883794386149, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05245434780789926, 0.03962586387771516, 0.038413835311222, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04759723959463469, 0.06280473723301438, 0.046361286106858746, 0.09116045645298354, 0.08521171240470027, 0.08844608583706759, 0.030437553733758005, 0.0330672230182415, 0.03292915718939504, 0.06423014812827144, 0.0684566119431973, 0.07647642640540298, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013724636414968572, 0.013085822213292464, 0.013598061299835984, 0.010204500585600962, 0.009608971177812897, 0.011180212381959986, 0.14155854717882832, 0.14194405352922768, 0.14345040069135695, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "72cc7432-571b-43d6-9393-7ab8d82663de", "fitness": 0.01952803543267207, "name": "HybridDELevy", "description": "Refined mutation strategy with adaptive Levy step size for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        # Adjusted step_size to adapt based on budget usage\n        adaptive_step_size = step_size * (1 - self.budget_used / self.budget)\n        return adaptive_step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 21, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00556155197007957, 0.0004624714474444902, 0.004208413792637478, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.043344620157446556, 0.042835675169078824, 0.041481127549137575, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052001559154685184, 0.06244561630151524, 0.0504799624920198, 0.08865668801687421, 0.08801034657026241, 0.09083833589340073, 0.03224324871612916, 0.03601516802405813, 0.034784583568087, 0.06771297838168189, 0.06563125168528505, 0.07466186276491638, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013851998807638655, 0.012720071451951864, 0.012510426514468986, 0.011050508456339148, 0.010905896785011415, 0.010449576881302436, 0.14307694029743923, 0.15524517515045688, 0.13526727776173553, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "03e7701b-3d6d-4729-a25e-ff24b994b581", "fitness": 0.01951338569819365, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with Dynamic Mutation Factor and Adaptive Population Size to improve exploration and convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            if func_evals > self.budget / 2:  # Adaptive population size reduction\n                self.population_size = max(self.dim, int(self.population_size * 0.9))\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 22, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.0054741464918687255, 0.002722721439480047, 0.004763668386861153, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04127250068034494, 0.04159081006896226, 0.041176871610824395, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05009982814155656, 0.06126540971327077, 0.050341752921989946, 0.0887444407154574, 0.08853527935323968, 0.0884751654340673, 0.032546502050741055, 0.0351950894952312, 0.03340619237020925, 0.06720487971278089, 0.06606703760798849, 0.07733811260287637, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013753268522774142, 0.01234403479260826, 0.012885402650024913, 0.010694155658481974, 0.010227351550650798, 0.011558099414206713, 0.14190167898792938, 0.1556625510526698, 0.14015160145154115, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e0d8f742-1a6f-4cb6-baa7-287b79509cd9", "fitness": 0.019053140285295065, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution algorithm with a tuned crossover probability to improve convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.95  # Adjusted from 0.9 to 0.95 for improved exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 23, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.001652383930054735, 0.0005671725959006668, 0.0007689515467849128, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03733820150430045, 0.04136538392876388, 0.04150575365224263, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048485294109770205, 0.058525534852800654, 0.04907081245708722, 0.08521508512856979, 0.08672356148357863, 0.08699681218542532, 0.03173729422349203, 0.03494862598851345, 0.033628559265593605, 0.06829117299141729, 0.07496238656377574, 0.07678712068987703, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013743717229240282, 0.012147558166429762, 0.012377887149985, 0.009989079800701739, 0.01050513205270065, 0.010520001932569412, 0.14612320828100955, 0.14417542035920572, 0.13410877108014918, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d5d600b8-9476-4c81-837f-9d0722869f92", "fitness": 0.01940226228316417, "name": "HybridDELevy", "description": "Incorporate dynamic population resizing based on convergence rate to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def dynamic_population_resizing(self, convergence_rate):\n        if convergence_rate < 0.1:\n            self.population_size = min(20 * self.dim, self.population_size + 1)\n        elif convergence_rate > 0.3:\n            self.population_size = max(5 * self.dim, self.population_size - 1)\n        self.population = np.resize(self.population, (self.population_size, self.dim))\n        self.fitness = np.resize(self.fitness, self.population_size)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        prev_best_fitness = np.inf\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            convergence_rate = np.abs(prev_best_fitness - self.fitness[best_idx]) / prev_best_fitness\n            self.dynamic_population_resizing(convergence_rate)\n            prev_best_fitness = self.fitness[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 24, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.006676611005344446, 0.0023420294016629484, 0.004381392318418054, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04809236112613291, 0.04953971945725477, 0.0357258768181169, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049201194977648965, 0.05934525730204032, 0.050531066753653375, 0.08728918247658501, 0.0884613736751706, 0.08654680091921407, 0.03354274368682697, 0.033933791325062135, 0.03296411056217652, 0.07747537788866654, 0.0678399319828692, 0.07399203230220242, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013710060288959602, 0.012363975605629185, 0.012320034084914, 0.009371692772146889, 0.010785211357318691, 0.011054648221944907, 0.14124775749224994, 0.14076381325708143, 0.1378996199372241, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b7f83980-3a55-497f-8623-6d556fcccd7d", "fitness": 0.019567711087107, "name": "HybridDELevy", "description": "Improved Hybrid Differential Evolution with Adaptive Population Reduction for enhanced computational efficiency and convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def reduce_population(self):\n        reduction_factor = 0.95\n        self.population_size = int(self.population_size * reduction_factor)  # Line 1\n        self.population = self.population[:self.population_size]  # Line 2\n        self.fitness = self.fitness[:self.population_size]  # Line 3\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            if func_evals % (self.budget // 10) == 0:  # Line 4\n                self.reduce_population()  # Line 5\n        return self.population[self.select_best()]", "configspace": "", "generation": 25, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.005579821859540868, 0.00048356611021205254, 0.004240989359108327, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04231029122185015, 0.04036823002242762, 0.04149836702890197, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05009982814155656, 0.061166595270570445, 0.050262007772771344, 0.08870000976387138, 0.08950221241954892, 0.08817762801303541, 0.033037345211115565, 0.035472900474261104, 0.03391789479116858, 0.06803644878363069, 0.0659623318707987, 0.07540155692121475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013858678215577958, 0.012730262654396252, 0.012517050869338298, 0.010756484156130175, 0.010234098880007925, 0.011338583758689014, 0.14409174474526776, 0.1556625510526698, 0.1439025015127372, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e7980e86-b5be-40c1-877f-03e8dc2744e2", "fitness": 0.019240583809535305, "name": "HybridDELevy", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Levy-based Exploration for Balanced Exploitation and Exploration.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (0.5 + 0.5 * np.random.rand())  # adaptively change mutation factor\n        mutated = (self.population[a] + \n                   adaptive_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            self.population_size = max(4, self.population_size - 1)  # dynamically adapt population size\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 26, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.0019458859949114116, 0.00074996805500116, 0.006773931551262824, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04822398896875557, 0.04110630422052053, 0.03144233432086718, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05053539381247363, 0.060941518018546414, 0.04951045438573576, 0.08421663155322201, 0.08770548637559816, 0.08827606717060343, 0.03189047992150196, 0.033084762422370684, 0.03471142133869343, 0.06450508592324078, 0.06633837136874288, 0.07647837636698684, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013681563107453387, 0.015912107053091318, 0.012646039622353111, 0.0100992077177251, 0.011875080958936635, 0.010477048451020488, 0.1480622734988113, 0.14076381325708143, 0.14380322145972946, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2b1a927b-546a-45d1-8b69-6dc4d18fb1d0", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Improved Hybrid Differential Evolution with Adaptive Crossover Probability for Enhanced Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)  # Changed line\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:  # Changed line\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 27, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "15f33338-7400-4647-9290-210e8a5530ab", "fitness": 0.019420807198176165, "name": "HybridDELevy", "description": "Introduce a small adaptive adjustment to the crossover probability to enhance exploration capacity.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)  # Change made here\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 28, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.003689496202709752, 0.0009530084414306472, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04236028682826143, 0.04567668789844448, 0.038254411444354486, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05056101005980762, 0.059946317683890804, 0.04755518820936311, 0.08871576351478405, 0.08918294062451082, 0.08817820735895032, 0.03063381517919106, 0.03502725948412555, 0.0324106508903641, 0.06684372235818159, 0.0666970874633167, 0.08069814916490936, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013751870419389522, 0.013339484793729484, 0.012171021577996544, 0.01020198698215291, 0.011858286302010912, 0.01053023070153769, 0.14692096236286212, 0.14953113311696153, 0.14260913920544627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6eb863b9-7151-4258-9e26-fff0e93127e2", "fitness": 0.019673155269115294, "name": "HybridDELevy", "description": "Modified the mutation strategy by integrating the best solution for enhanced convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 29, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["147cb84e-cf8f-4493-88af-b24da95745fc"], "operator": null, "metadata": {"aucs": [0.005011432824343243, 0.001209487980282864, 0.006000683124276152, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007322842386239703, 0.005689744060956681, 0.003773614607988085, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04681075378721089, 0.046868108123504615, 0.03364759227354963, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0483060872753579, 0.058525534852800654, 0.05273070837857863, 0.0909554278523722, 0.09000675164697736, 0.08993633760309538, 0.037935218435315776, 0.033901959255842606, 0.036817436144421234, 0.0687519662447168, 0.07080750036163985, 0.07433671235115802, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01443616981965179, 0.011833312918707373, 0.012543104494187829, 0.009268419239169767, 0.010949515903449836, 0.010834296563592472, 0.14124775749224994, 0.14221733597958297, 0.1355304978298626, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "90d66a97-a976-43be-822f-58d02182bf5a", "fitness": 0.01946636202347262, "name": "HybridDELevy", "description": "Enhanced dynamic mutation factor with adaptive crossover probability for improved convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget)\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 30, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6eb863b9-7151-4258-9e26-fff0e93127e2"], "operator": null, "metadata": {"aucs": [0.0030788895679007, 0.008970071227001775, 0.006405824893948253, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003648820009222953, 0.0037691759641130806, 0.0031580603808175622, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03222078881515955, 0.042493459866669414, 0.038794403385510434, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05147271779068574, 0.05954737559002454, 0.05267650172930172, 0.08692160851072461, 0.09180994443216584, 0.08683785189952864, 0.03209798735228542, 0.03645161911937245, 0.03483079695676938, 0.06756817992759057, 0.06706865116197702, 0.07415595331178038, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013735549839842598, 0.012090020265029922, 0.012192017739088734, 0.01025919083884419, 0.011235891508441176, 0.010233690939734807, 0.14278165032285484, 0.14704705700523313, 0.1397634457731911, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "34def751-2853-43f8-9740-2e1570b641f1", "fitness": 0.019673155269115294, "name": "HybridDELevy", "description": "Enhanced selection pressure by incorporating weighted fitness to boost exploration capability.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        weighted_fitness = self.fitness + 0.1 * np.std(self.fitness)  # Line 1\n        return np.argmin(weighted_fitness)  # Line 2\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0  # Added to track budget usage dynamically\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals  # Update budget usage\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight()\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals  # Update budget usage\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 31, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6eb863b9-7151-4258-9e26-fff0e93127e2"], "operator": null, "metadata": {"aucs": [0.005011432824343243, 0.001209487980282864, 0.006000683124276152, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007322842386239703, 0.005689744060956681, 0.003773614607988085, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04681075378721089, 0.046868108123504615, 0.03364759227354963, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0483060872753579, 0.058525534852800654, 0.05273070837857863, 0.0909554278523722, 0.09000675164697736, 0.08993633760309538, 0.037935218435315776, 0.033901959255842606, 0.036817436144421234, 0.0687519662447168, 0.07080750036163985, 0.07433671235115802, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01443616981965179, 0.011833312918707373, 0.012543104494187829, 0.009268419239169767, 0.010949515903449836, 0.010834296563592472, 0.14124775749224994, 0.14221733597958297, 0.1355304978298626, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "00357ce5-15f3-4782-accb-254b32d77373", "fitness": 0.019852327001049677, "name": "HybridDELevy", "description": "Enhance the exploration-exploitation balance by incorporating adaptive crossover probability and integrating global information into Levy flight.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 32, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6eb863b9-7151-4258-9e26-fff0e93127e2"], "operator": null, "metadata": {"aucs": [0.0007956414306915516, 0.0026404161772797252, 0.003599737303587869, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014002808048875437, 0.01781360473587501, 0.008727797319967201, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.040155598428774364, 0.04360872637681679, 0.041238075584583145, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05228892495226156, 0.058525534852800654, 0.05267650172930172, 0.08872560555735753, 0.09467677899045968, 0.08780929976517282, 0.033763710177778905, 0.032887156428612396, 0.0348198329222823, 0.06458242712820661, 0.06850638121998642, 0.0740452554179849, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013841611526885345, 0.01201969324526364, 0.013289648030803791, 0.009290665740581572, 0.01024122286504947, 0.010940602997690951, 0.1487961386742016, 0.1425914438002588, 0.1342058330809669, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9b81eef9-f56a-4ba7-a43b-4ee5449f7868", "fitness": 0.021062368713316515, "name": "HybridDELevy", "description": "Enhance exploration-exploitation balance by making mutation factor adaptive based on fitness improvement.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 33, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["00357ce5-15f3-4782-accb-254b32d77373"], "operator": null, "metadata": {"aucs": [0.009594226895170421, 0.01333049932815733, 0.012141615125035976, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048894809618177715, 0.057334517008628016, 0.04738421423007011, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0519625078778978, 0.05893485017104194, 0.060374610898662695, 0.09226450963698718, 0.09381803383268716, 0.0902946894147153, 0.03855092819005379, 0.03725996540348764, 0.037860800866935884, 0.07702337219720412, 0.08478851512686814, 0.08095880123458365, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01475220933852539, 0.01595684137009834, 0.013130754467080119, 0.010710358085003313, 0.011909517142050907, 0.01303356278392942, 0.14124775749224994, 0.14076381325708143, 0.1426490489751001, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "70b05123-a3d9-4734-bcc7-71d857b2e341", "fitness": 0.020566827535451217, "name": "HybridDELevy", "description": "Enhanced exploration by adapting levy flight step size based on population diversity.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        # Adapt step size based on population diversity\n        diversity = np.std(self.population, axis=0).mean()\n        return (step_size + 0.05 * diversity) * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx]))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 34, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9b81eef9-f56a-4ba7-a43b-4ee5449f7868"], "operator": null, "metadata": {"aucs": [0.006390095040984756, 0.010275457827680357, 0.013813736938140475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.047563041641467074, 0.050200993557771856, 0.04786127417465336, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04824565071177833, 0.05852553600740973, 0.048491698793074245, 0.09245662874972504, 0.09384107030478883, 0.0912275912204048, 0.03554332249593328, 0.0361648648969517, 0.03966115381636037, 0.07748564453613871, 0.07424729515188278, 0.08009234995774717, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01488670981095841, 0.016358184560904987, 0.014203035991510848, 0.012180845176318233, 0.011517464944568179, 0.011820962823787307, 0.14447938319497666, 0.1410633238614054, 0.14264904897385944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3d218fc6-b39b-4dcb-af8c-394fe2db2e61", "fitness": 0.02318645993116402, "name": "HybridDELevy", "description": "Enhance mutation strategy by incorporating a learning rate based on global best improvement.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) # Added line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate # Modified line\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 35, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["9b81eef9-f56a-4ba7-a43b-4ee5449f7868"], "operator": null, "metadata": {"aucs": [0.007875003499702826, 0.0033105857866020383, 0.004675994196725375, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06543542279300729, 0.0618120839987244, 0.05644104090384128, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0502909687087425, 0.058525534852800654, 0.055668436124899134, 0.09410164833949874, 0.09562829372969806, 0.09842118511718045, 0.03599094426918226, 0.037272231300039316, 0.034554555318705216, 0.1301186935427351, 0.12463025685286011, 0.12277538743101646, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015231495039838228, 0.014003234426616329, 0.014410003043644148, 0.0108949210737469, 0.010502991085041602, 0.013747682377338033, 0.14352677340193865, 0.14437806640061557, 0.14563646403776365, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "dba12de3-1bc7-448e-ba6a-e0253d73a762", "fitness": -Infinity, "name": "HybridDELevy", "description": "Integrate adaptive population size to enhance exploration-exploitation balance in optimization.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx])\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def adapt_population_size(self):  # New method added\n        self.population_size = int(self.population_size * (1 - self.budget_used / self.budget * 0.5))  # Line modified\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.adapt_population_size()  # Line added\n        return self.population[self.select_best()]", "configspace": "", "generation": 36, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["3d218fc6-b39b-4dcb-af8c-394fe2db2e61"], "operator": null, "metadata": {}}
{"id": "144af17d-d701-4171-9b59-d4662b1eb2d0", "fitness": 0.02297613155248561, "name": "HybridDELevy", "description": "Introduce adaptive learning rate and dynamic population resizing based on convergence speed to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = (0.5 + 0.5 * np.exp(-self.budget_used / self.budget)) * (self.fitness[best_idx] / self.fitness[idx]) # Modified line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        convergence_speed_tracker = []  # Added line\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            convergence_speed_tracker.append(self.fitness[best_idx])  # Added line\n            if len(convergence_speed_tracker) > 5:  # Added lines\n                convergence_speed_tracker.pop(0)\n                if np.std(convergence_speed_tracker) < 1e-3:  # Added line\n                    self.population_size = max(4, self.population_size // 2)  # Added line\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 37, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["3d218fc6-b39b-4dcb-af8c-394fe2db2e61"], "operator": null, "metadata": {"aucs": [0.011257614341457112, 0.006228220962637643, 0.010365342778107522, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06392882916757181, 0.06186372243898508, 0.0613386458995272, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0509995330470725, 0.058525534852800654, 0.058415028825894, 0.09277987961420642, 0.0930772339135254, 0.09352965908845823, 0.036529149845364595, 0.03755541197144818, 0.03783052734188819, 0.11486201721581135, 0.11340231457780114, 0.11622748790651849, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015165469720656577, 0.016245893030402914, 0.017338053073965964, 0.011952760741687163, 0.014405737444502797, 0.014374029574970248, 0.14713300802461282, 0.14187193062680148, 0.13751321836098318, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "922b0cad-7104-448c-b9f7-340da983cb90", "fitness": 0.027059488228385387, "name": "HybridDELevy", "description": "Utilize an adaptive mutation factor scaled by success rate of previous generations to enhance convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size  # New line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 38, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["3d218fc6-b39b-4dcb-af8c-394fe2db2e61"], "operator": null, "metadata": {"aucs": [0.004125324876887992, 0.003639069431780939, 0.0037741306344672987, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05868263007462937, 0.06928069246909474, 0.058843695935091866, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05328781881534739, 0.058525534852800654, 0.05402583272678585, 0.09529414556823368, 0.09987285365932763, 0.09667456946747754, 0.034456291840957665, 0.03900486786743407, 0.03703068756858019, 0.22520791244211413, 0.20965532340869553, 0.22760201483581177, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01400616770017693, 0.014025219170240355, 0.013459212076773475, 0.009849148204517322, 0.010492758416583703, 0.010653998900009842, 0.14446498803227736, 0.14076381325708143, 0.14201923281926376, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ab416e38-a7c0-4e2a-ba15-6d8cf4b259f9", "fitness": -Infinity, "name": "HybridDELevy", "description": "Improve convergence by dynamically adjusting the population size based on the diversity of the population.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.initial_population_size, self.dim))\n        self.fitness = np.full(self.initial_population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n    \n    def adjust_population_size(self):  # New line\n        diversity = np.mean(np.std(self.population, axis=0))  # New line\n        self.population_size = int(self.initial_population_size * (0.5 + diversity))  # New line\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            self.adjust_population_size()  # New line\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 39, "feedback": "An exception occurred: AttributeError(\"'HybridDELevy' object has no attribute 'population_size'\").", "error": "AttributeError(\"'HybridDELevy' object has no attribute 'population_size'\")", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {}}
{"id": "facda3b7-f1c0-4394-9063-14300e5b67e6", "fitness": 0.023197452174033975, "name": "HybridDELevy", "description": "Increase exploration by enhancing the dynamic mutation factor's adaptability using population diversity.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity = np.std(self.population, axis=0).mean()  # New line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * (1 + diversity)\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 40, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.005242490823102575, 0.003571827048872378, 0.007483797746373533, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0644155460920448, 0.061796473428517906, 0.06410144217858527, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05616201074190186, 0.058525534852800654, 0.05417106779214842, 0.09526461653390428, 0.09662969703369861, 0.09781554158311156, 0.039385041298009016, 0.03886872500921057, 0.03809686374013421, 0.11621398137666805, 0.11619072307846046, 0.12376318290187827, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01532286583323661, 0.020068955666848964, 0.014491870938915907, 0.010739670918619382, 0.011585155277963444, 0.011030974346683209, 0.1476051215620432, 0.14076381325708143, 0.14134434807832652, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b39abb47-1f18-42ff-b88e-a2967294f70e", "fitness": 0.02277831044158699, "name": "HybridDELevy", "description": "Introduce a dynamic adaptive learning rate based on population diversity to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        diversity = np.std(self.population, axis=0).mean()  # New line\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) + 0.5 * diversity  # Modified line\n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 41, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.012123418459274116, 0.017537273882337057, 0.020434308387206612, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.056148594661105666, 0.0694054677219601, 0.05940069705856055, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06002179699732291, 0.06275381700425298, 0.05575185574907604, 0.10086476326407512, 0.09590643325437176, 0.0923585844917787, 0.036039019372670844, 0.036304715596313875, 0.04460563908790649, 0.09238811603425312, 0.09577707740095365, 0.0957045126586219, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015359316428987801, 0.014179111498437091, 0.01483521697428225, 0.01144101048864743, 0.011488014779938771, 0.011523098358017125, 0.14124775749224994, 0.14762867429353488, 0.14924484300682128, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ea71d434-1d65-48e9-a791-81cb125d0286", "fitness": 0.02510816794337034, "name": "HybridDELevy", "description": "Introduce a decaying component to the mutation factor to enhance exploration in later stages.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        decay_component = 0.5 * (1 - self.budget_used / self.budget)  # New line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * (1 + decay_component)  # New line\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 42, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.011013829476952619, 0.004845914278260199, 0.0034937791303012444, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06145971368404646, 0.05992440768977103, 0.060292365774068046, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.054732744705565106, 0.058525534852800654, 0.05596052366622639, 0.0971838794961225, 0.09896596773872735, 0.09740395093739251, 0.03990666279609112, 0.03949833150363291, 0.038196130837570896, 0.20643669629367745, 0.12389779395093437, 0.1609095905203337, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014267345772121076, 0.013807266757444259, 0.014227254843728332, 0.00969667424711429, 0.01068272814126947, 0.010600327023214562, 0.15709700916250835, 0.14762867429353488, 0.13756777695794964, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2666ff74-7dc9-4e33-82b6-4937da06d48e", "fitness": 0.026980841720735265, "name": "HybridDELevy", "description": "Introduced adaptive step size into the Levy flight to enhance exploration.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step * (1 - self.budget_used / self.budget)  # Modified line\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size  # New line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 43, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.00365913788026917, 0.0038152323005231636, 0.0028794166367926977, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0630352884377583, 0.06795661872307646, 0.055015834438995825, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05582134404847139, 0.058525534852800654, 0.053404587842179274, 0.09584558984349001, 0.10048183251587883, 0.09765456789936078, 0.03806894540616257, 0.03420889973072461, 0.03893520971256792, 0.22523100756020742, 0.21117430706581453, 0.2254550942674406, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013968485692145927, 0.013939386777830909, 0.013516705745271862, 0.009727391673430508, 0.01050042951739627, 0.010622938956351247, 0.14124775749224994, 0.14076381325708143, 0.13760002822736161, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "dcb38052-03d2-4d00-96ff-c6a71418edb4", "fitness": 0.026866220728217358, "name": "HybridDELevy", "description": "Enhance adaptability by dynamically adjusting mutation factor based on population diversity and success rate.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        diversity = np.std(self.population, axis=0).mean() / (self.upper_bound - self.lower_bound)  # New line\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor * (1 + diversity)  # Modified line\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 44, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.003672387220971629, 0.0036390694318426675, 0.0029431017471757137, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05868263007215757, 0.06024109021166113, 0.05884369593556549, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05328781849376063, 0.058525534852800654, 0.05402583272678585, 0.09617088978914645, 0.09653994761710716, 0.09667456941019426, 0.03445677013756865, 0.039004867868003834, 0.03703068756857464, 0.22091866195075682, 0.21164948367126413, 0.2287609784550445, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01400616770019203, 0.01402533847400822, 0.013459212077233218, 0.009849148205274383, 0.010492758417264825, 0.010653998900725381, 0.14446498803227736, 0.14076381325708143, 0.142019232815906, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ba52c39a-6f25-40f5-88c9-298c08793f4a", "fitness": 0.02589112783232225, "name": "HybridDELevy", "description": "Introduce adaptive scaling and inertia in mutation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size  # New line\n        inertia_weight = 0.9 - (0.7 * (self.budget_used / self.budget))  # Change 1\n        adaptive_scaling = 1 + np.std(self.fitness) / (np.abs(np.mean(self.fitness)) + 1e-8)  # Change 2\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx]) * inertia_weight) * adaptive_scaling * learning_rate * success_rate  # Change 3\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 45, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.0060173080313740135, 0.003912994471674924, 0.0029039509335805347, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06599615895088651, 0.06468792407404855, 0.06750544972399242, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04973828628524701, 0.058525534852800654, 0.05465767759678841, 0.09391564131717034, 0.0919500324388568, 0.11114081845709944, 0.03127820129441716, 0.04131341966361457, 0.038426462659591265, 0.1882101312173623, 0.17717527759956841, 0.1975899625667752, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013959696111191633, 0.013922932112040098, 0.013465535850863963, 0.009614174858080582, 0.010517468261907137, 0.010644381431890504, 0.14743760542897555, 0.14273126556085336, 0.1373576947852455, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c41613e3-b928-404d-885f-bca712e25679", "fitness": 0.024814861392961383, "name": "HybridDELevy", "description": "Enhance search dynamics by incorporating adaptive step sizes based on current generation diversity.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        diversity = np.std(self.population, axis=0).mean()  # New line\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity  # Modified line\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 46, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.05.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.005739910213141131, 0.00532074017814943, 0.0047899598919842745, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06394179945556022, 0.06386674507874412, 0.05474792184125654, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05018848484163374, 0.058525534852800654, 0.05467471085931208, 0.0924655461236451, 0.09633992156726057, 0.09512876906724876, 0.036454972919157114, 0.03852572079657779, 0.034298957051214884, 0.16844653604143034, 0.15708518135704197, 0.16996627614917104, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015194368885499299, 0.013744167664151652, 0.015308590883770234, 0.011266519312223333, 0.011566465753702238, 0.01108205594650169, 0.14293367966081894, 0.14294767293562027, 0.152553593574297, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "14324579-18b1-4774-b739-8c8ca3a7049f", "fitness": 0.027305402998616796, "name": "HybridDELevy", "description": "Enhance convergence by integrating chaotic maps for dynamic parameter adaptation and leverage mutation diversity.", "code": "import numpy as np\n\nclass HybridDELevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)  # New line\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):  # New function\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)  # Logistic map\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n    \n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[idx]  # New line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor  # Modified line\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n    \n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.1\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 47, "feedback": "The algorithm HybridDELevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["922b0cad-7104-448c-b9f7-340da983cb90"], "operator": null, "metadata": {"aucs": [0.0031579620790845864, 0.0036959371753987336, 0.003007226142872188, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06542095847087159, 0.05858308308826532, 0.05471850245526089, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049037321827121505, 0.061901661905274574, 0.049072332277178665, 0.09585675718580622, 0.09421215366295577, 0.09794822011078552, 0.038329951466135825, 0.03616074398518021, 0.036128375860896456, 0.23910120598253404, 0.23889761308241408, 0.2386540261293848, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013673127063341006, 0.014048504703554565, 0.01331068169054661, 0.009054148385803096, 0.010486000010012098, 0.010153314105705857, 0.14124775749224994, 0.1408674496578486, 0.12969878251262157, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6d697f09-d7d7-418a-9a81-fd853986914c", "fitness": 0.02740196114937889, "name": "HybridDELevyEnhanced", "description": "Enhance solution accuracy by incorporating adaptive parameter tuning and improving diversity through chaotic learning.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 48, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["14324579-18b1-4774-b739-8c8ca3a7049f"], "operator": null, "metadata": {"aucs": [0.004509565757820466, 0.005868841243221179, 0.0027838279156551238, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06162670894940536, 0.056525937230153644, 0.055603513274678384, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05054592772746713, 0.0641255432930723, 0.05494956127876305, 0.09544761384307232, 0.09844366948495975, 0.10154716557798704, 0.03478934562553582, 0.03634471002817008, 0.035834333400975416, 0.2305452881362402, 0.22831019544753806, 0.2306216405388377, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013955587998122354, 0.014075434319035907, 0.014746625058833729, 0.009348457188446235, 0.01048599237463288, 0.01048212997239839, 0.1454186235056657, 0.14298934550192965, 0.14345040069135695, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "64923468-5f92-4d18-a756-82ea4e0a2b30", "fitness": 0.027117708887824006, "name": "HybridDELevyEnhanced", "description": "Improve adaptive parameters and enhance global exploration by refining chaotic sequence utilization.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor * 0.9  # Enhanced factor scaling\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx])\n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx + int(0.3 * self.population_size)) % self.population_size]  # Refined chaotic sequence utilization\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 49, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["6d697f09-d7d7-418a-9a81-fd853986914c"], "operator": null, "metadata": {"aucs": [0.004608088106895614, 0.006021776853555427, 0.0033808897732089394, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06316351738087678, 0.05509552935231232, 0.0538096192557912, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.046391004880743325, 0.0644149998389103, 0.0553697267743104, 0.09448047953067229, 0.09582465838261112, 0.09382036916355263, 0.037002703637997736, 0.038420139643214224, 0.03763588330141587, 0.22856896035694096, 0.22782310704755582, 0.22944423351410004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01385215241655502, 0.013312982107853588, 0.013579969089745347, 0.009499975615603784, 0.010565054581558542, 0.010502521366478779, 0.14209498131981213, 0.14076381325708143, 0.14346268598266954, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a4041ce4-5446-46e5-8de3-c8e602d02015", "fitness": 0.027165879833002542, "name": "HybridDELevyEnhanced", "description": "Refine search dynamics by integrating adaptive levy flight and improved chaotic sequence for enhanced convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = np.random.choice(self.chaotic_sequence)  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight(step_size=0.05) + 0.1 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 50, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["6d697f09-d7d7-418a-9a81-fd853986914c"], "operator": null, "metadata": {"aucs": [0.003848455861454547, 0.004389381813931559, 0.004518076191112885, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.060516749260591696, 0.05857224749689405, 0.0536983150135687, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048576666706693805, 0.058525534852800654, 0.0614467669392752, 0.09571743989282266, 0.09719829199503016, 0.09374672949163221, 0.033437221419571284, 0.035011402711922934, 0.037354566554442026, 0.2304853092829542, 0.229442457217079, 0.23055355611517114, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013713982400816338, 0.013632395201650382, 0.014607000168835538, 0.009283172225898917, 0.010488286510358602, 0.010219238261622965, 0.14173783441216603, 0.1422066518952234, 0.14345040069135695, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "fc5dc55c-7fef-44c0-b159-1cc0fa9a1d14", "fitness": -Infinity, "name": "HybridDELevyEnhanced", "description": "Enhance solution accuracy by incorporating adaptive parameter tuning, improving diversity through chaotic learning, and introducing an elite archive mechanism.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n        self.elite_archive = []  # Added\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def update_elite_archive(self, solution, fitness):  # Added\n        if not self.elite_archive or fitness < func(self.elite_archive[-1]):  # Added\n            self.elite_archive.append(solution)  # Added\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_elite_archive(trial, trial_fitness)  # Added\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n                        self.update_elite_archive(levy_trial, levy_fitness)  # Added\n        return self.population[self.select_best()]", "configspace": "", "generation": 51, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["6d697f09-d7d7-418a-9a81-fd853986914c"], "operator": null, "metadata": {}}
{"id": "493f6ae4-7665-419a-8da4-c56f449a5f91", "fitness": 0.027401961147864543, "name": "HybridDELevyEnhanced", "description": "Slightly adjust the mutation strategy by incorporating a global best scaling factor to potentially enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        global_best_factor = 0.1 * (self.population[best_idx] - self.population[idx])  # New global best scaling factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx] + global_best_factor)) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 52, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["6d697f09-d7d7-418a-9a81-fd853986914c"], "operator": null, "metadata": {"aucs": [0.004509565757830791, 0.005868841243221179, 0.0027838279156551238, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06162670894968614, 0.056525937231046264, 0.05560351327467461, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050545927725117235, 0.0641255432930723, 0.05494956127705097, 0.09544761384377975, 0.0984436694961709, 0.10154716557935539, 0.03478934562555447, 0.03634471002895834, 0.035834333401090324, 0.23054528813651554, 0.22831019544682618, 0.23062164053920498, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013955587997484975, 0.014075434318871594, 0.014746625058818519, 0.00934845718768651, 0.01048599237463288, 0.010482129972455234, 0.14541862349899992, 0.14298934538982455, 0.14345040069135695, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ef9322be-a937-4450-afb8-6ab6f7e72e9a", "fitness": 0.0272143402064212, "name": "HybridDELevyEnhanced", "description": "Refine the mutation and crossover strategy by introducing a randomization factor for better diversity and exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        randomization_factor = np.random.uniform(0.8, 1.2)  # Added randomization factor\n        mutated = ((self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor * randomization_factor)  # Modified\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 53, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["6d697f09-d7d7-418a-9a81-fd853986914c"], "operator": null, "metadata": {"aucs": [0.004811543950554387, 0.005265090699570485, 0.006667851905655997, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05432579343799615, 0.05826762923582007, 0.05587985291809672, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04949177698712526, 0.06147408187159531, 0.05736177965443501, 0.0956007248122338, 0.09456809233858365, 0.09478388285576034, 0.03733915451475245, 0.03409969734719964, 0.03834071881474699, 0.23031930880439644, 0.22886548449512378, 0.23067304010344014, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013673581112554123, 0.013650158350297148, 0.014107239315720776, 0.009135467796235086, 0.010989628425843723, 0.011645603138870753, 0.1440978798406295, 0.14076381325708143, 0.143668401486702, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4ccca1ee-55db-4b4a-a06b-a221cbf21ae3", "fitness": 0.027881354310019098, "name": "HybridDELevyEnhanced", "description": "Enhance solution accuracy by optimizing the initialization process with improved chaotic sequences.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 54, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["6d697f09-d7d7-418a-9a81-fd853986914c"], "operator": null, "metadata": {"aucs": [0.005373961577074815, 0.007443279297460248, 0.004939711173963968, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06537757640124398, 0.058762644334029446, 0.05515169117890206, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05010133700552122, 0.05480086748956481, 0.05917714394790474, 0.10445304592939186, 0.09689802792474278, 0.1041891418591313, 0.04352913629022859, 0.04000920836546018, 0.039892485725266824, 0.2283702667060865, 0.2307641705270923, 0.23077133967735242, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014371407639610312, 0.013504718059246246, 0.0145838624608432, 0.010823864211258027, 0.009163133485367125, 0.00908844444007939, 0.13208356076745242, 0.15057839915739446, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "911135fd-4876-4654-a487-2175c8e7d06c", "fitness": 0.027420703944120297, "name": "HybridDELevyEnhanced", "description": "Hybridize differential evolution with adaptive chaotic sequences and Levy flights for enhanced solution accuracy.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size] \n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n                if np.random.rand() < 0.1:  # New line: Occasionally add a random step to escape local optima\n                    self.population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n                    self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n                    self.fitness[i] = func(self.population[i])\n                    func_evals += 1\n                    self.budget_used = func_evals\n        return self.population[self.select_best()]", "configspace": "", "generation": 55, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["4ccca1ee-55db-4b4a-a06b-a221cbf21ae3"], "operator": null, "metadata": {"aucs": [0.004406952760356075, 0.005442267690611624, 0.009149202776917331, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07121239335656848, 0.05810047786839434, 0.05091378945021041, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052115359038300224, 0.05599382031382705, 0.04475356620541804, 0.10256019221010482, 0.09158391405704369, 0.1093878995210017, 0.043393337418590416, 0.03438619038794832, 0.03744203711084437, 0.22751522609983932, 0.2284721238638182, 0.2305462547674232, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01362174133978089, 0.014960638139329019, 0.01421481151979942, 0.011070927626335103, 0.009390534865714839, 0.009548285424979985, 0.13508671605637157, 0.14627708000596495, 0.1431797267098629, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "393e1eaa-a571-4405-bbcc-d424458f064f", "fitness": 0.027898063316480728, "name": "HybridDELevyEnhanced", "description": "Introduce an adaptive component to the mutation factor to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 56, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["4ccca1ee-55db-4b4a-a06b-a221cbf21ae3"], "operator": null, "metadata": {"aucs": [0.0053763361080874095, 0.007443279297559502, 0.0057993414266870325, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06537757638514552, 0.05880041584178641, 0.05514864691801724, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05010133704886832, 0.05480086748956481, 0.059177143894827866, 0.10445304593010607, 0.09700934997144839, 0.10418914185887351, 0.04352913629022859, 0.04000920836546018, 0.03989248572532711, 0.22832826153708863, 0.2308512387439584, 0.23092206756311284, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01437140763957001, 0.01350471805923581, 0.014584956610878885, 0.010823864211233936, 0.009163133485340813, 0.009086553819716015, 0.13208356078135874, 0.15057839909342463, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "1cf33f97-9ab2-48e9-89a0-5936d89d92f9", "fitness": 0.0276624370316581, "name": "HybridDELevyEnhanced", "description": "Adjust the mutation factor formula and enhance the population initialization for improved convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * (0.5 + 0.5 * improvement_factor)  # Modified for enhanced dynamics\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 57, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.005594437803213892, 0.007076543936689883, 0.005060714376815989, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07258094812092031, 0.0673526681779858, 0.06489066130154397, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04909404228988146, 0.0510236861730885, 0.04903459616400463, 0.10592764568406976, 0.0969855289670184, 0.10395079867287937, 0.04302914322170737, 0.033419743359364595, 0.04227989042919189, 0.22580553442199802, 0.22853511835101215, 0.2303490605531363, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014546546248046521, 0.01341469331507461, 0.01464869477473929, 0.010956493264442257, 0.009326673753660364, 0.010025064303917808, 0.13428889900972163, 0.1476553056762191, 0.1352771165377341, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "fd300db5-b7f4-4d17-92ff-687bb8734dda", "fitness": 0.027101825020324412, "name": "HybridDELevyEnhanced", "description": "Adjust the chaotic sequence generation and adaptive crossover probability to enhance exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.5  # Changed initial value to a constant for more consistent chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (0.5 + 0.5 * (1 - self.budget_used / self.budget))  # Slightly altered adaptive crossover probability\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 58, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.012049276339502035, 0.010646050883762248, 0.00893413232150142, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06766170392448245, 0.06296802598468909, 0.05508765050797593, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04501434764125212, 0.06069938220186344, 0.0517481041331781, 0.0937560195104915, 0.09750758218617572, 0.09714462374346722, 0.039183039987196966, 0.039939141837557424, 0.03712524706189946, 0.20950329289438163, 0.22095228535439027, 0.20984829105169533, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013874342083837976, 0.014250929518619615, 0.01570882379112215, 0.010586607545110427, 0.01265699589757907, 0.010904957766781243, 0.14666073662340706, 0.14253889694007693, 0.14481569634005553, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f54924bf-3374-445d-8ed5-2742513c1b74", "fitness": 0.026787707901728984, "name": "HybridDELevyEnhanced", "description": "Add local search to refine solutions after mutation and crossover operations to improve convergence efficiency.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def local_search(self, solution, func):  # New local search function\n        step_size = 0.01\n        new_solution = solution + step_size * np.random.uniform(-1, 1, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        return new_solution if func(new_solution) < func(solution) else solution\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n                # New: Apply local search after mutation and crossover\n                self.population[i] = self.local_search(self.population[i], func)\n        return self.population[self.select_best()]", "configspace": "", "generation": 59, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.002600229112410868, 0.002454801152467656, 0.006444117857819509, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058859553372259454, 0.05264045870685308, 0.05923511058406483, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.054374255612803735, 0.05493842930564963, 0.05135002837809388, 0.10204338687365355, 0.0926064038837413, 0.0971829602831582, 0.042872180498569334, 0.032644487993164994, 0.03584152784175609, 0.22243530263218048, 0.22532539376680683, 0.2294223655503963, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013506430836205618, 0.012927803343428468, 0.01421481151979942, 0.01065317882238459, 0.008752225821863635, 0.009205010965462668, 0.13474697503066224, 0.1463866142950313, 0.135485707492494, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "33aacd8d-a073-40df-bf93-8d79027e62d2", "fitness": 0.027102968482643083, "name": "HybridDELevyEnhanced", "description": "Introduce a slight adjustment in the crossover probability to enhance adaptability based on the average fitness of the population.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2 + 0.01 * np.mean(self.fitness)  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 60, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0004666460114112203, 0.0014087984316519808, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0685315906394598, 0.0575480771493041, 0.05120130014314783, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05506435736295867, 0.061748070078902706, 0.050983444580736226, 0.10314045946836814, 0.09467177912113311, 0.09787843772159444, 0.04320930548118329, 0.03492564256425479, 0.03441514985161176, 0.22895725124119248, 0.231093494454226, 0.23086017756611665, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.012954099673580521, 0.013174016939418998, 0.01421481151979942, 0.010648310020477059, 0.008999813325266559, 0.008822374343158357, 0.13289730362891028, 0.1492542393667151, 0.1343447800657216, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8871aedd-9863-4110-8372-5dc2698f0ce5", "fitness": -Infinity, "name": "HybridDELevyEnhanced", "description": "Introduce a dynamic population size adjustment and an improved selection strategy based on fitness variance to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        # Change: Improved selection by focusing on fitness variance\n        variance = np.var(self.fitness)\n        if variance > np.mean(self.fitness):\n            return np.argmin(self.fitness)\n        return np.argmax(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Dynamically adjust population size\n                self.population_size = int(15 * self.dim * (1 - self.budget_used / self.budget)) + 1\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 61, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {}}
{"id": "121d8231-4db8-43fd-aba6-367796f6eb89", "fitness": 0.0272490376550583, "name": "HybridDELevyEnhanced", "description": "Incorporate an adaptive learning rate and improved chaotic sequence to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.7  # Modified initial value to improve chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        adaptive_learning_rate = (0.5 + 0.5 * (1 - self.budget_used / self.budget)) * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * adaptive_learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 62, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.005645727310369053, 0.00629008605310144, 0.005912619135614361, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05708733128630206, 0.060114316956143554, 0.0583386115784309, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.045999601916297705, 0.058525534852800654, 0.056908664511842844, 0.0952739711254158, 0.09969899448685604, 0.0958298718550874, 0.03457354414019298, 0.03567382870334079, 0.034496650383951444, 0.23032534820928852, 0.2256867535064072, 0.2304162506962787, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013927312650633406, 0.015045064741139536, 0.01438060095336946, 0.010137783594898475, 0.010500873228278307, 0.010683561727468538, 0.14412859636817066, 0.14331359310985559, 0.14345040069135695, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9a2ac93c-3282-45a4-ab50-7c8c16f775ec", "fitness": 0.022883106016431735, "name": "HybridDELevyEnhanced", "description": "Adjust mutation strategy to incorporate random perturbation for enhanced exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        perturbation = np.random.randn(self.dim) * 0.1  # Added random perturbation\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor + perturbation\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 63, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.003980596297299077, 0.0076752813755711635, 0.005809251487466804, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06056396045322621, 0.0551664103054772, 0.05941345978569146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05083245522671842, 0.0562551201114041, 0.05245363972111039, 0.10399902381112203, 0.0983602081086834, 0.09688518854183592, 0.04470775383136916, 0.03455166174060964, 0.040020917861516514, 0.12131525381044117, 0.12253056358502312, 0.12088373025496257, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013915558970112651, 0.01379559026503474, 0.01421481151979942, 0.010648310020477059, 0.009440080881167656, 0.01041464018883842, 0.1332657222452206, 0.14924327637614243, 0.13767594901545832, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "56e85434-db11-46d2-b278-01cb3f74028c", "fitness": 0.02789231037031692, "name": "HybridDELevyEnhanced", "description": "Enhance the exploration by adjusting the Levy flight step size dynamically based on the improvement percentage.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step_size = 0.01 * (1 + (self.fitness[i] - self.fitness[best_idx]) / (self.fitness[best_idx] + 1e-8))\n                    levy_step = self.levy_flight(step_size=levy_step_size) + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 64, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.0074041069242639646, 0.007587000882622874, 0.004217982233456152, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06309731799092944, 0.05884173614313648, 0.055065433929974095, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05345781296728602, 0.054843288234434184, 0.05827696731598042, 0.10440261978370058, 0.09877760109904599, 0.09754199164522659, 0.045742227997744744, 0.041461363182731636, 0.04024267519439051, 0.2282840629680778, 0.230982879766079, 0.23082275183336542, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014371727218103203, 0.013504684770640707, 0.014584956610878885, 0.010823563105384904, 0.009126333652414442, 0.009086526423678354, 0.13169988016123602, 0.14627708000596495, 0.1581565572307656, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7f900594-6fca-462f-b2da-f38288d720d8", "fitness": 0.027891941322780087, "name": "HybridDELevyEnhanced", "description": "Enhance mutation strategy by adapting mutation factor dynamically based on success rate.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget) * (np.sum(self.fitness < self.fitness.mean()) / self.population_size + 0.5)  # tweaked\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 65, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.0053757234514252294, 0.007443279297285277, 0.004906613662434722, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06537757639553887, 0.05879930386970955, 0.05514972837684151, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05010133705549813, 0.05480086748956481, 0.05917714392346185, 0.10445304592986793, 0.09700832618539612, 0.10418914185951644, 0.04352913629022859, 0.04000920836547306, 0.039892485725185334, 0.2283113491410187, 0.2307009958742403, 0.23092310650918668, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014371407639507727, 0.013504718059214271, 0.014584992893924786, 0.010823864211277678, 0.009163133485335706, 0.009706244965945299, 0.13208356079516348, 0.15057839909821857, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "53d09684-bc76-4624-a622-ba597c7d6b1a", "fitness": 0.02753675929119981, "name": "HybridDELevyEnhanced", "description": "Introduce a dynamic learning rate and an adaptive chaotic sequence to balance exploration and exploitation based on convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) + 0.1 * improvement_factor  # Changed line\n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx + int(self.budget_used / 10)) % self.population_size]  # Changed line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 66, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.005934324323003892, 0.007463137442662693, 0.005235236758961093, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06359303093686064, 0.06245626878706978, 0.05482532056144307, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05271539500594158, 0.05341028276123716, 0.04958602672887358, 0.1031317401544396, 0.09626015048406478, 0.09996813148089567, 0.04296157960539981, 0.03183008688796929, 0.04011195898277409, 0.22819505642596927, 0.23066371391643303, 0.23092224881337609, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01433474160109216, 0.013422354904876643, 0.014488109698363338, 0.011561707283330835, 0.01122801665730011, 0.00999094112863963, 0.1323857773747914, 0.14627708000596495, 0.150129032863347, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4ef17ccf-df73-451e-a2dd-bf75774798c3", "fitness": 0.02672031436351656, "name": "HybridDELevyEnhanced", "description": "Introduce a dynamic chaotic sequence and implement a learning mechanism to balance exploration and exploitation based on success rate.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)  # Line 1\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        sequence = []  # Line 2\n        for i in range(length):\n            x = np.random.rand() # Line 3\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        dynamic_chaos = self.chaotic_sequence[idx % self.population_size] * success_rate  # Line 4\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * dynamic_chaos  # Line 5\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.1 * global_best  # Line 6\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 67, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.004154614085675856, 0.006113806971168589, 0.003954335705104617, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05118955434150119, 0.05751124227977633, 0.06221486909482965, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05295934599332308, 0.058752345239110104, 0.04918772102529623, 0.09551191575155116, 0.09535025480974368, 0.09410807800180643, 0.03549074089861104, 0.038469676604373615, 0.03614280826127292, 0.2130664169209877, 0.2302668621269035, 0.22258787504368183, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013699564933101205, 0.013453080401288009, 0.013769124866691906, 0.009216725464050057, 0.010489165446334714, 0.010152705115694882, 0.1414871084357171, 0.14083645687714075, 0.14416102208715098, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5274eded-f2bf-4916-a309-9d5596433d58", "fitness": 0.027567609239093765, "name": "HybridDELevyEnhanced", "description": "Introduce a reinforcement learning-inspired reward mechanism to dynamically adjust mutation and crossover parameters for enhanced convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n        self.reward_history = np.zeros(self.population_size)  # Added to track rewards\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        \n        reward_factor = np.tanh(self.reward_history[idx])  # Added reward adjustment\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor * reward_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2 \n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.reward_history[i] += 1  # Added reward increment\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 68, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.007078963891970158, 0.006971061113236754, 0.004827581347116361, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06474809508508594, 0.05470580221448751, 0.055660412721379005, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05495995946845711, 0.06375835269271746, 0.046887393562539126, 0.10393579949922538, 0.09248338129823386, 0.09967925790403409, 0.04359055892442565, 0.0342596971002721, 0.04237821353534621, 0.23136517519666366, 0.23240663867453626, 0.23162620500882047, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014156206176409003, 0.013288119838603452, 0.014589650542674137, 0.011239412824321171, 0.009776091784498675, 0.009384277401780938, 0.13836999397850647, 0.14627708000596495, 0.13689926603213998, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d1928715-4a72-4be0-acb9-3268e992bb08", "fitness": 0.027768099398991115, "name": "HybridDELevyEnhanced", "description": "Improve convergence speed by incorporating a self-adaptive scaling factor and enhancing mutation strategy based on population diversity.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        diversity = np.linalg.norm(self.population - self.population.mean(axis=0), axis=1).mean()  # Diversity measure\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx])\n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        self_adaptive_scaling = 0.5 + 0.5 * (diversity / (diversity + 1))  # Self-adaptive scaling\n        mutated = self_adaptive_scaling * (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 69, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.00539880599151199, 0.007538349927286303, 0.004831882503881779, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06695015613620303, 0.05595718395419225, 0.05140798196666452, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05459393569687088, 0.05864469973562292, 0.053570172757788526, 0.10598957247864449, 0.09378621473348192, 0.10039542530049583, 0.04534560620679973, 0.03966272963441719, 0.04376202164720844, 0.22834885173021569, 0.23093852360590417, 0.23086378172765798, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014344830400314645, 0.013397364148182378, 0.014551672925373071, 0.010853366418611565, 0.009088482227575856, 0.009748803707555487, 0.1392294773491134, 0.14993612594845374, 0.14060192047602726, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "206e428d-3eac-465b-88b0-6f949c64de18", "fitness": 0.027031146468843234, "name": "HybridDELevyEnhanced", "description": "Enhance the adaptive crossover probability by including population diversity to encourage exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (self.population[b] - self.population[c] +\n                                              self.population[best_idx] - self.population[idx])) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        diversity = np.std(self.fitness) / (np.mean(self.fitness) + 1e-8) # Change 1\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2 + diversity * 0.1  # Change 2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 70, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0007049050558630698, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06071866128835823, 0.060174793714164565, 0.03907274457529475, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04909404228988146, 0.05564340093901232, 0.04765725740439042, 0.10569192897059032, 0.09162920642201011, 0.09803670073471693, 0.042872180498569334, 0.03439704778476638, 0.037471034941815695, 0.2289152892179035, 0.23129484786207777, 0.23088608521426113, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014334828261054144, 0.013329425997918531, 0.014587004282094806, 0.010824069206714193, 0.009707992464105142, 0.009026486771644637, 0.13977088194644371, 0.14627708000596495, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f0310628-2b8a-4c32-93ac-4f62e12407b5", "fitness": 0.02792731556329799, "name": "HybridDELevyEnhanced", "description": "Refine mutation by using weighted factors for exploration, enhancing convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 71, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["393e1eaa-a571-4405-bbcc-d424458f064f"], "operator": null, "metadata": {"aucs": [0.00694253020774005, 0.007443279298062322, 0.005652229782279972, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06537757636066899, 0.058896771857831376, 0.055103379751140324, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05010133737597722, 0.05480086748956481, 0.05917714361338966, 0.10445304593090654, 0.09699638511773945, 0.10418914185711836, 0.043529136290244574, 0.04000920836520194, 0.039892485725616766, 0.22854844509353478, 0.2307939223290152, 0.2307883105545323, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014371407639338751, 0.0135047180591219, 0.014585110709978255, 0.010823864211051193, 0.009163133485801889, 0.00970624500777062, 0.13208356074493, 0.15057839900919268, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2941484b-329c-40fe-8d35-e323e33719c9", "fitness": 0.027923093281125362, "name": "HybridDELevyEnhanced", "description": "Improved exploration by dynamically adjusting step size in Levy flights based on adaptive mutation factor.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step * self.mutation_factor  # Change: Adjusted step size using mutation factor\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 72, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["f0310628-2b8a-4c32-93ac-4f62e12407b5"], "operator": null, "metadata": {"aucs": [0.005610660786418253, 0.007696197235114277, 0.004682096228223798, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06481516697884215, 0.06166389868919431, 0.05535741102658276, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04998415818242585, 0.05627114592375704, 0.05507260417847315, 0.10443223274051261, 0.0962640761354101, 0.10381184399119892, 0.04387364613785438, 0.03993228748720723, 0.04210847419906183, 0.22831438682794525, 0.23083312030454928, 0.23076670662128362, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014370856622536676, 0.01367303342864612, 0.014585633196198877, 0.010843139388442502, 0.009126519762851393, 0.009684642274596644, 0.1483571151699572, 0.14828132067540412, 0.14048512465703233, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "150c1a9e-030c-43d1-89b3-a4159de08f30", "fitness": 0.027790566733865034, "name": "HybridDELevyEnhanced", "description": "Incorporate adaptive levy flight scaling by adjusting step size based on budget consumption.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step * (1 - self.budget_used / self.budget)  # Changed line\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 73, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["f0310628-2b8a-4c32-93ac-4f62e12407b5"], "operator": null, "metadata": {"aucs": [0.005601845998777111, 0.008296768187703085, 0.0056615407911709825, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06499369867781102, 0.0616343325508818, 0.0545007291360462, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051090551575252885, 0.05503315495182626, 0.05596112579018475, 0.10449437483507273, 0.0973347053392496, 0.10419620290744658, 0.04364412981387078, 0.039963979367006575, 0.037979776447823466, 0.2282581905155059, 0.2307646584343842, 0.2307950248028907, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014371823994717259, 0.013674571406005365, 0.014585392604177017, 0.010826411100528954, 0.00912905091776639, 0.009684671118152188, 0.13319404519966094, 0.14627708000596495, 0.14940775097709968, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "15ef417d-323e-4de3-8408-bcfb15001eea", "fitness": 0.027629420988318, "name": "HybridDELevyEnhanced", "description": "Enhanced diversity and levy step impact to improve exploration and convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Increased population size for better exploration\n        self.mutation_factor = 0.9  # Adjusted to enhance search dynamics\n        self.crossover_prob = 0.8  # Adjusted for improved balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.015):  # Adjusted step_size for better exploration\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()  # Changed initial value to randomize chaotic sequence\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]  # Improved diversity factor\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2  # Adjusted\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                # Change: Introduce adaptive mutation factor based on budget usage\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best  # Modified levy step\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 74, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["f0310628-2b8a-4c32-93ac-4f62e12407b5"], "operator": null, "metadata": {"aucs": [0.006450783443758157, 0.007480176728056787, 0.004821134884403833, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06501824690819835, 0.06182594664874708, 0.05536078567896485, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04917295236766517, 0.05633118743553478, 0.054343342628549784, 0.10419126471157891, 0.09396304814711309, 0.1031932809670345, 0.04354490743167627, 0.039835203961461785, 0.042817898405751675, 0.22837268630150231, 0.23079202833866352, 0.23082723893361679, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01433965871218823, 0.013379730138082913, 0.014588951795806326, 0.010819856969013664, 0.009123904775734881, 0.009679759549872213, 0.13486193635390498, 0.14627708000596495, 0.13834010154474474, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b1199e1a-dc8b-48a5-b498-6fb2a8ebec4c", "fitness": 0.02081026255077664, "name": "HybridDELevyEnhanced", "description": "Introduce self-adaptive mutation and crossover rates based on fitness improvement to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        fitness_improvement = (self.fitness.mean() - np.min(self.fitness)) / (np.std(self.fitness) + 1e-8)\n        adaptive_crossover_prob = self.crossover_prob * (1 - fitness_improvement) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n        return self.population[self.select_best()]", "configspace": "", "generation": 75, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["f0310628-2b8a-4c32-93ac-4f62e12407b5"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.0035536795803018384, 0.002393037622785421, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07907559699567845, 0.044712726631995325, 0.03493509966332531, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05488152807961244, 0.061748070078902706, 0.05098344458305626, 0.10020214025860008, 0.09379259043161003, 0.09718486638853885, 0.042872180498569334, 0.03564120707720375, 0.043209976432106556, 0.0703354791358104, 0.07875624180191432, 0.08170119234504791, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01437637900860711, 0.012851426292032064, 0.014257371803805707, 0.011494493796223026, 0.009619278755182648, 0.009585977583180028, 0.13620094918096148, 0.14627708000596495, 0.14769688962490113, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3c2889f3-8b37-4e1c-a0fd-f970737c6dd7", "fitness": 0.028143238158284196, "name": "HybridDELevyEnhanced", "description": "Introduce a budget-based adaptive population size to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 76, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["f0310628-2b8a-4c32-93ac-4f62e12407b5"], "operator": null, "metadata": {"aucs": [0.007478380349414171, 0.010655317423162614, 0.008185906830389444, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06791882214835587, 0.06469262129176712, 0.05423297283682127, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0515431269176968, 0.05480086748956481, 0.058084352041896214, 0.104529066005844, 0.09561953192620265, 0.10519535317216311, 0.04477633613869747, 0.0409134930728865, 0.037977705353165137, 0.22837225016892748, 0.2307646584343842, 0.23088690322146777, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01473329935032186, 0.013808118971063488, 0.014367111278859146, 0.010860095848633011, 0.00915304009018969, 0.010033304355148043, 0.13289702898054223, 0.15057839900919268, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e889ac9c-2a97-4db4-b8da-be53cff55074", "fitness": 0.026978122957606012, "name": "HybridDELevyEnhanced", "description": "Enhance the crossover probability with a dynamic success-based scaling to improve convergence speed.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2 * (self.fitness.mean() / np.min(self.fitness)) # <- Change made here\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 77, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.0007158472890802514, 0.0004925445905847869, 0.003094342693589325, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058625048775740596, 0.04948827497802477, 0.043657425744224154, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05227979695990992, 0.0596710486328792, 0.04860610442685476, 0.1020487693788219, 0.10033802823105598, 0.09913347007845008, 0.043877290745603315, 0.02963408670476586, 0.036263139268334244, 0.22877959397806413, 0.23110968559376732, 0.23092450045084634, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014617888267266954, 0.013587270887604253, 0.01452892384873472, 0.011074706695100911, 0.009448293335144409, 0.009892984832489793, 0.14068228710184372, 0.14627708000596495, 0.1440112020615809, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b456b83f-f794-4dd4-bc4b-99c04e20973e", "fitness": 0.027084699608945773, "name": "HybridDELevyEnhanced", "description": "Refine the adaptive crossover probability for better convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - (self.budget_used / self.budget) ** 2) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 78, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.0017856908063156318, 0.0014520231002734807, 0.0012707827271754013, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06841054095535981, 0.055732124548828255, 0.0464830580380905, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0521750999951639, 0.05662186411310455, 0.04698214226806596, 0.10812197357472675, 0.09291532236516442, 0.1012909442489971, 0.04436630736838765, 0.03290918956914679, 0.03825478901660717, 0.22901100698551202, 0.23109784721774496, 0.23091806118949065, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014124868520661749, 0.013158186756114354, 0.01421481151979942, 0.010648310020477059, 0.009284586963616004, 0.01030394085379771, 0.13334648182353326, 0.14683291239077212, 0.13882028751586373, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6ccbf7af-25b9-4006-9a35-aa7957ba2053", "fitness": 0.027445002523315123, "name": "HybridDELevyEnhanced", "description": "Enhance adaptive crossover probability to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / (2 * self.budget)) + 0.2  # Modified line\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 79, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.004766782988402163, 0.003512176158121827, 0.004744080029214559, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06866881346120624, 0.054055647054389144, 0.05695383154929756, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04909404228988146, 0.053741477139767846, 0.04764415768499197, 0.10445454455264214, 0.09528199864612641, 0.10019455159104718, 0.044405855288335516, 0.03352517675231337, 0.03907593124168196, 0.22860622521925744, 0.2310865715077245, 0.2308465752401595, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014206895045229428, 0.013124002223158349, 0.014902921442291217, 0.010648310020477059, 0.009146309852620549, 0.010276419356458844, 0.1335447206482222, 0.14627708000596495, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ac5cc5fa-aa75-4bb1-b8ec-a30ddae004b0", "fitness": 0.02773923040302268, "name": "HybridDELevyEnhanced", "description": "Introducing self-adaptive mutation and crossover factors with a reinforced learning approach to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n        self.mutation_factor = np.random.uniform(0.5, 1.0)\n        self.crossover_prob = np.random.uniform(0.6, 0.9)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.5 + 0.4 * np.random.rand()  # Self-adaptive\n                self.crossover_prob = 0.6 + 0.3 * np.random.rand()  # Self-adaptive\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 80, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.009634827737382778, 0.01135096305514982, 0.007414767945089218, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05742348969479538, 0.07083003635047747, 0.06621748540969485, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05249756165947217, 0.0469396258960193, 0.051153915222469815, 0.09585668174705031, 0.09705935777496721, 0.10136657814768257, 0.03658359934237143, 0.040447630395722856, 0.04187553852173331, 0.2284954344346991, 0.22899103005364108, 0.2310318081290631, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014418150233840965, 0.014588478819544504, 0.015022185934281618, 0.012047229489675293, 0.013250466577475306, 0.010847190254414607, 0.14607621642732183, 0.13876543388248352, 0.13747368848980845, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b4ec0103-5e5f-4fc7-a9b8-643da9523e13", "fitness": 0.02794118057274865, "name": "HybridDELevyEnhanced", "description": "Introduce a slight adjustment to the Levy flight step size to enhance overall exploration capabilities.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.015):  # Slight adjustment to step size\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 81, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.008046834899091304, 0.009899359823421827, 0.008173754086051921, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06799309791563302, 0.06332660725360884, 0.054738167835428064, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0494207153793893, 0.05517870018874338, 0.05688795711955974, 0.10455761121589024, 0.09544362466988487, 0.10060337894248217, 0.04475760025115827, 0.041106241911272656, 0.04003441469053226, 0.2285220504783949, 0.23078152501613192, 0.2308005621452187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014774846192742719, 0.013796617932503863, 0.014421903536623204, 0.010993446167011367, 0.009141788859423183, 0.010050292727995735, 0.14300338363231768, 0.14627708000596495, 0.13946822097012135, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7f6099e7-2fbd-4aad-ba0a-97ba81fa6736", "fitness": 0.02792731556329799, "name": "HybridDELevyEnhanced", "description": "Refine the evolutionary strategy by introducing a history-based adaptation mechanism to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n        self.history = []  # Modified: Added history for adaptation\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def adapt_population_size(self):  # Modified: New method to adapt based on history\n        if len(self.history) > 5:\n            improvement = np.mean(self.history[-5:])\n            self.population_size = max(5, int(self.initial_population_size * (1 - improvement)))\n            \n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.history.append(self.fitness[best_idx])  # Modified: Track fitness history\n            self.adapt_population_size()  # Modified: Adapt population size based on history\n        return self.population[self.select_best()]", "configspace": "", "generation": 82, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.00694253020774005, 0.007443279298062322, 0.005652229782279972, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06537757636066899, 0.058896771857831376, 0.055103379751140324, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05010133737597722, 0.05480086748956481, 0.05917714361338966, 0.10445304593090654, 0.09699638511773945, 0.10418914185711836, 0.043529136290244574, 0.04000920836520194, 0.039892485725616766, 0.22854844509353478, 0.2307939223290152, 0.2307883105545323, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014371407639338751, 0.0135047180591219, 0.014585110709978255, 0.010823864211051193, 0.009163133485801889, 0.00970624500777062, 0.13208356074493, 0.15057839900919268, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f3634418-a6ec-4f22-91b5-f14a4b900424", "fitness": 0.02783011174897212, "name": "HybridDELevyEnhanced", "description": "Utilize an adaptive mutation factor strategy to enhance convergence speed by modifying the dynamic mutation factor.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        adaptive_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))  # Changed line\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   adaptive_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 83, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.005131523993914366, 0.005242259888816436, 0.01038692017814924, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0707654398535893, 0.06141714967339751, 0.07041219710019864, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05055925335894185, 0.05992788494914869, 0.05093868147355729, 0.10425799502693345, 0.09817982961777905, 0.10230868500738366, 0.04383226903213955, 0.03363854120635412, 0.037322670676571135, 0.22049834620581987, 0.22754782511797766, 0.22904404713209203, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013940231602982744, 0.01387280442052996, 0.01436312478211077, 0.010648310020477059, 0.009905210588377011, 0.01029806331760963, 0.13060705843806786, 0.14719887065327597, 0.15195763521849304, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e52d06a6-ff90-4bcc-8826-dbea6b1eb032", "fitness": 0.02786473429181796, "name": "HybridDELevyEnhanced", "description": "Adjusted the chaotic sequence generation to enhance dynamic diversity by slightly modifying its initial value.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = 0.5 + np.random.rand() * 0.01  # Slightly modified initial value for diversity\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 84, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.006797369814148024, 0.008255282190355095, 0.005825536800570186, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0667125631867026, 0.0626989787830936, 0.05656032102853403, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051592698574812634, 0.058476653425765135, 0.0500848749858982, 0.11107225699029821, 0.09461351954824315, 0.10143699380113502, 0.044850380603909445, 0.03930717462707156, 0.039939582602068646, 0.23131469988679765, 0.23202490191431557, 0.23001227700337168, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014507865092179939, 0.013208582923516787, 0.014354244148513384, 0.010882778637243185, 0.009598144545130971, 0.010373620210898049, 0.13488526267955592, 0.14627708000596495, 0.1410320076094943, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "21a485f7-06b4-43b9-90c7-ff1b909a42e0", "fitness": 0.027795859698593425, "name": "HybridDELevyEnhanced", "description": "Enhance exploitation by dynamically adjusting the mutation factor and introducing competition-based survival to improve convergence speed.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget) + 0.1 * np.random.rand()  # Change 1\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n            # Change 2: Introduce competition-based elimination\n            if np.random.rand() < 0.5:  # Change 3\n                competitors = np.random.choice(self.population_size, size=2, replace=False)\n                loser = competitors[np.argmax(self.fitness[competitors])]\n                self.population[loser] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[loser] = func(self.population[loser])\n        return self.population[self.select_best()]", "configspace": "", "generation": 85, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.005769290969008245, 0.006788937831109343, 0.009920436325307036, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06830049400728766, 0.059309623058228955, 0.055368854293848635, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.058330933219365, 0.05990922145149935, 0.0462506189882248, 0.10403649530766179, 0.10222417123890115, 0.10362931417058363, 0.04519819454584273, 0.03489125383088065, 0.04093383887309898, 0.2285617571292312, 0.22912464787847042, 0.23070605388863585, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013635992705045119, 0.0132779303352204, 0.01421481151979942, 0.010648310020477059, 0.009430277076596383, 0.010488657093295162, 0.13726236078572007, 0.14627708000596495, 0.1372471243581176, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "cb15ea91-b9fb-4181-880d-7e790a602572", "fitness": 0.027818815026247747, "name": "HybridDELevyEnhanced", "description": "Enhance mutation strategy by incorporating a diversity boost from the chaotic sequence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor * (1 + 0.05) # Change: Added a small diversity boost\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 86, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.007701339156732656, 0.011048810639634032, 0.006326637283180614, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06550350738038757, 0.06084484272133006, 0.0572624159466697, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05396179864577666, 0.05200763932396102, 0.05180729142088303, 0.10512367572201342, 0.0953745510786449, 0.10487389745967413, 0.04480022783441817, 0.04057841536209017, 0.03370945050389562, 0.22832594468492473, 0.23066919432473132, 0.23079240718692684, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014742225780245977, 0.013915138080537903, 0.014317220889766835, 0.010859581857324052, 0.009192833642518994, 0.009926737234399075, 0.14788293664109764, 0.14627708000596495, 0.1355636636908022, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "dc5053d8-b42a-4d72-94ea-54433ee9247c", "fitness": 0.021009762131841733, "name": "HybridDELevyEnhanced", "description": "Refine mutation dynamics by adjusting the learning rate and introducing a new diversity factor.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        diversity_factor = (self.fitness.std() / (self.fitness.mean() + 1e-8))  # Changed line\n        learning_rate = 0.5 * (1 + self.fitness[best_idx] / (self.fitness[idx] + 1e-8))  # Changed line\n        mutated = self.population[a] + dynamic_mutation_factor * (self.population[b] - self.population[c]) * learning_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 87, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.007902293622377266, 0.004420697817951957, 0.008435765631200076, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00046649309005653006, 0.0012119995820987217, 0.000788768691867392, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.060463483294266984, 0.053268725567233166, 0.043749059830289205, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05311814824799754, 0.05710280915627075, 0.04741948385282957, 0.10285629097921545, 0.09146749226563278, 0.096922580301538, 0.04638278444455646, 0.03412295151708644, 0.041112119532398905, 0.07942490541823921, 0.0863224689632508, 0.07953295382432568, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.012866371357607265, 0.014055489420876754, 0.01451093784728108, 0.011938798743652335, 0.010351759209357714, 0.01193864545331269, 0.13675990389612513, 0.14627708000596495, 0.13925074236252588, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c755124c-0e7c-470a-844f-cf37865bbc63", "fitness": 0.02779986843899661, "name": "HybridDELevyEnhanced", "description": "Refine the balance between exploration and exploitation by adjusting the mutation factor scaling during the evolution.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor + 0.1  # Change: refined mutation factor scaling\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 88, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.01153817490263287, 0.008470321312434526, 0.006639374039734691, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06841084728240232, 0.059732608962885125, 0.06246269088779266, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05311513463922535, 0.05880565609316546, 0.05227462695146756, 0.104750990957163, 0.09463365737077745, 0.10026903235894502, 0.044605761710978076, 0.034698116192377726, 0.038881153469114915, 0.22676537761652382, 0.22959121580334574, 0.2307989593684514, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014720171156830664, 0.014348568125718608, 0.014329705032648632, 0.010648310020477059, 0.009080330061328246, 0.010119008490007353, 0.13808944892509312, 0.14627708000596495, 0.13796898847896455, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a7de8060-5b39-4533-81dc-876eba54f819", "fitness": 0.02814155465744901, "name": "HybridDELevyEnhanced", "description": "Enhance mutation strategy by incorporating an elitism mechanism for better convergence.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx])\n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        # Enhance mutation with elitism mechanism\n        elite_factor = 0.5 if idx == best_idx else 1.0\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor * elite_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 89, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.007666419346764375, 0.010657941249995417, 0.008185905332024013, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06791882214835587, 0.06422246488170757, 0.05423297283682127, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0515431269176968, 0.05480086748956481, 0.058084352041896214, 0.104529066005844, 0.09561953192620265, 0.10519535317216311, 0.04477633613869747, 0.0409134930728865, 0.037977705353165137, 0.2282683850851771, 0.23111362287523673, 0.23080008688847387, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01473329935032186, 0.013808118971063488, 0.014367111278859146, 0.010860095848633011, 0.00915304009018969, 0.010033304355148043, 0.13289702898054223, 0.15057839900919268, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "58e45519-1c75-41ba-af53-33999b0c9625", "fitness": 0.027690228954915908, "name": "HybridDELevyEnhanced", "description": "Introduce levy flight adjustment based on fitness improvement to enhance exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight(step_size=0.01 * (self.fitness[best_idx] / (self.fitness[i] + 1e-8))) + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 90, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.008345901601983674, 0.01050834216702079, 0.008518224223166282, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06395346563730764, 0.061876460980823556, 0.05477823054234032, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05255413788388008, 0.049532822512035724, 0.04955941492166838, 0.10485357645369153, 0.09865970265717172, 0.10273105448441344, 0.0431003148284842, 0.039629849148754115, 0.040554433272832924, 0.2283481497600448, 0.23077172298403525, 0.2307757467660283, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014732355933562924, 0.013808240711731035, 0.014367109500241892, 0.010849401509114731, 0.00915983300487433, 0.010033089997505185, 0.13509504394184912, 0.14627708000596495, 0.1407575619321132, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d11ddc1d-5173-4166-afa4-aad1fe77b88d", "fitness": 0.022959687137653596, "name": "HybridDELevyEnhanced", "description": "Enhance adaptive mutation and crossover rates with Gaussian noise to improve exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated += np.random.normal(0, 0.1, self.dim)  # Added line\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        adaptive_crossover_prob = min(1.0, adaptive_crossover_prob + np.abs(np.random.normal(0, 0.05)))  # Modified line\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 91, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.00416250085921166, 0.004495724633319265, 0.004368918234293084, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06717545908703515, 0.05681217967869645, 0.05582422834912093, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05108621079991593, 0.0565066381889362, 0.0546212860823293, 0.10378019803410121, 0.09364803201298222, 0.09959237352022265, 0.04646297769274044, 0.03417406147993307, 0.03892276973976927, 0.12065306814390642, 0.12562997101940754, 0.12140217566298073, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013369673032218476, 0.013423025984314552, 0.014993774310271935, 0.010648310020477059, 0.00901216111851133, 0.01033717089776831, 0.1398819111644758, 0.1491536205860765, 0.13339383618673817, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "53258e26-e881-4694-959d-151650f06bb7", "fitness": -Infinity, "name": "HybridDELevyEnhanced", "description": "Enhance the initialization strategy by introducing chaos-influenced diversity for improved exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim)) * self.chaotic_sequence[:, None]\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 92, "feedback": "An exception occurred: TypeError('list indices must be integers or slices, not tuple').", "error": "TypeError('list indices must be integers or slices, not tuple')", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {}}
{"id": "e311a784-c137-4b69-a74e-4bc6fe6934c4", "fitness": 0.022463446725817397, "name": "HybridDELevyEnhanced", "description": "Introduce a dynamic crossover probability based on the improvement rate to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        # Line changed here to make crossover probability dynamic based on improvement rate\n        adaptive_crossover_prob *= np.exp(-np.min(self.fitness) / (self.fitness.mean() + 1e-8))\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 93, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.006788453292712937, 0.009571658728723564, 0.009697497518104115, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0599182118053192, 0.05522677078134519, 0.051069273788239555, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050507939434054516, 0.05926098141467284, 0.04962306546706796, 0.10314045946836814, 0.0921892971021322, 0.09761278005920182, 0.04454488271709356, 0.03774400959610735, 0.04001479085347337, 0.10775181492805463, 0.11197336721862228, 0.11022247688320541, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0140552865368897, 0.014166823261010042, 0.0146469087042711, 0.012613236156778895, 0.010567245236089429, 0.01232005741806741, 0.1380307109626362, 0.14627708000596495, 0.13826786752934106, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a2db13e7-f38c-48e8-9f6f-bdeae4fc5be6", "fitness": 0.01983291384455733, "name": "HybridDELevyEnhanced", "description": "Enhance adaptation by incorporating fitness diversity and chaotic local search for improved convergence performance.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        dynamic_mutation_factor = self.mutation_factor * (1 - self.budget_used / self.budget)\n        diversity = np.std(self.fitness) / np.mean(self.fitness)\n        mutation_intensity = 1 + 0.5 * diversity\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * mutation_intensity * (0.5 * (self.population[b] - self.population[c]) +\n                                            0.5 * (self.population[best_idx] - self.population[idx])))\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def chaotic_local_search(self, idx):\n        chaotic_factor = self.chaotic_sequence[idx % self.population_size]\n        perturbation = chaotic_factor * (self.upper_bound - self.lower_bound) * np.random.randn(self.dim)\n        local_solution = np.clip(self.population[idx] + perturbation, self.lower_bound, self.upper_bound)\n        return local_solution\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    local_trial = self.chaotic_local_search(i)\n                    local_fitness = func(local_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if local_fitness < self.fitness[i]:\n                        self.population[i] = local_trial\n                        self.fitness[i] = local_fitness\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 94, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.006734230575339506, 0.01103878358877941, 0.003042900462904674, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0021734989798818383, 0.0021499272606463338, 0.0011477481085104824, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05724059470190257, 0.05464897278404335, 0.03601659794200873, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.049116469056926126, 0.04954764521729549, 0.055765533345195406, 0.08703239352164394, 0.08297086548776289, 0.09210519457045674, 0.042872180498569334, 0.030997667075271074, 0.03182948921205564, 0.07130288252655037, 0.07758439410680751, 0.07387024974936196, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.012278128543837141, 0.013043864248023063, 0.01421481151979942, 0.010982874081464589, 0.00966964208603871, 0.011965664386548225, 0.13633388110319078, 0.1464050474947255, 0.13562679500736874, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a88f5780-4da6-472c-8487-cd4efd79900f", "fitness": 0.02759488164611483, "name": "HybridDELevyEnhanced", "description": "Enhancing the mutation and crossover strategy to adaptively alter based on budget usage and population mean.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        population_mean = np.mean(self.population, axis=0)  # New line\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx])) + \n                   0.1 * (population_mean - self.population[idx])) * learning_rate * success_rate * diversity_factor  # Modified line\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 95, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.009587352679162442, 0.008151580176115392, 0.005968067090357132, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06610281619677782, 0.06061307988272446, 0.0550708654281834, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05194114526380911, 0.05364073293756799, 0.05463555152791899, 0.10510522042714754, 0.0953298934999115, 0.09985362135269615, 0.04602093425180298, 0.03784589799557303, 0.03845500318174244, 0.22655483556512823, 0.2294377071701833, 0.2306438767321637, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014683901305204805, 0.013850445019770286, 0.014323820107174812, 0.010673412074680422, 0.009245969315977098, 0.009893215469423344, 0.13404830032475212, 0.14627708000596495, 0.13931193614704906, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "159031b7-61f7-45f3-bfcb-b28b27a13cbb", "fitness": 0.028143238158284196, "name": "HybridDELevyEnhanced", "description": "Enhance exploration by introducing an additional random restart mechanism when convergence stalls.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n            if func_evals % (self.budget // 10) == 0:  # Random restart mechanism\n                bad_idx = np.random.choice(self.population_size, 1)\n                self.population[bad_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.fitness[bad_idx] = func(self.population[bad_idx])\n        return self.population[self.select_best()]", "configspace": "", "generation": 96, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.007478380349414171, 0.010655317423162614, 0.008185906830389444, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06791882214835587, 0.06469262129176712, 0.05423297283682127, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0515431269176968, 0.05480086748956481, 0.058084352041896214, 0.104529066005844, 0.09561953192620265, 0.10519535317216311, 0.04477633613869747, 0.0409134930728865, 0.037977705353165137, 0.22837225016892748, 0.2307646584343842, 0.23088690322146777, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01473329935032186, 0.013808118971063488, 0.014367111278859146, 0.010860095848633011, 0.00915304009018969, 0.010033304355148043, 0.13289702898054223, 0.15057839900919268, 0.1536898672984004, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e3a4babc-394d-45ae-a7c7-96b4fefc39bb", "fitness": 0.028139743257103507, "name": "HybridDELevyEnhanced", "description": "Introduce a dynamic adaptive levy flight step size to enhance exploration during the search process.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step_size = 0.01 * (1 - self.budget_used / self.budget)  # Change: Dynamic levy flight step size\n                    levy_step = self.levy_flight(levy_step_size) + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 97, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.007456049362334016, 0.008884447728555456, 0.007971213876438621, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06709218308184461, 0.06371834174872004, 0.054943183766682835, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05279488277035671, 0.05503315495182626, 0.05766768572380754, 0.10469386518504153, 0.09685532669455632, 0.10481068255069992, 0.044756802696988784, 0.040655405274042544, 0.038543350321094016, 0.22854028548028282, 0.23077396170859354, 0.2308226107673279, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.01469631065828847, 0.013817674398469926, 0.014318046109896287, 0.010688844523494612, 0.009162386639483655, 0.009960249493259354, 0.13760769868299316, 0.15006954718768484, 0.1501621057373833, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "18b1956d-a2c9-4f0a-b508-fa6aa06d30b3", "fitness": 0.0277638559997582, "name": "HybridDELevyEnhanced", "description": "Increase mutation factor adaptively based on population diversity for enhanced exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) \n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity = np.std([np.linalg.norm(self.population[i] - self.population[j]) for i in indices for j in indices])\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size] * (1 + diversity / (self.upper_bound - self.lower_bound))\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 98, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.00832784430323541, 0.01102373353172148, 0.0076135044145396735, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06450739048841647, 0.06621075372817398, 0.056072861552725284, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05063514308295769, 0.05572165536143614, 0.05060772510143541, 0.10956600819125417, 0.09446044749160509, 0.10324308940373572, 0.04528549903104251, 0.03790164179968547, 0.04228843961448847, 0.22731414241626013, 0.23006406386316014, 0.23046426108305806, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014811832366994127, 0.013701029169258638, 0.014332428659978302, 0.011125622200021335, 0.009124849098106624, 0.010926449087382939, 0.13371511803032554, 0.14627708000596495, 0.13410980151432128, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "46062a85-e705-40e6-93e2-49563be3a47c", "fitness": 0.027769754905110237, "name": "HybridDELevyEnhanced", "description": "Adjusted mutation strategy by incorporating diversity factor into learning rate to enhance exploration.", "code": "import numpy as np\n\nclass HybridDELevyEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 15 * dim  # Changed to initial population size\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.9\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = None\n        self.fitness = None\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size)\n\n    def levy_flight(self, step_size=0.01):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return step_size * step\n\n    def generate_chaotic_sequence(self, length):\n        x = np.random.rand()\n        sequence = []\n        for _ in range(length):\n            x = 4.0 * x * (1 - x)\n            sequence.append(x)\n        return sequence\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound,\n                                            (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def mutation(self, idx, best_idx):\n        indices = list(range(self.population_size))\n        indices.remove(idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        improvement_factor = 1 - (self.fitness[idx] - self.fitness[best_idx]) / abs(self.fitness[idx] - self.fitness[best_idx] + 1e-8)\n        dynamic_mutation_factor = self.mutation_factor * improvement_factor\n        learning_rate = 0.5 * (self.fitness[best_idx] / self.fitness[idx]) * self.chaotic_sequence[idx % self.population_size]  # Modified line\n        success_rate = np.sum(self.fitness < self.fitness.mean()) / self.population_size\n        diversity_factor = self.chaotic_sequence[(idx + best_idx) % self.population_size]\n        mutated = (self.population[a] + \n                   dynamic_mutation_factor * (0.5 * (self.population[b] - self.population[c]) +\n                                              0.5 * (self.population[best_idx] - self.population[idx]))) * learning_rate * success_rate * diversity_factor\n        mutated = np.clip(mutated, self.lower_bound, self.upper_bound)\n        return mutated\n\n    def crossover(self, target, mutant):\n        crossover_vector = np.copy(target)\n        rand_idx = np.random.randint(self.dim)\n        adaptive_crossover_prob = self.crossover_prob * (1 - self.budget_used / self.budget) + 0.2\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_prob or j == rand_idx:\n                crossover_vector[j] = mutant[j]\n        return crossover_vector\n\n    def select_best(self):\n        return np.argmin(self.fitness)\n\n    def __call__(self, func):\n        self.initialize_population()\n        func_evals = 0\n        self.budget_used = 0\n        while func_evals < self.budget:\n            self.evaluate_population(func)\n            best_idx = self.select_best()\n            global_best = self.population[best_idx]\n            for i in range(self.population_size):\n                if func_evals >= self.budget:\n                    break\n                self.mutation_factor = 0.9 * (1 - self.budget_used / self.budget)\n                mutant = self.mutation(i, best_idx)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                func_evals += 1\n                self.budget_used = func_evals\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    levy_step = self.levy_flight() + 0.15 * global_best\n                    levy_trial = np.clip(self.population[i] + levy_step, \n                                         self.lower_bound, self.upper_bound)\n                    levy_fitness = func(levy_trial)\n                    func_evals += 1\n                    self.budget_used = func_evals\n                    if levy_fitness < self.fitness[i]:\n                        self.population[i] = levy_trial\n                        self.fitness[i] = levy_fitness\n            # Change: Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.budget_used / self.budget)))\n        return self.population[self.select_best()]", "configspace": "", "generation": 99, "feedback": "The algorithm HybridDELevyEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.06.", "error": "", "parent_ids": ["3c2889f3-8b37-4e1c-a0fd-f970737c6dd7"], "operator": null, "metadata": {"aucs": [0.006786697315348644, 0.008901662014128786, 0.008006528599768692, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06464279333783673, 0.057996904181568665, 0.05527234595390418, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05523926335381135, 0.05480086748956481, 0.0507037291186927, 0.10270908465864526, 0.09219037993250012, 0.10300497284404331, 0.044789069212261334, 0.038992271704284986, 0.042799514569605845, 0.23157415849135243, 0.23199026066070338, 0.2310901045801207, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014240970527940489, 0.013350552190878107, 0.014326587841232863, 0.010711023499422101, 0.00911824305237452, 0.009477175830745366, 0.13833605021336937, 0.14627708000596495, 0.14252884459656212, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
