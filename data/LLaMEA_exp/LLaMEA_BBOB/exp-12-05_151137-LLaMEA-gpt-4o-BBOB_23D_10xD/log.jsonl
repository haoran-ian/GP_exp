{"id": "a0e1cd46-55d0-47a1-9dec-6e0399fea20e", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Adaptive Differential Evolution with Dynamic Population Sizing (ADE-DPS) combines differential evolution with adaptive strategies and dynamic population sizing to efficiently explore and exploit the search space within a limited evaluation budget.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "33c8ba59-e1f9-4178-adf8-cca9c0b41ac5", "fitness": 0.018733184811971566, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing (ADE-DPS) by fine-tuning crossover probability and enhancing initial population diversification.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.85  # Adjusted crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound - 0.5, self.upper_bound + 0.5, (self.population_size, self.dim))  # Enhanced initial diversification\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02126028809669711, 0.034428040025546, 0.02182631180332395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04043902285539824, 0.04412630751674751, 0.04186526891413789, 0.07404810969808628, 0.0865732451609258, 0.07415292586313504, 0.019847439743900352, 0.02440375117818494, 0.0252183414695778, 0.05422839496422294, 0.050966203755576256, 0.06031607986703591, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015391299658282898, 0.01374663560641498, 0.013779340857663636, 0.012087791212315624, 0.012157791491846925, 0.012170159350453513, 0.1219397321448974, 0.1370559077352007, 0.12806526531846907, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a45654de-a371-45cc-a466-c6741f6b6627", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS with adaptive crossover probability to balance exploration and exploitation across different search phases.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                self.CR = 0.5 + 0.4 * (1 - evals / self.budget)  # Update crossover probability adaptively\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "34709a08-33ec-41af-a9e3-faf3e204601d", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution by adjusting crossover probability dynamically based on fitness improvement.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.CR = min(1.0, self.CR + 0.1)  # Increase CR if fitness improved\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c09bc076-6fef-43d1-bbee-47b29fc4a2df", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with enhanced mutation diversity to better explore the search space while maintaining population adaptability.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + self.F * (population[i] - x_1), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 4, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cb588527-f180-4fb5-9b8e-eed425b1110f", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS with adaptive differential weight adjustment for improved convergence.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                self.F = 0.5 + np.random.rand() * 0.5  # Adaptive differential weight\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "fe50ee48-6fae-4426-9f88-6a00d2843cb5", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing (iADE-DPS) enhances exploration by adjusting crossover probability dynamically based on evaluation progress.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                self.CR = 0.5 + 0.4 * (evals / self.budget)  # Dynamic CR based on progress\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4c619633-085c-483b-b960-d7535c6f2e5b", "fitness": 0.019763853354779422, "name": "E_ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing (E-ADE-DPS) improves exploration by incorporating chaotic sequences in mutation and adaptive crossover probabilities.", "code": "import numpy as np\n\nclass E_ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            # Chaotic sequence based mutation\n            chaos_sequence = np.random.rand(self.dim)\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + chaos_sequence, self.lower_bound, self.upper_bound)\n\n                # Adaptive crossover\n                self.CR = 0.9 - (0.5 * (evals / self.budget))\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm E_ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cb2f007e-a6c1-443d-9f4b-cf5afd496f92", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved ADE-DPS by enhancing crossover strategy and fine-tuning adaptive population sizing for better convergence.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.6:  # Modified threshold for population resizing\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(10, self.population_size // 2)  # Increased minimum population size\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "80198ce1-cbb9-42c4-82e8-f3cc2c80067c", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved selection strategy by integrating elitism to retain the best individual across generations.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_individual = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Retain the best individual\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_individual = population[best_idx].copy()\n                best_fitness = fitness[best_idx]\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        return best_individual, best_fitness", "configspace": "", "generation": 9, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4a04a0b6-8f3b-4bfe-b58c-ca7c72d1e65b", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing (ADE-DPS) by introducing a dynamic crossover probability adjustment based on fitness improvement trend.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.CR = min(1.0, self.CR + 0.01)  # Incremental improvement\n                else:\n                    self.CR = max(0.1, self.CR - 0.01)  # Penalize worsening\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "640726f0-c00b-4d40-a55d-c80a3309cd12", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with an adaptive differential weight to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4eb1b731-b9b5-45d2-b7fb-31e8a93d3c6f", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with improved mutation strategy for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)  # Increased to 5 for better diversity\n                x_1, x_2, x_3, x_4, x_5 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + self.F * (x_4 - x_5), self.lower_bound, self.upper_bound)  # Enhanced mutation strategy\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "410914a5-b466-4f59-a8d4-4f02e2a9dcaa", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Incremental enhancements to adaptive population sizing and selection strategy in ADE-DPS for improved convergence efficiency.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2 + 1)  # Slightly enhance retention of diversity\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "df01c535-b651-4b01-9b8d-a863090d0192", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved ADE-DPS with adaptive crossover probability for enhanced exploitation and exploration balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                self.CR = 0.9 * (1 - evals / self.budget) + 0.1 * (evals / self.budget)  # Adaptive CR based on progress\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f26efaee-4527-427f-8d4f-94fd940dccd6", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing (EADE-DPS) improves crossover strategy to better explore and exploit the search space.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < (self.CR if np.random.rand() < 0.5 else 1 - self.CR)\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "771ff99f-462f-4873-8378-a799634a6ea2", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS incorporates adaptive mutation scaling to adjust exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                adaptive_F = self.F * (1 - evals / self.budget)  # Adaptive mutation scaling\n                mutant = np.clip(x_1 + adaptive_F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b75be31a-cc9a-4e59-bbb7-a2b3d061b854", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Refined Adaptive Differential Evolution with Dynamic Population Sizing (R-ADE-DPS) enhances exploration by updating mutation and crossover parameters for diverse search.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                self.F = np.random.uniform(0.5, 1.0)  # Refined mutation\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.uniform(0.7, 0.9)  # Refined crossover\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "852f6868-ab3b-43b1-a1dd-4329f0dacb34", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS adapts mutation strategies based on iteration progress to improve convergence.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adaptive = 0.5 + 0.3 * (evals / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x_1 + F_adaptive * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7f11d0e0-6d8f-407b-9d6e-7aff24984fe6", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Introduced a step to re-evaluate and update the best solution periodically to enhance convergence efficiency.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        best_idx = np.argmin(fitness)  # Track best solution\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                \n                    # Update best\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Re-evaluate and update the best solution\n            re_eval_fitness = func(best_solution)\n            evals += 1\n            if re_eval_fitness < best_fitness:\n                best_fitness = re_eval_fitness\n\n        # Return the best solution found\n        return best_solution, best_fitness", "configspace": "", "generation": 19, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f7bfd542-71f0-489e-9d87-4c4eac495d8d", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing (Enhanced ADE-DPS) adjusts mutation strategies to provide better exploration and convergence control.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                x_1, x_2, x_3, x_4, x_5 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + self.F * (x_4 - x_5), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3c671106-e483-4180-8682-9d3500867237", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Modified ADE-DPS with an improved adaptive population sizing strategy to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.3:  # Modified threshold point\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 3)  # Changed reduction factor\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4ea04cbe-8a1e-4f48-8b61-c58c59be8182", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with enhanced crossover and mutation strategy for better convergence.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + 0.1 * (np.random.rand(self.dim) - 0.5), self.lower_bound, self.upper_bound)  # Enhanced mutation\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < (self.CR + 0.1 * np.sin(evals / self.budget * np.pi))  # Dynamic crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "16cd4f28-2018-4829-aefd-f5984a346f96", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with refined mutation strategy to boost convergence speed.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.9  # Differential weight, adjusted for better exploration\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b9984bc3-2187-4a2d-9b41-9653c4c2f647", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution (E-ADE): Incorporate a self-adaptive mutation strategy to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adaptive = np.random.uniform(0.5, 1.0)  # Adapt F\n                mutant = np.clip(x_1 + F_adaptive * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 24, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7c51cad2-e02c-448b-8425-e8ce85836929", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing (iADE-DPS) enhances the mutation strategy for better exploration and exploitation within the evaluation budget.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_a, x_b, x_c = population[indices]\n                mutant = np.clip(x_a + self.F * (x_b - x_c) + np.random.uniform(-0.1, 0.1, self.dim), self.lower_bound, self.upper_bound) \n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "76e02deb-c30d-4ede-8d2d-745a3be865f2", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with refined mutation strategy and dynamic population control for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.9  # Differential weight, increased for better exploration\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3 + x_1 - population[i]), self.lower_bound, self.upper_bound)  # Modified mutation strategy\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2558df47-2f5d-4dfe-940d-49144d309d04", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Refined ADE-DPS enhances mutation strategy by dynamically adjusting F based on fitness variance to maintain diversity and improve convergence.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            fitness_variance = np.var(fitness)  # Calculate variance of fitness\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                self.F = 0.5 + 0.4 * (fitness_variance / (1.0 + fitness_variance))  # Adjust F based on variance\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "728fd86c-09f1-4393-9ef4-711d283d2943", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution (IADE) refines the crossover strategy to maintain diversity and enhance convergence efficiency within limited evaluations.  ", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "886499c7-67ec-4e1a-9c34-a0e15c5f5912", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing includes fitness-based scaling of differential weight to improve exploration.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                # Adjust F based on relative fitness\n                self.F = 0.5 + (fitness[i] - np.min(fitness)) / (np.ptp(fitness) + 1e-12) * 0.5 \n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a9b2c84b-7658-4aed-9155-26fb36cf044f", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing by tuning crossover probability for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.85  # Crossover probability tweaked for better performance\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "fe5d2e8b-9174-418a-82fe-9ba43e2e781d", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS with dynamic crossover probability to improve exploration and exploitation balance within limited budget.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover\n                self.CR = 0.9 - 0.5 * (evals / self.budget)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "15536e0b-ff1b-4043-888f-72aa71c4286c", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Slightly adjust the crossover probability to enhance diversity and exploration in the search space.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.95  # Crossover probability, adjusted for diversity\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "20fdd1a4-9546-496e-8487-0276c37ab843", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing (EADE-DPS) slightly tweaks mutation and crossover strategies to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.9  # Differential weight (changed from 0.8 to 0.9)\n        self.CR = 0.95  # Crossover probability (changed from 0.9 to 0.95)\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e382ab6e-1776-4023-9afd-8f94b26baa45", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS with improved mutation strategy for better convergence by adjusting mutation factor adaptively.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with adaptive F\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adaptive = 0.5 + 0.3 * (1 - evals / self.budget)\n                mutant = np.clip(x_1 + F_adaptive * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 34, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6a248386-f80d-4bea-bc4e-71464428cfc7", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS by introducing probability-based mutation scaling for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_dynamic = np.random.uniform(0.5, 1.0)  # Dynamic mutation factor\n                mutant = np.clip(x_1 + F_dynamic * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "45e40a32-68ae-42c4-b096-c52a3927f907", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing (EADE-DPS) incorporates a refined strategy for adapting the crossover probability to improve convergence efficiency.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            \n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Change: Refined strategy for crossover probability adaptation\n            self.CR = 0.6 + 0.4 * (evals / self.budget)\n        \n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0964890a-d663-40a0-ab4a-a1dd50e7f528", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing (IADE-DPS) introduces dynamic adjustment of the crossover probability to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic adjustment\n                self.CR = 0.5 + 0.5 * np.random.rand()  # Update crossover probability dynamically\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cb35545b-0bab-4bf1-bbaf-9e86f4e4a76a", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Refined Adaptive Differential Evolution with Enhanced Selection (RADE-ES) enhances the selection mechanism by introducing a dynamic scaling factor to adaptively balance exploration and exploitation, leading to improved convergence within the evaluation budget.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            dynamic_F = self.F * (1 - evals / self.budget)  # Change 1: Adjust scaling factor dynamically\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + dynamic_F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "5553ddc2-b3bc-48f8-b48e-11e9458a145d", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS with dynamic differential weight adjustment to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                self.F = 0.5 + 0.3 * np.random.rand()  # Dynamic adjustment of F\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "121d252e-fa4f-4fb3-8e0e-eec119febc79", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing (EADE-DPS) introduces variable differential weight and crossover probability to improve exploration and exploitation within a limited evaluation budget.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            self.F = 0.5 + 0.3 * np.random.rand()  # Change 1: Introduce variability in F\n            self.CR = 0.6 + 0.4 * np.random.rand()  # Change 2: Introduce variability in CR\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 40, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "74bdd22c-63b9-4e28-a843-3ef43b26a63f", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Refined Adaptive Differential Evolution with Early Exploration (RADE-EE) maintains the core of ADE-DPS but improves convergence by adjusting early exploration strategies.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.4:  # Adjust early exploration factor\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 41, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7863f972-ae11-40f1-86a6-b4dcf6ce1c2a", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing (ADE-DPS) by dynamically adjusting control parameters F and CR to enhance convergence speed and robustness.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Dynamic adjustment of F and CR\n            self.F = 0.5 + 0.3 * np.random.rand()  # Adjust F dynamically\n            self.CR = 0.9 - 0.4 * (evals / self.budget)  # Adjust CR dynamically\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2bc07a6a-3461-4a9b-9f04-e0d3b692f8f6", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Refined Adaptive Differential Evolution with Dynamic Population Sizing (RADE-DPS) enhances exploration by adjusting strategy parameters dynamically, leading to improved performance within the evaluation budget.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Dynamic adjustment of F and CR to improve exploration\n            self.F = 0.5 + 0.5 * np.random.rand()\n            self.CR = 0.5 + 0.5 * np.random.rand()\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 43, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e89e36ea-9774-4f75-92dc-bb3fed7f7867", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Modified ADE-DPS algorithm that uses a variable differential weight F to enhance exploration and exploitation balance, improving solution quality within the evaluation budget.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                # Change line: use dynamic F\n                self.F = 0.5 + np.random.rand() * 0.5\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cbe15202-a1a3-43cf-a8a9-f26af5ba741c", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Adaptive Differential Evolution with Dynamic Population Sizing (ADE-DPS) enhanced by adjusting crossover probability based on the iteration to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < (0.5 + 0.5 * evals / self.budget)  # Adjust CR over iterations\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "626d2818-39fb-4681-baf8-5c0b37c7614a", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing by altering crossover probability to enhance diversity and convergence.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < 0.8  # Changed CR to 0.8 for better exploration\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 46, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0a14a4ff-ea47-4a01-bc0e-b5633092a1f2", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Refined ADE-DPS with enhanced crossover probability adaptation to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR_initial = 0.9  # Initial crossover probability\n        self.CR = self.CR_initial\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Update crossover probability\n            self.CR = self.CR_initial * (1 - evals / self.budget)  # Modify crossover probability\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 47, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0b249e8a-8503-4d64-814a-f5efcc990bc0", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS with dynamic mutation control for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                self.F = 0.5 + 0.3 * np.random.rand()  # Dynamic mutation control\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 48, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "51ea01d4-820f-4b77-ae8f-ab7bdfdad1e3", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Enhanced ADE-DPS with adaptive crossover probability adjustment for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Adaptive crossover probability adjustment\n            self.CR = 0.9 - 0.5 * (evals / self.budget)\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b9d0d8f5-1b7f-41bf-b6b4-0fd86cbbe8b8", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved crossover strategy in ADE-DPS to enhance exploration with controlled randomness.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < (self.CR + np.random.uniform(-0.1, 0.1))\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 50, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "eb2f7406-a472-436c-9e28-c2ca266a1275", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Enhanced Mutation Strategy (iADE-EMS) refines the original by introducing a dynamic scaling factor for more effective exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with dynamic scaling factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_dynamic = 0.5 + (0.5 * evals / self.budget)  # Dynamic scaling factor\n                mutant = np.clip(x_1 + F_dynamic * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "71d98d4b-8bff-4bc1-926b-8de4502ee9db", "fitness": 0.019823761424463286, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing leverages adaptive mutation and crossover parameters to improve exploration and exploitation capabilities.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["a0e1cd46-55d0-47a1-9dec-6e0399fea20e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02755876894011322, 0.031071383376257256, 0.032571609810918, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045452398353443835, 0.05177441301478658, 0.04066993219021475, 0.0882902201783049, 0.08422301826134604, 0.08395341091129627, 0.02422015214623241, 0.030263671761548205, 0.024579666949457013, 0.06099347678247902, 0.06351742090746249, 0.06930287341763586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.013773055988867355, 0.01540421584706253, 0.013266310621489419, 0.012406689283644412, 0.01248394755452531, 0.01268866387042289, 0.12687009785802217, 0.1330132940582739, 0.12026647830364101, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c3ad7320-bce4-4fd8-a74e-522c0b1a3141", "fitness": 0.019823761424463286, "name": "ADE_DPS", "description": "Enhance convergence by introducing a memory buffer for the best solutions to guide the search process.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover probability\n        self.best_solutions_buffer = []  # Memory buffer for best solutions\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Update best solutions buffer\n            current_best_idx = np.argmin(fitness)\n            self.best_solutions_buffer.append(population[current_best_idx])\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["71d98d4b-8bff-4bc1-926b-8de4502ee9db"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02755876894011322, 0.031071383376257256, 0.032571609810918, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045452398353443835, 0.05177441301478658, 0.04066993219021475, 0.0882902201783049, 0.08422301826134604, 0.08395341091129627, 0.02422015214623241, 0.030263671761548205, 0.024579666949457013, 0.06099347678247902, 0.06351742090746249, 0.06930287341763586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.013773055988867355, 0.01540421584706253, 0.013266310621489419, 0.012406689283644412, 0.01248394755452531, 0.01268866387042289, 0.12687009785802217, 0.1330132940582739, 0.12026647830364101, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ab75cbb0-e1f6-45b8-abdb-c80f9ed63761", "fitness": 0.019823761424463286, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing and Local Re-Initialization boosts performance by adding a local re-initialization mechanism in stagnant periods.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Local re-initialization\n            if evals > self.budget * 0.75 and np.allclose(fitness, fitness[0]):  # Check if stagnation occurs\n                worst_idx = np.argmax(fitness)\n                population[worst_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                fitness[worst_idx] = func(population[worst_idx])\n                evals += 1\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["71d98d4b-8bff-4bc1-926b-8de4502ee9db"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02755876894011322, 0.031071383376257256, 0.032571609810918, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045452398353443835, 0.05177441301478658, 0.04066993219021475, 0.0882902201783049, 0.08422301826134604, 0.08395341091129627, 0.02422015214623241, 0.030263671761548205, 0.024579666949457013, 0.06099347678247902, 0.06351742090746249, 0.06930287341763586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.013773055988867355, 0.01540421584706253, 0.013266310621489419, 0.012406689283644412, 0.01248394755452531, 0.01268866387042289, 0.12687009785802217, 0.1330132940582739, 0.12026647830364101, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6c285850-7016-4ca8-ae54-8d8bc2e3990f", "fitness": 0.019823761424463286, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing and Random Restart introduces a random restart mechanism to escape local optima.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.8 + np.random.rand() * 0.2  # Adaptive crossover probability\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            # Random restart strategy\n            if evals < self.budget * 0.8 and np.min(fitness) > -4.5:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evals += self.population_size\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 55, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["71d98d4b-8bff-4bc1-926b-8de4502ee9db"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02755876894011322, 0.031071383376257256, 0.032571609810918, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045452398353443835, 0.05177441301478658, 0.04066993219021475, 0.0882902201783049, 0.08422301826134604, 0.08395341091129627, 0.02422015214623241, 0.030263671761548205, 0.024579666949457013, 0.06099347678247902, 0.06351742090746249, 0.06930287341763586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.013773055988867355, 0.01540421584706253, 0.013266310621489419, 0.012406689283644412, 0.01248394755452531, 0.01268866387042289, 0.12687009785802217, 0.1330132940582739, 0.12026647830364101, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "34368132-6456-4070-bc8b-0ff2d801baab", "fitness": 0.019823761424463286, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with a slight improvement in the dynamic adjustment of the crossover probability to fine-tune exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.7 + np.random.rand() * 0.3  # Adjusted crossover probability to enhance balance\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 56, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["71d98d4b-8bff-4bc1-926b-8de4502ee9db"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02755876894011322, 0.031071383376257256, 0.032571609810918, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045452398353443835, 0.05177441301478658, 0.04066993219021475, 0.0882902201783049, 0.08422301826134604, 0.08395341091129627, 0.02422015214623241, 0.030263671761548205, 0.024579666949457013, 0.06099347678247902, 0.06351742090746249, 0.06930287341763586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.013773055988867355, 0.01540421584706253, 0.013266310621489419, 0.012406689283644412, 0.01248394755452531, 0.01268866387042289, 0.12687009785802217, 0.1330132940582739, 0.12026647830364101, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "badd59f8-0863-404e-b412-ab5fe792daaf", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing, adding individual adaptation of CR to improve diversity and convergence.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["71d98d4b-8bff-4bc1-926b-8de4502ee9db"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "53b2d279-7e38-4375-8e90-8a1a1808d726", "fitness": 0.02047621008833397, "name": "ADE_DPS_FBC", "description": "Enhanced Adaptive DE with Dynamic Population Sizing and Fitness-Based Crossover adapts CR based on fitness to further enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS_FBC:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Fitness-based Crossover\n                self.CR[i] = 0.9 if fitness[i] > np.median(fitness) else 0.5\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm ADE_DPS_FBC got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a703f11e-db52-4258-aee4-f5764194ab7c", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved adaptive strategy for mutation and crossover with stochastic population adjustments to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.5 + np.random.rand() * 0.5  # Adjusted adaptive differential weight\n        self.CR = np.full(self.population_size, 0.7) + np.random.rand(self.population_size) * 0.3  # Adjusted crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i] + np.random.rand(self.dim) * 0.1  # Slightly more stochastic crossover\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # More frequent population adjustment based on evaluations\n            if evals % (self.budget // 10) == 0:\n                if np.random.rand() > 0.5:\n                    self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n                else:\n                    self.population_size = max(5, self.population_size // 2)\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "affec1bf-f99e-46bf-b1c2-2dd90487621c", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced ADE with Adaptive Mutation Strategy for Improved Exploration-Exploitation Balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.5 + np.random.rand() * 0.5  # Adjusted adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_dynamic = 0.5 + np.random.rand() * (self.F - 0.5)  # Dynamic F adaptation\n                mutant = np.clip(x_1 + F_dynamic * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "270a3e4f-0724-4b7e-83c9-ea21e26d5c49", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Introduced adaptive scaling factor and combined with periodic local search to enhance convergence and exploitative accuracy.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n        self.local_search_period = max(1, self.budget // (5 * self.population_size))  # New\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if evals % self.local_search_period == 0:                         # New\n                best_idx = np.argmin(fitness)\n                local_candidate = population[best_idx] + np.random.uniform(-0.5, 0.5, self.dim)  # New\n                local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)  # New\n                local_fitness = func(local_candidate)                                           # New\n                evals += 1                                                                      # New\n                if local_fitness < fitness[best_idx]:                                           # New\n                    population[best_idx] = local_candidate                                      # New\n                    fitness[best_idx] = local_fitness                                           # New\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adaptive = self.F * (1 + (np.min(fitness) / fitness[i]))  # Updated\n                mutant = np.clip(x_1 + F_adaptive * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "455b4a2d-ded5-4040-80fe-6c640ed159e5", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Differential Evolution with Dynamic Population and Adaptive F for improved convergence speed and solution diversity.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.5 + np.random.rand() * 0.5  # More adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            \n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "acd50636-22a6-4175-a012-fe74de6dedfe", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with improved mutation and adaptive mutation factor scaling based on convergence rate.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)  # Changed to use 5 indices\n                x_1, x_2, x_3, x_4, x_5 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + 0.5 * (x_4 - x_5), self.lower_bound, self.upper_bound)  # Improved mutation strategy\n\n                # Adaptive mutation factor\n                self.F = 0.5 + 0.5 * (1 - min(evals / self.budget, 1))  # Adjust F based on convergence rate\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d6101627-bc7f-47b3-b35d-801a97975fde", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Self-Adaptive Parameters and Enhanced Mutation Strategy.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.5 + np.random.rand() * 0.4  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.9) + np.random.rand(self.population_size) * 0.1  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with best solution guidance\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                best_ind = population[np.argmin(fitness)]\n                mutant = np.clip(best_ind + self.F * (x_1 - x_2) + self.F * (x_3 - population[i]), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "383e3bf6-2074-4cbd-9312-604df0bcfa2c", "fitness": 0.02047621008833397, "name": "ADE_DPS_Improved", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing and Memory-Based Adaptation of CR for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n        self.memory_CR = np.zeros(self.population_size)  # Memory for adaptive CR\n        self.memory_index = 0  # Initialize memory index\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n        memory_size = 5  # Define size of memory\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory_CR[self.memory_index % memory_size] = self.CR[i]  # Store successful CR\n                    self.memory_index += 1\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Update CR based on memory\n            if self.memory_index > memory_size:\n                self.CR = np.mean(self.memory_CR[:memory_size]) + np.random.rand(self.population_size) * 0.1\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 65, "feedback": "The algorithm ADE_DPS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d1c965ed-be61-47d4-8c67-0aba2b44752a", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing and Adaptive Mutation Factor to improve exploration.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + np.random.rand() * 0.5  # Adjusted differential weight range\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                # Adaptive mutation factor based on current evaluations\n                F_dynamic = self.F * (0.5 + 0.5 * np.cos(np.pi * evals / self.budget))\n                mutant = np.clip(x_1 + F_dynamic * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "90d0acc4-1f45-4bc1-85bb-a4577a49604d", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved ADE_DPS with smarter mutation and selective feedback for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim \n        self.F = 0.6 + np.random.rand() * 0.4  # Adjusted adaptive differential weight\n        self.CR = np.full(self.population_size, 0.9) + np.random.rand(self.population_size) * 0.1  # Adjusted crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                else:\n                    self.CR[i] *= 0.9  # Penalize the CR value\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c172a628-a51b-4d26-a024-2b048ab64a96", "fitness": 0.02047621008833397, "name": "ADE_DPS_Enhanced", "description": "Integrated an adaptive mutation strategy and enhanced the crossover mechanism to improve convergence and diversity.", "code": "import numpy as np\n\nclass ADE_DPS_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + np.random.rand() * 0.5  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.7) + np.random.rand(self.population_size) * 0.3  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Adaptive mutation strategy based on fitness ranking\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                if fitness[i] > np.median(fitness):\n                    mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(x_1 + 0.5 * self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Enhanced Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm ADE_DPS_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1e0cec13-fcc6-49ab-b19f-5afad13b1a38", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Adaptive DE with dynamic scaling of F and CR based on fitness variance to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7\n        self.CR = np.full(self.population_size, 0.8)\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            fitness_variance = np.var(fitness)\n            self.F = 0.3 + 0.4 * fitness_variance\n            self.CR = np.clip(0.6 + 0.2 * fitness_variance, 0.5, 1.0)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 69, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "72b08bec-3952-4f93-8d88-3ba88b6d8be6", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Minor adjustments in mutation strategy and dynamic CR adaptation to enhance performance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.6 + np.random.rand() * 0.4  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.85) + np.random.rand(self.population_size) * 0.15  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 70, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b7d98ab2-4798-4b14-ae61-8891c2a6a819", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing using novel adaptive crossover strategies for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()  # Adaptive CR adjustment\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7d2bea4a-673c-4ba2-a90a-af3588c8158f", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced adaptive differential evolution with dynamic local search and calibrated mutation strategies for improved exploitation and exploration balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                x_1, x_2, x_3, x_4, x_5 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3 + x_4 - x_5), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Local search enhancement\n                if evals < self.budget * 0.3:\n                    local_trial = np.clip(trial + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_trial)\n                    evals += 1\n                    if local_fitness < fitness[i]:\n                        population[i] = local_trial\n                        fitness[i] = local_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6d9986e9-6419-44df-92fc-e378c88664ce", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced differential evolution with dynamic mutation strategy and hybrid crossover for improved exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                x_1, x_2, x_3, x_4, x_5 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3 + x_4 - x_5), self.lower_bound, self.upper_bound)\n\n                # Hybrid Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i]) * 0.5 + population[i] * 0.5\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "949ae312-0cf0-4d85-8428-523e2c1977be", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved mutation strategy using dynamic F scaling based on population diversity.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                diversity = np.std(population, axis=0).mean()\n                dynamic_F = self.F * (1 + diversity)\n                mutant = np.clip(x_1 + dynamic_F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "40d50ca1-5e8d-42e0-8398-4227ab1cabb8", "fitness": 0.01986276457464722, "name": "ADE_DPS", "description": "Enhanced Adaptive DE with Dynamic Population Sizing and Fitness-based Mutation Scaling, improving diversity and convergence by scaling mutation factor according to fitness.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with fitness-based scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                scaling_factor = (fitness[i] - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-12)\n                F = 0.7 + scaling_factor * 0.3  # Sigmoid scaling\n                mutant = np.clip(x_1 + F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.028235974987984136, 0.04035783385417413, 0.027560801568384807, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04082336356559724, 0.05242005222828672, 0.04495476380557728, 0.07706805560812102, 0.08519488328876357, 0.07888937095367854, 0.027321086900921054, 0.031194826999447534, 0.027581326222635982, 0.06269084436490635, 0.061796625754186096, 0.06549691845868988, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017152767274717373, 0.014515883146274167, 0.015020266328748533, 0.012440716540134344, 0.012645459010914073, 0.013311170804741312, 0.12585173190551302, 0.13684299420990564, 0.12205567941838513, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6d7c9c11-d9a5-49fe-93c6-11fa373f7436", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced ADE_DPS with dynamic F adaptation based on fitness diversity to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            fitness_diversity = np.std(fitness) / np.mean(fitness)  # Change applied here\n            self.F = 0.5 + 0.5 * fitness_diversity\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "80107510-ed11-4c00-b1b5-f74de097eac1", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved ADE_DPS with adaptive learning rate for F and stochastic crossover strategy to enhance exploration.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + np.random.rand() * 0.4  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.9) + np.random.rand(self.population_size) * 0.1  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adaptive = self.F + np.random.normal(0, 0.1)  # Adapt F with normal perturbation\n                mutant = np.clip(x_1 + F_adaptive * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                else:\n                    cross_points[np.random.randint(0, self.dim)] = not cross_points[np.random.randint(0, self.dim)]  # Stochastic crossover adjustment\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a5e346ea-30a4-4ff2-97f4-7a2b9484d794", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Implemented adaptive learning strategies for F and CR based on success ratios to refine convergence and diversity.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n        self.success_count = np.zeros(self.population_size)\n        self.trial_count = np.ones(self.population_size)\n    \n    def adapt_params(self, i):\n        success_rate = self.success_count[i] / self.trial_count[i]\n        self.F = max(0.4, min(0.9, self.F + 0.1 * (success_rate - 0.1)))\n        self.CR[i] = max(0.4, min(0.9, self.CR[i] + 0.1 * (success_rate - 0.1)))\n        \n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                self.trial_count[i] += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_count[i] += 1\n                    self.adapt_params(i)\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "71609cdc-4a4f-446c-b811-af9353478be8", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Refined ADE_DPS with dynamic F-parameter adaptation and a more responsive population size strategy.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = np.random.uniform(0.5, 0.9)  # Dynamic F\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing and F-parameter\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n                self.F = min(self.F + 0.01, 0.9)  # Increment F for exploration\n            else:\n                self.population_size = max(5, self.population_size // 2)\n                self.F = max(self.F - 0.01, 0.5)  # Decrement F for exploitation\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 79, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "39194b65-597a-4653-9959-88772e3bd93b", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced ADE_DPS with dynamic scaling factor adjustment based on fitness diversity to improve convergence speed.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            fitness_std = np.std(fitness)  # Calculate standard deviation of fitness\n            self.F = 0.5 + 0.5 * np.exp(-fitness_std)  # Dynamic adjustment of F\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f1f6e86d-1fb8-47ab-8b52-08fe3ea611c6", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced ADE with dynamic F strategy and improved crossover for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.5 + np.random.rand() * 0.5  # More dynamic differential weight range\n        self.CR = np.full(self.population_size, 0.9) + np.random.rand(self.population_size) * 0.1  # Slightly increased avg CR\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "54982b55-c1df-4dce-a68e-7ea5707f0af7", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Randomized Adaptive Population Resizing to improve convergence and exploration.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Randomized adaptive population resizing\n            if evals < self.budget * 0.5:\n                self.population_size = np.random.randint(self.population_size, min(self.population_size * 2, self.budget - evals + 1))\n            else:\n                self.population_size = np.random.randint(max(5, self.population_size // 2), self.population_size)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "adfdf2d3-461e-4bc0-9274-495c108ce175", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population Sizing and Fitness-Based Crossover Adaptation, improving exploration and exploitation with fitness-aware crossover probability adjustment.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive CR\n                self.CR[i] = 0.2 + 0.8 * (fitness[i] / (np.max(fitness) + 1e-9))\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6769bd7b-e0b3-4fe5-b40b-0534920fa87e", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced ADE_DPS with adaptive mutation factor and elite preservation to improve convergence speed and stability.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n        best_fitness = np.min(fitness)\n        best_solution = population[np.argmin(fitness)]\n        \n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                F = 0.5 + 0.5 * (1 - evals / self.budget)  # Adaptive F\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        return best_solution, best_fitness", "configspace": "", "generation": 84, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "14f4a719-8a71-423e-9476-b11b674bc160", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced ADE_DPS with strategy refinement using adaptive mutation scaling and tournament selection to improve convergence and diversity.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                adaptive_F = self.F * (1 - (evals / self.budget))  # Adaptive mutation scaling factor\n                mutant = np.clip(x_1 + adaptive_F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i] or np.random.rand() < 0.1:  # Tournament selection\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e8ff3191-e381-4a18-a18d-1c19eb21b91b", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved ADE_DPS with adaptive F and CR using historical success rates to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n        self.success_rate = 0.5  # Historical success rate for adaptive F and CR\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n        \n        while evals < self.budget:\n            success_count = 0  # Track successful trials\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adapt = self.F * (0.8 + 0.2 * self.success_rate)\n                mutant = np.clip(x_1 + F_adapt * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                CR_adapt = self.CR[i] * (0.8 + 0.2 * self.success_rate)\n                cross_points = np.random.rand(self.dim) < CR_adapt\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_count += 1  # Successful trial\n\n            # Update success rate\n            self.success_rate = success_count / self.population_size\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            \n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "4ed8aa1e-e260-4755-9dab-9dd4ad1743c4", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with Enhanced Dynamic Population Sizing utilizing Gaussian mutation for exploration.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation using Gaussian noise for better exploration\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Enhanced adaptive population sizing strategy to ensure diversity\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 3 // 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cc89a827-e4dc-481b-866c-7347dcac7ecd", "fitness": 0.02047621008833397, "name": "Enhanced_ADE_DPS", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing using dynamic scaling factor and enhanced selection strategy to boost convergence.", "code": "import numpy as np\n\nclass Enhanced_ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_dynamic = 0.5 + np.random.rand() * 0.5  # Dynamic scaling factor\n                mutant = np.clip(x_1 + F_dynamic * (x_2 - x_3), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                # Enhanced selection with tournament\n                elif np.random.rand() < 0.1:  # Allow exploration\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm Enhanced_ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1146e5ad-958a-436c-a111-574acf6774ea", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved Diversity and Exploration by Introducing Dynamic Differential Weight and Memory to Track Best Solutions.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + np.random.rand() * 0.5  # Dynamic differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n        self.best_solutions = []  # Memory to track best solutions\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.best_solutions.append(trial)  # Track the best solutions\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "5ec6331d-d590-4967-b85d-1cc2c808f181", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Introduce a diversity preservation strategy combined with adaptive mutation based on success history to enhance convergence and robustness.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n        self.success_archive = []\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adapted = self.F if len(self.success_archive) < 5 else np.mean(self.success_archive)\n                mutant = np.clip(x_1 + F_adapted * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_archive.append(F_adapted)\n                    if len(self.success_archive) > 10:\n                        self.success_archive.pop(0)\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a85d712d-152b-46f2-9982-b0a0646ffd49", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Incorporation of adaptive mutation factor to enhance exploration and diversity alongside existing dynamic population sizing and crossover adaptation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with adaptive F\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_adaptive = self.F * (1 + np.random.uniform(-0.1, 0.1)) # Adaptive F\n                mutant = np.clip(x_1 + F_adaptive * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "46a8a085-2de6-40f3-a550-3a9c675ff0e7", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Introduce self-adapting mutation strategies based on historical success to dynamically adjust exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n        self.success_rate = np.zeros(self.population_size)  # Track success rate for self-adaptation\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                self.F = 0.5 + 0.5 * self.success_rate[i]  # Adjust F based on success rate\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_rate[i] += 0.1  # Increase success rate\n                else:\n                    self.success_rate[i] *= 0.9  # Decrease success rate\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2f575864-6abd-44df-8656-db5e102898f9", "fitness": 0.02047621008833397, "name": "ADE_DPS_Improved", "description": "Improved Adaptive Differential Evolution with Dynamic Population Sizing, adding noise reduction and diversity preservation strategies.", "code": "import numpy as np\n\nclass ADE_DPS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with noise reduction\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                noise = np.random.normal(0, 0.1, self.dim)  # Noise reduction\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3) + noise, self.lower_bound, self.upper_bound)\n\n                # Crossover with enhanced diversity\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm ADE_DPS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "93d1e5f1-3e66-4ea1-be67-d50efd247b6e", "fitness": 0.019763853354779422, "name": "ADE_DPS", "description": "Refined Adaptive Differential Evolution with dynamic F and CR adaptation strategies for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.8  # Fixed differential weight for stability\n        self.CR = np.linspace(0.6, 0.9, self.population_size)  # Vary CR linearly across population\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 1.5, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 1.5)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.027955511592328564, 0.03917244759553362, 0.02644353904117358, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0450474820722776, 0.05127570532139403, 0.044131526863781634, 0.07760251494979065, 0.08404701175035822, 0.0801147449209062, 0.02649625880028117, 0.03028333493773916, 0.026694704124362034, 0.06197422483340864, 0.060148793653970856, 0.06470490548147767, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01689512484481448, 0.014569277235056521, 0.014907383042973787, 0.012403494466121101, 0.012742500704561177, 0.013172492544230252, 0.126063184588589, 0.13579276246726357, 0.12166286353781308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ceca04ac-529c-4993-94db-311c2bc2072c", "fitness": 0.02047621008833397, "name": "ADE_DPS_Refined", "description": "Enhanced differential evolution with adaptive population and learning rate updates.", "code": "import numpy as np\n\nclass ADE_DPS_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n            # Adaptive learning rate update\n            self.F = 0.5 + 0.5 * np.mean(np.abs(np.diff(fitness)))  # Update F based on fitness differences\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm ADE_DPS_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ea20f661-00f5-4fd9-a61f-755aec6cc2e1", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Enhanced Adaptive Differential Evolution with Strategic Individual Scaling and Partial Population Culling for Improved Convergence and Exploration.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                F_i = self.F * (1 + np.random.rand() * 0.1)  # Strategic scaling\n                mutant = np.clip(x_1 + F_i * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n                    if evals > self.budget * 0.75:  # Partial population culling\n                        cull_size = self.population_size // 4\n                        worst_indices = np.argsort(fitness)[-cull_size:]\n                        population = np.delete(population, worst_indices, axis=0)\n                        fitness = np.delete(fitness, worst_indices)\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d3537bc0-896d-4cd0-bed6-9725ad21ea48", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved Adaptive Differential Evolution with enhanced dynamic mutation scaling for better convergence and diversity.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7 + np.random.rand() * 0.3\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with dynamic scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                dynamic_F = self.F * (1 - evals / self.budget)  # Dynamic adjustment\n                mutant = np.clip(x_1 + dynamic_F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c94aeee5-c2a9-46e5-ac67-1df694582d79", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved ADE_DPS with dynamic CR adaptation and diversity-enhanced selection.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.7 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = np.full(self.population_size, 0.8) + np.random.rand(self.population_size) * 0.2  # Individual adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                self.CR[i] = 0.9 - (0.5 * (fitness[i] / max(fitness)))  # Dynamic CR adjustment\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, self.budget - evals + 1)\n            else:\n                self.population_size = max(5, self.population_size // 2)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    diversity_idx = np.argsort(fitness + np.std(population, axis=1))[:self.population_size]  # Diversity-enhanced selection\n                    population = population[diversity_idx]\n                    fitness = fitness[diversity_idx]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 98, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7362a759-79bc-49bb-a19a-1213f35c4020", "fitness": 0.02047621008833397, "name": "ADE_DPS", "description": "Improved mutation and crossover strategies with adaptive scaling for better exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_DPS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Start with a reasonably sized population\n        self.F = 0.9 + np.random.rand() * 0.1  # Modified adaptive differential weight\n        self.CR = np.full(self.population_size, 0.7) + np.random.rand(self.population_size) * 0.3  # Updated adaptive crossover probabilities\n\n    def __call__(self, func):\n        evals = 0\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_1, x_2, x_3 = population[indices]\n                mutant = np.clip(x_1 + self.F * (x_2 - x_3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR[i]\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive population sizing\n            if evals < self.budget * 0.4:  # Adjusted threshold\n                self.population_size = min(self.population_size * 1.5, self.budget - evals + 1)\n            else:\n                self.population_size = max(8, self.population_size // 1.5)\n            # Adjust population size\n            if len(population) != self.population_size:\n                if len(population) < self.population_size:\n                    additional_pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_pop])\n                    evals += len(additional_pop)\n                    population = np.vstack([population, additional_pop])\n                    fitness = np.hstack([fitness, additional_fitness])\n                else:\n                    selected = np.argsort(fitness)[:self.population_size]\n                    population = population[selected]\n                    fitness = fitness[selected]\n\n        # Return the best solution found\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm ADE_DPS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["badd59f8-0863-404e-b412-ab5fe792daaf"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.03280949952785883, 0.03679014352480603, 0.03099127557376602, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0373005056360991, 0.04327752119131267, 0.04090008708245407, 0.08727895958910903, 0.07979809076888655, 0.09312852897415214, 0.041786452367002624, 0.027060307569532704, 0.028690168962191787, 0.06772957019722192, 0.07524382671684382, 0.06565892765999581, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.014685126273985771, 0.014914531547776777, 0.01404997765880689, 0.013516132305777417, 0.012089005769828853, 0.012091870123358883, 0.12813843899921462, 0.13812148593302398, 0.12954104023312774, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
