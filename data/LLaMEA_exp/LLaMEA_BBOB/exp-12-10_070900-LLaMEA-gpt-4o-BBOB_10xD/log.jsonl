{"id": "188b6b37-cbf6-4375-ad12-1e3a7f0f7295", "fitness": -Infinity, "name": "HybridDEPSO", "description": "A hybrid differential evolution and swarm intelligence algorithm that dynamically balances exploration and exploitation using adaptive population sizes and velocity updates.", "code": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)  # Adaptive population size\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0   # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x1 + 0.8 * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            trial = np.where(np.random.rand(self.dim) < 0.9, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight = 0.5 + np.random.rand() / 2  # Dynamic inertia weight\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step()\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 0, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 88, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 60, in __call__\n  File \"<string>\", line 43, in differential_evolution_step\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 88, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 60, in __call__\n  File \"<string>\", line 43, in differential_evolution_step\nNameError: name 'func' is not defined\n", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "628166f0-6cef-4a61-bbb8-2760eec71df8", "fitness": 0.03682763875179483, "name": "HybridDEPSO", "description": "A hybrid differential evolution and swarm intelligence algorithm that fixes a bug and further refines exploration by enhancing the mutation strategy with amplified diversity.", "code": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)  # Adaptive population size\n        self.lb = -5.0  # Lower bound\n        self.ub = 5.0   # Upper bound\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):  # Added 'func' parameter\n        F = 0.8 + (0.9 - 0.8) * np.random.rand()  # Added amplified diversity\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            trial = np.where(np.random.rand(self.dim) < 0.9, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight = 0.5 + np.random.rand() / 2  # Dynamic inertia weight\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)  # Passed 'func' parameter\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03683 with standard deviation 0.04267.", "error": "", "parent_ids": ["188b6b37-cbf6-4375-ad12-1e3a7f0f7295"], "operator": null, "metadata": {"aucs": [0.11018522630120231, 0.11434131077962806, 0.17208846507423425, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04120913198558096, 0.021206764324567917, 0.026736145021570845, 0.032034883858634955, 0.020000000000000018, 0.029069894345621905, 0.08253342160737764, 0.057055972557917056, 0.11231325440781748, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04683163160584991, 0.08594148016760361, 0.07294257899803602, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04569019197996993, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10042794209927086, 0.11734524555010428, 0.16553954302590224, 0.020000000000000018, 0.028321293868385, 0.020000000000000018, 0.09974051772735848, 0.08472735495540873, 0.10179692772236248, 0.14513482245337828, 0.13323277534341382, 0.12652264965698445, 0.07844884955771858, 0.07914392060572795, 0.09456595253226086, 0.11980483856704438, 0.10449114005016047, 0.1258351936072818, 0.020000000000000018, 0.020000000000000018, 0.11299908438019057, 0.08343677235934466, 0.08150564270371474, 0.10201743509336214, 0.06527120746322768, 0.07512921145074147, 0.05307171049325787, 0.16187759326795226, 0.1368344633112628, 0.15608801516265136, 0.0404468978547351, 0.027065866303097708, 0.03557275828666717, 0.04208905445201239, 0.028810792465704393, 0.05251394718574298, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05696637877317101, 0.013596016909955377, 0.024597013770663145, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013281750724010055, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07945798035426521, 0.0575001778680696, 0.07700322087186762, 0.010000000000000009, 0.010000000000000009, 0.01032093400705858, 0.0565030295520037, 0.06751896055894491, 0.06042911126040196, 0.12157164420203614, 0.09810063372613687, 0.10281775224528589, 0.061628654339579425, 0.03965410239441569, 0.053936809511723194, 0.08748239458177753, 0.08322453708088484, 0.09525147085085939, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026035897653799656, 0.03200182199486268, 0.032173252354791515, 0.028393662100227646, 0.025379013285641627, 0.024640285494433645, 0.1394077270033257, 0.14622742673804312, 0.14045665821947972, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0021127002814886886, 0.00028435686244510094, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02941681228122006, 0.033571571081130624, 0.0307655976466793, 0.0, 0.0, 0.0, 0.04263724196452101, 0.04147096444131815, 0.035657161394417214, 0.08282559290498326, 0.08159111632672134, 0.07834880168916958, 0.025639003123516635, 0.025102734529133253, 0.021147340783881696, 0.06638987453120127, 0.06103119175758864, 0.0617393837170801, 0.0, 0.0, 0.0, 0.010137925636695355, 0.010647162781893038, 0.009490556905927705, 0.0073553148140215185, 0.010051284513262426, 0.0074446423143857965, 0.11723079852004148, 0.1304161139054778, 0.10671663467972503, 0.0, 0.0, 0.0]}}
{"id": "d4b60c9b-d112-4b03-9b03-9eb7ebc2290f", "fitness": 0.035661263474221855, "name": "RefinedHybridDEPSO", "description": "\"Refined hybrid of differential evolution and particle swarm optimization with adaptive crossover and local exploitation to enhance convergence speed and accuracy.\"", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F = 0.8 + 0.2 * np.random.rand()\n        CR = 0.5 + 0.1 * np.random.rand()  # Adaptive crossover rate\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            trial = np.where(np.random.rand(self.dim) < CR, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight = 0.5 + np.random.rand() / 2\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            local_exploit = 0.1 * np.random.randn(self.dim)  # Local exploitation\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social + local_exploit\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 2, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03566 with standard deviation 0.04189.", "error": "", "parent_ids": ["628166f0-6cef-4a61-bbb8-2760eec71df8"], "operator": null, "metadata": {"aucs": [0.0942375173949499, 0.08016936998725266, 0.147850996342052, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.036213360165555875, 0.02078343994534182, 0.0204956863833593, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08104347955111135, 0.06729819239398294, 0.06194734011002534, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.06489671746312098, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12024821099187322, 0.11734263920985966, 0.1545311423425869, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08724021374026047, 0.07994832517764294, 0.09677484823995808, 0.1480700767784271, 0.13323277534341382, 0.1437933343051978, 0.08056610456681002, 0.055692651699813966, 0.09422555345207884, 0.11868920271735417, 0.12761341160151263, 0.13169210081455385, 0.020000000000000018, 0.020000000000000018, 0.09549119422944552, 0.08343677235934466, 0.06360782465788817, 0.08465906553292113, 0.06527120746322768, 0.062187398675093264, 0.05072531772409239, 0.15532318404675793, 0.13648691245276068, 0.16339364235381848, 0.04381857093116537, 0.033686778503437154, 0.030131104814022036, 0.0369708328800149, 0.033850158648488726, 0.05694496016272088, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03920831603499775, 0.01161760485252561, 0.01353773478816489, 0.010000000000000009, 0.019759576636477427, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0814796033368047, 0.07001990093547805, 0.08047181164860817, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05799673936952543, 0.07072266050044196, 0.054470649048234177, 0.12365921570840077, 0.0973769713373216, 0.10768560826076823, 0.06588048485257869, 0.039630420894473106, 0.05412414930813414, 0.08905204452619797, 0.0776637293325021, 0.09927634408234487, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03252517747634687, 0.038967135393990215, 0.03436784819220817, 0.02492763167015566, 0.02871065452152266, 0.026459454964703144, 0.14539467454889432, 0.13377702841573635, 0.1478436002146606, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0013956779598791602, 0.0, 0.002499316167262622, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029340483086242042, 0.032188833790670945, 0.030674409316163276, 0.0, 0.0, 0.0, 0.03428654331668912, 0.03753213255583987, 0.0352458882463057, 0.08286289857374174, 0.08085058684783974, 0.07840444379593947, 0.022599806833550007, 0.02504712769843309, 0.0211540303921971, 0.06564540542879371, 0.05979308172678999, 0.06331548823209232, 0.0, 0.0, 0.0, 0.009901771017018057, 0.010618216925484814, 0.009582644938359808, 0.007659703063388035, 0.010051284513262426, 0.007411045556938389, 0.11897671176004121, 0.1304161139054778, 0.11224939761042374, 0.0, 0.0, 0.0]}}
{"id": "1e8ffdff-fb11-40ab-975b-0bebdcfcfc01", "fitness": 0.0378028619123266, "name": "EnhancedHybridDEPSO", "description": "Enhanced HybridDEPSO incorporating adaptive inertia and crossover rates to balance exploration and exploitation and improve convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + (0.1 * (1 - self.f_evals / self.budget))  # Adaptive scaling factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)  # Adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight_base = 0.5\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = inertia_weight_base + (0.5 * np.random.rand() * (1 - self.f_evals / self.budget))  # Adaptive inertia\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03780 with standard deviation 0.04472.", "error": "", "parent_ids": ["628166f0-6cef-4a61-bbb8-2760eec71df8"], "operator": null, "metadata": {"aucs": [0.11929995443125418, 0.11051525002982432, 0.1573167370301357, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024370014081892988, 0.020000000000000018, 0.03131001413286816, 0.02330211250191827, 0.020000000000000018, 0.020000000000000018, 0.0813038154459903, 0.07120461760952934, 0.13671027479666065, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.09663240027711706, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029460036870511463, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11156627035652344, 0.16834897559483208, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07674152501554088, 0.07851326277455906, 0.07127732547500099, 0.14704588659451656, 0.13323277534341382, 0.130440704509732, 0.1052595534622276, 0.08552849562078113, 0.08066170057803135, 0.14797939560260598, 0.1389383124409619, 0.13196574747065748, 0.020000000000000018, 0.12201981412068297, 0.13272567875515418, 0.15010838922444736, 0.10517813800617459, 0.09340445843394407, 0.07943987805540986, 0.04616535580723691, 0.051757917818537, 0.15637179806584345, 0.14128631892307286, 0.15107519084025045, 0.050184742548765926, 0.045805614640523906, 0.032926184810493475, 0.03819770545938084, 0.04580245678377326, 0.057869681949303975, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028498366902357075, 0.013790760701087201, 0.017813700058642135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08265412790799631, 0.05747600898813332, 0.07367382314943383, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05512912897196964, 0.06174418980532781, 0.05395939349942802, 0.1232761951997875, 0.09676293139758729, 0.10552487605866889, 0.06061271519745959, 0.03971493214898236, 0.054560952260404694, 0.09520468364283319, 0.08413938273263422, 0.09940273528591448, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026219958858099246, 0.04117132607365348, 0.03273891629946024, 0.041074705775833276, 0.02618775241194482, 0.024974104417751275, 0.13729680727102012, 0.13123409970527322, 0.14164655470265897, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022307109555481652, 0.0, 0.0001675023938922937, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028083560534590823, 0.03492568453456224, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03538549697398308, 0.03758687493488566, 0.03671238569143864, 0.08168909887199372, 0.07988436275839506, 0.07733454128098383, 0.02194040160561106, 0.024192448856156457, 0.018635041974139455, 0.0662031382295113, 0.06250742338739201, 0.06359895439976826, 0.0, 0.0, 0.0, 0.009718887130442777, 0.010754996208139578, 0.009964239526628615, 0.008095268875978001, 0.010051284513262426, 0.007478892906637946, 0.11359103835950723, 0.13479334625184536, 0.10748389675571857, 0.0, 0.0, 0.0]}}
{"id": "110dea8f-0014-4edb-ad58-b875e21e5599", "fitness": 0.03786452190507555, "name": "EnhancedHybridDEPSO", "description": "Enhanced HybridDEPSO with dynamic mutation factor and diversity-based reinitialization to prevent premature convergence and improve exploration.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight_base = 0.5\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = inertia_weight_base + (0.5 * np.random.rand() * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03786 with standard deviation 0.04456.", "error": "", "parent_ids": ["1e8ffdff-fb11-40ab-975b-0bebdcfcfc01"], "operator": null, "metadata": {"aucs": [0.11992628555211982, 0.1112527791699719, 0.15968871961170483, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02554853020567105, 0.020000000000000018, 0.031773488414293616, 0.023322672797786326, 0.020000000000000018, 0.020000000000000018, 0.0813038154459903, 0.07667240133106124, 0.13706864548934983, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.11721875292836392, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02145165637657509, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11352421489347164, 0.16331147346710284, 0.13084903150896143, 0.02889479437586795, 0.020000000000000018, 0.020000000000000018, 0.08201934430585989, 0.07324227683377416, 0.0797837545554878, 0.14745365552639156, 0.14315923047024715, 0.12974910637805703, 0.10495931817815918, 0.08524848519202421, 0.06201525807962516, 0.1283009520154178, 0.12358650473540378, 0.13196574747065748, 0.020000000000000018, 0.12212080444473739, 0.13272567875515418, 0.1470103917218063, 0.10509694285667759, 0.09191512694713821, 0.07955352139136918, 0.06971434612122562, 0.0518288124287446, 0.1438526290318487, 0.1349619864309648, 0.15367691357871593, 0.050184742548765926, 0.050641896898688143, 0.032926184810493475, 0.038072432945039036, 0.04500784192086338, 0.05759359054459012, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02917463317866198, 0.013733439662684921, 0.01858224821088572, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08247017487348562, 0.05747600898813332, 0.07326026008122388, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0652925772135039, 0.05395939349942802, 0.1232761951997875, 0.0994354204014174, 0.10881962017922331, 0.06052997059283105, 0.03575610387051331, 0.05968121330338705, 0.09937439522072966, 0.0820222122231401, 0.10047117439849929, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02568233494906269, 0.0347019700548975, 0.032870715501775005, 0.041074705775833276, 0.026325707241101948, 0.024974104417751275, 0.1342624740211431, 0.1503972832474736, 0.13384283269274166, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0001675023938922937, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028131121211464438, 0.034910527143984016, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03337297545143936, 0.03753213255583987, 0.038922240611508396, 0.08168909887199372, 0.0799662223890063, 0.07733454128098383, 0.021980466219375216, 0.024192448856156457, 0.018635041974139455, 0.0662031382295113, 0.06250742338739201, 0.06367256541023847, 0.0, 0.0, 0.0, 0.009718887130442777, 0.010754996208139578, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.007481031748742484, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "37d7a28d-c545-429b-9af9-2d908dea80d0", "fitness": 0.03756112068045185, "name": "EnhancedHybridDEPSO", "description": "Refined Enhanced HybridDEPSO with adaptive inertia weight in PSO and expanded diversity reinitialization to boost exploration.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight_base = 0.6  # Adjusted value\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = inertia_weight_base * (1 - self.f_evals / self.budget)  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-4:  # Expanded reinitialization condition\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03756 with standard deviation 0.04464.", "error": "", "parent_ids": ["110dea8f-0014-4edb-ad58-b875e21e5599"], "operator": null, "metadata": {"aucs": [0.09042822700010855, 0.11688559368993834, 0.1510340992565482, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023419679801107485, 0.022429309881257242, 0.021062419885162775, 0.02601139604297842, 0.020000000000000018, 0.07622133534506237, 0.054749991829152744, 0.12933926840796617, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11738334988203258, 0.12139221384079579, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14848204934338327, 0.16331147346710284, 0.17391018827725868, 0.03700328741689973, 0.020000000000000018, 0.020000000000000018, 0.0860851838569533, 0.07324227683377416, 0.0733846035984621, 0.14745365552639156, 0.14315923047024715, 0.15068732682927755, 0.09127786563201024, 0.07430507359703842, 0.08371213830696633, 0.1358870766895217, 0.11643763445521638, 0.13533539531651517, 0.023203334420230814, 0.031007670192624626, 0.1177720309668503, 0.1470103917218063, 0.10379587679125624, 0.08090468752040147, 0.08604254465977335, 0.047742532393375, 0.051063234575713934, 0.1438526290318487, 0.13664823037578133, 0.14155516199613927, 0.043086343211119926, 0.039222634751819974, 0.04479285264388555, 0.04001239310591198, 0.034751629156918984, 0.058757250850461795, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028206916132227478, 0.013557136881487852, 0.013535318614639746, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012882136942793943, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07287157133918754, 0.06624705544253173, 0.0744226371929897, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06408102125840232, 0.06632845280281274, 0.05451771177889764, 0.12054028450529386, 0.10622592046456136, 0.10281775224528589, 0.06493782507650292, 0.045426050217092784, 0.057334361966964065, 0.0899532331908065, 0.07795687556409081, 0.10391841116981271, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03118345180779647, 0.0358654911718691, 0.04119693012327774, 0.03890292881532886, 0.029283558946388122, 0.02822940824671416, 0.13199293018407676, 0.1503972832474736, 0.13414519440500283, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022770312048777663, 0.0001446240533923282, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02873410432161938, 0.03344875504371658, 0.030516510582256018, 0.0, 0.0, 0.0, 0.0316264510895391, 0.03762498831015637, 0.038922240611508396, 0.08093352033423518, 0.07965841969894782, 0.07737698330800069, 0.02248006334387198, 0.024192448856156457, 0.020973461442823305, 0.06648769358642692, 0.06286942237928428, 0.06178108508912816, 0.0, 0.0, 0.0, 0.009885304809127193, 0.010693947845183183, 0.009885441451964017, 0.008136655007303983, 0.010087863429754096, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10820634436694121, 0.0, 0.0, 0.0]}}
{"id": "451e0511-a763-4816-bd54-c48a6c7497b6", "fitness": 0.03924835481857389, "name": "EnhancedHybridDEPSO", "description": "Introduced adaptive inertia weight in PSO to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight_base = 0.5\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03925 with standard deviation 0.05561.", "error": "", "parent_ids": ["110dea8f-0014-4edb-ad58-b875e21e5599"], "operator": null, "metadata": {"aucs": [0.08491925202256911, 0.09812773655106954, 0.16174199704740644, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021779355757826746, 0.022879734699692733, 0.0227722817157604, 0.021062419885162775, 0.02083450574194634, 0.020000000000000018, 0.0643308993614583, 0.06178470918729617, 0.5333842708406861, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.12342063308376028, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11558084070624342, 0.16331147346710284, 0.15953845930274413, 0.020000000000000018, 0.020000000000000018, 0.020255439542284925, 0.09722394588705296, 0.07324227683377416, 0.07724901117171312, 0.14745365552639156, 0.14315923047024715, 0.14514411505334923, 0.08941108059227332, 0.09044392798476364, 0.07237150322886265, 0.11732927276896987, 0.11563822350830744, 0.17278903304892002, 0.08358982754533084, 0.020000000000000018, 0.1301782973909299, 0.1470103917218063, 0.10833526036217134, 0.09571167744551501, 0.06527120746322768, 0.04616535580723691, 0.05426369878140713, 0.1438526290318487, 0.1581469878294668, 0.13057902439077484, 0.049518645939529926, 0.03118059238511106, 0.03312430542884981, 0.03961034718240075, 0.03274324409848017, 0.05862278644190111, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013606237178525493, 0.015579148565249779, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011383798697921166, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012003637734546824, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07399289008066612, 0.06230127549915321, 0.0754938354242991, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059836951835986696, 0.0652925772135039, 0.054737391682624814, 0.11962764919948088, 0.09834369050516789, 0.10530814463888927, 0.06716100719523654, 0.043859590379989544, 0.053936809511723194, 0.09091293425700842, 0.076077587661463, 0.11102321121366032, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03110096098137871, 0.03699087161513637, 0.03297947854010641, 0.03958268038103119, 0.029945376926573064, 0.02561708186523992, 0.14137414109531266, 0.1503972832474736, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.000320174878816859, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02860827172552094, 0.03325109139505911, 0.03090718345236254, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.08087725801728907, 0.07975261354782393, 0.07747755012244995, 0.021045316952231885, 0.02444045895014124, 0.018681156330333293, 0.06575519953063913, 0.06214794463151163, 0.06167490829503253, 0.0, 0.0, 0.0, 0.00991557226095341, 0.01069235902887855, 0.009885441451964017, 0.008136655007303983, 0.010137281240348961, 0.007448662441329024, 0.11619717782090566, 0.1304161139054778, 0.10817563953138687, 0.0, 0.0, 0.0]}}
{"id": "1506631b-b621-41e2-9218-e9c531cff0c2", "fitness": 0.0365520171557096, "name": "EnhancedSynergisticDEPSO", "description": "Introduced a novel synergy between adaptive inertia weight in PSO and self-adaptive control parameters in DE to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedSynergisticDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.1 * np.random.uniform(-1, 1)  # Self-adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + 0.5 * (1 - self.f_evals / self.budget)  # Enhanced adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedSynergisticDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03655 with standard deviation 0.04268.", "error": "", "parent_ids": ["451e0511-a763-4816-bd54-c48a6c7497b6"], "operator": null, "metadata": {"aucs": [0.0996155837721876, 0.08588429250530905, 0.14766609782714768, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02382473887492087, 0.026577724110067646, 0.025874301379612774, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0822572370686957, 0.057429348690767434, 0.05376507191994706, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07569906526117887, 0.08594148016760361, 0.08807516694287931, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030846081812255788, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10177203984768535, 0.14293709704678126, 0.15321528737090295, 0.03551538909889784, 0.020000000000000018, 0.020000000000000018, 0.10299282177937097, 0.06506164887864829, 0.10339638770852788, 0.15150875554483945, 0.14682184445138313, 0.14766383931266258, 0.07968053977749434, 0.07777664367615045, 0.07078285462446354, 0.11451099939721898, 0.11999613967954337, 0.13188876592314813, 0.020000000000000018, 0.020000000000000018, 0.12627426803139774, 0.08671787426116395, 0.07274603597706564, 0.09980685969191161, 0.07952093245224379, 0.07968881897162339, 0.053845421378851066, 0.1545781593073916, 0.15428483997563447, 0.12323447914757335, 0.047485253671790684, 0.039405292562597394, 0.04173572375325196, 0.04865394698940273, 0.031013229197383363, 0.05725840265708759, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023658177797220348, 0.011918323790563345, 0.01661222672763074, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010803344078660237, 0.010000000000000009, 0.01000489487172218, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08147876397876419, 0.054906603603261495, 0.0822974273884175, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06193264748345484, 0.06147825531143891, 0.05469595774487257, 0.13757616622513236, 0.09918501221774334, 0.10438330647277527, 0.07934938635498623, 0.03702492966410442, 0.05448918772067057, 0.09464354497587424, 0.07458266715773787, 0.09848049838657813, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03416123046720532, 0.03204599055306001, 0.03089862709170066, 0.03292387099320693, 0.022856638002234586, 0.025650016095934647, 0.1435745924652133, 0.14084260157044615, 0.13980175533326278, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02936929775657271, 0.030294978567129816, 0.030478501641254208, 0.0, 0.0, 0.0, 0.03268558872564409, 0.039329495042728646, 0.03657424095720163, 0.08131148950027489, 0.0810711454818438, 0.08146471180096371, 0.022553773186008264, 0.024192448856156457, 0.026824839674127632, 0.06657575870467813, 0.05941644942412139, 0.06261879157048034, 0.0, 0.0, 0.0, 0.01092485391572029, 0.010727733377789539, 0.009832831886976034, 0.008013115696984596, 0.01020378976517089, 0.0075877083819727575, 0.11210060080345952, 0.1304161139054778, 0.11318402001000039, 0.0, 0.0, 0.0]}}
{"id": "0259e033-38ea-46a9-a2d4-17be939ea25e", "fitness": 0.03961934719285184, "name": "EnhancedHybridDEPSO", "description": "Introduce a scaling factor to enhance the diversification of the Particle Swarm Optimization velocities.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight_base = 0.5\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # New scaling factor for velocity diversification\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social)\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03962 with standard deviation 0.05690.", "error": "", "parent_ids": ["451e0511-a763-4816-bd54-c48a6c7497b6"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09527923371026137, 0.14722178639728445, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02355823047805583, 0.020154742289534067, 0.020257735538720234, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.060926444581960726, 0.06302044197304779, 0.565186031861366, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.032420292660422234, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12816480524576135, 0.16331147346710284, 0.16479627487688442, 0.028395129147585574, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09035622729692927, 0.09910703258487163, 0.14745365552639156, 0.14315923047024715, 0.14217068351823103, 0.08941108059227332, 0.059849482686032074, 0.08247882563971898, 0.11732927276896987, 0.11324737311861288, 0.14263268656517136, 0.12236909713592947, 0.020000000000000018, 0.12612376519730129, 0.1470103917218063, 0.10883030192026122, 0.08863950726660508, 0.11149903942011774, 0.0478493036148413, 0.054279011051946324, 0.15331934274301862, 0.1349619864309648, 0.1506876434036668, 0.038669801718039354, 0.05521668681280478, 0.028012845038915102, 0.03985108112702307, 0.03386706549538343, 0.05753668064346651, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017947183936774413, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07374102588978293, 0.06122124331264145, 0.0673899263894624, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830561251587174, 0.07008139015047721, 0.0596411606160564, 0.12754790854729547, 0.10194530255020762, 0.10281775224528589, 0.06906884508368061, 0.04071101934736332, 0.053936809511723194, 0.1025927079556368, 0.07093482774497362, 0.11073559828626445, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934472475539486, 0.036528488685498406, 0.02963375679841196, 0.03961757365660035, 0.028758913481129467, 0.02547921143662646, 0.13329409711480578, 0.1503972832474736, 0.13866419155085064, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.00038922634623961283, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521191340273, 0.033000718567680165, 0.030384406427254373, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03792500033903223, 0.038922240611508396, 0.08189680077627104, 0.08002688505148914, 0.07712499243641413, 0.02197454167671098, 0.02447924137766677, 0.019575860637392695, 0.06612333382413249, 0.06172958944594242, 0.060940262843072524, 0.0, 0.0, 0.0, 0.009680067435466011, 0.010833938096955764, 0.009885441451964017, 0.00814237737888146, 0.010157896730383809, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "8cfad4bc-5720-4a64-84ee-ede4159f3cd7", "fitness": 0.03970597666067176, "name": "EnhancedHybridDEPSO", "description": "Introduce a dynamic crowding distance control in PSO velocities to enhance exploration during early convergence stages.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["0259e033-38ea-46a9-a2d4-17be939ea25e"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "f67a55e9-7d97-472e-9628-242aeee95993", "fitness": 0.03673759640171868, "name": "RefinedHybridDEPSO", "description": "Integrate a self-adaptive learning strategy to dynamically adjust DE and PSO parameters based on population diversity and convergence rate, improving balance between exploration and exploitation.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = 0.5 + 0.5 * (np.std(self.population) / 5.0)  # Adjusted dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.7 + 0.3 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * (1 - self.f_evals / self.budget))  # More aggressive adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.0 + 0.4 * np.tanh(np.var(self.best_values) * 10)  # More dynamic scaling for diversity\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance and variance of fitness\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.var(self.best_values) < 1e-5:  # Enhanced diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 10, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03674 with standard deviation 0.04261.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.0982644405685511, 0.10425399825328607, 0.13874582739107266, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027072720746211587, 0.025246795334395222, 0.022188563627917435, 0.020000000000000018, 0.020000000000000018, 0.028092932751014432, 0.05989179878327289, 0.059676757996977026, 0.06449812305842384, 0.020000000000000018, 0.020000000000000018, 0.022979815650821855, 0.05712644715061255, 0.08594148016760361, 0.10354781657964873, 0.02010736696512705, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13263784550993984, 0.16417300022057546, 0.15628218185080767, 0.02226417251944357, 0.020000000000000018, 0.020000000000000018, 0.09810464666820295, 0.11080139289157132, 0.09499287839254322, 0.13632624986627562, 0.13323277534341382, 0.13573534911847052, 0.07161405102410423, 0.060846884406403956, 0.07340963383989385, 0.11205586464406281, 0.11055418175023701, 0.1362894785897779, 0.020000000000000018, 0.020000000000000018, 0.11007057105790496, 0.15294846801048678, 0.09467889846367317, 0.08401758872373877, 0.06741842842609946, 0.06338273163686681, 0.061373017738059255, 0.14645616574311493, 0.13787768913417064, 0.1260432012194812, 0.0626445666775336, 0.025441988954969186, 0.02657375009670604, 0.03876832722907664, 0.03499891605990868, 0.052066853123107104, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0568883833444741, 0.013603196789502059, 0.01956695392216734, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013951246689467678, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07938761575498332, 0.05963975431903079, 0.08248231720648846, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06418149400837236, 0.06721828060154633, 0.06511879327632242, 0.11876880642625176, 0.10008746825895576, 0.10281775224528589, 0.06883071037557609, 0.04767781422609829, 0.053936809511723194, 0.09574319610940807, 0.06976462959201069, 0.10080396032859706, 0.028823364212028246, 0.010000000000000009, 0.010000000000000009, 0.02631336223538905, 0.02977570489320913, 0.05320770621675108, 0.0384049714710778, 0.02373047254051419, 0.024640285494433645, 0.14425431664024313, 0.13142401767319922, 0.137766772798542, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0012328273498463105, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02855415999860511, 0.03179899035629641, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03872862709335745, 0.03753213255583987, 0.034215952184717624, 0.08156358949642095, 0.08459563576438744, 0.07714904844903114, 0.02316492159189154, 0.024691026019100892, 0.018520294280353844, 0.06594569772657943, 0.06269124762789757, 0.05966882349753466, 0.0, 0.0, 0.0, 0.009719276391315534, 0.010993636315170696, 0.009433151669329232, 0.0073572292615599055, 0.010051284513262426, 0.007291952205074725, 0.11284976519396694, 0.1304161139054778, 0.10673807644646616, 0.0, 0.0, 0.0]}}
{"id": "085a2cb5-9f95-4a03-873a-71125f0f7523", "fitness": 0.03970597666067176, "name": "EnhancedHybridDEPSO", "description": "Add diversity by applying a small random perturbation to reinitialized particles to avoid local optima.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim)) + np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "d8fcca3d-a1ee-4193-aa05-48547ae9994d", "fitness": 0.039291772172429136, "name": "EnhancedHybridDEPSO", "description": "Introduce a learning strategy that adjusts the scaling factor dynamically to maintain diversity and control convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2 - (0.7 * self.f_evals / self.budget)  # Adjust scaling factor dynamically\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03929 with standard deviation 0.05551.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08359013011268213, 0.09723199229250123, 0.15816169481893239, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026069392924193746, 0.020000000000000018, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06468506039398647, 0.06061028318933237, 0.5345926801161591, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02299120912347863, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11938800964524998, 0.16331147346710284, 0.16129958984994575, 0.02115120069050558, 0.02108757563297814, 0.020000000000000018, 0.07932796414964427, 0.09695152854041611, 0.07712914131452198, 0.14745365552639156, 0.14315923047024715, 0.15241609226969188, 0.08941108059227332, 0.06862600852930656, 0.09781898866308925, 0.12861542009151805, 0.14792146765819925, 0.13320199459602544, 0.11602891316015762, 0.020000000000000018, 0.14198003164647033, 0.1470103917218063, 0.10899436736211399, 0.09210815757173374, 0.06527120746322768, 0.04616535580723691, 0.054121845092816145, 0.1438526290318487, 0.1349619864309648, 0.13892137803125193, 0.03885848601797848, 0.04261294580799868, 0.0327576299479404, 0.0397442044420514, 0.0322944997110679, 0.05886708061203916, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013775347375934666, 0.014248128933821658, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012787531121177587, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07213159697359528, 0.0603355852162939, 0.07509900908392964, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0652925772135039, 0.05475106714081723, 0.1232394114947879, 0.09839197891219531, 0.10281775224528589, 0.06651453214911418, 0.04367925029238773, 0.053936809511723194, 0.08777628354917932, 0.0776527312555193, 0.09752173553759536, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030711358585808757, 0.03679330466733288, 0.03498306588052158, 0.039160546919611794, 0.028598279956907557, 0.025305711805811648, 0.13141309820135194, 0.1503972832474736, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0024168458096687218, 0.0, 0.0013216897174649356, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029201194195572655, 0.03451255956665633, 0.03258558772092268, 0.0, 0.0, 0.0, 0.03153719327947835, 0.037925128882106196, 0.04123382980310164, 0.08320723438611322, 0.08248530787761865, 0.07780152437049226, 0.022143461639331674, 0.024630428512018798, 0.020770536942497753, 0.06691351289447955, 0.06264450948278533, 0.0626835588148299, 0.0, 0.0, 0.0, 0.00994873356440562, 0.010904874964904554, 0.01003304811500172, 0.008136655007303983, 0.010386196771009937, 0.007634509917922694, 0.11647287396409967, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "079840c8-5f26-41df-a91c-96848c58b497", "fitness": 0.0359604759589612, "name": "EnhancedHybridDEPSO", "description": "Incorporate a multi-phase adaptive inertia weight adjusting based on fitness diversity and enhance mutation strategies with self-adaptive parameters in DE for better global search balance.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = 0.5 + 0.5 * np.random.rand()  # Self-adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.7 + 0.3 * np.random.rand()  # Self-adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        fitness_diversity = np.std(self.best_values)\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.9 - (0.4 * (1 - fitness_diversity / (np.max(self.best_values) - np.min(self.best_values) + 1e-9)))  # Multi-phase adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and fitness_diversity < 1e-3:  # Diversity check for reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03596 with standard deviation 0.04212.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.10642063514259803, 0.08233466270464651, 0.16013520233463618, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02189009613409243, 0.020637948943497242, 0.028121849464990967, 0.020639449055434467, 0.0337538510521993, 0.020811795071699946, 0.07252115194615172, 0.10602834401384031, 0.05223675403322259, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024463670152536254, 0.09174366620059016, 0.08172824582179739, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11319587417768673, 0.1127241542043328, 0.14719301144136343, 0.0319835907519086, 0.020000000000000018, 0.020000000000000018, 0.103023025322174, 0.08422971804140444, 0.06942783573945543, 0.13559570829974343, 0.13323277534341382, 0.1206701345887069, 0.07484475004699387, 0.07996040543839611, 0.08217539952489372, 0.11474849334854897, 0.1344190830911467, 0.15403946288492987, 0.020000000000000018, 0.020000000000000018, 0.08753064727277438, 0.08535181245099777, 0.08620846612994948, 0.09826116959895392, 0.06527120746322768, 0.05089266906461343, 0.08906394799066564, 0.1438526290318487, 0.14933044002559237, 0.14393250991536177, 0.04385488273075344, 0.02873117519182733, 0.042247476901097536, 0.03618256814712484, 0.030201527292047836, 0.05220750596910462, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016067074781509483, 0.012740701463992643, 0.010000000000000009, 0.012723956372940992, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01460809592501311, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07523660371333973, 0.0613500093287801, 0.07348887074090871, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05469207750219729, 0.06761550166117303, 0.06661631484519726, 0.12005310073297282, 0.10481908642065507, 0.10399000359379418, 0.07106418924540125, 0.044410145597677086, 0.053936809511723194, 0.09465041900450022, 0.08128009428098182, 0.09718532997019635, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02874148965414347, 0.032968223870568525, 0.04072699312947625, 0.025045809209124026, 0.02427279062160037, 0.025481122326512118, 0.13141309820135194, 0.1473187315906006, 0.14947094506263658, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.00024178247641204464, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02912491579108012, 0.032231605656892315, 0.03174499158255284, 0.0, 0.0, 0.0, 0.032686106204461995, 0.0380848502970248, 0.03669655712432285, 0.08117267011977025, 0.07982898723161669, 0.07714743736563645, 0.021615385560020406, 0.025098650999355265, 0.021459604854491277, 0.06720831348888501, 0.06073029933826124, 0.06305612423912677, 0.0, 0.0, 0.0, 0.010231857800923616, 0.010619593307538922, 0.009746107383080682, 0.0074770589241143215, 0.010065264856158218, 0.007920012372410912, 0.1154379779876481, 0.13164749183108693, 0.1161701924908054, 0.0, 0.0, 0.0]}}
{"id": "833c76da-cade-4af9-a95e-d4d39ebf513f", "fitness": 0.037339521476656805, "name": "EnhancedAdaptiveDEPSO", "description": "Introduce a self-adaptive mutation strategy in DE to dynamically balance exploration and exploitation, enhancing convergence speed across varying dimensions.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        base_F = 0.5\n        F_adaptive = 0.3 * (1 - self.f_evals / self.budget)\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = base_F + F_adaptive\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03734 with standard deviation 0.04426.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.0967098294368981, 0.1602299072655251, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027461572199860895, 0.02829377388569143, 0.02147655426765116, 0.020700752261877398, 0.020000000000000018, 0.020000000000000018, 0.06087536702910612, 0.06324333348201572, 0.08041744896924341, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06174323273051341, 0.08594148016760361, 0.0736001816764209, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13518289671509254, 0.1514285839818703, 0.2029632145279323, 0.028467202391701973, 0.020000000000000018, 0.020000000000000018, 0.07799541262773035, 0.06876779669763056, 0.07079849053134168, 0.14723593856590955, 0.13453395932260637, 0.1395638790077559, 0.10181388610521891, 0.059749155038553714, 0.069983499538813, 0.11205586464406281, 0.1240307023230166, 0.14234383190506494, 0.12236910104527288, 0.020000000000000018, 0.13112593227348324, 0.153397054276335, 0.11050027592784284, 0.07667167264800068, 0.11059602943049751, 0.047765377747111204, 0.05379367211913544, 0.1464818607592716, 0.14370959888765555, 0.1342618111211743, 0.04116604026677895, 0.05604084961455835, 0.02657375009670604, 0.04005189293650957, 0.026233557414474973, 0.05808514591392222, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028465746394603975, 0.013697575082836533, 0.018389479728940006, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01655837200754806, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544894080026, 0.06120408181785142, 0.06801778165191519, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05782907136697579, 0.062005959253081055, 0.05395939349942802, 0.12754790309576647, 0.10207794675308757, 0.10281775224528589, 0.06906890134484756, 0.04001039472405321, 0.053936809511723194, 0.09551643698906731, 0.07239769989470834, 0.11185697220587498, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04250401480990762, 0.05643184969197668, 0.02960186723767866, 0.03961757438367908, 0.0274024131148074, 0.026562333177928443, 0.13406220165094307, 0.13714824430644823, 0.14110941207882488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002074327819588273, 0.000489549210879292, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027420340906914586, 0.032986118820386046, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03497455969808794, 0.03753213255583987, 0.03431991507369958, 0.0818968007760088, 0.0806549965844825, 0.07712499243641413, 0.021599469277714833, 0.024483082906095355, 0.01957586063739869, 0.06617284828125036, 0.061729589426607445, 0.06158569223093535, 0.0, 0.0, 0.0, 0.0098738821221942, 0.010833938096958207, 0.009987469128491244, 0.007884777607710447, 0.010157896730316307, 0.007424952133890161, 0.11255020128303872, 0.1304161139054778, 0.1086390229397568, 0.0, 0.0, 0.0]}}
{"id": "89f8c552-8df5-4692-b558-6b6ff9268c47", "fitness": 0.037520656742704404, "name": "EnhancedHybridDEPSO", "description": "Adaptive learning factors with enhanced diversity management to improve search effectiveness and robustness in early and late stages of optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive_component = 2.0 * (0.5 + r1) * (self.best_positions[i] - self.population[i])\n            social_component = 2.0 * (0.5 + r2) * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive_component + social_component) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03752 with standard deviation 0.05757.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08271636017026818, 0.07805461096106625, 0.12534994523398668, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023577177501768465, 0.020000000000000018, 0.020013840738720035, 0.08065447533179226, 0.09517910646159322, 0.6190594479659413, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08838535102732858, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021875761725241305, 0.0312520443826978, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.105004936412458, 0.16331147346710284, 0.1388555218672366, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0974599054415779, 0.07461328902315556, 0.07583732825492862, 0.14745365552639156, 0.14315923047024715, 0.12464000431508482, 0.08941108059227332, 0.058740950086430765, 0.06510426635497435, 0.11732927276896987, 0.1207166289536119, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.11842861299631435, 0.1470103917218063, 0.0639908680245298, 0.08034847126631428, 0.07346069720702841, 0.04616535580723691, 0.054279678248511654, 0.1438526290318487, 0.1736744797205475, 0.13241138395248475, 0.038669801718039354, 0.020000000000000018, 0.02657375009670604, 0.02777611841037908, 0.025449604472236764, 0.048692334122647285, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03369137531521493, 0.013658498290225696, 0.022372179608368903, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06657642151306586, 0.05239910326469843, 0.0661565173024159, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05462153097226874, 0.06580589250107427, 0.05427050764024244, 0.12070054093504179, 0.09374914627582431, 0.10281775224528589, 0.06041156789254887, 0.035507677759466394, 0.053936809511723194, 0.07980411804863596, 0.06739379816605762, 0.09150156134240328, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02568233494906269, 0.0347019700548975, 0.027762531783583122, 0.025120423127497182, 0.02251399353214112, 0.024724449805234583, 0.13192179934648163, 0.1503972832474736, 0.13937579752586116, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026699896500181675, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.032548343533033486, 0.03753213255583987, 0.038922240611508396, 0.08104114571401122, 0.08002688507764433, 0.07712499243641413, 0.02089890047118559, 0.024479241403204233, 0.018646756342115323, 0.06501016208547095, 0.05775643297460331, 0.06058280166632146, 0.0, 0.0, 0.0, 0.009673399527633908, 0.010618216925484814, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.00743479250564183, 0.11629393274685074, 0.1304161139054778, 0.10664364948764771, 0.0, 0.0, 0.0]}}
{"id": "db11de79-5e14-470e-8721-bd9cd10b9f39", "fitness": 0.03914382277940125, "name": "EnhancedHybridDEPSO", "description": "Increase the scaling factor for velocity diversification to enhance exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.5  # Adjusted scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03914 with standard deviation 0.05668.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10589488258673119, 0.1364604450065291, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02767923955881013, 0.03282732886895934, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.07028063241254612, 0.08748215293702633, 0.5778451395708717, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.05964744147460732, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12708689217842617, 0.16331147346710284, 0.1468816532618098, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08694394337820521, 0.08341996990155565, 0.08113970244834912, 0.14745365552639156, 0.14315923047024715, 0.140777565775568, 0.08941108059227332, 0.05425189282683984, 0.09453907269923034, 0.11732927276896987, 0.11319473082481779, 0.13669618348403734, 0.020000000000000018, 0.10861805599759211, 0.11602924611974952, 0.1470103917218063, 0.09977089897214764, 0.08186947841519865, 0.06527120746322768, 0.04616535580723691, 0.0550607790886275, 0.14856727658367264, 0.15496116577346397, 0.13480361848198585, 0.05196329696809854, 0.03028116812198478, 0.02657375009670604, 0.03740518431544826, 0.03446225008128634, 0.05178124457717548, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013654317409434347, 0.021049626080115624, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07138989190585887, 0.058022140720682125, 0.06647190673463843, 0.010000000000000009, 0.010000000000000009, 0.011875073949707993, 0.06125621208003906, 0.0652925772135039, 0.05494132855982903, 0.1247468910855658, 0.10480041190629918, 0.10281775224528589, 0.0737655327980059, 0.039573152285321656, 0.05452324229879513, 0.08847720469486609, 0.07074300834936775, 0.10417749636199103, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028123386089645708, 0.0347019700548975, 0.03187904918163609, 0.0369789920422231, 0.02315836134579774, 0.024768093546048697, 0.1353608931372109, 0.1503972832474736, 0.13394794627018047, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02873114900540874, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03298043010285823, 0.037543568044758224, 0.038922240611508396, 0.08158129245825418, 0.07979931039860289, 0.07712499243641413, 0.02237407441968997, 0.024192448856156457, 0.018482390482473354, 0.06562881416836663, 0.061115856391971146, 0.06058280166632146, 0.0, 0.0, 0.0, 0.00967230606319125, 0.011042766531781711, 0.009885441451964017, 0.008140036658503491, 0.010051284513262426, 0.00743479250564183, 0.11782360885015042, 0.1304161139054778, 0.10660783249433547, 0.0, 0.0, 0.0]}}
{"id": "e4ca1d2c-3c91-4af4-afd9-5ae4129ef1c6", "fitness": 0.03857265651093137, "name": "EnhancedHybridDEPSO", "description": "Introduce a crowding distance-based exploration boost to improve adaptation in early convergence phases of the hybrid DE-PSO algorithm.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            if self.f_evals < self.budget * 0.3:  # Exploration boost in early stages\n                velocity_control_factor *= 1.5\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03857 with standard deviation 0.05678.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10216415851119143, 0.14101815084221703, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.028160159952166697, 0.020000000000000018, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.02302679336609248, 0.06553691509152804, 0.08873277963338921, 0.581839704650069, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11427049680750345, 0.16331147346710284, 0.1364624908190345, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0804793407566009, 0.07324227683377416, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.14464542310478234, 0.08941108059227332, 0.07081344134860845, 0.07615683793108796, 0.11732927276896987, 0.11992702404881816, 0.14645811712059986, 0.020000000000000018, 0.020000000000000018, 0.11692788862557946, 0.1470103917218063, 0.10262341902937, 0.07667167264800068, 0.06527120746322768, 0.04694955942988688, 0.05467456718952601, 0.1438526290318487, 0.1349619864309648, 0.16748195655858011, 0.038669801718039354, 0.030957374425158113, 0.02657375009670604, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "b63e6066-5abe-4b92-950b-96b8e7ad3d00", "fitness": 0.03970597666067176, "name": "EnhancedHybridDEPSO", "description": "Introduce dynamic scaling factor adjustment in DE step based on population diversity for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            diversity_factor = np.std(self.population) / 5.0\n            F = F_base + 0.2 * diversity_factor if diversity_factor < 1 else F_base  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "2c87ca8b-dcef-481e-8781-06e8d6d2cc62", "fitness": 0.039705976659074986, "name": "EnhancedHybridDEPSO", "description": "Refine the dynamic mutation factor in differential evolution to enhance adaptability during optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * ((np.std(self.population) + 1e-10) / 5.0)  # Improved dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294483659, 0.14586163459289825, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.02381729913791053, 0.021266716609225633, 0.021062419885174433, 0.020000000000000018, 0.020000000000000018, 0.06090747270934582, 0.06293453442855523, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372762102, 0.16331147346639285, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796404703657, 0.09729625096753125, 0.09967766500492259, 0.14745365552650402, 0.1431592304699899, 0.13667652669798958, 0.08941108059189329, 0.059991541706611695, 0.08127669377996938, 0.11972062277501838, 0.11312883128017814, 0.14993026075965044, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917212251, 0.10884677519573505, 0.08880535241269572, 0.11150825111161555, 0.04776537690280014, 0.054279678248507546, 0.1438526290318487, 0.13496198637040024, 0.1589139162928075, 0.038669801718039354, 0.05521662063987409, 0.03462062017148493, 0.03985108091845446, 0.03386706579683296, 0.05753667778075722, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028184627025891307, 0.013557136881482856, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485835, 0.06742351492146637, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572897795916, 0.07008234767845412, 0.06069732135584871, 0.12754790273435246, 0.10195228551698365, 0.10281775224528589, 0.06906887936676553, 0.0407393465547109, 0.053936809511723194, 0.10264046159609175, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02993446906966557, 0.03632836096664671, 0.029646709453070352, 0.03961757438367908, 0.02876672067503705, 0.025481546363021024, 0.13336588564014873, 0.15039728306881894, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884269808, 0.0003892263461193757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.03300071856767639, 0.03038440642721174, 0.0, 0.0, 0.0, 0.031537193290466115, 0.03788570828422766, 0.038922240592850654, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168256907, 0.024483082906095355, 0.019575860637573772, 0.06612333839708673, 0.061729589426607445, 0.06094026271192787, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451957577, 0.008142145109170773, 0.010157896730316307, 0.00743479250564183, 0.11619717786030859, 0.1304161139054778, 0.10657390809978307, 0.0, 0.0, 0.0]}}
{"id": "a3888e81-9b1f-46eb-8896-e0ff58a3cd7f", "fitness": 0.03796572046726925, "name": "ChaosHybridDEPSO", "description": "Enhance exploration and convergence by introducing chaos-inspired randomization and adaptive velocity limits in the hybrid DE-PSO algorithm.", "code": "import numpy as np\n\nclass ChaosHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size * dim)\n        \n    def generate_chaotic_sequence(self, size):\n        x = 0.7\n        sequence = np.zeros(size)\n        for i in range(size):\n            x = 4.0 * x * (1.0 - x)  # Logistic map\n            sequence[i] = x\n        return sequence\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * self.chaotic_sequence[i * self.dim]  # Chaos-inspired mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n            v_max = (self.ub - self.lb) * (0.1 + 0.9 * (1 - self.f_evals / self.budget))\n            \n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance with chaotic influence\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance)) * self.chaotic_sequence[i * self.dim + 1]\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.velocities[i] = np.clip(self.velocities[i], -v_max, v_max)  # Limit velocity\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 20, "feedback": "The algorithm ChaosHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03797 with standard deviation 0.04463.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09531413105093023, 0.14593993767208446, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023570437483466655, 0.023889551976839507, 0.02134772850563582, 0.021172771541795088, 0.020000000000000018, 0.020000000000000018, 0.06086366108077712, 0.06323771661132616, 0.0783434478488586, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.044099361630408396, 0.08594148016760361, 0.10832180052346274, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03595995963006837, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13275804407453928, 0.1701322635872401, 0.16410980260444408, 0.028398602063267053, 0.020000000000000018, 0.020000000000000018, 0.07679015924157884, 0.07949934092157063, 0.07983373928346338, 0.15045175932164223, 0.13323277534341382, 0.15542461112320127, 0.08494264392404305, 0.06653025594051276, 0.09186081749329489, 0.14063149662084695, 0.11929137980442306, 0.14150726372328226, 0.12236910290140912, 0.020000000000000018, 0.12355928369924296, 0.15443182740317996, 0.11322547667000515, 0.09033914198724802, 0.1111190634797985, 0.04784456408731219, 0.05412963030231599, 0.16100741488860848, 0.12600475580459003, 0.1377264748352165, 0.038669801718039354, 0.055977966173685334, 0.0335026981327502, 0.04305314656142245, 0.0346352023553439, 0.058019932808569874, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028382604072477613, 0.013701852915072088, 0.014079590029798639, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020338575255624436, 0.011511461238636667, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08684473939201043, 0.07885335882169697, 0.07724888657126183, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055242726829534905, 0.06147825531143891, 0.055155813480570304, 0.12788906258106136, 0.10251320446176149, 0.10281775224528589, 0.06892486526736052, 0.04346789125078876, 0.053936809511723194, 0.10114623562969682, 0.07616733388786745, 0.1050678933923449, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031983756834064514, 0.03863328269833932, 0.03324943878707498, 0.039617574047491555, 0.02675433039710029, 0.025480003200492374, 0.13983270688593297, 0.13438047810597653, 0.13853672773632975, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0036896323588053725, 0.0005503076816074648, 0.0032495315848134476, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03047638952621501, 0.034175604669328785, 0.031336033697032195, 0.0, 0.0, 0.0, 0.035649882057811944, 0.03753213255583987, 0.038765189092360375, 0.08113158280236221, 0.08264498249236918, 0.07798627450911955, 0.022721910937827272, 0.025191693284311478, 0.01988746844551148, 0.06808188077467558, 0.06231276321213142, 0.0624972157651561, 0.0, 0.0, 0.0, 0.009824045918480628, 0.010633081205063788, 0.010055639774689706, 0.00814356479825662, 0.010051284513262426, 0.007699958855361344, 0.11736940319562505, 0.1304161139054778, 0.11373372267059634, 0.0, 0.0, 0.0]}}
{"id": "e2afbd92-1521-4a72-b47c-64cc6f1bf602", "fitness": 0.03693802253165867, "name": "EnhancedHybridDEPSO_v2", "description": "Introduce a dynamic velocity clamping mechanism and crowding-driven reinitialization to balance exploration and exploitation in PSO-DE hybrid.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            \n            # Dynamic velocity clamping\n            vel_clamp = (self.ub - self.lb) * 0.1\n            self.velocities[i] = np.clip(self.velocities[i], -vel_clamp, vel_clamp)\n\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n            # Use crowding distance to guide reinitialization\n            for i in range(self.population_size):\n                if np.linalg.norm(self.population[i] - self.global_best_position) < vel_clamp:\n                    self.population[i] = np.random.uniform(self.lb, self.ub, self.dim)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridDEPSO_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03694 with standard deviation 0.04373.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.10172015330130024, 0.0877934000167283, 0.15576357527153983, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030082775154493646, 0.025828003979963987, 0.03601581747352467, 0.021062419885162775, 0.020000000000000018, 0.030916853458064164, 0.05676862851019626, 0.052920900404947124, 0.05211716007367384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04730238192152425, 0.08594148016760361, 0.10843824255957613, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.105004936412458, 0.16331147346710284, 0.15588109466376776, 0.033239061831623506, 0.020000000000000018, 0.026761983410634738, 0.09207863024232565, 0.07324227683377416, 0.08454249208081588, 0.1521563686432773, 0.14315923047024715, 0.1489213936639041, 0.09281570087398416, 0.07917305303594901, 0.09768053907053798, 0.13526502026808263, 0.11496132376312285, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.11916386671534185, 0.1470103917218063, 0.11089118891540506, 0.10744489517124778, 0.06527120746322768, 0.06776640990701255, 0.057751096545950675, 0.15134689973038373, 0.14396910228373427, 0.16258659391459018, 0.04352298775553298, 0.031235165173784996, 0.03988188072957599, 0.04793338472184272, 0.03838109499508402, 0.05944285740368416, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.010172493137437733, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07459836133033126, 0.06250163560824262, 0.07486992228577694, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0570965810762436, 0.08094880885658295, 0.05395939349942802, 0.12070113028232943, 0.09567104315931674, 0.10672344890343277, 0.06406743557978767, 0.03598406170864554, 0.05531857556687636, 0.09030307048101349, 0.07714860534948687, 0.09536305719622684, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031438394970581096, 0.03901015749181458, 0.028609368071219277, 0.02922468437831005, 0.024885534469001325, 0.025949605817876087, 0.13141309820135194, 0.15102446859567265, 0.13551219881786825, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003470918314843363, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028173535400851102, 0.033384213742952085, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.08104108627288686, 0.08045061356473793, 0.07763187480148703, 0.02160428507934231, 0.02569210558651336, 0.018866123376435118, 0.06516043306265773, 0.05850428738901314, 0.06058280166632146, 0.0, 0.0, 0.0, 0.009742965975385598, 0.010626888988826688, 0.00989842015633502, 0.008136655007303983, 0.010051284513262426, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.1065992342384412, 0.0, 0.0, 0.0]}}
{"id": "e6032073-a9e2-434d-8a96-afb43ce02634", "fitness": 0.039191141556967964, "name": "EnhancedHybridDEPSO", "description": "Introduce a dynamic velocity scaling factor in PSO to improve convergence speed in later stages.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor * (1 + 0.5 * self.f_evals / self.budget)  # Changed line\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03919 with standard deviation 0.05718.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10111869655290362, 0.14466506527719925, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022539370345208587, 0.023629312432642546, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.064850460958784, 0.08655526471151409, 0.5761238919558764, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13166845410413086, 0.16331147346710284, 0.1609740487765251, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09722313593342735, 0.07324227683377416, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.15997944922042795, 0.08941108059227332, 0.05938365661812495, 0.09028312345919753, 0.11732927276896987, 0.11182541953804359, 0.14414587005710766, 0.13052645002538776, 0.02668663971445573, 0.11450442430899532, 0.1470103917218063, 0.10696243749380008, 0.08178112262998949, 0.07500208706017697, 0.05077564191684081, 0.05472924869248341, 0.1438526290318487, 0.1349619864309648, 0.15473100200311107, 0.04412523029080151, 0.028420476904732928, 0.03153531901904161, 0.03813584790041136, 0.03460799968911166, 0.053211069052089055, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013581061865532762, 0.021087965694519095, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07154872521316447, 0.05838820513812881, 0.06690935109261853, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05781771685430104, 0.0652925772135039, 0.054108771460776084, 0.12973867768317104, 0.10395190422029477, 0.10281775224528589, 0.06396451599808772, 0.03957358909074771, 0.05509016026383984, 0.09911408487590934, 0.06837674054599674, 0.09353654677726342, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028149784595890903, 0.03559387271409464, 0.031836586347986806, 0.03791104363564357, 0.023240766610976626, 0.02467259436495073, 0.1370516071426795, 0.1503972832474736, 0.13808480141006907, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029061676939957537, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.08135455780990652, 0.07965841969894782, 0.07712499243641413, 0.022865390809225117, 0.024192448856156457, 0.01864152662983698, 0.0656181506261655, 0.06059948082300137, 0.060670772348315194, 0.0, 0.0, 0.0, 0.009671144669404552, 0.010969574702205165, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.007437769449110787, 0.11619717782090566, 0.1304161139054778, 0.10713372802510568, 0.0, 0.0, 0.0]}}
{"id": "4b158f73-aa43-4894-9bec-21e3a73bb485", "fitness": 0.039212574956952725, "name": "EnhancedHybridDEPSO", "description": "Introduce a dynamic inertia weight adjustment based on the ratio of current best to global best value to enhance convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + 0.5 * (self.global_best_value / (self.best_values[i] + 1e-9))  # Dynamic inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03921 with standard deviation 0.05678.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08864340808825522, 0.08332319378275288, 0.1515864678562593, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024037158889828603, 0.025716584563146516, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.061260758564102624, 0.06406802273289747, 0.5719613612113089, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026825132117333506, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14208722873516166, 0.16331147346710284, 0.15421706573528482, 0.023356712806197222, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.07324227683377416, 0.07794452267699059, 0.14745365552639156, 0.14315923047024715, 0.14854559722554417, 0.08941108059227332, 0.06184919275666756, 0.0846312541788552, 0.11886885852520124, 0.1134007564355991, 0.14678432215008486, 0.12575832762729178, 0.020000000000000018, 0.11389182459966041, 0.1470103917218063, 0.10760858064298762, 0.09006410286505528, 0.1117864997058109, 0.046994928304670225, 0.054768102820785924, 0.1523054345847945, 0.1356531306202905, 0.13203651232871905, 0.0392025035889918, 0.03625921716040925, 0.031224348571493477, 0.04009540178217508, 0.03747458675374449, 0.0573264483619742, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031216959678908696, 0.013847768880943967, 0.019613920238366833, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012409560671793218, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07862098360399239, 0.056721586811415925, 0.06641418000561572, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06559398752867251, 0.05623279832766892, 0.11915327286477573, 0.10231578600929903, 0.10281775224528589, 0.07669874733239168, 0.03964587470580938, 0.053936809511723194, 0.09619362120386821, 0.07075713779652093, 0.09900199368037432, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029772335728615595, 0.0347019700548975, 0.02904767567644906, 0.041425645571604996, 0.02917510931993439, 0.024766970634840124, 0.1332022743359086, 0.1503972832474736, 0.13692334669512773, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003808509132690041, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028099583761224234, 0.033000718567680165, 0.03039051324434372, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.08072778292416571, 0.07965841969894782, 0.07712499243641413, 0.022563467694219908, 0.024192448856156457, 0.019274927248020934, 0.06567273873367663, 0.060933776362080305, 0.06058280166632146, 0.0, 0.0, 0.0, 0.009683970988332513, 0.010923828387242818, 0.009885441451964017, 0.008136655007303983, 0.010272057613999741, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657677324848125, 0.0, 0.0, 0.0]}}
{"id": "a67543d8-add3-4f27-bcda-d490316e993c", "fitness": 0.03723036698097875, "name": "EnhancedHybridDEPSO", "description": "Introduce an adaptive inertia weight and crowding-aware mutation in a hybrid DE-PSO framework to reinforce both global exploration and local exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            F = F_base + 0.2 * (np.std(self.population) / 5.0) * crowding_distance\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * (1 - self.f_evals / self.budget))\n            cognitive = 1.5 * r1 * (self.best_positions[i] - self.population[i])\n            social = 1.5 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03723 with standard deviation 0.04513.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09177953901229474, 0.09557358943972571, 0.18719246508790666, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023784902942206698, 0.02253422531300775, 0.028659721764431656, 0.020000000000000018, 0.030947495086742105, 0.020000000000000018, 0.06293359748570893, 0.059020425198779924, 0.17753735823630834, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03148409199825242, 0.08594148016760361, 0.06544067594753589, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09754575832158552, 0.11735074544655566, 0.15967756536311983, 0.020000000000000018, 0.020000000000000018, 0.029685664961794034, 0.07622765039246249, 0.10241947742650581, 0.08254607411406156, 0.15594871300261814, 0.1529369106133871, 0.13843017804039937, 0.0752909452890137, 0.07979383245443006, 0.0589719385018701, 0.1157492618192778, 0.1074403011606685, 0.1269138815861044, 0.029666606973898557, 0.020000000000000018, 0.14176265257963683, 0.08798629445106088, 0.11042991563278859, 0.08260142125532166, 0.13711257037416946, 0.04616535580723691, 0.05366991419220524, 0.1684122044659656, 0.19590761322711503, 0.15606472222191448, 0.0464179731826978, 0.042042094623614634, 0.031031077987905498, 0.03776484980121053, 0.02883692587154396, 0.05639341314594848, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02431629489407383, 0.01385009991874564, 0.017108024244938402, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07513705349131328, 0.060960866976738304, 0.08378164215665918, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055503420215663124, 0.06935902924082593, 0.05395939349942802, 0.1249364625797359, 0.09718707371298652, 0.10588954510026372, 0.0688288393428711, 0.04367853058298432, 0.053936809511723194, 0.08860187255057128, 0.08887486251047261, 0.10514075034883741, 0.010081911400563581, 0.010000000000000009, 0.010000000000000009, 0.0319718150849263, 0.03568910648197077, 0.035362890203693986, 0.03780793775405511, 0.028075524681909658, 0.025145148361690572, 0.1435972482478738, 0.1355973681985726, 0.1404031321182453, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00019201362285115042, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028946945859256945, 0.03278719633942795, 0.031173445701340174, 0.0, 0.0, 0.0, 0.033902398421808755, 0.04018573202898268, 0.03801939726837278, 0.08131700936665254, 0.07982978039378563, 0.07758431824053302, 0.021434788280850214, 0.024192448856156457, 0.019400662251113143, 0.06635533055757536, 0.06222772091552686, 0.06257857641158016, 0.0, 0.0, 0.0, 0.010084563339694874, 0.010732940823030224, 0.009917527033378115, 0.0073608693194121555, 0.010051284513262426, 0.00748354947137575, 0.11187995645991478, 0.1304161139054778, 0.10689797312912275, 0.0, 0.0, 0.0]}}
{"id": "11e712e1-2bf7-4449-982a-7ec645f2246a", "fitness": 0.03798036667413326, "name": "AdaptiveEnhancedHybridDEPSO", "description": "Integrate adaptive learning rates in DE mutation and PSO inertia to improve the balance between exploration and exploitation during the optimization process.", "code": "import numpy as np\n\nclass AdaptiveEnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = 0.5 + 0.3 * (1 - self.f_evals / self.budget)  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.4 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 25, "feedback": "The algorithm AdaptiveEnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03798 with standard deviation 0.04480.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09270680622024774, 0.09784953512885608, 0.16291840237198496, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04726399806729775, 0.020000000000000018, 0.020000000000000018, 0.020700752261877398, 0.020000000000000018, 0.020000000000000018, 0.06225938701300682, 0.06267644008926931, 0.08084288321031652, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.056618525332547964, 0.08594148016760361, 0.07854731926280878, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026709084397895544, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14964104620037688, 0.15040902290988556, 0.20345068711309333, 0.048135473551695784, 0.020000000000000018, 0.020000000000000018, 0.08076503816720337, 0.07240705348566734, 0.0736517912597483, 0.14723593856590955, 0.13323277534341382, 0.14217678222520191, 0.10181388610521891, 0.06746767578612334, 0.07272045733777177, 0.1290089063278833, 0.1178251659464089, 0.1533375912042294, 0.12549018836954184, 0.020000000000000018, 0.1374577841863649, 0.15239345032377172, 0.11063591936052541, 0.07667167264800068, 0.11035632162932563, 0.057403991804160226, 0.053673135670811445, 0.15274366136562523, 0.12240943477147903, 0.13240016048189407, 0.06256775308467755, 0.04447232453957606, 0.03357144274046808, 0.04021663255934371, 0.026344559181382565, 0.05791702155527789, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02856900441465482, 0.013522172056331105, 0.01702828106505383, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015123683992536607, 0.010801588007095075, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07296117882932451, 0.06282414731498565, 0.06797997398237743, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061843263941061766, 0.061999042283300665, 0.06074308250163274, 0.12263207564165401, 0.09544628279627076, 0.10281775224528589, 0.06541393061307388, 0.03900166074658318, 0.053936809511723194, 0.08930985908019595, 0.07277713017216503, 0.09640252570877006, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.044001180257698946, 0.05769086364483711, 0.029559849818395212, 0.03898599957212068, 0.027413625683763154, 0.027874335426647856, 0.13319775986540305, 0.1432509728529584, 0.1460274342690705, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002930199604560091, 0.0004971664745784254, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02826481877914855, 0.032851695894056676, 0.030393864265814252, 0.0, 0.0, 0.0, 0.03497455969808794, 0.03753213255583987, 0.03517333121789623, 0.08230136393922705, 0.0796987399128607, 0.08069742650386158, 0.023133233577337764, 0.024192448856156457, 0.023023993507869434, 0.06568667062383171, 0.06287458278428926, 0.062496923514062, 0.0, 0.0, 0.0, 0.00977435676216376, 0.010793505338535403, 0.009979343064865809, 0.007860498454059783, 0.010117044335944736, 0.007402188774536578, 0.12239198976779464, 0.1304161139054778, 0.1141261838791846, 0.0, 0.0, 0.0]}}
{"id": "2ec314f9-e640-4bbe-91dc-32aeccea113e", "fitness": 0.03963332588345364, "name": "EnhancedHybridDEPSO", "description": "Integrate a dynamic local search phase based on swarm convergence to enhance precision in later optimization stages.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def local_search_phase(self, func):\n        if self.f_evals / self.budget > 0.75:  # Trigger local search towards the end\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(self.global_best_position + perturbation, self.lb, self.ub)\n                candidate_value = self.evaluate(func, candidate)\n                if candidate_value < self.global_best_value:\n                    self.global_best_value = candidate_value\n                    self.global_best_position = candidate\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n            self.local_search_phase(func)\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03963 with standard deviation 0.05683.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557341478423801, 0.01745336980718415, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.011641160446892562, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07265515462178385, 0.059860685379635625, 0.0661565173024159, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10266875016893495, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.099106343357097, 0.06850843069633328, 0.1109024799215601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03548875730795997, 0.029489696169114232, 0.03961757438367908, 0.028010629422038802, 0.024640285494433645, 0.13329411941578284, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026699896500181675, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03153719327947835, 0.039271453843410686, 0.038922240611508396, 0.08256184159345903, 0.08115896567267877, 0.07712499243641413, 0.022082332083539935, 0.02596125215572842, 0.018449874749746464, 0.06501016208547095, 0.057855653756687664, 0.06058280166632146, 0.0, 0.0, 0.0, 0.010032793709249144, 0.010927686203043963, 0.009885441451964017, 0.008142595346669279, 0.010051284513262426, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10685807707809758, 0.0, 0.0, 0.0]}}
{"id": "f9c57dc5-1893-4e01-b553-0d962c8a955d", "fitness": -Infinity, "name": "EnhancedHybridDEPSO", "description": "Improve EnhancedHybridDEPSO by incorporating adaptive learning rates and local search intensification to boost convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        inertia_weight_decay = (self.budget - self.f_evals) / self.budget\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * inertia_weight_decay)  # Adaptive inertia weight\n            cognitive = 1.5 * r1 * (self.best_positions[i] - self.population[i])  # Reduced cognitive weight\n            social = 2.5 * r2 * (self.global_best_position - self.population[i])  # Increased social weight\n            scaling_factor = 1.5  # Adjusted scaling factor\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n            if self.f_evals / self.budget > 0.5 and np.random.rand() < 0.1:  # Local search intensification\n                local_search = self.population[i] + np.random.normal(0, 0.1, self.dim)\n                local_search = np.clip(local_search, self.lb, self.ub)\n                local_fitness = self.evaluate(func, local_search)\n                if local_fitness < self.best_values[i]:\n                    self.population[i] = local_search\n                    self.best_values[i] = local_fitness\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 27, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {}}
{"id": "c9799dc1-a11b-41c7-8550-48fe81c7b143", "fitness": 0.03964025566538205, "name": "EnhancedHybridDEPSO", "description": "Enhance exploration and convergence balance by integrating adaptive inertia weights and crowding-aware mutation strategies in a hybrid DE-PSO framework.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F_dynamic = F_base + 0.2 * (np.std(self.population, axis=0) / 5.0)  # Dynamic mutation factor per dimension\n            mutant = x1 + F_dynamic * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.3 * np.sin(2 * np.pi * (self.f_evals / self.budget)))  # Sinusoidal adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03964 with standard deviation 0.05596.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09171305407321884, 0.09889254049414153, 0.1394141211433393, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02048746609448382, 0.022388755803520732, 0.021085727308847724, 0.02075525632732389, 0.020000000000000018, 0.020000000000000018, 0.06462930725543858, 0.0619579738493613, 0.5390230716614977, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.09187238790459262, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03671367144565185, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1525011364049581, 0.1648017234806456, 0.16949537337373244, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11054707830482069, 0.06929704440042339, 0.07725660656170996, 0.14722415112672582, 0.1366494550724887, 0.14951191324802204, 0.09121213921922489, 0.06450458759383049, 0.08614506592879023, 0.13110214174667845, 0.11681936451363295, 0.14604470739627884, 0.12761875653335208, 0.020000000000000018, 0.11275558167648936, 0.1493739403513782, 0.10852197290801713, 0.09212040687793477, 0.11166306036944607, 0.06024731758934454, 0.054429748382030185, 0.14835719908587597, 0.1520797769426807, 0.14305768929820029, 0.06768654370370342, 0.04890646979772495, 0.02842340176158753, 0.04007778687386376, 0.0357602582073272, 0.05726785593427419, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028236626077310256, 0.01357161293250253, 0.017460634088767635, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012466570810502176, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07347449882495649, 0.06338365175247884, 0.0667604316530569, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055858213501996934, 0.061911647715700124, 0.05395939349942802, 0.12481724929572824, 0.10092731306371217, 0.1028347234885939, 0.0707684571026248, 0.041491721997621855, 0.053936809511723194, 0.08800739929837786, 0.07074777986013647, 0.10088417944937933, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029945550965016277, 0.03730093220255526, 0.030280312562192546, 0.0387372058841271, 0.027436726194909333, 0.026107407903781188, 0.13807767781930602, 0.1314907087396603, 0.1362814692637493, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022473989801006233, 0.000267170616686796, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02806571762351051, 0.03299611737346897, 0.030137388381939023, 0.0, 0.0, 0.0, 0.03185872846925941, 0.03753213255583987, 0.037841786343767, 0.08108971265279452, 0.08013728928888908, 0.07775473816998746, 0.02221962240698583, 0.024192448856156457, 0.019721040998884498, 0.06565050270372208, 0.06265357255820703, 0.06246433176465216, 0.0, 0.0, 0.0, 0.009682016711451857, 0.010726992277663938, 0.009887767862988395, 0.008145231956825816, 0.010069053655508475, 0.007437566264769213, 0.11535042113602723, 0.13059185957294406, 0.11008264088538144, 0.0, 0.0, 0.0]}}
{"id": "2723e164-6d60-447f-a139-50eb958fad32", "fitness": 0.03505479373370569, "name": "RefinedHybridDEPSO", "description": "Introduce adaptive learning rates via topology-based PSO with self-adaptive DE mutation to dynamically balance exploration and exploitation phases.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.4 * np.random.rand() * np.std(self.population)  # Self-adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.8 + 0.2 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            lhc_factor = 1.0 + np.tanh(np.mean(self.best_values) - self.best_values[i])  # Learning factor control\n\n            neighbors = np.random.choice(self.population_size, size=5, replace=False)\n            local_best = self.best_positions[neighbors[np.argmin(self.best_values[neighbors])]]\n            lhc_social = 2.0 * r2 * (local_best - self.population[i])\n\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social * lhc_factor + lhc_social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.3 and np.std(self.best_values) < 1e-4:  # Dynamic reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 29, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03505 with standard deviation 0.04097.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09915730591374416, 0.0825825176015681, 0.18735871535196336, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022569197123713303, 0.02003666703448459, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029510098038702748, 0.05828568722028149, 0.062089960577418446, 0.06805221991357568, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.06903665451140961, 0.09287381179755527, 0.05987650581227755, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10392228155159389, 0.0916799919439919, 0.13084903150896143, 0.020126779947820417, 0.020000000000000018, 0.021462718503736045, 0.09683940847978245, 0.0651772556396163, 0.065319766186, 0.13212464557337145, 0.1742681448874709, 0.12956724746706816, 0.07404270107801836, 0.08424174495012948, 0.08260457788442976, 0.11205586464406281, 0.09018896711908786, 0.1345980345335459, 0.020000000000000018, 0.020000000000000018, 0.13679140419446245, 0.08390811322713598, 0.06553539201466829, 0.079896616354998, 0.06527120746322768, 0.05500746114627819, 0.05185847193049764, 0.1438526290318487, 0.1362597222034745, 0.13786814390053737, 0.038669801718039354, 0.02626280302019035, 0.027297206511880723, 0.040257830738916756, 0.03913591584339182, 0.04343226516240917, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034145366207441685, 0.03455339352876341, 0.011157524608567004, 0.010000000000000009, 0.010000000000000009, 0.01577342614782884, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06123509410695438, 0.0623614217841435, 0.0761614521299846, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.07158683525596043, 0.05968522154133804, 0.11869262382913237, 0.09509078728213793, 0.10281775224528589, 0.05756835603815702, 0.03681983983857262, 0.053936809511723194, 0.08235395725597472, 0.08322934018529216, 0.09885135868620754, 0.010348974004338762, 0.010000000000000009, 0.010000000000000009, 0.05203919783207023, 0.03522011720808382, 0.027502594921495538, 0.025999845169984326, 0.02300725629197653, 0.02585980793751208, 0.13968059127355514, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002717548784756718, 0.00029819786767693035, 0.0004768247882567245, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026699896500181675, 0.032057330945964524, 0.0335816074649129, 0.0, 0.0, 0.0, 0.03136890510938428, 0.04062992527966147, 0.039193416918302804, 0.08218595039426146, 0.08268644549668591, 0.077940677948515, 0.022135809174290033, 0.024192448856156457, 0.019723548004429325, 0.0704404678571191, 0.059174940141773824, 0.06000810250203126, 0.0, 0.0, 0.0, 0.009732584710434256, 0.010710142184886529, 0.009523259021177677, 0.007531383139894543, 0.010051284513262426, 0.007667111558289141, 0.11671767262418031, 0.1306725460034056, 0.1166176813267964, 0.0, 0.0, 0.0]}}
{"id": "54296ad9-a64a-4311-bb0e-0f5d712b1e70", "fitness": 0.03709513261913128, "name": "EnhancedHybridDEPSO", "description": "Enhance exploration by introducing adaptive inertia weight decay in PSO and adapting crossover rate in DE based on convergence rate.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * np.exp(-5 * self.f_evals / self.budget)  # Updated adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.9 - 0.4 * (self.f_evals / self.budget)  # Enhanced adaptive inertia weight decay\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03710 with standard deviation 0.04357.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08299763012828931, 0.09572917452628471, 0.16277246438597615, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03320873645355049, 0.02390438243455928, 0.04113960413945972, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1158440200645523, 0.06272374023494276, 0.07338161282230427, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.041002677129271525, 0.08594148016760361, 0.0779329349506207, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08058565970812537, 0.16331147346710284, 0.16624517997887112, 0.025238836317220015, 0.020000000000000018, 0.020000000000000018, 0.07131407602902162, 0.06868448634195945, 0.08960378543460878, 0.13334360478743223, 0.13577909902401242, 0.15148258793040326, 0.06797976284093876, 0.0653158216886115, 0.08350236380183618, 0.12887662629699126, 0.10408367547123387, 0.13513117119213747, 0.11830079057915754, 0.020000000000000018, 0.12675608209305067, 0.09111245499081178, 0.09875881975644973, 0.07696313704346724, 0.08834545860056298, 0.08409678922190666, 0.053248733086672106, 0.15921441378777024, 0.1420932695908923, 0.1763892841057495, 0.05860087609032083, 0.04333075581718904, 0.02657375009670604, 0.041292387933562935, 0.03167874204174481, 0.0563263605741533, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030384989524098516, 0.011206439882217034, 0.01874636246533412, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013647489747945607, 0.010416201069627706, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07708650332472144, 0.06219666298074755, 0.08415982929957266, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059247231573660075, 0.07390102252697484, 0.05395939349942802, 0.12164457372704318, 0.10114344188515378, 0.10281775224528589, 0.07686716334023114, 0.04959052800979147, 0.053936809511723194, 0.09225847574467105, 0.07419604508605604, 0.10384686635678819, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025798698919715868, 0.034465541047070225, 0.030236089959742696, 0.039434684788853036, 0.0273708852505965, 0.024640285494433645, 0.14189722589247244, 0.13722073633391307, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0009297846162951151, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028376741471534683, 0.03112054988908486, 0.030388982074295634, 0.0, 0.0, 0.0, 0.030499991321740527, 0.03775945750570897, 0.0379843265311568, 0.08210914347989773, 0.08095826577249154, 0.07972533251533287, 0.022924040795130773, 0.024416432826356194, 0.01909447596284297, 0.06575403330671492, 0.06238025659162871, 0.060238705204633036, 0.0, 0.0, 0.0, 0.009855154722800297, 0.010827586142978851, 0.009460876302524235, 0.00817202223469149, 0.010151192715439072, 0.007334802304070576, 0.11516761910939377, 0.1304161139054778, 0.11026280337555805, 0.0, 0.0, 0.0]}}
{"id": "1ecd4acc-4803-46aa-9e96-59eb62d64c50", "fitness": 0.03960734525660278, "name": "EnhancedHybridDEPSO", "description": "Introduce an adaptive cognitive scaling factor in PSO for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = (1.5 + 0.5 * self.f_evals / self.budget) * r1 * (self.best_positions[i] - self.population[i])  # Modified cognitive factor\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03961 with standard deviation 0.05605.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08762228496490776, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.030128285507674324, 0.020000000000000018, 0.021062419885162775, 0.024307382347274697, 0.020000000000000018, 0.06782964837262118, 0.06293453442856733, 0.5449471266895625, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11239200566297114, 0.16331147346710284, 0.16390552602552466, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08152123564846536, 0.08736818740846275, 0.07803674574616726, 0.14745365552639156, 0.14315923047024715, 0.14111832081959763, 0.08941108059227332, 0.05999154170664933, 0.07299629306784994, 0.11732927276896987, 0.13203775969324738, 0.1415063152232563, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.09899398623621014, 0.11197717197256107, 0.04776537754370025, 0.054279678248511654, 0.1438526290318487, 0.14823026657741623, 0.1589139162928075, 0.038669801718039354, 0.05823914440800915, 0.031179029699010208, 0.03985108091846645, 0.03386706579684329, 0.05763262730230101, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017944696340432942, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06114955044088677, 0.06840503242533857, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06986080926452976, 0.060915877561060094, 0.12754790273435246, 0.1019353915026896, 0.10281775224528589, 0.06906887936676553, 0.04237174374752295, 0.053936809511723194, 0.09551643924129505, 0.07517757612977793, 0.1109024799215601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03160015007664574, 0.03639191799979136, 0.02990021003060339, 0.03961757438367908, 0.02720680190479352, 0.025575167549747868, 0.14039504441585793, 0.1503972832474736, 0.1386596385176313, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0004347417934433828, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.0338937361141578, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02149201226150299, 0.024483082906095355, 0.019575860637573772, 0.0654689760447621, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.009680917862953997, 0.010833938096958207, 0.009885441451964017, 0.008142232647572079, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "6a46b3b8-4f59-44d3-9b8f-84fe4d2997c9", "fitness": 0.03749015831042771, "name": "EnhancedHybridDEPSO_SA", "description": "Integrate a temperature-driven simulated annealing phase to dynamically escape local optima and enhance global search capabilities.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def simulated_annealing_step(self, func):\n        initial_temp = 1.0\n        final_temp = 0.001\n        alpha = 0.99\n        temperature = initial_temp\n        while temperature > final_temp and self.f_evals < self.budget:\n            for i in range(self.population_size):\n                new_position = self.population[i] + np.random.normal(0, temperature, self.dim)\n                new_position = np.clip(new_position, self.lb, self.ub)\n                new_fitness = self.evaluate(func, new_position)\n                delta_e = new_fitness - self.best_values[i]\n                if delta_e < 0 or np.random.rand() < np.exp(-delta_e / temperature):\n                    self.population[i] = new_position\n                    self.best_values[i] = new_fitness\n                    if new_fitness < self.global_best_value:\n                        self.global_best_value = new_fitness\n                        self.global_best_position = new_position\n            temperature *= alpha\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n            self.simulated_annealing_step(func)\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedHybridDEPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03749 with standard deviation 0.04478.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09618630416897633, 0.11296712201319992, 0.16846745919106243, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0339752610106866, 0.024151830633423965, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.028001223330120006, 0.05641121426080875, 0.056527594588592134, 0.07115867098241768, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03162910008866704, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.105004936412458, 0.16331147346710284, 0.1589697015440421, 0.020000000000000018, 0.020000000000000018, 0.03427984668762396, 0.12533999896449677, 0.0761710944844971, 0.08928404403262902, 0.14745365552639156, 0.14315923047024715, 0.14950092907102652, 0.08941108059227332, 0.08762888795306689, 0.07852173437266896, 0.12972325327446788, 0.11326869810633966, 0.1453875736776723, 0.10460142251785842, 0.020000000000000018, 0.10094068034480752, 0.1470103917218063, 0.08594565788988551, 0.07667167264800068, 0.07990527341430764, 0.05507864698739651, 0.04899349435066003, 0.1438526290318487, 0.17566749874339083, 0.15437560826162278, 0.05084708505323787, 0.05082436637965548, 0.04166953264828832, 0.040973046619842135, 0.025449604472236764, 0.0566003844660109, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.01169651592066201, 0.014639975409838968, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07058328607056907, 0.060540655942814436, 0.07499020785246069, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06765366626231806, 0.05395939349942802, 0.12770345904313274, 0.10120043627928244, 0.10281775224528589, 0.06563472068655118, 0.040922955091798774, 0.053936809511723194, 0.09402022429519774, 0.07466585773542689, 0.10510990114078889, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030080298920683757, 0.03609195945579402, 0.034992337612522406, 0.025283150412314215, 0.030308077150096535, 0.024640285494433645, 0.13796910449185784, 0.15148529013610157, 0.15680588372575455, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026712603163265958, 0.033000718567680165, 0.03085924459604039, 0.0, 0.0, 0.0, 0.032734389810516795, 0.03990405731293789, 0.038922240611508396, 0.08119586915647559, 0.08031454882192934, 0.07721812577895326, 0.021916754405542194, 0.024192448856156457, 0.018449874749746464, 0.06539910983083952, 0.060036789169991445, 0.06144009054183319, 0.0, 0.0, 0.0, 0.009900537232367834, 0.010660356541869587, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.1069634080863644, 0.0, 0.0, 0.0]}}
{"id": "27d90770-0136-4ceb-ba8f-9d70686cb545", "fitness": 0.039356150722828484, "name": "EnhancedHybridDEPSO", "description": "Fine-tune the inertia weight and incorporate a diversity boost mechanism to limit premature convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.6 + (0.4 * (1 - self.f_evals / self.budget))  # Adjusted adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03936 with standard deviation 0.05703.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09578328296215444, 0.14643580457221783, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02243486680198936, 0.02491873491313501, 0.020885858680094738, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06104108408709574, 0.06317157682731522, 0.5722926626652625, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12590452774867944, 0.16331147346710284, 0.1633601438073543, 0.020142884074786038, 0.020000000000000018, 0.020000000000000018, 0.08140317794571761, 0.07631833626532714, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.13565911262008, 0.08941108059227332, 0.0746853908076881, 0.08025511790815965, 0.11732927276896987, 0.1156601546592606, 0.1524981798283329, 0.12341037315284775, 0.020000000000000018, 0.11798923887353452, 0.1470103917218063, 0.10865349347948983, 0.08878829922766895, 0.11142153756299278, 0.04759661644149471, 0.05439489343168036, 0.16199235715422455, 0.15026315976571913, 0.1433353655273295, 0.04535669960967481, 0.04808621396731594, 0.02923195410241508, 0.03978103597982918, 0.033546161773012395, 0.05757848775456109, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.018347778021156946, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010007564308053496, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010577797725312532, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07458578840471874, 0.06080609136975401, 0.0667971301381185, 0.010000000000000009, 0.010000000000000009, 0.010826427985476283, 0.05974005788366399, 0.0652925772135039, 0.06148070566360064, 0.12523443707928839, 0.10204167379051088, 0.10281775224528589, 0.06961173179943358, 0.037656681676958126, 0.053936809511723194, 0.08844886770684457, 0.07366781389514176, 0.10281849262692755, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029907242538859458, 0.03594078087730079, 0.029425030727252333, 0.040350881646967984, 0.028665453304130728, 0.025267171054662474, 0.13170806805592106, 0.1503972832474736, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003768710646852025, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028410735001793253, 0.033000718567680165, 0.030354805779171934, 0.0, 0.0, 0.0, 0.03153719327947835, 0.0376147966047361, 0.038922240611508396, 0.08163647737835955, 0.08006541110436372, 0.07712499243641413, 0.022604112891041583, 0.024192448856156457, 0.0201137454642607, 0.06590090879389121, 0.06102519286489039, 0.06058280166632146, 0.0, 0.0, 0.0, 0.00967839282621652, 0.010857733152295768, 0.009885441451964017, 0.008138409242925748, 0.010184252273692906, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "152c6e01-d580-4ca4-b593-40df25977f8c", "fitness": 0.03916316413210308, "name": "EnhancedHybridDEPSO", "description": "Adjust the DE mutation factor for better performance at different budget stages.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0) * (1 - self.f_evals / self.budget)  # Adjusted mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03916 with standard deviation 0.05642.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.0959477999017102, 0.1456118605104334, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.024022449439227156, 0.021294640687923305, 0.021030700892772147, 0.020000000000000018, 0.020000000000000018, 0.060900964186097806, 0.06298046636800958, 0.5651865159977747, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.07627602014141943, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12885752778602422, 0.16558924009468, 0.16390561334158804, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07455901496064254, 0.0933490222736908, 0.05614053822921261, 0.14718951827932447, 0.13323277534341382, 0.12761106041122838, 0.09047750419989709, 0.07054518222431316, 0.06854301991442202, 0.11218196236781486, 0.12965706377382002, 0.14150710264975774, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.14921112185909324, 0.10884677519573505, 0.09003197973801846, 0.11142919496544634, 0.04776537695287686, 0.05425895136113923, 0.1438526290318487, 0.13270529778386986, 0.17786586603763643, 0.04272735367661573, 0.055387617074871165, 0.02738860709795743, 0.0399449175549208, 0.03394650440567448, 0.05769274498440069, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028275584565636058, 0.013593957936699597, 0.017956951866514137, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544900625934, 0.06121243561399181, 0.06803777864198324, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06272140010656135, 0.05536149691717274, 0.12754790290075657, 0.10107611980788078, 0.10281775224528589, 0.0690688810208816, 0.04133285221879446, 0.053936809511723194, 0.09551643924129505, 0.07239733356076217, 0.1111431334886045, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030020555592134346, 0.039020909733700204, 0.02964657415567329, 0.03961757438367908, 0.028966028491562046, 0.0254702338299313, 0.13424896415964493, 0.13198813091578288, 0.1397301031858632, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022755772502509597, 0.0004253167662155999, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029473545906491982, 0.033039565087322975, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03441695932730193, 0.03753213255583987, 0.03723581324486003, 0.08189680077626849, 0.08003114951368417, 0.07712499243641413, 0.022150471681403827, 0.024483082906095355, 0.019575860637573772, 0.06570365050191385, 0.061729589426607445, 0.061006563751159426, 0.0, 0.0, 0.0, 0.009680065528055781, 0.010833938096958207, 0.009961630632944307, 0.008108042045365416, 0.010157896730316307, 0.007431247018395926, 0.1112398058338967, 0.1304161139054778, 0.10495413656666708, 0.0, 0.0, 0.0]}}
{"id": "43b2ac10-729f-4626-82c5-8722d3d68dbc", "fitness": 0.036773653183347646, "name": "EnhancedHybridDEPSO", "description": "Introduce dynamic local search via adaptive perturbation in DE and crowding-based reinitialization to improve exploration and exploitation balance in EnhancedHybridDEPSO.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n\n            # Local adaptive perturbation for exploration\n            perturbation_strength = 0.1 * (1 - self.f_evals / self.budget)\n            trial += np.random.uniform(-perturbation_strength, perturbation_strength, self.dim)\n\n            trial = np.clip(trial, self.lb, self.ub)\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        # Crowding-based reinitialization\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            crowded_indices = np.argsort(distances)[:self.population_size // 2]\n            self.population[crowded_indices] = np.random.uniform(self.lb, self.ub, (len(crowded_indices), self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03677 with standard deviation 0.04313.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09693273309859218, 0.11864198129489212, 0.13760722337502795, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03365076560272273, 0.02572948398347852, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09516500279257822, 0.10537777933539783, 0.077719812908699, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.033650936826951416, 0.08594148016760361, 0.08558145293704345, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13216282663384016, 0.11565843530266362, 0.1507908084454357, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07764163177900796, 0.09191577411580054, 0.08252147425344336, 0.1545078035493488, 0.16149768167717016, 0.14349200064086576, 0.09642417539281978, 0.08345523813409128, 0.06236038204428784, 0.13178822486316466, 0.10505711444883215, 0.125814881751804, 0.020000000000000018, 0.020000000000000018, 0.12491745272757782, 0.08759182817142175, 0.10731502756758116, 0.07667167264800068, 0.06527120746322768, 0.133510711017919, 0.05380410847000894, 0.1438526290318487, 0.1431368361677603, 0.14110192026873247, 0.05864633520238782, 0.02810546785900958, 0.02657375009670604, 0.038448949572831626, 0.034242121413094684, 0.059932113143640775, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0366723076753821, 0.011049536319146736, 0.01844775738962534, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06653781034708484, 0.07599906857595418, 0.07940073888445942, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05637380171696771, 0.06609783205430331, 0.05848773044419742, 0.12070099035217308, 0.10166248626936125, 0.10358477872816296, 0.05778213884155481, 0.050414479034873616, 0.053936809511723194, 0.08098779121631183, 0.08132464560970365, 0.09519301633105737, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025722669141567178, 0.03169614213825245, 0.02921265831477493, 0.02870185264115488, 0.027789463266941872, 0.02816854940657787, 0.13141309820135194, 0.1403260713440555, 0.1400988856236901, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.001366646708647501, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0172357672755261e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02768261814635309, 0.03235198333637712, 0.03227345480588251, 0.0, 0.0, 0.0, 0.03316366028485207, 0.04473065127672515, 0.039841212490762334, 0.08104407591398921, 0.08157008682744982, 0.07993973209996308, 0.020976423993371518, 0.026653938238306307, 0.0214776889563012, 0.06592454788926294, 0.06169865691512266, 0.06311442756797869, 0.0, 0.0, 0.0, 0.010640844638845515, 0.010942208012298837, 0.009664585403655557, 0.007513626489383252, 0.010235758183482435, 0.007324619274672317, 0.1212971197144016, 0.1304161139054778, 0.1092618886141341, 0.0, 0.0, 0.0]}}
{"id": "2f7a1aef-92ef-4b7a-b918-58040ea00108", "fitness": 0.03746440455959679, "name": "EnhancedHybridDEPSO", "description": "Enhance the dynamic control of velocity factors and introduce local search to improve convergence in hybrid DEPSO.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.7 * (1 - np.tanh(crowding_distance))  # Adjusted factor\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def local_search(self, func):  # New local search strategy\n        indices = np.random.choice(self.population_size, 2, replace=False)\n        for i in indices:\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate = self.population[i] + perturbation\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.evaluate(func, candidate)\n            if candidate_fitness < self.best_values[i]:\n                self.population[i] = candidate\n                self.best_values[i] = candidate_fitness\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n            self.local_search(func)  # Call local search\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03746 with standard deviation 0.04434.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.1003164219708842, 0.09561524975805669, 0.14737255779349523, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027096078802129275, 0.02208134686202301, 0.023458800782728995, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.07586879897707854, 0.055757449626074984, 0.1560135486774854, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.041798358843185945, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.105004936412458, 0.16331147346710284, 0.1625981485778023, 0.020000000000000018, 0.020000000000000018, 0.02547903151281672, 0.07932796414964427, 0.08889250113931213, 0.076127385233977, 0.14745365552639156, 0.14315923047024715, 0.13842122005957824, 0.08941108059227332, 0.05977570937856225, 0.08582680605266835, 0.11732927276896987, 0.1068002420695362, 0.1595778030393753, 0.11963928212086383, 0.020000000000000018, 0.12447380099805949, 0.1470103917218063, 0.1076467857291038, 0.07667167264800068, 0.11026217733138077, 0.0476879644420416, 0.054168536700558434, 0.1438526290318487, 0.1349619864309648, 0.13871575858091856, 0.038669801718039354, 0.054251968678825424, 0.02657375009670604, 0.04027511069297307, 0.03656469091458603, 0.05719650961597467, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02984241762817219, 0.019819461918415993, 0.017979226744628263, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014129712701023922, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07303503161358915, 0.06250856338488231, 0.06759434758648708, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05813733429633894, 0.06991754872069789, 0.055571100935337125, 0.12781113671260957, 0.09639212578689393, 0.10298646621067875, 0.07008343135025885, 0.039139618205399795, 0.053936809511723194, 0.09492458984209662, 0.07047856935863162, 0.10565170565900739, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02568233494906269, 0.0356137527953152, 0.030024813064024602, 0.0391185125816339, 0.027010167262963347, 0.024856005080948873, 0.13428308002329858, 0.1503972832474736, 0.13843853929776673, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.00034597897429189395, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027882065814573198, 0.033000718567680165, 0.03138965598097099, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03778005696044351, 0.038922240611508396, 0.08163701903107323, 0.07992585238057048, 0.07712499243641413, 0.02180155871175049, 0.024400991235188352, 0.01941500551080433, 0.06556675115396393, 0.06128304823228403, 0.0629671240904277, 0.0, 0.0, 0.0, 0.009668480421112124, 0.010808559135608409, 0.009885441451964017, 0.008136655007303983, 0.010146674391657395, 0.0075206816712029, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "b56bbb72-df53-4a77-8306-fcc4adcdc747", "fitness": 0.03920457892369849, "name": "EnhancedHybridDEPSO", "description": "Improve the dynamic mutation factor F in the differential evolution step for better adaptability.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.4 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03920 with standard deviation 0.05548.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09633057924645438, 0.1444436158243172, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023749835818957954, 0.021142865313809933, 0.021156957189759518, 0.020000000000000018, 0.021140503094770557, 0.0609035226336051, 0.06255729268773591, 0.5439862911142023, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.1034851499394207, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11624532645507235, 0.15137631193701895, 0.16390557263277972, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.10352668674162546, 0.06656637273959409, 0.0722589525832007, 0.1548704557817535, 0.13323277534341382, 0.1552213240398299, 0.08283382896205826, 0.06066789845243903, 0.07299629306784994, 0.11350982596052872, 0.1269740717713026, 0.1415017109338098, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.12930854304511452, 0.1089268363673469, 0.0822679053626233, 0.11190324808152952, 0.04776537654168622, 0.0680620700361072, 0.1464407715221705, 0.15330944566914328, 0.14307827659154038, 0.039709652904235226, 0.05562376279263315, 0.02657375009670604, 0.03969648926736935, 0.033568884212053285, 0.056942590013801864, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027397548611822864, 0.013522172056331105, 0.017960128463407332, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0737954490277416, 0.06121668950584924, 0.08362168051514618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.054704342368444125, 0.06837267481388609, 0.05395939349942802, 0.1275479024400873, 0.10058766498190352, 0.10281775224528589, 0.06906887670718997, 0.03769695605810186, 0.053936809511723194, 0.09551643924129505, 0.07239621747334535, 0.11139945238660853, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030138632199668947, 0.03510240019606581, 0.0334769407568154, 0.03961987716659232, 0.028426226813743516, 0.02544962410975471, 0.13336588564014873, 0.13443327520908865, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022185554076290526, 0.00024302565816525235, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.032883807183402114, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03674966484036657, 0.03753213255583987, 0.03713260231967486, 0.08189680077626971, 0.08007552576084909, 0.07712499243641413, 0.02245609060689102, 0.024483082906095355, 0.019575860637573772, 0.06599157913751663, 0.061729589426607445, 0.06036301339767869, 0.0, 0.0, 0.0, 0.009679904111020488, 0.010833938096958207, 0.009850599370640367, 0.008156731070173784, 0.010157896730316307, 0.007417577165427902, 0.11315590447836543, 0.1304161139054778, 0.10890368855599464, 0.0, 0.0, 0.0]}}
{"id": "648c1077-f86d-4010-94ba-cdde9ff3b0f3", "fitness": 0.03914382277940125, "name": "EnhancedHybridDEPSO", "description": "Adjust the scaling factor for velocity diversification to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.5  # Adjusted scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03914 with standard deviation 0.05668.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10589488258673119, 0.1364604450065291, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02767923955881013, 0.03282732886895934, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.07028063241254612, 0.08748215293702633, 0.5778451395708717, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.05964744147460732, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12708689217842617, 0.16331147346710284, 0.1468816532618098, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08694394337820521, 0.08341996990155565, 0.08113970244834912, 0.14745365552639156, 0.14315923047024715, 0.140777565775568, 0.08941108059227332, 0.05425189282683984, 0.09453907269923034, 0.11732927276896987, 0.11319473082481779, 0.13669618348403734, 0.020000000000000018, 0.10861805599759211, 0.11602924611974952, 0.1470103917218063, 0.09977089897214764, 0.08186947841519865, 0.06527120746322768, 0.04616535580723691, 0.0550607790886275, 0.14856727658367264, 0.15496116577346397, 0.13480361848198585, 0.05196329696809854, 0.03028116812198478, 0.02657375009670604, 0.03740518431544826, 0.03446225008128634, 0.05178124457717548, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013654317409434347, 0.021049626080115624, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07138989190585887, 0.058022140720682125, 0.06647190673463843, 0.010000000000000009, 0.010000000000000009, 0.011875073949707993, 0.06125621208003906, 0.0652925772135039, 0.05494132855982903, 0.1247468910855658, 0.10480041190629918, 0.10281775224528589, 0.0737655327980059, 0.039573152285321656, 0.05452324229879513, 0.08847720469486609, 0.07074300834936775, 0.10417749636199103, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028123386089645708, 0.0347019700548975, 0.03187904918163609, 0.0369789920422231, 0.02315836134579774, 0.024768093546048697, 0.1353608931372109, 0.1503972832474736, 0.13394794627018047, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02873114900540874, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03298043010285823, 0.037543568044758224, 0.038922240611508396, 0.08158129245825418, 0.07979931039860289, 0.07712499243641413, 0.02237407441968997, 0.024192448856156457, 0.018482390482473354, 0.06562881416836663, 0.061115856391971146, 0.06058280166632146, 0.0, 0.0, 0.0, 0.00967230606319125, 0.011042766531781711, 0.009885441451964017, 0.008140036658503491, 0.010051284513262426, 0.00743479250564183, 0.11782360885015042, 0.1304161139054778, 0.10660783249433547, 0.0, 0.0, 0.0]}}
{"id": "909215e5-1c98-4521-89c4-516e8b631feb", "fitness": 0.037908270216273465, "name": "EnhancedHybridDEPSO", "description": "Enhance the hybrid DE-PSO by introducing a stochastic adaptive inertia weight and dynamic group velocity influence based on global convergence trends for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        global_convergence = np.std(self.best_values) / (1e-9 + np.abs(self.global_best_value))\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget)) * np.random.rand()  # Stochastic adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2 * (1 + global_convergence)  # Dynamic scaling factor based on convergence\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03791 with standard deviation 0.05813.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09234770947246917, 0.07602287599886492, 0.1542639105994862, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02125138733530163, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.08133654633381171, 0.09019308073500609, 0.6212720687330973, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02119521874735708, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1084270571948005, 0.16331147346710284, 0.13755242186423555, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09140358047147001, 0.08119004441619582, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.13090238666894094, 0.08941108059227332, 0.05425189282683984, 0.05610455226583122, 0.12856174472157333, 0.11320809609735971, 0.13537612286962852, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1470103917218063, 0.1032441198762819, 0.08437522936741115, 0.09924637309440276, 0.05061440195976363, 0.06187416046722205, 0.1438526290318487, 0.1349619864309648, 0.1622657147123735, 0.0427316589581892, 0.032206304063429614, 0.026743502618265413, 0.02777611841037908, 0.025449604472236764, 0.048703593308591864, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03785107359948536, 0.014235446667954066, 0.01677930878165368, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07069509175021993, 0.05737862454822562, 0.0661565173024159, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0618196043938698, 0.0652925772135039, 0.05395939349942802, 0.11880297544273843, 0.09356267114715211, 0.10281775224528589, 0.05756835603815702, 0.03518359929680204, 0.053936809511723194, 0.09447266125549458, 0.07628044362817388, 0.0924570269563969, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025701417916742852, 0.0347019700548975, 0.03553101919169821, 0.03926584493343044, 0.023739446895529093, 0.024640285494433645, 0.1433458875193565, 0.1503972832474736, 0.13413309741234092, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026699896500181675, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03210887576921351, 0.03753213255583987, 0.038922240611508396, 0.08078779892194698, 0.07969733312619143, 0.07747933552758324, 0.020957452754594263, 0.024192448856156457, 0.018449874749746464, 0.06501016208547095, 0.06045485562491526, 0.06101876001388673, 0.0, 0.0, 0.0, 0.009745345428367247, 0.011017627618285397, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.007531782335703507, 0.11694244813991073, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "47521bbb-9f04-494f-b351-8638c135d0bf", "fitness": 0.03626919274917346, "name": "AdaptiveHybridDEPSO", "description": "Introduce adaptive inertia and mutation factors based on search space exploration metrics to enhance convergence speed and solution diversity.", "code": "import numpy as np\n\nclass AdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            diversity_metric = np.std(self.population) / (self.ub - self.lb)\n            F = F_base + 0.2 * (1 - diversity_metric)  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + 0.6 * (1 - np.std(self.best_values) / (self.ub - self.lb))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 40, "feedback": "The algorithm AdaptiveHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03627 with standard deviation 0.04323.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.10011828726676608, 0.09013356084472068, 0.12507055411882073, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021145322514837694, 0.020000000000000018, 0.020000000000000018, 0.08146049670028022, 0.04712232432877672, 0.07791964263399964, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10832180052346274, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12723846322279475, 0.16020923906242635, 0.133933078569751, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09876027846277535, 0.09510514513656365, 0.09348979034395799, 0.14899197607018133, 0.14781222365518998, 0.15680115007225537, 0.09023674082777067, 0.06314681700493319, 0.0890053478833025, 0.1262660777204292, 0.12429390539178198, 0.14079686422968563, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14101764392191574, 0.09050764372713271, 0.08278320002930573, 0.08211326667500318, 0.058880666255202274, 0.06099330566464489, 0.15606561428022292, 0.13961296246002464, 0.14638030279651648, 0.05429852201926588, 0.03552928967128477, 0.04158189408181778, 0.03862162802657887, 0.03947263305453186, 0.04830716167692062, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02822479695732194, 0.0188143548876748, 0.010546238633675986, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0619196900739617, 0.06703123679588174, 0.07730344642882425, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05553762645007421, 0.06775955250299948, 0.05395939349942802, 0.12097451673562465, 0.10285224932077885, 0.10522590444607227, 0.05756835603815702, 0.03518359929680204, 0.053936809511723194, 0.09071124182963575, 0.09079586700296882, 0.09977849122081006, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030004175376130315, 0.03657833255892984, 0.029826237015025847, 0.03915739269051277, 0.028983695366448625, 0.025427113111191946, 0.1458278740110086, 0.13708226213895702, 0.1355057339849941, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022378946593653026, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02804028124962532, 0.03298566891747934, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03366829543313554, 0.037676568173746094, 0.05224826716920605, 0.08103965728196327, 0.07965841969894782, 0.07776606398496155, 0.021089675629349602, 0.02504956678738479, 0.018449874749746464, 0.06663751276220875, 0.06305807078560943, 0.06044381425351475, 0.0, 0.0, 0.0, 0.009679408315687144, 0.010901574025945049, 0.009870488785802212, 0.008146314738902927, 0.010257598786276967, 0.0074330472026978844, 0.11457914129532942, 0.1369495999478465, 0.12038576844714166, 0.0, 0.0, 0.0]}}
{"id": "a7865037-ea4c-4344-943b-cff9aba53920", "fitness": 0.0391952456656497, "name": "EnhancedDynamicHybridDEPSO", "description": "Dynamic inertia weight adjustment and adaptive scaling factor for enhanced convergence in hybrid DE-PSO.", "code": "import numpy as np\n\nclass EnhancedDynamicHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.9 * (1 - self.f_evals / self.budget) + 0.1  # More dynamic inertia weight adjustment\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2 + 0.8 * (1 - np.tanh(np.std(self.best_values)))  # Adaptive scaling factor\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedDynamicHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03920 with standard deviation 0.05567.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09229256388706641, 0.09640219001210482, 0.1435407867472963, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02057901441543819, 0.021368089316149974, 0.024782056848984158, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06134911325130188, 0.06197024815235774, 0.5394774236133497, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13706957066111325, 0.16331147346710284, 0.16606352444768935, 0.022289502288592944, 0.020000000000000018, 0.020000000000000018, 0.08437056523496533, 0.07324227683377416, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.1410984020644932, 0.08941108059227332, 0.06520456635179206, 0.07773072481104781, 0.14500074900314897, 0.1264344412402575, 0.134361422786489, 0.11830079057915754, 0.020000000000000018, 0.11547650483860139, 0.1470103917218063, 0.10923964380208329, 0.0883429830844179, 0.111756741657415, 0.05380824084576419, 0.05373473921955052, 0.1509879733984687, 0.1429087553348336, 0.13158562844050148, 0.04484872631787584, 0.04328367258201948, 0.02657375009670604, 0.04005007506213987, 0.035234681276447244, 0.057191678016955794, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013561636565757929, 0.017280472351230536, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013665565327632745, 0.010086720457440523, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07297172436121802, 0.06277274193237492, 0.0661565173024159, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05994974658555852, 0.07057059545780486, 0.05395939349942802, 0.12527740617688565, 0.09976986414017053, 0.10281775224528589, 0.06556859828071082, 0.035253975766038836, 0.053936809511723194, 0.09674789100678338, 0.0710672898832152, 0.09745345332414712, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029996004844581092, 0.03672286363186261, 0.0296629514531912, 0.03898604792204563, 0.027326499208574995, 0.026280369491588518, 0.14151640351154693, 0.1503972832474736, 0.13536140975564692, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.00034753367950235425, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02820352207880983, 0.033000718567680165, 0.030307109423428735, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.08186454770442386, 0.07965841969894782, 0.07772515684992798, 0.02216164406076704, 0.024192448856156457, 0.018908930199762475, 0.06582428576324872, 0.06290991954285641, 0.06060490299892496, 0.0, 0.0, 0.0, 0.009674714886285019, 0.010745566720904542, 0.009885441451964017, 0.00816418097615812, 0.010051284513262426, 0.00743851602439749, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "a83ffbc3-1cca-4179-bb24-8964606df44e", "fitness": 0.039528804134739526, "name": "EnhancedHybridDEPSO", "description": "Fine-tune the crowding distance's influence on velocity for improved exploration during early stages.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance (fine-tuned)\n            velocity_control_factor = 1 + 0.6 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03953 with standard deviation 0.05655.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09604146443891148, 0.14558756898088332, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02358024667253711, 0.0237318205722008, 0.020926950750011053, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090368572387295, 0.06291677795345374, 0.5651866126733204, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0410146488797547, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12804167092192376, 0.16331147346710284, 0.1637253907052263, 0.02848137640254711, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09564535336284052, 0.0990881175409859, 0.14745365552639156, 0.14315923047024715, 0.1359694673017563, 0.08941108059227332, 0.05996512075972571, 0.08107151924618561, 0.11732927276896987, 0.11370695984368284, 0.1464426338402497, 0.12236912141934897, 0.020000000000000018, 0.11692627202380701, 0.1470103917218063, 0.10885005622667365, 0.08883847074337525, 0.11151008946717356, 0.04774844612159679, 0.054279811655883026, 0.1438526290318487, 0.1349619864309648, 0.13007523940734245, 0.038669801718039354, 0.05521660708953502, 0.032107541289491004, 0.03985108087675415, 0.03386706585713395, 0.057536677208242515, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017959755180541603, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07380599291808043, 0.06120742874741736, 0.06743014062139663, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830575460865173, 0.07008253738939374, 0.06078663576883758, 0.1275479015717632, 0.1019535745343505, 0.10281775224528589, 0.0690688862233848, 0.04074487651070147, 0.053936809511723194, 0.10264997584952795, 0.07470846947380305, 0.10856008062569233, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934468388502, 0.03628558508083812, 0.02964921208964355, 0.03961757452907677, 0.02876828024811684, 0.02548201204172984, 0.13329412556547993, 0.1503972832474736, 0.1386562306998771, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461015011, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02838452119252377, 0.033000718567680165, 0.030384406427204635, 0.0, 0.0, 0.0, 0.03153719327947835, 0.037881627553545516, 0.038922240611508396, 0.0818968007759564, 0.08003198965096392, 0.07712499243641413, 0.021974541683744686, 0.024483760777447294, 0.01957586063761152, 0.0661233393088142, 0.0617295894227351, 0.060940262752316565, 0.0, 0.0, 0.0, 0.009680083924161087, 0.010833938096958207, 0.009885441451964017, 0.008142098658185715, 0.010157896730302873, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "a5f8725e-79d8-4700-bd5e-f9bb252f72d3", "fitness": 0.03649760418535651, "name": "AdaptiveHybridDEPSO", "description": "Introduce adaptive learning rates in DE/PSO hybrids and integrate a stochastic reinitialization strategy based on stagnation metrics to enhance convergence and escape local optima.", "code": "import numpy as np\n\nclass AdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.stagnation_counter = 0\n        self.prev_global_best_value = np.inf\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n                self.stagnation_counter = 0\n            else:\n                self.stagnation_counter += 1\n\n    def differential_evolution_step(self, func):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            velocity_control_factor = 1 + 0.5 * np.random.rand()  # Stochastic velocity control\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.velocities[i] *= velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        # Stochastic reinitialization based on stagnation\n        if self.stagnation_counter > self.population_size:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n            self.stagnation_counter = 0\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03650 with standard deviation 0.04230.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.0946291117618262, 0.08153741848430196, 0.1635459947041994, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022447583875348842, 0.03130235681471505, 0.027951774976168187, 0.020000000000000018, 0.020000000000000018, 0.022204679039075748, 0.08067326581320589, 0.06534685231427761, 0.10586807163513412, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08879890831949921, 0.08594148016760361, 0.1058602645602551, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02338337600454965, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10037667460413147, 0.14671662014967357, 0.15182162724428172, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07401620070258541, 0.09727194053189181, 0.0727374728711484, 0.12990506644848054, 0.1350642650033833, 0.11688461684857299, 0.0765720746827876, 0.08572803745497937, 0.07903817274528468, 0.11653378081231092, 0.11833985433885341, 0.12589240065247065, 0.020000000000000018, 0.020000000000000018, 0.1181904210594883, 0.08343677235934466, 0.08212708095875254, 0.08676109560392276, 0.07501056540474482, 0.07006451925939472, 0.09057074914644714, 0.150419631478658, 0.14097124981789988, 0.15495411034611717, 0.04554731564114689, 0.020000000000000018, 0.0329700034099244, 0.037231174728338035, 0.03186021175291143, 0.046063043465832676, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014469984643100453, 0.013384545154543126, 0.019537645470623866, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015011477176944954, 0.01010702461140156, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07939591051312833, 0.05926623306673706, 0.0867704640236926, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06265877459675062, 0.06147825531143891, 0.0609427749537077, 0.12120315593036268, 0.10190038345205255, 0.10663449252649837, 0.061860116396805, 0.04109057138887362, 0.053936809511723194, 0.09169047931370955, 0.08476058168973821, 0.09659476426750824, 0.03877300790732108, 0.010000000000000009, 0.010000000000000009, 0.02585048369755638, 0.03602179308894082, 0.030181093626548305, 0.029513183728945958, 0.025979398855332958, 0.02633115527834784, 0.13451567825395694, 0.13775755298641035, 0.1350321741305287, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0010705096734675568, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02984397406245265, 0.030317961759307233, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03287986065980353, 0.042920549562680876, 0.034215952184717624, 0.08080727318924696, 0.08190642883962551, 0.08335528909812207, 0.025564279650485244, 0.024739358393790045, 0.023378008981555065, 0.06804384510817807, 0.05910620724300575, 0.06127639341158331, 0.0, 0.0, 0.0, 0.010825807582392155, 0.010676172392269034, 0.00991632911292073, 0.007424845994276397, 0.01009879826558191, 0.007573143833981999, 0.12183327570977165, 0.1304161139054778, 0.1201837001146181, 0.0, 0.0, 0.0]}}
{"id": "bf54f4e2-2dfc-40e6-81c4-6347fab76a46", "fitness": 0.03900578085267023, "name": "EnhancedHybridDEPSO", "description": "Enhance the dynamic control factor by modifying the scaling factor to improve exploitation during later stages of optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2 - 0.2 * (self.f_evals / self.budget)  # Adjusted scaling factor for late-stage exploitation\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03901 with standard deviation 0.05525.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09396958993659044, 0.14979600078443012, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027129722622390218, 0.020000000000000018, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06567026391150821, 0.0625272847468894, 0.5393286720713121, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12587455867734776, 0.16331147346710284, 0.16361131697345144, 0.022482588576066553, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.07324227683377416, 0.07953831870103234, 0.14745365552639156, 0.14315923047024715, 0.1338304070002354, 0.08941108059227332, 0.05425189282683984, 0.08283039057940977, 0.11732927276896987, 0.11304701165028153, 0.1283833890620224, 0.12175858462873546, 0.020000000000000018, 0.1285270764327615, 0.1470103917218063, 0.10911872791774624, 0.08956020135340281, 0.09959615099145025, 0.05170313820893302, 0.05409087787938671, 0.14592292402864526, 0.13713583678122232, 0.14986903754357728, 0.04314227915539004, 0.03262518928138658, 0.0421215016422507, 0.03994253543308812, 0.03338322668949789, 0.05829104108112926, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013594238922550184, 0.016856404914180834, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.019826426242238404, 0.010263664650468352, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07496811022967076, 0.06191770310973477, 0.06675659869551953, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06641399204981768, 0.0578323263861098, 0.12496509077163709, 0.10215489921977505, 0.10281775224528589, 0.06259188732866727, 0.04048326271862435, 0.053936809511723194, 0.09981123108600243, 0.07265175679439662, 0.10884550936925663, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03073397153561641, 0.03770743200555515, 0.02952411089364526, 0.03936653735664419, 0.02914645993681253, 0.0255689172618756, 0.1327344208127773, 0.1503972832474736, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0004037589102813266, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028405446670146994, 0.033128615311585174, 0.030925866423794912, 0.0, 0.0, 0.0, 0.03153719327947835, 0.037570256002827485, 0.038922240611508396, 0.08103798046147392, 0.07992706429936647, 0.07712499243641413, 0.02110352324422815, 0.02436971312586267, 0.019514725505998864, 0.06578244974385783, 0.06415274811613914, 0.06124415949870199, 0.0, 0.0, 0.0, 0.009853880306389007, 0.01069775002654949, 0.009885441451964017, 0.008136655007303983, 0.010263230067803497, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10681861806412396, 0.0, 0.0, 0.0]}}
{"id": "8a2eefbd-9014-48f5-a8dd-bbe413e9afee", "fitness": 0.03873196124660754, "name": "RefinedHybridDEPSO", "description": "Introduce adaptive crossover rates and inertia scaling based on convergence speed to refine exploration-exploitation balance in EnhancedHybridDEPSO.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = 0.5 + 0.3 * (np.std(self.best_values) / np.std(self.population))  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.6 + 0.4 * (1 - np.std(self.best_values) / np.std(self.population))\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        convergence_speed = np.std(self.best_values) / (np.max(self.best_values) - np.min(self.best_values) + 1e-9)\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * convergence_speed)  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 45, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03873 with standard deviation 0.05575.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09377596329920435, 0.11406364316944317, 0.16285606522739304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022506425755737358, 0.02113435108318218, 0.020000000000000018, 0.020000000000000018, 0.052120010981074105, 0.020000000000000018, 0.0839131785382915, 0.06181780840478135, 0.5682283366804208, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04275745830262623, 0.08594148016760361, 0.08528733559360546, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08135105247909113, 0.11171135413075495, 0.16986682753459603, 0.02702356561969277, 0.020000000000000018, 0.020000000000000018, 0.092242938089514, 0.06391109031206388, 0.07381197857393207, 0.13168694597556874, 0.14074915510779396, 0.15575265922538106, 0.06703405101216786, 0.06979498043122656, 0.08378695910587419, 0.11936924266656546, 0.10187070763945139, 0.14526645805595417, 0.12788756902125298, 0.020000000000000018, 0.12527662646008086, 0.08343677235934466, 0.10796778331116219, 0.07828803947677554, 0.09661201044379775, 0.0557855649381338, 0.05385951286276647, 0.1504913488074341, 0.14561436543405537, 0.14636868023290928, 0.06218944022819595, 0.031812984303113634, 0.02657375009670604, 0.03929707941572547, 0.03332555429222894, 0.05550585965936772, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029749041363693496, 0.013775010533330967, 0.01744424838786629, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010287340065934014, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07350231873404467, 0.06380501800150018, 0.08222456158592817, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05395939349942802, 0.12378622590030885, 0.10076851280143262, 0.10281775224528589, 0.06817435009167983, 0.05327726198280214, 0.053936809511723194, 0.09295727930807174, 0.06957745963744544, 0.10151166356901997, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026347715110476178, 0.031215106251938685, 0.030953305197101266, 0.039001850437567875, 0.027433599255681895, 0.025671217657260104, 0.13310938243829706, 0.13123409970527322, 0.13467331436582075, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0009237496722539484, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02835690384022327, 0.031151822307169286, 0.030401355295836208, 0.0, 0.0, 0.0, 0.030499991321740527, 0.03782515685414867, 0.03617507688032162, 0.0822418967092311, 0.07998819563914128, 0.07722654658079331, 0.021018399909269014, 0.024367284338665196, 0.01907040466536547, 0.06528369268185119, 0.06169026348549478, 0.060408896694100656, 0.0, 0.0, 0.0, 0.010198008713305562, 0.010815250319223368, 0.009433151669329232, 0.008060145508728578, 0.010126712110389069, 0.007391437476414242, 0.1112398058338967, 0.135174108441106, 0.10983836169280536, 0.0, 0.0, 0.0]}}
{"id": "c325b23f-038f-4851-8c1e-9bf2ce0ee963", "fitness": 0.03642690113782629, "name": "RefinedHybridDEPSO", "description": "Introduce adaptive neighborhood-based mutation and velocity perturbation to enhance convergence precision in DEPSO.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            # Select neighborhood-based indices, ensuring diversity\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.linalg.norm(self.global_best_position - self.population[i]) / 5.0)  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            velocity_perturbation = 0.1 * np.random.randn(self.dim)  # Small perturbation to velocity\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social + velocity_perturbation) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 46, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03643 with standard deviation 0.04294.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09984874108919528, 0.10975029255009905, 0.14992347500787162, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024142156404481363, 0.024476979679984745, 0.020000000000000018, 0.02156050798698428, 0.020000000000000018, 0.020000000000000018, 0.08170693215980629, 0.06128330141952176, 0.08159722391264224, 0.020000000000000018, 0.020000000000000018, 0.030659059325967908, 0.029316755686768503, 0.08846735893327173, 0.06830436629521475, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10239329273350906, 0.1385471055273756, 0.16049241712962015, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09648368077113578, 0.080363464729581, 0.0749605212666381, 0.15281759998962852, 0.14675363379892759, 0.12219209681477361, 0.0836000450204133, 0.07207443594857099, 0.0702248813102152, 0.13175026300369774, 0.1234541115997202, 0.13985071671833083, 0.060958173030145946, 0.020000000000000018, 0.14465489000578502, 0.11913459727131137, 0.07139677850619253, 0.11302201220163566, 0.07442110021111825, 0.0473944471829284, 0.054848979317939084, 0.15327394880665768, 0.1555883073597495, 0.13531576492970399, 0.04310077081959318, 0.020249435024531248, 0.03655154139370409, 0.040382098499847086, 0.041198186111169655, 0.052501178809366666, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025801682235802703, 0.010970163686227719, 0.01861516696111054, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0706725981957732, 0.06844427777398276, 0.07672777412470522, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06667071380927891, 0.06196996482442163, 0.054491669858025116, 0.12484265986541376, 0.10903096402266665, 0.10281775224528589, 0.06039824671978267, 0.041293649663233456, 0.053936809511723194, 0.08553880318992302, 0.0758396926805659, 0.09301485424675004, 0.02014804560938599, 0.010000000000000009, 0.010000000000000009, 0.026217177696601812, 0.03411948535966536, 0.028174451647013377, 0.039965460578841205, 0.02351001048505541, 0.024659773202780122, 0.15057686372521628, 0.13276184037504235, 0.13482501683784787, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.000486052747057264, 0.0, 0.00015341905008481316, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.031164381194075053, 0.03258523392050239, 0.029890571760543994, 0.0, 0.0, 0.0, 0.043355588622515207, 0.03791328741085309, 0.034215952184717624, 0.08093133358663085, 0.08058596394955164, 0.07712499243641413, 0.02190765122933247, 0.02589077660793382, 0.01860382966261298, 0.06731326052232167, 0.05939708734433713, 0.0616854009802672, 0.0, 0.0, 0.0, 0.009834587938592376, 0.010732475558397514, 0.009788206811005673, 0.007720026259584234, 0.010205690762829067, 0.007506700444665171, 0.11154951493225351, 0.1304161139054778, 0.11022935052047234, 0.0, 0.0, 0.0]}}
{"id": "501555f1-1d71-42ef-a020-f0c16a460e59", "fitness": 0.03864364570200602, "name": "EnhancedHybridDEPSO", "description": "Introduce adaptive crossover rate modulation in the differential evolution step based on fitness variance to enhance performance diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - np.std(self.best_values) / 10)  # Adaptive crossover rate modulation\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03864 with standard deviation 0.05552.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09546707026936119, 0.16114565946868098, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03617459421211722, 0.02379704818472983, 0.022359531670943178, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0839131785382915, 0.06138248592385931, 0.5696568957595172, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03969430159058507, 0.08594148016760361, 0.08830397158990422, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09291656203430332, 0.1217993308667693, 0.16370914247816015, 0.029916238289118602, 0.021934127322357, 0.020000000000000018, 0.07131407602902162, 0.07564616099862942, 0.08067651353034055, 0.13144395272392262, 0.13323277534341382, 0.1610063287877711, 0.06461156088363507, 0.07750519095845532, 0.07299629306783084, 0.11205586464406281, 0.10711548163076567, 0.14149722781526097, 0.12236911737207379, 0.020000000000000018, 0.1234271746358151, 0.08416222251238892, 0.10884677519573505, 0.07667167264800068, 0.0826768684710879, 0.04758143026794981, 0.05429144347018988, 0.1438526290318487, 0.14908211231918567, 0.12777119275732818, 0.04547266681297568, 0.05473954280309612, 0.028755745693840762, 0.03905384234856124, 0.03180056405119458, 0.05614502664455434, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027029254495522514, 0.013796004826919006, 0.020111183032116897, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379537543741588, 0.061618759071742524, 0.08362168051514618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06200623693445795, 0.05395939349942802, 0.12754790514744752, 0.10073029708355907, 0.10281775224528589, 0.06906890117749598, 0.04873480961731791, 0.053936809511723194, 0.09551669048237843, 0.07218232297023885, 0.11139946211242768, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03134585824719205, 0.03501857933579933, 0.029011354968416336, 0.039621363033242596, 0.028401396678400914, 0.02663505742822192, 0.1344057526156952, 0.14582960663430422, 0.13534539162411585, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0009344351291611375, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326595, 0.03110960165714205, 0.03038440642721174, 0.0, 0.0, 0.0, 0.030499991321740527, 0.037885708277317076, 0.03510248230493607, 0.081896800775904, 0.08003114951368417, 0.07712499243641413, 0.021264918173327096, 0.024483082906095355, 0.019575860637573772, 0.06531741341400821, 0.061729589427969134, 0.06081986037989895, 0.0, 0.0, 0.0, 0.0097186725668017, 0.010833938096958207, 0.009433151669329232, 0.00735721758304253, 0.010157896730316307, 0.007471894737538065, 0.12036987641262575, 0.13155566155847498, 0.10952472723890494, 0.0, 0.0, 0.0]}}
{"id": "e1bf7299-1da0-484c-b310-eccd10be7443", "fitness": 0.03719964423995244, "name": "EnhancedHybridDEPSO", "description": "Introduce an adaptive crossover rate in DE based on population diversity to enhance exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            # Change: Adjust crossover rate based on population diversity\n            diversity = np.std(self.population) / 5.0\n            crossover_rate = 0.9 * (1 - diversity)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03720 with standard deviation 0.04312.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.1078366845298373, 0.1602284242178762, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03617444974127337, 0.020000000000000018, 0.04125338196182793, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11541560881696955, 0.0625661134756984, 0.07272763316541608, 0.020000000000000018, 0.021174761835279, 0.020000000000000018, 0.03874107358775947, 0.08594148016760361, 0.08911378598152997, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1137307992538874, 0.12363155702732431, 0.1639056567586985, 0.021977348898839844, 0.020000000000000018, 0.020000000000000018, 0.07131407602902162, 0.08856885035437356, 0.08940879026459725, 0.1327644350012085, 0.14871047603663468, 0.1584270291776968, 0.05943752786449574, 0.061411105798424015, 0.06241162346299045, 0.11504770867674641, 0.1053658267114389, 0.14170962366742235, 0.12236911737207379, 0.020000000000000018, 0.12343230277589035, 0.09263027971025795, 0.10922886220783345, 0.08086215978886457, 0.08267699220759028, 0.04784891893841636, 0.05380216297674878, 0.1438526290318487, 0.14785116176611302, 0.14732499941252541, 0.056216842328858596, 0.02934911359125436, 0.05240603821752898, 0.039607715884715566, 0.03463834666721877, 0.055613615947018635, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027397805647178197, 0.019847003919270967, 0.013327425422214767, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013110132268715824, 0.013217005967376516, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07347975153266684, 0.06156344782713563, 0.08362168051514618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055889253018112206, 0.07390163239844583, 0.06160263904796448, 0.12754790377129244, 0.10252438655124207, 0.10565182053704392, 0.06892488673485997, 0.04874460544829906, 0.057182498707087026, 0.09551645003236908, 0.07561578859349694, 0.11121658723469874, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03402969651088894, 0.03501857933579933, 0.02795204683860053, 0.03961757438367908, 0.027345117502584504, 0.03643444111100336, 0.13414374087931646, 0.13392453490698064, 0.1461070977265596, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005207972110385928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0283845211922944, 0.03111876607149444, 0.030891077163040515, 0.0, 0.0, 0.0, 0.03368731490965171, 0.038873298442787974, 0.03954132670825605, 0.08224141235940263, 0.08011063778801275, 0.07712499243641413, 0.02277386860209274, 0.024483082906095355, 0.019807837203337342, 0.06595888716408438, 0.061729589426607445, 0.06315972505648981, 0.0, 0.0, 0.0, 0.009681466768079794, 0.010833938096958207, 0.009961129564070581, 0.00787229467647732, 0.010157896730316307, 0.0074347964066190375, 0.12046635217298685, 0.13043182413854026, 0.10796712472225423, 0.0, 0.0, 0.0]}}
{"id": "474301c6-b8a6-4196-a582-a90fcf47a750", "fitness": 0.03970597666067176, "name": "EnhancedHybridDEPSO", "description": "Enhance strategic reinitialization by incorporating diversity and convergence rate to stabilize performance.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5 and np.linalg.norm(self.velocities) < 1e-3:  # Enhanced diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "bf51a64c-edea-44c2-944b-4bdba0656835", "fitness": -Infinity, "name": "AdaptiveHybridDEPSO", "description": "Introduce adaptive parameter control via historical success learning to balance exploration and exploitation dynamically in hybrid DE-PSO.", "code": "import numpy as np\n\nclass AdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.success_rate = 0.5  # Initial success rate for adaptive control\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        successful_updates = 0\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * self.success_rate)  # Adaptive inertia weight based on success rate\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            new_velocity = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            new_position = np.clip(self.population[i] + new_velocity, self.lb, self.ub)\n            \n            new_fitness = self.evaluate(func, new_position)\n            if new_fitness < self.best_values[i]:\n                successful_updates += 1\n                self.population[i] = new_position\n                self.velocities[i] = new_velocity\n                self.best_values[i] = new_fitness\n\n        # Update success rate for parameter adaptation\n        self.success_rate = successful_updates / self.population_size\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 50, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {}}
{"id": "b74b1b87-bcd5-41d4-aa91-aeade8de8c5d", "fitness": 0.03897839007904638, "name": "EnhancedHybridDEPSO", "description": "Improve velocity update by introducing a dynamic cognitive scaling factor based on fitness diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive_scaling = 1.5 + 0.5 * np.std(self.best_values)  # Dynamic cognitive scaling\n            cognitive = cognitive_scaling * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03898 with standard deviation 0.05624.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08523996004704204, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.020000000000000018, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06842235775406569, 0.06293453442856733, 0.565201449773378, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.105004936412458, 0.16331147346710284, 0.1639053580478378, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0872976313258601, 0.07324227683377416, 0.07160932741291748, 0.14745365552639156, 0.14688078176043373, 0.12050719803777843, 0.08941108059227332, 0.06847064370856426, 0.07299629306784994, 0.11732927276896987, 0.12782394671955277, 0.1415063152232563, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08842594662855585, 0.06527120746322768, 0.047765376230326395, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.0395673350871647, 0.05473954285536864, 0.030126685617281934, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02941963899792943, 0.015318916910954772, 0.017924409980434652, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016869878375034952, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.060565302708243784, 0.0661565173024159, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06024739101859011, 0.0652925772135039, 0.05395939349942802, 0.12754790273435246, 0.10049801328978536, 0.10281775224528589, 0.06906887936676553, 0.03530621521123645, 0.053936809511723194, 0.09551643924129505, 0.06947339295024335, 0.1109024799215601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025742245208847714, 0.035488759743377285, 0.029489696169114232, 0.03961757438367908, 0.02800006954724732, 0.024945351818044137, 0.13329411941578284, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03185876058388093, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.021316435450930316, 0.024483082906095355, 0.019575860637573772, 0.0652780794211063, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.009676781668047862, 0.010833938096958207, 0.009885441451964017, 0.008142218886385333, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "6ef9d038-be08-491e-b758-d73377d5cd79", "fitness": 0.03970597666067176, "name": "EnhancedHybridDEPSO", "description": "Enhance diversity by adjusting the scaling factor in the velocity update based on fitness variance.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2 if np.std(self.best_values) > 1e-3 else 1.0  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "788fda64-0c15-491d-a961-1e8a20e40dcd", "fitness": 0.03962928896291227, "name": "EnhancedHybridDEPSO", "description": "Introduce a dynamic crossover rate in DE to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            # Modified line below to introduce dynamic crossover rate\n            crossover_rate = 0.9 - 0.5 * (self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03963 with standard deviation 0.05579.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591314180235389, 0.14778263707815686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.02871247777390007, 0.021062419885162775, 0.020000000000000018, 0.030991497678769186, 0.06475264649512724, 0.0629345344101937, 0.5439931493440522, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.0989799418979751, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12812348558101916, 0.16331147346710284, 0.1639056257954219, 0.028467367342368655, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09242863412070756, 0.07596756915222924, 0.14745365552639156, 0.13323277534341382, 0.1271704330222554, 0.08941108059227332, 0.05982597444098903, 0.07609522695435911, 0.11972062280354545, 0.11103034668390821, 0.1415063152232563, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08873175814757472, 0.11150825113262242, 0.04776537690280014, 0.054286104540684055, 0.14852995365915234, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.036961645468614246, 0.03985012819076028, 0.03213627303594435, 0.0556136451783622, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05049198389018539, 0.014638793103993075, 0.0180646059956987, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01352058386296795, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901017665, 0.06128638650121454, 0.08506791165462158, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06613053595566631, 0.05395939349942802, 0.12754790273435246, 0.10049801370273403, 0.10281775224528589, 0.06906888070130379, 0.0490365269430848, 0.053936809511723194, 0.09551669048237843, 0.07341427481672069, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025439592432088043, 0.030756893921417006, 0.03082102730739411, 0.03961757438367908, 0.02720680501300532, 0.025441426005721746, 0.15690576657337207, 0.14048019681452684, 0.14519989277755085, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0009344351291611375, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028405231522930396, 0.03110950040829319, 0.03861568802248572, 0.0, 0.0, 0.0, 0.034659044600452216, 0.03939035494496934, 0.03431991507369958, 0.08195350186180606, 0.08003114951368118, 0.07712499243641413, 0.022327736454688107, 0.024483082906095355, 0.020517245819112295, 0.06552330841882592, 0.061729589426607445, 0.06036301339767869, 0.0, 0.0, 0.0, 0.009709816750536171, 0.010833938096958207, 0.009449803402120649, 0.007361762980919728, 0.010157896730316307, 0.007398481417765335, 0.1150512789830016, 0.1304161139054778, 0.10695219583912474, 0.0, 0.0, 0.0]}}
{"id": "2bb51029-8d3e-4f0f-9107-b2aad8f18978", "fitness": 0.036858498851443225, "name": "EnhancedHybridDEPSO", "description": "Introduce adaptive local search intensity by dynamically adjusting the differential evolution's crossover rate based on current population diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            # Updated line with dynamic crossover rate adjustment based on diversity\n            crossover_rate = 0.9 * (1 - (self.f_evals / self.budget) * (1 - np.std(self.best_values) / 10))\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03686 with standard deviation 0.04404.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08955735364748929, 0.09548019360906634, 0.21298653304369142, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02357656456127588, 0.024042452263297154, 0.028136214535526838, 0.020000000000000018, 0.020000000000000018, 0.03337123711665979, 0.058754163658985004, 0.11162693041739469, 0.06250856612099431, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03787302505298029, 0.08594148016760361, 0.08830397158990422, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02438604795267818, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0804436504730035, 0.1628784128798736, 0.1638799832154344, 0.029019666411548295, 0.020000000000000018, 0.020000000000000018, 0.07131407602902162, 0.063315538300037, 0.09369430945386459, 0.1314302119540598, 0.13323277534341382, 0.13299944142265563, 0.05970893447193959, 0.06385220835328964, 0.07299629306784994, 0.11205586464406281, 0.13666343557588168, 0.1415063152232563, 0.12236914942998967, 0.020000000000000018, 0.11602719003010775, 0.0879741544882533, 0.08025098969124467, 0.09786245072670896, 0.0826768694302672, 0.04776537690280014, 0.08482856172567044, 0.1567873511365363, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.03995850820394309, 0.0365778844985718, 0.03977289960635444, 0.031941902459106886, 0.055613624220333, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017552028602837888, 0.013697308300598676, 0.01653209496662922, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544886978906, 0.06227111014904407, 0.08362168050809415, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06492822356577077, 0.05395939349942802, 0.12070034606251578, 0.10036746192771873, 0.10281775224528589, 0.06906887578167242, 0.04857902424928706, 0.053936809511723194, 0.09551669048237843, 0.0727544451623321, 0.1113996848027895, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025439592432088043, 0.03124670326257506, 0.030821014515683864, 0.03961757438367908, 0.02752273171322439, 0.024640285494433645, 0.15690576657337207, 0.14453251666049138, 0.14519989277755085, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0009344351291611375, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0283845211922944, 0.0311094989827444, 0.02992700000596271, 0.0, 0.0, 0.0, 0.03740336877097905, 0.03753213255583987, 0.0350930315190322, 0.08193106182931731, 0.08048385339450448, 0.07712499243641413, 0.02213291462134903, 0.024483082906094356, 0.019575860637573772, 0.06531741341400821, 0.061729589427969134, 0.06081985938660883, 0.0, 0.0, 0.0, 0.009680081106339444, 0.010833938096958207, 0.009849438792000065, 0.008142144736111856, 0.010157896730316307, 0.007434793584827126, 0.1112398058338967, 0.1304161139054778, 0.10918604569649337, 0.0, 0.0, 0.0]}}
{"id": "04dd1bd8-af88-4552-98c1-a8614266223b", "fitness": 0.038839262377426596, "name": "EnhancedAdaptiveDEPSO", "description": "EnhancedAdaptiveDEPSO with dynamic parameter adaptation based on swarm diversity and convergence speed for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        diversity = np.std(self.population)\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F_dynamic = F_base + 0.2 * (diversity / 5.0)  # Dynamic mutation factor based on diversity\n            mutant = x1 + F_dynamic * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on both crowding distance and convergence speed\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance)) * (1 - self.f_evals / self.budget)\n            self.velocities[i] = (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03884 with standard deviation 0.05500.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08477879231198837, 0.0976686507683957, 0.1604491090251885, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021852076850906066, 0.0237996265543563, 0.02346297024104471, 0.021062419885162775, 0.020882995596306575, 0.020000000000000018, 0.06425551707159116, 0.06178574840038886, 0.5333847202495423, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.11576174225382918, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11565966115653936, 0.16331147346710284, 0.15948169944134094, 0.020000000000000018, 0.020000000000000018, 0.02069712709499294, 0.0833550481198102, 0.07320684781971631, 0.06679265629345077, 0.14745365552639156, 0.14337991623431934, 0.13215954322559031, 0.08941108059227332, 0.08952573227844252, 0.07140039404013299, 0.11732927276896987, 0.11256953686420212, 0.16225166145780445, 0.08358997095438492, 0.020000000000000018, 0.13020471186041715, 0.1470103917218063, 0.10834328334012999, 0.0960292922601983, 0.06527120746322768, 0.04616535580723691, 0.05416575717535499, 0.1438526290318487, 0.13144503125649942, 0.12743288784969875, 0.049534782202576344, 0.03104480701475898, 0.035348492842086854, 0.03962658557676535, 0.03275708033466518, 0.058626249241325645, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02831418412935849, 0.013606993287476388, 0.015598066745490247, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011383798697921166, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012008688719715277, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07399807798648239, 0.06230630490334965, 0.07442179789539538, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05996013255406174, 0.06290381279282131, 0.05395939349942802, 0.11962765744278625, 0.09842631354670983, 0.10530812676371881, 0.0671629579062416, 0.043602910837255426, 0.053936809511723194, 0.08842703948024122, 0.07638940814596362, 0.10254348292324356, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031105872695764036, 0.03697678822353867, 0.033135064044951035, 0.03958283459588896, 0.02994537747837489, 0.02564590079783602, 0.1413751613880876, 0.16126665319019484, 0.13395806926726206, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022500896019664873, 0.000320178860069964, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02860826778351866, 0.033253676545852096, 0.030907149856175486, 0.0, 0.0, 0.0, 0.03158039846713878, 0.03753213255583987, 0.03806209031697083, 0.08087735261328632, 0.07977469974063245, 0.07747755012244395, 0.02105440502840361, 0.024440458950143795, 0.0186811563303253, 0.06569122968075125, 0.06214794463257178, 0.061866983988491, 0.0, 0.0, 0.0, 0.009915579678668518, 0.01069235902887855, 0.009887776459815756, 0.008136534771163051, 0.010137496754208386, 0.007448675548129224, 0.11290572637667029, 0.1304161139054778, 0.11481729478490355, 0.0, 0.0, 0.0]}}
{"id": "8d112a6d-0a70-4ba5-99be-b6bcb98802d2", "fitness": 0.03940705159466852, "name": "EnhancedHybridDEPSORefined", "description": "Incorporate dynamic learning rates and adaptive crossover in DE to improve convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSORefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.6 + 0.2 * (1 - self.f_evals / self.budget)  # Dynamic mutation factor\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 - 0.8 * (self.f_evals / self.budget)  # Adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.3  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedHybridDEPSORefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03941 with standard deviation 0.05723.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10058086993723536, 0.14430386302577491, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020771891687047517, 0.023987337163157596, 0.024278420924134236, 0.021002411530897103, 0.020000000000000018, 0.02069390720595754, 0.06272501724058122, 0.0630299412256119, 0.5756519434579879, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.0872878899008882, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13440889897691888, 0.1666033430891184, 0.16239101924878285, 0.02509923783779211, 0.020000000000000018, 0.020000000000000018, 0.08067915319247532, 0.08696676373622614, 0.0793365732864828, 0.1470294353424657, 0.13323277534341382, 0.15359762871389837, 0.09141226222474952, 0.06511721576612872, 0.0633928437139375, 0.1139517652109141, 0.13920261628370667, 0.13466128751775241, 0.139420111217199, 0.020000000000000018, 0.11594922933596508, 0.14965547538270785, 0.10771317398508329, 0.08954144224178118, 0.08323531078135527, 0.046907905369406366, 0.05458237192706894, 0.1516327087468291, 0.1500229817336851, 0.14284365680052558, 0.048735796232852846, 0.029138840552492273, 0.02657375009670604, 0.03955104024341849, 0.04271141293304115, 0.056470419500633695, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02825503886666514, 0.02201679712234883, 0.01831625994115227, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012961416951983162, 0.010186242277746338, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07228475744438267, 0.060657607012776116, 0.08301781893193005, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05951929529550737, 0.06211994804837062, 0.054797359665409995, 0.13220585301110066, 0.09995118943676129, 0.10281775224528589, 0.07563767158905177, 0.04035932210557436, 0.053936809511723194, 0.09295287428555654, 0.07146073738122938, 0.0964156450661513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02941274773900726, 0.04093470939621968, 0.030584408209058722, 0.039265935172684174, 0.02510574336749971, 0.02543186572630074, 0.13622096348265655, 0.13746210694051797, 0.14017903009277044, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00029910363203133894, 0.00013793420122565347, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027259237237615364, 0.03149785602234134, 0.03794647361669534, 0.0, 0.0, 0.0, 0.034028147836550504, 0.03782714540735688, 0.034514574774987206, 0.08240029566472884, 0.07993725186144518, 0.07729526227249439, 0.020830188500076896, 0.02430783411451931, 0.019054228987886668, 0.06614291254607907, 0.06320796261944339, 0.06095391034380526, 0.0, 0.0, 0.0, 0.00967350014305357, 0.0109200656155789, 0.0098896547043269, 0.00809421122054299, 0.010051284513262426, 0.007430927403377696, 0.11851456763242785, 0.1304161139054778, 0.11026247811676382, 0.0, 0.0, 0.0]}}
{"id": "7de992f6-0c6f-4b15-94e1-6657ee0006e3", "fitness": 0.03909239950204561, "name": "EnhancedHybridDEPSO", "description": "Introduce a more adaptive mutation strategy in DE based on the fitness variance of the population to enhance exploration.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.3 * (np.std(self.best_values) / (np.std(self.population) + 1e-9))  # More adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03909 with standard deviation 0.05657.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09551015057849155, 0.16456828529781664, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023745776374139105, 0.02487130338723431, 0.022343008726087188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08395513068552962, 0.06085793652632676, 0.5752942816780984, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03874107358775947, 0.08594148016760361, 0.08321611387007632, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08228844738167851, 0.12179784035722818, 0.16457329856465974, 0.029916238289118602, 0.020000000000000018, 0.020000000000000018, 0.08928342293633817, 0.06370099127933815, 0.0822759948031847, 0.15045221444934387, 0.14566772717595589, 0.14708034412207072, 0.08252384120042944, 0.07748250500309373, 0.06915216263458679, 0.132745533208679, 0.11482252182612596, 0.1496605614398948, 0.12285326935600227, 0.020000000000000018, 0.11602719003010775, 0.0841624658225677, 0.10958994979476921, 0.07855946200672292, 0.06527120746322768, 0.047765376230716305, 0.054081212595891937, 0.16951241652120785, 0.13766007882795828, 0.1722235470967205, 0.038669801718039354, 0.054878822198602406, 0.03357307814256516, 0.03905384234856124, 0.030436534607051313, 0.05614502664455434, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03241539064847143, 0.01653013185839114, 0.020186660397331635, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544886978906, 0.06072951332060539, 0.08362168051514618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057189768502204585, 0.06200596548889015, 0.05825716631959432, 0.12754790233768565, 0.10085090362984317, 0.10281775224528589, 0.06906887578167242, 0.04857760706563963, 0.053936809511723194, 0.09551669048237843, 0.07218232297023885, 0.11135090611753529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03265128525840855, 0.034017017715351816, 0.0296178505258895, 0.03961757438367908, 0.027206805291242087, 0.024640285494433645, 0.13711640005202907, 0.13349120894414257, 0.13455638231013078, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00020946908400931719, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326595, 0.031109601657146713, 0.02992700000596271, 0.0, 0.0, 0.0, 0.043594692781002475, 0.03753213255583987, 0.03510248232742641, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.021264918173327096, 0.024483082906095355, 0.01957586063739869, 0.06531741341400821, 0.061729589427969134, 0.06081986037989895, 0.0, 0.0, 0.0, 0.009680038776297861, 0.010833938096958207, 0.009873083430111063, 0.008096136266877108, 0.010157896730316307, 0.007431465586909769, 0.1166250716732471, 0.1304161139054778, 0.10825381035993298, 0.0, 0.0, 0.0]}}
{"id": "cf4250ab-316c-4bf9-b714-624c865411c5", "fitness": 0.03550418460586862, "name": "AdaptDEPSO", "description": "Integrate adaptive learning rates and self-adaptive crossover rates in DE and PSO for enhanced convergence control.", "code": "import numpy as np\n\nclass AdaptDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * np.random.rand()  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.8 + 0.2 * np.random.rand()  # Self-adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 58, "feedback": "The algorithm AdaptDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03550 with standard deviation 0.04170.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.10124719641559776, 0.0919082895364991, 0.20279351659134937, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029911222015702066, 0.029347844091865305, 0.0282973613231694, 0.020000000000000018, 0.03428142933960532, 0.061904012491535765, 0.07707856494300402, 0.06421094865765264, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.044732685518217075, 0.08671375161567085, 0.08594738278337133, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08253914517655236, 0.10758123656232899, 0.13084903150896143, 0.024254011499837302, 0.020000000000000018, 0.0237599450362338, 0.10517712403220147, 0.09625244361060392, 0.09491297644192032, 0.12990506644848054, 0.14962258553269037, 0.13588973316722275, 0.05943272979281122, 0.08343127313087284, 0.08977248695906159, 0.1330009911812362, 0.10927732703467585, 0.12196690961088252, 0.020000000000000018, 0.020000000000000018, 0.11732956630262781, 0.09202625470112547, 0.06629070974236684, 0.0846757286373564, 0.06527120746322768, 0.04771816029583109, 0.05468863179775019, 0.15224044411484972, 0.13207998042236857, 0.1368707876823143, 0.044923936875331916, 0.030851955584445978, 0.02723897451666768, 0.033623249279583156, 0.02784934014101126, 0.046582265674806056, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02366434866612044, 0.019258713244492465, 0.01925721959510096, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07563530347590641, 0.07241575040827908, 0.06561110067396969, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.060935719737303384, 0.12065209502706509, 0.10262550896835199, 0.10281775224528589, 0.059930214104801816, 0.03829182928998165, 0.053936809511723194, 0.09016947455433011, 0.07806078777037395, 0.09873880444381777, 0.012395505492676095, 0.010000000000000009, 0.010000000000000009, 0.02571007525735114, 0.029240905268814843, 0.027878961360807475, 0.024895242935785933, 0.024903126529918662, 0.024640285494433645, 0.13141309820135194, 0.13144598245644856, 0.15372229952550043, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 2.1113756342616696e-05, 0.0, 0.00015652466889337635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029828502453061234, 0.03261050742527616, 0.03155454037075689, 0.0, 0.0, 0.0, 0.03890961840155471, 0.03753213255583987, 0.034215952184717624, 0.08221890215217587, 0.0801869337054717, 0.07821077804298904, 0.024008338548151653, 0.024484602969785385, 0.0214542888806456, 0.06535564874253041, 0.05915127404207565, 0.06436177142874155, 0.0, 0.0, 0.0, 0.00992303245579862, 0.010702956519928919, 0.009580302344553981, 0.007816159111438181, 0.010051284513262426, 0.0075817499665866706, 0.11344407935870171, 0.1304161139054778, 0.11454122835992409, 0.0, 0.0, 0.0]}}
{"id": "f6119731-de78-4f08-a2e8-42bcf4d2375a", "fitness": 0.03900678287358121, "name": "EnhancedHybridDEPSO", "description": "Introduce an adaptive scaling factor for velocity diversification to enhance exploration while maintaining stability.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2 * (1 + 0.5 * np.random.rand())  # Adaptive scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03901 with standard deviation 0.05867.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.09893388344827614, 0.09149625971727715, 0.1547835797006779, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02074157430485346, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.08130267181079176, 0.0945191687003869, 0.6197641736856733, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08882496229346903, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11051324524123463, 0.16331147346710284, 0.13186497119019347, 0.022771432425297222, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.0823335457990495, 0.0964647550279778, 0.14745365552639156, 0.15198050749115966, 0.14383972465154893, 0.08941108059227332, 0.08135039452576831, 0.09314869615046717, 0.11732927276896987, 0.12296524138598808, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.11622397217731528, 0.1470103917218063, 0.1091927088356931, 0.08580368852178433, 0.06527120746322768, 0.04616535580723691, 0.05446733994669373, 0.16415718023146608, 0.1447559547689633, 0.1477342378619403, 0.042859904271872695, 0.025143152075118413, 0.02657375009670604, 0.04011658382246153, 0.038615516393240346, 0.05405806282782566, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041673336015008666, 0.014023432400715352, 0.01696492595387422, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017442577547274962, 0.010131053915352517, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0782152022797239, 0.06314763801957213, 0.07042883446689019, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057343290066428354, 0.0652925772135039, 0.05395939349942802, 0.11869262382913237, 0.09499721954495499, 0.10281775224528589, 0.06377601254007492, 0.03757044197481807, 0.053936809511723194, 0.0894454055972439, 0.07872495653974876, 0.09775771579440207, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02568233494906269, 0.0347019700548975, 0.03170971482989127, 0.034917876806523473, 0.023756796043296502, 0.024640285494433645, 0.13302987891482831, 0.1503972832474736, 0.13438130699281658, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028486770114142357, 0.03553460727133606, 0.030174498754376722, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.0809111985838713, 0.08201331840613324, 0.07767673715738466, 0.02089890047118559, 0.02494205511383274, 0.01872308843856485, 0.06618371720477423, 0.06194715968990805, 0.062166287464962, 0.0, 0.0, 0.0, 0.00971792747858502, 0.01103825737990316, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.007564398047454124, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "03481a15-9214-4432-a4ab-f9c243dbe24f", "fitness": 0.03608414589021165, "name": "AdvancedAdaptiveDEPSO", "description": "Integrate a self-adaptive mutation and crossover strategy in DE with a crowding-informed inertia weight adjustment in PSO to maintain diversity and enhance convergence.", "code": "import numpy as np\n\nclass AdvancedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def adaptive_de_step(self, func):\n        for i in range(self.population_size):\n            indices = np.random.choice([x for x in range(self.population_size) if x != i], 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.6 + 0.3 * np.random.rand()\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def crowding_informed_pso_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            inertia_weight = 0.4 + 0.1 * np.tanh(crowding_distance)  # Crowding-informed inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social)\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.adaptive_de_step(func)\n            self.crowding_informed_pso_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 60, "feedback": "The algorithm AdvancedAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03608 with standard deviation 0.04217.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.0899200749147212, 0.07602287599886492, 0.19025142376396043, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.031231041371781898, 0.020000000000000018, 0.02469643031888813, 0.020000000000000018, 0.020000000000000018, 0.029641578570883675, 0.08976710975087543, 0.06427249689961767, 0.06870987589018707, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07649317043884507, 0.08594148016760361, 0.06819258523666905, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12366640788867389, 0.10014438844352958, 0.14974905050347986, 0.020000000000000018, 0.02925294180191773, 0.03708037124565777, 0.08874384409925962, 0.07865911530862146, 0.07695480424240597, 0.15547496893409574, 0.13323277534341382, 0.12046410243000594, 0.09285299795221957, 0.07923423248340355, 0.07054081981515314, 0.14034708978829713, 0.13179310129501065, 0.12214876119250784, 0.020000000000000018, 0.020000000000000018, 0.10306622866446447, 0.08343677235934466, 0.072143963096436, 0.11541317147520758, 0.06527120746322768, 0.054809051126607944, 0.053272544627359086, 0.1438526290318487, 0.1281202190235179, 0.13751860999658405, 0.063273024798431, 0.025431693541758005, 0.03370599087038073, 0.059898176898558586, 0.030548858591122774, 0.06021330875101283, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012842916024147444, 0.010571501137680572, 0.020608693502486508, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06578468446942731, 0.06587395155663334, 0.08805249160745943, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0773968342309459, 0.06147825531143891, 0.05598037834138703, 0.12628563163881779, 0.10033728357226368, 0.1036309981779191, 0.06587370509006019, 0.037534286273012474, 0.053936809511723194, 0.09415191554567226, 0.07375459642790716, 0.09462015826355274, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026534150547168456, 0.03171330573517661, 0.028614383439364843, 0.02757193153176385, 0.02366146455127993, 0.024640285494433645, 0.1587364819558258, 0.13860149375598596, 0.13409097465605868, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003139333955095247, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0386709082511254, 0.031536653202001164, 0.02998747438412852, 0.0, 0.0, 0.0, 0.034601191056633285, 0.03753213255583987, 0.037957070817971617, 0.08192195338940933, 0.08285760555053101, 0.07712499243641413, 0.023069492090880717, 0.02422269168027258, 0.01933503727947572, 0.06718503843969259, 0.058439744212977596, 0.06149202482454552, 0.0, 0.0, 0.0, 0.009799790866522828, 0.010618216925484814, 0.009433670218465084, 0.009066608983079094, 0.01025598010057649, 0.007494798312401185, 0.1112398058338967, 0.1304161139054778, 0.10844225425681131, 0.0, 0.0, 0.0]}}
{"id": "30933f59-1c43-4ddc-bdce-b342319f4bb9", "fitness": 0.0391556017914913, "name": "AdvancedHybridDEPSO", "description": "Introduce a dynamic adaptive learning rate and velocity variant control in PSO to further balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdvancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance and adaptive velocity variant\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            adaptive_velocity_factor = 0.9 + 0.1 * (1 - self.f_evals / self.budget)\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor * adaptive_velocity_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 61, "feedback": "The algorithm AdvancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03916 with standard deviation 0.05537.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09475718159780167, 0.14824598542287337, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02421663437207311, 0.020000000000000018, 0.020171094500159525, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.0663614050593253, 0.06269518661535267, 0.541176536927944, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12678786580653822, 0.16331147346710284, 0.16379191524293701, 0.02080986772337734, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.08574833811424498, 0.0812680445205356, 0.14745365552639156, 0.14315923047024715, 0.13786418854501337, 0.08941108059227332, 0.07453844135807774, 0.08101244723546808, 0.135286020701615, 0.119902788411689, 0.1297914824272811, 0.12188672056845007, 0.020000000000000018, 0.12032845418262283, 0.1470103917218063, 0.10903236212934087, 0.08799635749492252, 0.10657581536531291, 0.05010531790160977, 0.05416867693084104, 0.1438526290318487, 0.1349619864309648, 0.1363300265923969, 0.04696495167956782, 0.03365289547545647, 0.03918913139728997, 0.0399360893862295, 0.03349306575053146, 0.058038185787041674, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017309218924671632, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014253176037532178, 0.01044228593490426, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07474159815246995, 0.06166870333025998, 0.06707448125790949, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06607241862555935, 0.06771374526675966, 0.12196652595104684, 0.09993613572418225, 0.10281775224528589, 0.0710029391701279, 0.040020155497087595, 0.053936809511723194, 0.09071043222220287, 0.07595490762774804, 0.09682198824951616, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030457252986823224, 0.037585566392042025, 0.029419896611687868, 0.039516984846598824, 0.030330560816260177, 0.0255642276119743, 0.13222403595973742, 0.1503972832474736, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.000465513548937202, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028223946230179986, 0.033000718567680165, 0.03084354767580111, 0.0, 0.0, 0.0, 0.03301533175690341, 0.037576614463234126, 0.038922240611508396, 0.08102532310849864, 0.07995440842256218, 0.07718335197658177, 0.021600925740817067, 0.024348935858524268, 0.01918898030496008, 0.0659691412700022, 0.062173384810689125, 0.06175546918731489, 0.0, 0.0, 0.0, 0.009746940524917314, 0.010732684844801721, 0.009885441451964017, 0.008136655007303983, 0.010368771864226134, 0.00743479250564183, 0.11664528361387738, 0.13067542553242528, 0.10740566100123061, 0.0, 0.0, 0.0]}}
{"id": "a0c601d8-4dae-462d-85e7-2b0266e29f22", "fitness": 0.03970597666067176, "name": "RefinedHybridDEPSO", "description": "Introduce adaptive elitism with a local search around the best-found solutions to enhance exploitation in later optimization stages.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def local_search(self, func):\n        # Apply a simple local search around the global best\n        if self.global_best_position is not None:\n            epsilon = 0.01 * (self.ub - self.lb)  # Small perturbation range\n            for _ in range(5):  # Limited local search steps\n                candidate = self.global_best_position + epsilon * np.random.uniform(-1, 1, self.dim)\n                candidate = np.clip(candidate, self.lb, self.ub)\n                candidate_fitness = self.evaluate(func, candidate)\n                if candidate_fitness < self.global_best_value:\n                    self.global_best_value = candidate_fitness\n                    self.global_best_position = candidate\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n            if self.f_evals / self.budget > 0.8:  # Apply local search in the later optimization stages\n                self.local_search(func)\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 62, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "1dd68652-2117-4614-a29e-6024166dc405", "fitness": 0.03946004478773739, "name": "EnhancedHybridDEPSO", "description": "Enhanced exploration by dynamically adjusting the cognitive component's influence in PSO based on the population's diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            population_diversity = np.std(self.population) / 5.0  # New population diversity factor\n            cognitive = (1.5 + population_diversity) * r1 * (self.best_positions[i] - self.population[i])  # Adjusted cognitive component\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03946 with standard deviation 0.05598.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023240160424883527, 0.021302970238297414, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06082861705699616, 0.06293453442856733, 0.5439862942474772, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13373689293034952, 0.16331147346710284, 0.16390557072230594, 0.023606360451498554, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09726955071885668, 0.09162571576022815, 0.14745365552639156, 0.14315923047024715, 0.13472653631548637, 0.08941108059227332, 0.05999154170664933, 0.07383000377338989, 0.11732927276896987, 0.11080279415746463, 0.15076982330346678, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08881343215327353, 0.1112140285893587, 0.04776537667245617, 0.054279678248511654, 0.1438526290318487, 0.14093763603546672, 0.1589139162928075, 0.038669801718039354, 0.056633052544508566, 0.027668565910695442, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017965476750765208, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.061259819597472065, 0.06772904214424458, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05478600085271412, 0.0652925772135039, 0.0577587682763232, 0.12754790273435246, 0.10054078583436787, 0.10281775224528589, 0.06906887936676553, 0.03813057689924404, 0.053936809511723194, 0.0994302914496562, 0.07581146043688591, 0.1109024799215601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029194592792571084, 0.03624738428790453, 0.029489696169114232, 0.03961757438367908, 0.028908025797646508, 0.02542490647242812, 0.13329411941578284, 0.1503972832474736, 0.14290306008005726, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.00034696788061294725, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.022432358145594966, 0.024483082906095355, 0.019575860637573772, 0.06575900895643172, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.009679074150628963, 0.010833938096958207, 0.009885441451964017, 0.008141813153635269, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10708062556162234, 0.0, 0.0, 0.0]}}
{"id": "0bdf9be4-6b8e-4e0e-8348-b5e28c639b9b", "fitness": 0.03911633793704476, "name": "EnhancedHybridDEPSO", "description": "Introduce a dynamic inertia weight upper bound to further enhance exploration in the PSO step.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.7 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight with increased upper bound\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03912 with standard deviation 0.05682.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09474817250954659, 0.1503514641172966, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024427909119544067, 0.020000000000000018, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06564589842038016, 0.06313535037703, 0.5725735391561311, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11194302349500518, 0.16331147346710284, 0.1597024190898384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.07324227683377416, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.1313495497603736, 0.08941108059227332, 0.05425189282683984, 0.07012595123918564, 0.11732927276896987, 0.11951502009963799, 0.13431551367279893, 0.13410665016394863, 0.020000000000000018, 0.14421946839783029, 0.1470103917218063, 0.10609183707360836, 0.10259391544956442, 0.11055559041211183, 0.04616535580723691, 0.054953495593194734, 0.15021515390714824, 0.13603417545048102, 0.13403012547116988, 0.038669801718039354, 0.03555282297616358, 0.028518118781620916, 0.039617060804643556, 0.03289674381743779, 0.05760793497819927, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.019282639475381447, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01520215451514384, 0.012691643147052067, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0762384264645809, 0.05972111429220428, 0.0669757490037598, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057345848450762404, 0.0652925772135039, 0.06141959980601841, 0.12399145107361431, 0.10404145224555506, 0.10281775224528589, 0.07092373828884035, 0.03825217237615908, 0.053936809511723194, 0.09897506554526503, 0.073127816716411, 0.10039550167772548, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029839204238632955, 0.03492285182399035, 0.02955875806977415, 0.03978208937775074, 0.029124754409712406, 0.025190317745242052, 0.14012722446847803, 0.1503972832474736, 0.1348854219130654, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.00038418624914726696, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02839861363006846, 0.033000718567680165, 0.030371821360859474, 0.0, 0.0, 0.0, 0.03153719327947835, 0.037663903144648625, 0.038922240611508396, 0.08186036849410072, 0.08008686313942293, 0.07712499243641413, 0.022467493198223165, 0.024395264133743044, 0.019680486753440363, 0.0656018984678951, 0.06308140433958087, 0.06058280166632146, 0.0, 0.0, 0.0, 0.009679334510211302, 0.010846161892439588, 0.009885441451964017, 0.008140278075486118, 0.010171169052496598, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "a1327785-0b9c-4d34-9bf6-5351f8c18b47", "fitness": 0.03693802253165867, "name": "EnhancedHybridDEPSOImproved", "description": "Integrate adaptive velocity clamping and perturbation-based reinitialization to enhance exploration and prevent premature convergence in EnhancedHybridDEPSO.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSOImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        v_max = (self.ub - self.lb) * 0.1\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.velocities[i] = np.clip(self.velocities[i], -v_max, v_max)\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            perturbation = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n            self.population += perturbation\n            self.population = np.clip(self.population, self.lb, self.ub)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedHybridDEPSOImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03694 with standard deviation 0.04373.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.10172015330130024, 0.0877934000167283, 0.15576357527153983, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030082775154493646, 0.025828003979963987, 0.03601581747352467, 0.021062419885162775, 0.020000000000000018, 0.030916853458064164, 0.05676862851019626, 0.052920900404947124, 0.05211716007367384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04730238192152425, 0.08594148016760361, 0.10843824255957613, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.105004936412458, 0.16331147346710284, 0.15588109466376776, 0.033239061831623506, 0.020000000000000018, 0.026761983410634738, 0.09207863024232565, 0.07324227683377416, 0.08454249208081588, 0.1521563686432773, 0.14315923047024715, 0.1489213936639041, 0.09281570087398416, 0.07917305303594901, 0.09768053907053798, 0.13526502026808263, 0.11496132376312285, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.11916386671534185, 0.1470103917218063, 0.11089118891540506, 0.10744489517124778, 0.06527120746322768, 0.06776640990701255, 0.057751096545950675, 0.15134689973038373, 0.14396910228373427, 0.16258659391459018, 0.04352298775553298, 0.031235165173784996, 0.03988188072957599, 0.04793338472184272, 0.03838109499508402, 0.05944285740368416, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.010172493137437733, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07459836133033126, 0.06250163560824262, 0.07486992228577694, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0570965810762436, 0.08094880885658295, 0.05395939349942802, 0.12070113028232943, 0.09567104315931674, 0.10672344890343277, 0.06406743557978767, 0.03598406170864554, 0.05531857556687636, 0.09030307048101349, 0.07714860534948687, 0.09536305719622684, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031438394970581096, 0.03901015749181458, 0.028609368071219277, 0.02922468437831005, 0.024885534469001325, 0.025949605817876087, 0.13141309820135194, 0.15102446859567265, 0.13551219881786825, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003470918314843363, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028173535400851102, 0.033384213742952085, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.08104108627288686, 0.08045061356473793, 0.07763187480148703, 0.02160428507934231, 0.02569210558651336, 0.018866123376435118, 0.06516043306265773, 0.05850428738901314, 0.06058280166632146, 0.0, 0.0, 0.0, 0.009742965975385598, 0.010626888988826688, 0.00989842015633502, 0.008136655007303983, 0.010051284513262426, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.1065992342384412, 0.0, 0.0, 0.0]}}
{"id": "665fd2c5-4ed4-4ad4-ae16-f15db144b9c6", "fitness": 0.039528804134739526, "name": "EnhancedHybridDEPSO", "description": "Slightly adjust the velocity control factor formula for improved adaptability in changing conditions.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.6 * (1 - np.tanh(crowding_distance))  # Adjusted the factor from 0.5 to 0.6\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03953 with standard deviation 0.05655.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09604146443891148, 0.14558756898088332, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02358024667253711, 0.0237318205722008, 0.020926950750011053, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090368572387295, 0.06291677795345374, 0.5651866126733204, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0410146488797547, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12804167092192376, 0.16331147346710284, 0.1637253907052263, 0.02848137640254711, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09564535336284052, 0.0990881175409859, 0.14745365552639156, 0.14315923047024715, 0.1359694673017563, 0.08941108059227332, 0.05996512075972571, 0.08107151924618561, 0.11732927276896987, 0.11370695984368284, 0.1464426338402497, 0.12236912141934897, 0.020000000000000018, 0.11692627202380701, 0.1470103917218063, 0.10885005622667365, 0.08883847074337525, 0.11151008946717356, 0.04774844612159679, 0.054279811655883026, 0.1438526290318487, 0.1349619864309648, 0.13007523940734245, 0.038669801718039354, 0.05521660708953502, 0.032107541289491004, 0.03985108087675415, 0.03386706585713395, 0.057536677208242515, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017959755180541603, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07380599291808043, 0.06120742874741736, 0.06743014062139663, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830575460865173, 0.07008253738939374, 0.06078663576883758, 0.1275479015717632, 0.1019535745343505, 0.10281775224528589, 0.0690688862233848, 0.04074487651070147, 0.053936809511723194, 0.10264997584952795, 0.07470846947380305, 0.10856008062569233, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934468388502, 0.03628558508083812, 0.02964921208964355, 0.03961757452907677, 0.02876828024811684, 0.02548201204172984, 0.13329412556547993, 0.1503972832474736, 0.1386562306998771, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461015011, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02838452119252377, 0.033000718567680165, 0.030384406427204635, 0.0, 0.0, 0.0, 0.03153719327947835, 0.037881627553545516, 0.038922240611508396, 0.0818968007759564, 0.08003198965096392, 0.07712499243641413, 0.021974541683744686, 0.024483760777447294, 0.01957586063761152, 0.0661233393088142, 0.0617295894227351, 0.060940262752316565, 0.0, 0.0, 0.0, 0.009680083924161087, 0.010833938096958207, 0.009885441451964017, 0.008142098658185715, 0.010157896730302873, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "e434da3c-46f5-4f2e-97d0-2896a791785a", "fitness": 0.03688891438516157, "name": "StochasticElitistHybridDEPSO", "description": "Enhance exploration using a stochastic elitist strategy and adaptive local search to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass StochasticElitistHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, self.dim * 3)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.3 * (np.std(self.population) / 5.0)  # More aggressive factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.6 + (0.4 * (1 - self.f_evals / self.budget))  # Adjusted inertia weight\n            cognitive = 1.5 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.5 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.5  # Enhanced scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.4 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.6 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n            self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reset velocities\n\n    def local_search(self, func):\n        elite_indices = np.argsort(self.best_values)[:max(1, self.population_size // 5)]\n        for i in elite_indices:\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n            candidate = self.best_positions[i] + perturbation\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.evaluate(func, candidate)\n            if candidate_fitness < self.best_values[i]:\n                self.best_values[i] = candidate_fitness\n                self.best_positions[i] = candidate\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n            if self.f_evals / self.budget > 0.7:\n                self.local_search(func)\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 67, "feedback": "The algorithm StochasticElitistHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03689 with standard deviation 0.04275.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.10676181524623474, 0.10259273836649285, 0.12464707547186393, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026618621693474176, 0.0387512087123838, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07883447383868036, 0.06743532684392894, 0.07110687548380834, 0.020000000000000018, 0.05119665605398094, 0.020000000000000018, 0.02044834815542307, 0.09969096077127881, 0.06565052255883552, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03499804991388311, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1470891443071095, 0.12328415045793495, 0.13771473824906366, 0.03097335270509316, 0.020000000000000018, 0.030489549102060476, 0.08967152462977335, 0.0863116411064907, 0.06391222624661819, 0.13329926208128284, 0.1404081183164826, 0.12156906576956938, 0.08667695161419631, 0.09031149317102116, 0.09644164172317238, 0.13801184685994872, 0.12336476673815655, 0.13351610416959692, 0.11539317720985987, 0.020000000000000018, 0.11171682475291134, 0.12153615554967478, 0.09649713082425904, 0.07815839911783495, 0.06588391167471375, 0.10914105568588017, 0.0479157738851097, 0.1438526290318487, 0.15715455643550658, 0.15475448018179316, 0.04788029214188494, 0.0271865569174069, 0.03436048090868038, 0.033444911655348575, 0.0338818061252959, 0.043024984180787595, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02231750870559357, 0.015331396061430191, 0.010881599483893778, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0812200358283911, 0.08613754666297946, 0.06737048594111039, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06504488885017179, 0.05870863164259876, 0.12345816168041357, 0.09739923122075667, 0.10281775224528589, 0.060308361941526, 0.04139161051411766, 0.054009697355812736, 0.09038528846101701, 0.07884622233717176, 0.0957300968823569, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034725099142825955, 0.03135738619868078, 0.02673833231564937, 0.024895242935785933, 0.024299637686272635, 0.024640285494433645, 0.13338381263541932, 0.13731662708200365, 0.13784233308280391, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03779577982572657, 0.030556176043432304, 0.029890571760543994, 0.0, 0.0, 0.0, 0.0352935746984504, 0.046343363419250605, 0.03502841000154022, 0.08072778292416571, 0.08014066969373335, 0.08430029781132409, 0.020806169371402228, 0.024600116063123623, 0.027679073480967542, 0.06501016208547095, 0.05775643297460331, 0.0597099457471727, 0.0, 0.0, 0.0, 0.010123842630744284, 0.010899483094048645, 0.009535664293725876, 0.007614210209906824, 0.010051284513262426, 0.007591647015283476, 0.11450217822524078, 0.1304161139054778, 0.10691395521113134, 0.0, 0.0, 0.0]}}
{"id": "4001da05-885e-4ed3-a423-66395559d3df", "fitness": 0.03970597666067176, "name": "ImprovedHybridDEPSO", "description": "Incorporate adaptive learning rates and crowding-based selection to balance exploration and exploitation in hybrid DE and PSO for improved convergence.", "code": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 68, "feedback": "The algorithm ImprovedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03971 with standard deviation 0.05686.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.021266716609232073, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.5651865158420164, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09729625109611417, 0.09967766502383002, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.08127669378317282, 0.11972062280354545, 0.11312883107801586, 0.14993026077716276, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.017957659298126982, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06742351492157683, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.06069732137191053, 0.12754790273435246, 0.10195228551722724, 0.10281775224528589, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.10264046154172901, 0.07239621732617818, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029646709453070352, 0.03961757438367908, 0.0287667206750456, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "f81396af-b8ce-403c-99bb-b426ebbc13d9", "fitness": 0.03691417217282226, "name": "EnhancedHybridDEPSO", "description": "Introduce adaptive mutation and crossover strategies in DE, and adaptive cognitive and social components in PSO, driven by population diversity to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.zeros((self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = np.copy(self.population[0])\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            diversity = np.std(self.population) / (self.ub - self.lb)\n            crossover_rate = 0.9 * (1 - diversity)  # Adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            diversity = np.std(self.population, axis=0)\n            adapt_cognitive = 1.5 + 1.5 * (1 - diversity / (self.ub - self.lb))\n            adapt_social = 1.5 + 1.5 * (diversity / (self.ub - self.lb))\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = adapt_cognitive * r1 * (self.best_positions[i] - self.population[i])\n            social = adapt_social * r2 * (self.global_best_position - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive + social\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03691 with standard deviation 0.04320.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.11054862243042662, 0.12787180308730028, 0.154913643906482, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024343520124944562, 0.02171684443798161, 0.020000000000000018, 0.020000000000000018, 0.029048608017765765, 0.02608046809565101, 0.07567817605409455, 0.06676580084023953, 0.09742206864997482, 0.020000000000000018, 0.04000195292320807, 0.020000000000000018, 0.04045022906063023, 0.09695989089735957, 0.08871983878840728, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09122143992471676, 0.13616718183774124, 0.1544977959529541, 0.020000000000000018, 0.020000000000000018, 0.02746333405903867, 0.08349473829508225, 0.11534678313196323, 0.07405460098500238, 0.16499779315588559, 0.1347025297098472, 0.13081474813314398, 0.10115742702233788, 0.07845048345413874, 0.06702453673615993, 0.11941135503612588, 0.1157349998605176, 0.12406264074584972, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11437368479469145, 0.11348405628780922, 0.07882178667275186, 0.06527120746322768, 0.06813815459843964, 0.04630473132652457, 0.16095547492577933, 0.14901492010117123, 0.14953775146512727, 0.04560420829817258, 0.03970217661614128, 0.0459349958338956, 0.057415445176874025, 0.04307654743167011, 0.0647875099741202, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01981210474221673, 0.011451719128158677, 0.01138125528933398, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01073098738837952, 0.010000000000000009, 0.014079572657931028, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08145870721200987, 0.0649658970422482, 0.09507206104815058, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05644367361274305, 0.06147825531143891, 0.06263138741263052, 0.12736092965200707, 0.0966005435190036, 0.10281775224528589, 0.0631322236648818, 0.03592342971378104, 0.053936809511723194, 0.09142435262747639, 0.08596989512796038, 0.10185785446714524, 0.023021594674748957, 0.010000000000000009, 0.010000000000000009, 0.03505773898131537, 0.03150794844103544, 0.03089248990498772, 0.025534388444878764, 0.03482040444409351, 0.026573656533096957, 0.13672204988670478, 0.15396290164054005, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022121722741417216, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.032924671344967016, 0.03556625976718697, 0.032069677528745566, 0.0, 0.0, 0.0, 0.0321730911544148, 0.038340918895608755, 0.04188413299384808, 0.08394685542408997, 0.0830972341410614, 0.08112875099565897, 0.023181217759642547, 0.025210506059063498, 0.025809815318526996, 0.06972447356840972, 0.061718668509700425, 0.06273539621655033, 0.0, 0.0, 0.0, 0.009795413369880657, 0.010780591363672154, 0.011179063060102412, 0.007404856194409892, 0.010126579335509311, 0.007415151739423642, 0.11645289993445074, 0.1304161139054778, 0.10621433541917302, 0.0, 0.0, 0.0]}}
{"id": "a8b7e2eb-840c-457c-8797-293ef789bccd", "fitness": 0.03539474454127484, "name": "EnhancedMemoryDEPSO", "description": "Implement a self-adaptive memory-driven hybrid DE-PSO approach by integrating a memory bank for promising solutions to enhance exploitation and dynamic inertia adjustment to bolster exploration.", "code": "import numpy as np\n\nclass EnhancedMemoryDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.memory_bank = []\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n                # Update memory bank with promising positions\n                self.memory_bank.append(np.copy(self.population[i]))\n                self.memory_bank = sorted(self.memory_bank, key=lambda x: self.evaluate(func, x))[:min(5, len(self.memory_bank))]\n                \n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  \n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n    \n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            # Crowd-based velocity control\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n            \n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedMemoryDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03539 with standard deviation 0.04152.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08325571323309733, 0.09348331787169128, 0.139731869012912, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02263172418984083, 0.021026201025441393, 0.020000000000000018, 0.020000000000000018, 0.05763959787423045, 0.05975393261641937, 0.07763733855778443, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08379121450996418, 0.09882738451441953, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13835648444370752, 0.14584829392998955, 0.1472770541156524, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07985973679186431, 0.06968966171584223, 0.07057839966316948, 0.14610939662627975, 0.13164334617226015, 0.14000081752298144, 0.08717847900931919, 0.06414575380773957, 0.07673249001132887, 0.11802416361571777, 0.11026542363625313, 0.14577595115773634, 0.11659415489521607, 0.020000000000000018, 0.10478215881115427, 0.08247611483273265, 0.10707889807794913, 0.08434323312333203, 0.07508369509864476, 0.07752120524420636, 0.050399720148257554, 0.14268714710201924, 0.12805576796003948, 0.14016652033572574, 0.04473772919947516, 0.041393124503904644, 0.026359388680509133, 0.03811608972272906, 0.02414742525031044, 0.05095005391376617, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027318637163876835, 0.010268218206748503, 0.012683913163055949, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06809255313681262, 0.059884912529771794, 0.06739611469107898, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04560259864656946, 0.06802634056802659, 0.05336231083408094, 0.12396454983595706, 0.09736207507689909, 0.10168900813641235, 0.06601578986562151, 0.03765506385646333, 0.05164385839919694, 0.09637414144738932, 0.0736810265312201, 0.09592593257359772, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025545767917092288, 0.03662260013950869, 0.02918347190972259, 0.038473089025228946, 0.02548632323580735, 0.025481529862911967, 0.13220765497478115, 0.13095615713375497, 0.1337671441542212, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003580164025062227, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.025819061336307958, 0.03082573295613278, 0.028305493686499816, 0.0, 0.0, 0.0, 0.03353185971198114, 0.037996316255913154, 0.03393655119917749, 0.08055784323284387, 0.07971633908103781, 0.07636098376814004, 0.02530790621700263, 0.024160483952593625, 0.017706352919209523, 0.06480575996100069, 0.05925204253693994, 0.05782785257280798, 0.0, 0.0, 0.0, 0.00955503879478814, 0.010111605291774683, 0.010098232008055708, 0.007717821820951265, 0.009702825167996254, 0.007429470161251617, 0.11745433957413554, 0.1289288626721623, 0.10574892647017675, 0.0, 0.0, 0.0]}}
{"id": "c5a08028-b469-44eb-b6be-5172bb4fdf4a", "fitness": 0.03741517170097134, "name": "EnhancedHybridDEPSO", "description": "Introduce an adaptive crossover rate that decreases more rapidly as the function evaluations approach the budget, promoting faster convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - (self.f_evals / self.budget)**2)  # Adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03742 with standard deviation 0.04376.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.0959136298026827, 0.14547721100430433, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023864000560267606, 0.028567191725297536, 0.021062419885162775, 0.020000000000000018, 0.029781889915733717, 0.06457419573113665, 0.06293453438510566, 0.0623757773428395, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.036961536282963836, 0.08594148016760361, 0.0989799418979751, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1280032306711486, 0.16331147346710284, 0.16389310369661503, 0.028665670603852833, 0.020000000000000018, 0.03527521339163597, 0.07131407602902162, 0.09242863412070756, 0.0681454142554645, 0.14745365552639156, 0.13323277534341382, 0.14445371783243444, 0.08941108059227332, 0.0598309067617212, 0.07619434295318883, 0.1177445507989967, 0.10613969087682251, 0.1415063152232563, 0.12236910104527288, 0.020000000000000018, 0.11602719003010775, 0.14355152219182032, 0.08601805872325352, 0.08999154894709382, 0.08267686943080332, 0.04776537690280014, 0.08482856172567044, 0.14884624841438887, 0.14168633488997218, 0.15934541564857452, 0.038669801718039354, 0.0552166206398671, 0.027559852055803358, 0.03985093200743639, 0.03213549965383389, 0.055613650557648, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.050500900280955774, 0.014628197083051742, 0.019174588440522333, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012649106712010472, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901012092, 0.06589037692725308, 0.08362168051514618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05465167493565071, 0.062005959253081055, 0.05840514649443951, 0.12754790273584304, 0.10049801371656697, 0.10281775224528589, 0.0690688806670724, 0.04905188326814325, 0.053936809511723194, 0.09551669048237843, 0.0724602771833327, 0.11139970215797645, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.025317295159155484, 0.03112526710019159, 0.03928421314108865, 0.03961757438367908, 0.027206805365776465, 0.027347667553992205, 0.15690576657337207, 0.14453251666049138, 0.1397133500339034, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0009344351291611375, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028405214895520725, 0.03109596879978127, 0.02992700000596271, 0.0, 0.0, 0.0, 0.03335334967530412, 0.039140959588838675, 0.03431991507369958, 0.08210362088511314, 0.08003114951368417, 0.07736964608135255, 0.021846407941511936, 0.030363672202227687, 0.019575860637573772, 0.06556001601447548, 0.061729589426607445, 0.06036301339767869, 0.0, 0.0, 0.0, 0.009709816750570588, 0.010833938096958207, 0.009449803402120649, 0.007361645323264665, 0.010157896730316307, 0.007303519110818946, 0.1112398058338967, 0.1304161139054778, 0.10918706847704351, 0.0, 0.0, 0.0]}}
{"id": "46aa1b29-3e65-4443-9e28-6fbc8c26122d", "fitness": 0.039619714057632364, "name": "EnhancedHybridDEPSO", "description": "Enhance convergence by increasing cognitive weight in PSO when nearing budget limit.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            cognitive *= 1 + 0.5 * (self.f_evals / self.budget)  # Increase cognitive weight near budget limit\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03962 with standard deviation 0.05626.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.020000000000000018, 0.020071634177144748, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06081569200877268, 0.06293453442856733, 0.5439862947797236, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13664790356183087, 0.16331147346710284, 0.16390557168887743, 0.022583250582906667, 0.020000000000000018, 0.020000000000000018, 0.08602700260148277, 0.09673918391626901, 0.08602449380589894, 0.14745365552639156, 0.14315923047024715, 0.1421978391583576, 0.08941108059227332, 0.05999154170664933, 0.07828168896864851, 0.12491914732346254, 0.10688213426526527, 0.14789522686788048, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08872969973356615, 0.11097617375461188, 0.04776537658249025, 0.054279678248511654, 0.1612655849579654, 0.1442034218862247, 0.1589139162928075, 0.038669801718039354, 0.054940957513952116, 0.02766891909085234, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013598066361771521, 0.017977583014234022, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.061258099997901216, 0.06793416137237918, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06652315231464545, 0.07521999486576347, 0.056916106093814034, 0.12754790273435246, 0.10049801328978536, 0.10281775224528589, 0.06906887936676553, 0.03715489993321752, 0.053936809511723194, 0.09551643924129505, 0.06947339295024335, 0.1109024799215601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02736076581798441, 0.03548875917771366, 0.029489696169114232, 0.03961757438367908, 0.028733576478236933, 0.02531877235744706, 0.13329411941578284, 0.1503972832474736, 0.14138957865009016, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.032094552736408044, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.022696603350052746, 0.024483082906095355, 0.019575860637573772, 0.06551378166832966, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00967469718954661, 0.010833938096958207, 0.009885441451964017, 0.008136655007303983, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "282b4248-5482-449a-a6cd-f8adfe061b87", "fitness": 0.03829726246101085, "name": "EnhancedHybridDEPSO", "description": "Add a velocity boundary control to prevent excessive velocity magnitudes and enhance convergence stability.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            \n            # Add velocity boundary control\n            self.velocities[i] = np.clip(self.velocities[i], -2.0, 2.0)\n            \n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03830 with standard deviation 0.04550.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.15068813988623275, 0.09344659052538473, 0.20896461183966863, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03761228661155369, 0.03762340716556989, 0.04066991382846108, 0.028866190453000207, 0.020000000000000018, 0.020000000000000018, 0.05390040919135397, 0.05288443250419517, 0.05545254150514811, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03629805599121805, 0.11326534408426991, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.105004936412458, 0.16331147346710284, 0.17636559272168517, 0.03399874319169438, 0.04354233580035083, 0.020734169266325986, 0.07932796414964427, 0.07675640675066275, 0.0882889349989543, 0.15200942990222954, 0.14315923047024715, 0.14575437253264023, 0.08941108059227332, 0.06791629487389628, 0.09626395348098493, 0.13267085395470546, 0.13887874299946357, 0.14037271508331683, 0.020000000000000018, 0.02610701810975735, 0.1184479186515095, 0.1470103917218063, 0.11300467955545312, 0.07961866431671605, 0.06527120746322768, 0.06423210470618301, 0.054354000036218486, 0.14721454228807507, 0.14319792889116922, 0.14494388018021853, 0.06077153505868249, 0.05590074584030447, 0.03935478615020571, 0.06373790171506555, 0.042765589407736004, 0.059099736767955435, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.010172493137437733, 0.011208130645870673, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01013465537541447, 0.011193904544985811, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07839451184920287, 0.06834152532056659, 0.08931765907473643, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05590317645173348, 0.0652925772135039, 0.06024185274429472, 0.12981107688130467, 0.10072834438763711, 0.10612416653449686, 0.06313191534967688, 0.04396483512970972, 0.05713511190759435, 0.09578551365236732, 0.08569519722486008, 0.10215118465831907, 0.012194543435793181, 0.010000000000000009, 0.010000000000000009, 0.033602455938344544, 0.03521023941676926, 0.02797480498417171, 0.03649712945192496, 0.02980247451460738, 0.02770419731165419, 0.13141309820135194, 0.1503972832474736, 0.1339132814305556, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0041257956981580746, 0.0, 0.0012456568084783237, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029821836369571586, 0.03542445603437738, 0.03134183093804144, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.08182906322386496, 0.08174513971334962, 0.07732860916277451, 0.021904184510790348, 0.0259261429022003, 0.01994331097219204, 0.06776185188427908, 0.06237946484603807, 0.062329149078110935, 0.0, 0.0, 0.0, 0.009687701272096949, 0.010639338641714291, 0.010106306113040198, 0.008136655007303983, 0.010051284513262426, 0.007608652677244532, 0.11619717782090566, 0.1304161139054778, 0.10731156426282029, 0.0, 0.0, 0.0]}}
{"id": "cef7b169-c9ed-4c77-84d2-eeb456110c07", "fitness": 0.03920389224148466, "name": "EnhancedHybridDEPSO", "description": "Enhance the exploration by adjusting the scaling factor for velocity diversification dynamically based on the budget used.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2 + 0.3 * (1 - self.f_evals / self.budget)  # Dynamic scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03920 with standard deviation 0.05683.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10482249963976176, 0.14155085319850513, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022110443121551082, 0.022392414422671147, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.0662260159508099, 0.08668570665262532, 0.577231294875607, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020597287398794628, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12957747951412268, 0.16331147346710284, 0.152496452718205, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08022559269294516, 0.07324227683377416, 0.09485824091065043, 0.14745365552639156, 0.14315923047024715, 0.15339963048664518, 0.08941108059227332, 0.0601562379843531, 0.09723821192999171, 0.11791524431422518, 0.11021579564767103, 0.13768024334748963, 0.057040506966575366, 0.11420846996168776, 0.11574298311957376, 0.1470103917218063, 0.10322184291490843, 0.08070087071417664, 0.06527120746322768, 0.04616535580723691, 0.0549969339319244, 0.149243458646387, 0.1349619864309648, 0.13485455848156003, 0.06186123829240797, 0.03320904508010203, 0.02657375009670604, 0.03875447188981995, 0.034620288477671735, 0.05452802544458857, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.019835683135908555, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07170812170352936, 0.05966228132250617, 0.06649844022231155, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0652925772135039, 0.05395939349942802, 0.13461906708449423, 0.10457447572070722, 0.10281775224528589, 0.06958706473573006, 0.037855962425001444, 0.053936809511723194, 0.09889571447895251, 0.07123411105124489, 0.10147688098923136, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027947673884050617, 0.0347019700548975, 0.031397775516611715, 0.03975986326981695, 0.023935184147841126, 0.02513682437808895, 0.13141309820135194, 0.1503972832474736, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.00024081428362199286, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028467799477360334, 0.033000718567680165, 0.029914207275640092, 0.0, 0.0, 0.0, 0.03165430204871045, 0.03753213255583987, 0.038922240611508396, 0.08104338313023352, 0.08008785483011105, 0.07712499243641413, 0.021837172432988106, 0.024453052843437573, 0.01944353198980553, 0.0661353512958498, 0.06397161228834225, 0.06058280166632146, 0.0, 0.0, 0.0, 0.009673246792226697, 0.010905485237024948, 0.009885441451964017, 0.008145022701968152, 0.010051284513262426, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "f553a08b-f4b5-44d1-afcb-0ce1f19af6d4", "fitness": 0.038421880166880244, "name": "EnhancedHybridDEPSO", "description": "Introduce adaptive inertia weight and crossover rate based on population diversity to enhance convergence and maintain balance between exploration and exploitation.  ", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        pop_diversity = np.std(self.population, axis=0).mean()\n        crossover_base = 0.9\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (pop_diversity / 5.0)  # Dynamic mutation factor based on diversity\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = crossover_base * (1 - (pop_diversity / 5.0))  # Adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        pop_diversity = np.std(self.population, axis=0).mean()\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + 0.3 * (1 - self.f_evals / self.budget) + 0.3 * (pop_diversity / 5.0)  # More adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.5  # Scaling factor for better velocity control\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03842 with standard deviation 0.05595.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10716589489427208, 0.1614731124826515, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025654418186409456, 0.024957918553109026, 0.03337654953189384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0839131785382915, 0.06035019171158751, 0.5780228037964701, 0.020000000000000018, 0.02183300436394431, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.06030388395051489, 0.04256234610514009, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12571129247794077, 0.12171865775222768, 0.148611144223335, 0.03559551779155523, 0.020000000000000018, 0.020000000000000018, 0.07914666268726867, 0.07849694235136861, 0.07472907774136528, 0.1520543873002873, 0.13323277534341382, 0.13820998038222443, 0.07217094026334303, 0.07048948429843405, 0.06284245056086957, 0.1130255320606226, 0.11344081620849611, 0.13898416585651918, 0.020000000000000018, 0.020000000000000018, 0.11020940611034846, 0.08343677235934466, 0.10472028326799032, 0.08060728041481269, 0.07030315759734973, 0.10270789171526507, 0.0717062527776744, 0.1598400973067936, 0.16171336993707885, 0.13938417765145028, 0.05410318901563782, 0.026131440465702926, 0.0321460596987907, 0.03668744180277128, 0.03506920061864449, 0.0496302721818348, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023639819784667004, 0.014386849062562601, 0.013450264591561623, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013395102720407004, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07396188230177958, 0.06130433416776215, 0.0807264747291917, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05757911922139347, 0.06576314039416731, 0.05395939349942802, 0.1257281819807906, 0.10325075210525825, 0.10588388634615908, 0.07262681360926349, 0.051589949658387146, 0.0564157097169562, 0.09714249699049404, 0.07411002624468821, 0.09623344829053482, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03429820780616888, 0.029043163533977734, 0.028072629873857502, 0.03699540274699065, 0.0236098924626702, 0.025242023498924793, 0.13227317827465046, 0.13123409970527322, 0.1412916396113424, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005205409186630705, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0287597219764818, 0.031949952776972546, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03359833454019934, 0.037579411527581597, 0.03958907097514586, 0.08166188054649726, 0.07975336265829969, 0.07712499243641413, 0.021712430120621073, 0.024192448856156457, 0.01875326681288414, 0.0660348397330458, 0.06115760140286608, 0.0623185433622413, 0.0, 0.0, 0.0, 0.009671827052633364, 0.011049982298743433, 0.009963749056405624, 0.007811767683226112, 0.010051284513262426, 0.007434853485276172, 0.12465796506573723, 0.13227405028366657, 0.10877131729814893, 0.0, 0.0, 0.0]}}
{"id": "e6096a29-3890-4eaa-8d4e-25dc042db21d", "fitness": 0.03665637707581862, "name": "EnhancedHybridDEPSO", "description": "Integrate a self-adaptive parameter control mechanism with dynamic clustering to further enhance exploration and exploitation balance within the hybrid DE-PSO framework.", "code": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def dynamic_clustering(self):\n        \"\"\" Perform k-means clustering to promote diversity \"\"\"\n        kmeans = KMeans(n_clusters=min(self.population_size, 10))\n        kmeans.fit(self.population)\n        cluster_centers = kmeans.cluster_centers_\n        return cluster_centers\n\n    def differential_evolution_step(self, func, cluster_centers):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self, cluster_centers):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n\n            # Dynamic control based on crowding distance and clustering\n            cluster_distances = np.linalg.norm(cluster_centers - self.population[i], axis=1)\n            min_cluster_distance = np.min(cluster_distances)\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance)) * (1 - np.tanh(min_cluster_distance))\n            \n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            cluster_centers = self.dynamic_clustering()\n            self.differential_evolution_step(func, cluster_centers)\n            self.particle_swarm_optimization_step(cluster_centers)\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03666 with standard deviation 0.04280.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.12590665253755418, 0.09756424549754572, 0.1540077489903081, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.028551919297731376, 0.0376639526275957, 0.02458244693539191, 0.03712242178264047, 0.020000000000000018, 0.020000000000000018, 0.07241305826817068, 0.055841696146955444, 0.10887728147915565, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09081094843222548, 0.08594148016760361, 0.07859349986608999, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09615553973643776, 0.11746583458678006, 0.16648700297093766, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09623609693184076, 0.07826776956135761, 0.09920506783211436, 0.12990506644848054, 0.1510404856702101, 0.11782898007538212, 0.07567563556267709, 0.08505084926543138, 0.07191369918825474, 0.11235794515266972, 0.13563208767837975, 0.12216234313950847, 0.020000000000000018, 0.020000000000000018, 0.1276057532446302, 0.08343677235934466, 0.09048506259974598, 0.07667167264800068, 0.06527120746322768, 0.08780559880927541, 0.11635568671589824, 0.15623601003985044, 0.15012792731629188, 0.14596522980660576, 0.04263215430039735, 0.02314568798524741, 0.04093865594957735, 0.04375830016629323, 0.03868447500787853, 0.03943926844771195, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03238950848447131, 0.013484721294969582, 0.01666375408940668, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08093302203481956, 0.06232963856393936, 0.07208945768254094, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05639157964744157, 0.06647864240280799, 0.059774709719024766, 0.1207393568232138, 0.09782174220319362, 0.10577667255124423, 0.062343187452959525, 0.0357322899891066, 0.054085786061365826, 0.0895330334030473, 0.07444032826129143, 0.09306018080695166, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03152919492455153, 0.030653047743710138, 0.028811668557281567, 0.025569788883608058, 0.037124442229779175, 0.024640285494433645, 0.13249190944591593, 0.13702793376453204, 0.13518111997055016, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027634169275453258, 0.03118074476080024, 0.03041205081768572, 0.0, 0.0, 0.0, 0.030499991321740527, 0.03753213255583987, 0.036290954461220104, 0.08124485993013375, 0.0802502782379384, 0.07888495181344268, 0.02170252531995953, 0.024479241414210318, 0.01984980337117792, 0.06587896371748125, 0.06205506079672929, 0.062492104876340604, 0.0, 0.0, 0.0, 0.010239083129603865, 0.010618216925484814, 0.009616509418719277, 0.007444262793584899, 0.010051284513262426, 0.00744051558188874, 0.13264273291405226, 0.1304161139054778, 0.11000267534902841, 0.0, 0.0, 0.0]}}
{"id": "9b1e05fa-0238-408e-b13d-d12135081122", "fitness": 0.036268205953631935, "name": "EnhancedHybridDEPSO", "description": "Integrate adaptive mutation and crossover rates in DE and crowding-based reinitialization in PSO for improved diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.3 * np.random.rand() # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.7 + 0.2 * np.random.rand() # Adaptive crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            unique_positions = np.unique(self.population, axis=0).shape[0]\n            if unique_positions < self.population_size // 2:  # Crowding-based condition\n                self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03627 with standard deviation 0.04284.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.10124708265401783, 0.08889333565799717, 0.17054970420291649, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03739954568331394, 0.029911222015702066, 0.02067548228475824, 0.028264760911965836, 0.020000000000000018, 0.03184925404258365, 0.08042066748783638, 0.1013609910219424, 0.06591109212422053, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.043818222945646745, 0.08671375161567085, 0.08605216328618182, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10472616264031298, 0.11857721815390254, 0.13084903150896143, 0.032188184516699914, 0.020000000000000018, 0.02724738448268116, 0.09650270914118153, 0.07853933907296129, 0.0866920198167963, 0.132089884238485, 0.14962556838937924, 0.13715125346510404, 0.06950464839727999, 0.06720588161237118, 0.07477345051500617, 0.11664124881818372, 0.12560433805775462, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.11611588490053426, 0.09199540333152068, 0.07938439460747981, 0.08482080672161985, 0.06527120746322768, 0.04770966854590686, 0.1052865421672915, 0.15882836720033344, 0.19317666706261005, 0.158900107618542, 0.038669801718039354, 0.03059034562412255, 0.03910242778257489, 0.03362324590703991, 0.02863259237273541, 0.04658227819019789, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.016784880773095368, 0.015443413921025662, 0.019801575359470247, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0756353068754555, 0.056967918294612896, 0.07510332482576598, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05554447290047637, 0.06231311144676088, 0.06130768771082262, 0.12065211297147582, 0.10387610356869947, 0.10312007773940257, 0.05830184227813007, 0.04393511678725215, 0.053936809511723194, 0.09015739732840045, 0.08439225028641806, 0.0987389824039202, 0.012395301382706392, 0.010000000000000009, 0.010000000000000009, 0.02573779637941298, 0.029069553385956404, 0.029038515267563847, 0.024895242935785933, 0.024903126529918662, 0.024640285494433645, 0.13171436929834812, 0.13171777081911018, 0.1537222995243236, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 2.1113756344837142e-05, 0.0, 0.00015652466889337635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02763872698221792, 0.03246144014949437, 0.03168921829063942, 0.0, 0.0, 0.0, 0.03543716751982284, 0.04059372668349159, 0.03948314343807635, 0.08104931062193099, 0.0801890556792515, 0.07855187951085751, 0.020806169371402228, 0.024486100027191315, 0.0228235993229281, 0.06535564874253041, 0.06008205904448827, 0.06298349509620593, 0.0, 0.0, 0.0, 0.009772421672132436, 0.010702956519928919, 0.009580302344553981, 0.007567624426571107, 0.010051284513262426, 0.0075817499666051, 0.1213093542656678, 0.1304161139054778, 0.10770055214606788, 0.0, 0.0, 0.0]}}
{"id": "337d0bc5-ef10-489c-b56f-799d9cd4c6ac", "fitness": 0.039685773675664573, "name": "RefinedHybridDEPSO", "description": "Introduce a convergence-based dynamic inertia weight and crowding distance for improved exploration and exploitation balance in PSO-DE hybrid.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * np.exp(-5 * self.f_evals / self.budget))  # Exponential decay inertia\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.mean(distances)  # Use mean distance for smoother velocity control\n            \n            velocity_control_factor = 1 + 0.3 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.6 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 78, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03969 with standard deviation 0.05616.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.0859135958025321, 0.10649681441405079, 0.13900152469606586, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022580169088503133, 0.020000000000000018, 0.02311777775452728, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06665912117779305, 0.06065765510775545, 0.5380075528717916, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1580950992001937, 0.16331147346710284, 0.1731235568657803, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08057614957398018, 0.07324227683377416, 0.08337615220401684, 0.14745365552639156, 0.14315923047024715, 0.15358990747646994, 0.08941108059227332, 0.06285456569749892, 0.07433440031153316, 0.1193383534340492, 0.11080907274778151, 0.1329651544888566, 0.1297649295223633, 0.04764713977608748, 0.11076230079147242, 0.1470103917218063, 0.10739204965932347, 0.09609229435198907, 0.11165351598092732, 0.06337026919783084, 0.05391843686042819, 0.1706308954868082, 0.1349619864309648, 0.15869204255545044, 0.06537093701556773, 0.02674054977704554, 0.036892508166402216, 0.0401170072000987, 0.03630474470376255, 0.057590651773474555, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.015319041207577544, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011373665739539796, 0.010013327571313124, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07389861576009193, 0.06390264277154456, 0.06715244403051068, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.056836503480871436, 0.0652925772135039, 0.056995620515775336, 0.12629820957088445, 0.10162426142751657, 0.10281775224528589, 0.0705098578919825, 0.04086563918459174, 0.053936809511723194, 0.09608979193209688, 0.06960558572234066, 0.09935233545345834, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029982394127271772, 0.03701849804111235, 0.029492810950988102, 0.03793122799282567, 0.02740630647655551, 0.026372829431527967, 0.13419741298604537, 0.1503972832474736, 0.13828190602165735, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.000382190387659076, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028291895294951686, 0.033000718567680165, 0.030378903478095243, 0.0, 0.0, 0.0, 0.03153719327947835, 0.039812539334682984, 0.038922240611508396, 0.08253790367226799, 0.07965841969894782, 0.07712499243641413, 0.02154036740609344, 0.024192448856156457, 0.01873036502085834, 0.0659603198296006, 0.062017011379631115, 0.06102288649920562, 0.0, 0.0, 0.0, 0.009680786275894748, 0.010774616517059465, 0.009885441451964017, 0.008150985995648008, 0.010092926899107124, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "28849ee4-e6b2-45f8-b277-99cc96396afd", "fitness": -Infinity, "name": "AdaptiveMultiPopDEPSO", "description": "Introduce adaptive multi-population strategies with local leader election to potentiate global searches and maintain solution diversity.", "code": "import numpy as np\n\nclass AdaptiveMultiPopDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.main_pop_size = max(4, self.dim * 2)\n        self.sub_pop_size = max(2, self.dim)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.main_population = np.random.uniform(self.lb, self.ub, (self.main_pop_size, dim))\n        self.sub_population = np.random.uniform(self.lb, self.ub, (self.sub_pop_size, dim))\n        self.main_velocities = np.random.uniform(-1, 1, (self.main_pop_size, dim))\n        self.sub_velocities = np.random.uniform(-1, 1, (self.sub_pop_size, dim))\n        self.main_best_positions = np.copy(self.main_population)\n        self.sub_best_positions = np.copy(self.sub_population)\n        self.main_global_best_position = None\n        self.sub_global_best_position = None\n        self.main_best_values = np.full(self.main_pop_size, np.inf)\n        self.sub_best_values = np.full(self.sub_pop_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func, population, best_positions, best_values):\n        for i in range(population.shape[0]):\n            fitness_value = self.evaluate(func, population[i])\n            if fitness_value < best_values[i]:\n                best_values[i] = fitness_value\n                best_positions[i] = population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                if population is self.main_population:\n                    self.main_global_best_position = population[i]\n                else:\n                    self.sub_global_best_position = population[i]\n\n    def differential_evolution_step(self, func, population, best_positions, best_values):\n        F_base = 0.8\n        for i in range(population.shape[0]):\n            indices = np.random.choice(population.shape[0], 3, replace=False)\n            x1, x2, x3 = population[indices]\n            F = F_base + 0.2 * (np.std(population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < best_values[i]:\n                population[i] = trial\n                best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self, population, velocities, best_positions, global_best_position):\n        for i in range(population.shape[0]):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (best_positions[i] - population[i])\n            social = 2.0 * r2 * (global_best_position - population[i])\n            scaling_factor = 1.2\n            distances = np.linalg.norm(population - population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            velocities[i] = scaling_factor * (inertia_weight * velocities[i] + cognitive + social) * velocity_control_factor\n            population[i] = np.clip(population[i] + velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(best_values) < 1e-5:\n            population[:] = np.random.uniform(self.lb, self.ub, population.shape)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func, self.main_population, self.main_best_positions, self.main_best_values)\n            self.update_positions(func, self.sub_population, self.sub_best_positions, self.sub_best_values)\n            self.differential_evolution_step(func, self.main_population, self.main_best_positions, self.main_best_values)\n            self.differential_evolution_step(func, self.sub_population, self.sub_best_positions, self.sub_best_values)\n            self.particle_swarm_optimization_step(self.main_population, self.main_velocities, self.main_best_positions, self.main_global_best_position)\n            self.particle_swarm_optimization_step(self.sub_population, self.sub_velocities, self.sub_best_positions, self.sub_global_best_position)\n        return self.main_global_best_position if self.global_best_value <= min(self.sub_best_values) else self.sub_global_best_position, self.global_best_value", "configspace": "", "generation": 79, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {}}
{"id": "63b23aaf-2766-4a2f-80e1-e30e6db528e3", "fitness": -Infinity, "name": "RefinedHybridDEPSO", "description": "Adaptive Exploration-Exploitation Balance with Dynamic Population Resizing in Hybrid DE-PSO for Enhanced Convergence.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.min_population_size = 4\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def resize_population(self):\n        # Dynamic population resizing to enhance exploration-exploitation balance\n        resizing_factor = 1.0 - (self.f_evals / self.budget)\n        new_population_size = max(self.min_population_size, int(self.population_size * resizing_factor))\n        if new_population_size < self.population_size:\n            new_indices = np.random.choice(self.population_size, new_population_size, replace=False)\n            self.population = self.population[new_indices]\n            self.velocities = self.velocities[new_indices]\n            self.best_positions = self.best_positions[new_indices]\n            self.best_values = self.best_values[new_indices]\n            self.population_size = new_population_size\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n            self.resize_population()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 80, "feedback": "An exception occurred: ValueError('zero-size array to reduction operation minimum which has no identity').", "error": "ValueError('zero-size array to reduction operation minimum which has no identity')", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {}}
{"id": "9b46d2a5-9390-4427-8143-8c9216e1d93f", "fitness": 0.03936507252629365, "name": "EnhancedHybridDEPSO", "description": "Enhance exploration by dynamically adjusting crossover rate and adding noise to velocity updates for improved diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - np.std(self.best_values) / np.max(self.best_values))  # Adjusted crossover rate\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            noise_factor = np.random.uniform(-0.1, 0.1, self.dim)  # Added noise\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor + noise_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03937 with standard deviation 0.05712.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.11201357293458447, 0.09403778172378996, 0.2192626467631953, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02562580526055913, 0.02053015705273087, 0.030252997129757042, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07995526462414915, 0.0753913042377069, 0.5767721654043751, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03746167737829831, 0.0988614630610195, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03802812552178014, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11887187469727001, 0.16331147346710284, 0.13588317451109932, 0.020476744285247817, 0.020000000000000018, 0.020000000000000018, 0.07712769489897764, 0.0680671244774399, 0.09369430945386459, 0.13205948295460956, 0.14376536016476937, 0.1160417955509998, 0.08486895949517448, 0.11300037627373105, 0.06931124218583606, 0.1525297819821373, 0.09673653625177647, 0.12351598374713801, 0.020000000000000018, 0.020000000000000018, 0.11647492159827866, 0.1470103917218063, 0.06360782465788817, 0.08224885096453238, 0.08270217874803565, 0.08164627228118337, 0.08184914747822569, 0.15753905493955944, 0.11889151370926643, 0.1343020576463856, 0.05324254296423714, 0.022116525823324795, 0.02657375009670604, 0.03805217092726787, 0.03294631382758806, 0.04364331023191559, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05049969650708552, 0.01487188916211013, 0.02526540621659934, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07164385844248744, 0.05627092455367888, 0.07124345572809943, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055003660678801136, 0.06492822356577077, 0.05857001807576079, 0.1254741422823119, 0.09889220941895327, 0.10281775224528589, 0.061865465922281926, 0.041870605454387366, 0.053936809511723194, 0.093179397204463, 0.07780309898024695, 0.09836335082066017, 0.04153585301703988, 0.010000000000000009, 0.010000000000000009, 0.026116833661492755, 0.02904770161649506, 0.04008523941646003, 0.03729138556923839, 0.022673756866384065, 0.025484524959112687, 0.15690576657337207, 0.14453251666049138, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0017972521210666281, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026776682790382256, 0.03044796308823683, 0.0384769598217396, 0.0, 0.0, 0.0, 0.03597598902268628, 0.03765242724162887, 0.034215952184717624, 0.0837020778232872, 0.07988071457909063, 0.07719556858378906, 0.02109658644043877, 0.030396199132856294, 0.019314405665069367, 0.06599641754425523, 0.05877108554506816, 0.06113783434170028, 0.0, 0.0, 0.0, 0.009716114659982455, 0.010791019173432392, 0.009623757039830538, 0.007556461166257411, 0.010051284513262426, 0.007394907059878664, 0.11304620071633376, 0.1304161139054778, 0.11030510625605017, 0.0, 0.0, 0.0]}}
{"id": "43c3d956-8942-492f-810e-4d7cc44462f9", "fitness": 0.036159231600465094, "name": "EnhancedHybridDEPSO", "description": "Introduce adaptive mutation and crossover rates based on convergence and improve exploration by introducing chaotic maps in EnhancedHybridDEPSO.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.chaos_map = np.random.rand()  # Initialize chaotic map\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.3 * (np.std(self.population) / 5.0)  # Adjusted dynamic mutation factor (line changed)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            self.chaos_map = 4 * self.chaos_map * (1 - self.chaos_map)  # Logistic map for chaotic exploration (line changed)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (0.5 + 0.5 * self.chaos_map)  # Chaotic crossover rate (line changed)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03616 with standard deviation 0.04142.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08430833297994311, 0.09527923427285567, 0.14957015283277397, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576457098718473, 0.02387081865205465, 0.020820729776293345, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0839131785382915, 0.05121824753478166, 0.08675850205748514, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03569807577061457, 0.08594148016760361, 0.057929235093625686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10510925620673306, 0.12205985179588807, 0.15896815510074946, 0.030234663615721358, 0.020000000000000018, 0.02559678477250682, 0.07199809060947215, 0.08356814955468617, 0.0843061309049995, 0.1326195207865709, 0.13323277534341382, 0.1278070851267512, 0.07238783860336984, 0.0601283586908653, 0.09118922037237698, 0.12261412041638753, 0.10338213961315434, 0.12896650434414791, 0.12236912489147656, 0.020000000000000018, 0.11014048147616962, 0.08841851672483503, 0.09552890745409515, 0.09501154265780964, 0.06527120746322768, 0.04776537625935928, 0.05386574644312314, 0.1613185884181917, 0.13373323317281594, 0.13265814538956333, 0.038669801718039354, 0.046640767531981875, 0.027131580557983703, 0.03978370474441395, 0.037007204810747374, 0.055613650557648, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03708806910753748, 0.013697308284432386, 0.01635677852914119, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011880487246789362, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07212700278198969, 0.06196104699180138, 0.08385429405195355, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06313533328649923, 0.06152435499060227, 0.12754790259059035, 0.10065172933264988, 0.11136748467782509, 0.06892487753578858, 0.04243157902685868, 0.053936809511723194, 0.09551644954073923, 0.0727160778791831, 0.1113486899368078, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058786627304372896, 0.034743402900011544, 0.02885048768049847, 0.03963157148718355, 0.027348273042778537, 0.024904969219076367, 0.1332941309917518, 0.13123409970527322, 0.1393501126387352, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.008217045181238558, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02838452119231316, 0.03295225239415922, 0.030487764597612377, 0.0, 0.0, 0.0, 0.03615424246933108, 0.03887399873302044, 0.034215952184717624, 0.08200683696941047, 0.08003114951368417, 0.07712499243641413, 0.022638088191442418, 0.024483082906095355, 0.019575860637573772, 0.06607729187561884, 0.061729589426607445, 0.06471158816992495, 0.0, 0.0, 0.0, 0.009941496902627023, 0.010833938096958207, 0.009850132748071783, 0.007974345709769182, 0.010157896730383809, 0.00785411660182167, 0.11753673188074021, 0.1304161139054778, 0.10585371974967872, 0.0, 0.0, 0.0]}}
{"id": "00f0b37b-4fa8-413d-ac07-3b2f98fdd6a6", "fitness": 0.03862717674105545, "name": "EnhancedHybridDEPSO", "description": "Introduce adaptive neighborhood search and crowding distance-based reinitialization to enhance exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.sum(distances < np.mean(distances)) / len(distances)\n\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            crowded_indices = np.argsort(np.linalg.norm(self.population - np.mean(self.population, axis=0), axis=1))\n            for j in range(self.population_size // 2):\n                self.population[crowded_indices[j]] = np.random.uniform(self.lb, self.ub, self.dim)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03863 with standard deviation 0.05646.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10628354280316843, 0.14254179689417412, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02456485019118415, 0.02531379676266854, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.07175090851309651, 0.08813172152844084, 0.5780822388519495, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02038942146820588, 0.08594148016760361, 0.10086208663817786, 0.02947531066507192, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1250246157748578, 0.16331147346710284, 0.15139102049982978, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0870722178727823, 0.07324227683377416, 0.07632323064296032, 0.14745365552639156, 0.14315923047024715, 0.13748922169682343, 0.08941108059227332, 0.05877087738603881, 0.07967229405653298, 0.12171136952572115, 0.12188443668411353, 0.1287738704293454, 0.020000000000000018, 0.06599823631886981, 0.11486709227903047, 0.1470103917218063, 0.09211610726052555, 0.0865915223931526, 0.06527120746322768, 0.04616535580723691, 0.05507258990455488, 0.14829573879172875, 0.15332165533764874, 0.12403223555376597, 0.047349706918739076, 0.03535391843455915, 0.02657375009670604, 0.03676332345760058, 0.03425736991680006, 0.04926180428336391, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013634354773995438, 0.02173946563485374, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07119942520394862, 0.05788627034243443, 0.06854636823762905, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06122970114080106, 0.0652925772135039, 0.05395939349942802, 0.12846874648563356, 0.10565207985160785, 0.10281775224528589, 0.0664878985711268, 0.03900020676122562, 0.053936809511723194, 0.09135038086400082, 0.07160476549917949, 0.09676001746523188, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028179110731310297, 0.0347019700548975, 0.030720554649586673, 0.03516291798548199, 0.02315524222479748, 0.024641000983994465, 0.13975127101091256, 0.1503972832474736, 0.14104837083721988, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02886642171115894, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03349735002604404, 0.037702737358482175, 0.038922240611508396, 0.08208768213467199, 0.07965841969894782, 0.07712499243641413, 0.022259018857489266, 0.024192448856156457, 0.018561552921591118, 0.0660356487007212, 0.0610883027421224, 0.060694617163991604, 0.0, 0.0, 0.0, 0.009672112080777229, 0.011031592905224152, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10937269642092451, 0.0, 0.0, 0.0]}}
{"id": "d98a3533-3172-4353-8144-a409e754ec72", "fitness": 0.03747679265820536, "name": "ImprovedEnhancedHybridDEPSO", "description": "Integrate adaptive learning rates and stochastic restarts into EnhancedHybridDEPSO to maintain diversity and improve convergence robustness.", "code": "import numpy as np\n\nclass ImprovedEnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n            self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n    def adaptive_learning_rate(self):\n        return 0.1 + 0.9 * (1 - self.f_evals / self.budget)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n\n            # Implement stochastic restarts with small probability\n            if np.random.rand() < 0.01:\n                self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 84, "feedback": "The algorithm ImprovedEnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03748 with standard deviation 0.04407.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09591538294484436, 0.14586163459286572, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.038291208342485894, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.06090747270934471, 0.06293453442856733, 0.08910952733140931, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12806218372799438, 0.16331147346710284, 0.16390560842373614, 0.028467382615725012, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.09043013407187128, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.1366765266954022, 0.08941108059227332, 0.05999154170664933, 0.07299629306784994, 0.11972062280354545, 0.11312883107801586, 0.1415063152232563, 0.12236911737207379, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825111159579, 0.04776537690280014, 0.09031355384723161, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03867497930181785, 0.03985108091846645, 0.03386706579684329, 0.057536677780778867, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02818462702591029, 0.013557136881487852, 0.01745336980718415, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901010471, 0.06121409018485802, 0.06730931158039366, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05830572896068431, 0.07008234776633226, 0.05395939349942802, 0.12754790273435246, 0.10194265503935629, 0.10317224973527683, 0.06906887936676553, 0.040739346554354516, 0.053936809511723194, 0.09979798237311699, 0.07239621732617818, 0.1109024799215601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029934469069674896, 0.03632836096682812, 0.029489696169114232, 0.03961757438367908, 0.028766902102530856, 0.024640285494433645, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.033000718567680165, 0.03038440642721174, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03788570828422766, 0.038922240611508396, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.02197454168257229, 0.024483082906095355, 0.019575860637573772, 0.06612333839503692, 0.061729589426607445, 0.06094026276743891, 0.0, 0.0, 0.0, 0.00968008154441935, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "e10b0fce-2208-4fdb-9836-57bf9df937bb", "fitness": 0.038963267000615254, "name": "EnhancedHybridDEPSO", "description": "Introduce a feedback loop to dynamically adjust the crossover rate and scaling factor based on historical successes in DE steps to enhance adaptability.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.success_history = []\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        success_rate = np.mean(self.success_history[-5:]) if len(self.success_history) >= 5 else 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (0.5 + success_rate / 2)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n                self.success_history.append(1)\n            else:\n                self.success_history.append(0)\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03896 with standard deviation 0.05488.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09527923435424701, 0.14586450462028888, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576541631824877, 0.023799392609785475, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.062244164414793524, 0.06293453440568986, 0.5443309891776779, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03874107358775947, 0.08594148016760361, 0.08266709884943624, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13033250504800942, 0.16331147346710284, 0.1638578201186628, 0.028667425686258685, 0.020000000000000018, 0.020000000000000018, 0.07131407602902162, 0.07278439279635651, 0.0883786080609209, 0.14745365552639156, 0.13323277534341382, 0.13567550629332392, 0.08941108059227332, 0.059938978781739816, 0.06408139733975304, 0.11205586464406281, 0.10471235961481706, 0.14321410024058023, 0.12236910104527288, 0.020000000000000018, 0.11602719003010775, 0.08593056104096486, 0.09198479617712763, 0.07983635445502923, 0.08350341915927828, 0.0849523069829885, 0.05379367211913544, 0.15295353927733235, 0.13997343452913225, 0.15891391619059636, 0.04811247049849299, 0.0552166206398671, 0.034444607288879325, 0.039852957707780634, 0.04134987590030659, 0.05643262039661712, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034615429390306485, 0.01369731298738186, 0.015480560783088793, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07424667688581776, 0.061414094094804694, 0.08362168051514618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.07057436709307863, 0.05573102238910632, 0.12754790273572336, 0.10216424840105409, 0.10281775224528589, 0.06892487866650765, 0.03927528673335923, 0.053936809511723194, 0.09551669048237843, 0.07261850315561713, 0.11139974345453552, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03117009629936407, 0.03633454547413384, 0.029825034446838594, 0.03961757438367908, 0.028770641540803, 0.026867639040145108, 0.13329411941578284, 0.13123409970527322, 0.13866419112572015, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005208405808985739, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192288736, 0.03300022515575518, 0.030515765126543304, 0.0, 0.0, 0.0, 0.034081151819716826, 0.04074201754125528, 0.03431991505393617, 0.08219804574626166, 0.0800777408631107, 0.07717755097120549, 0.021927708395464873, 0.024483082906095355, 0.019575860637573772, 0.0653008689630401, 0.061729589426607445, 0.06292616976054088, 0.0, 0.0, 0.0, 0.009695055219544613, 0.010833938096958207, 0.009850050592696835, 0.007869620893046325, 0.010157896730316307, 0.007461291635591838, 0.1192121468264401, 0.1304161139054778, 0.11160963831975179, 0.0, 0.0, 0.0]}}
{"id": "96b46dfc-ddd6-44c1-8ae5-acd2c97350ea", "fitness": 0.0390644863542629, "name": "EnhancedHybridDEPSO", "description": "Improved velocity update by incorporating a time-varying acceleration coefficient for better convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n\n            # Adjust the social component with a time-varying coefficient\n            T = self.f_evals / self.budget\n            social *= (1 + 0.5 * (1 - T))  # Time-varying acceleration coefficient\n\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03906 with standard deviation 0.05688.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08423954570556391, 0.11345433191377108, 0.15261715623028094, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03324457157135852, 0.020000000000000018, 0.020138335917513683, 0.021062419885162775, 0.020000000000000018, 0.03102006128017809, 0.0779964995131468, 0.08858668704631345, 0.5806523835150543, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.023610895192595627, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11793457744410996, 0.16331147346710284, 0.1333364550628806, 0.020235910430518644, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.07324227683377416, 0.07160932741291748, 0.14745365552639156, 0.14315923047024715, 0.13010215746410614, 0.08941108059227332, 0.05425189282683984, 0.06777853721598759, 0.11732927276896987, 0.13344364797507668, 0.13228653860605843, 0.03309999553980303, 0.12322812094423652, 0.11835959135080576, 0.1470103917218063, 0.10643545593401826, 0.07667167264800068, 0.06527120746322768, 0.04616535580723691, 0.054279678248511654, 0.14878632368074451, 0.15379924385284316, 0.13895447394402505, 0.04922503835766179, 0.03537567767751837, 0.028204791413724006, 0.03672076264333002, 0.03600954429833958, 0.050494268860908575, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02831817329758901, 0.013557136881487852, 0.018520998127701027, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07333999833340454, 0.05958587741262078, 0.06726670149138936, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06297285042980305, 0.0652925772135039, 0.05395939349942802, 0.12802903359163542, 0.10424600908278558, 0.10281775224528589, 0.0749073125241485, 0.037164703210938344, 0.053936809511723194, 0.0991184079627555, 0.07374362714900018, 0.09751404655427331, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02962953326791773, 0.0347019700548975, 0.0329925313412428, 0.03659929542710505, 0.023495875824857793, 0.025353180562324162, 0.13492699595654156, 0.1503972832474736, 0.13605165952222353, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.00016226257291918067, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028511370763288357, 0.033000718567680165, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03153719327947835, 0.03753213255583987, 0.038922240611508396, 0.081058759356881, 0.08005282643769229, 0.07712499243641413, 0.021577533679510985, 0.024479434276419743, 0.018449874749746464, 0.06608457132902401, 0.061187780209634446, 0.06058280166632146, 0.0, 0.0, 0.0, 0.009673394482436648, 0.010946529495715507, 0.009885441451964017, 0.008151065767449062, 0.010051284513262426, 0.00743479250564183, 0.11622223347639249, 0.1304161139054778, 0.10857147485085294, 0.0, 0.0, 0.0]}}
{"id": "1b75904b-d47e-4b81-a439-59c28bd8682e", "fitness": 0.036712774182947744, "name": "RefinedHybridDEPSO", "description": "Integrate a self-adaptive mutation probability and perturbation-based reinitialization in DE steps to enhance global search capability.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            mutation_probability = 0.2 + 0.8 * (self.f_evals / self.budget)  # Self-adaptive mutation probability\n            trial = np.where(np.random.rand(self.dim) < mutation_probability, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            perturbation = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n            self.population += perturbation\n            self.population = np.clip(self.population, self.lb, self.ub)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 87, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03671 with standard deviation 0.04305.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08280319371162326, 0.1078366845298373, 0.16080794387945874, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03617444309085638, 0.020000000000000018, 0.022933202490700633, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08441087698687422, 0.0625661134756984, 0.06351651121078017, 0.020000000000000018, 0.05172277076870757, 0.020000000000000018, 0.03874107358775947, 0.08594148016760361, 0.07381700752894294, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12623907965592285, 0.12361475168375857, 0.20081846627813238, 0.025747538546657123, 0.020000000000000018, 0.020000000000000018, 0.07134006364295264, 0.06678676026393238, 0.06499127536180904, 0.13143040560906338, 0.14871047603663468, 0.13805298075628625, 0.06811578502035986, 0.061411105798424015, 0.07907463567679018, 0.11205586464406281, 0.11392327734459284, 0.14170310244262285, 0.12236911737207379, 0.020000000000000018, 0.12342810568909968, 0.08415684366680953, 0.10922886220783345, 0.07987294583157312, 0.08267686845061573, 0.059435981242646374, 0.05957944474295607, 0.1438526290318487, 0.1363657335940105, 0.1540864870625035, 0.038669801718039354, 0.02934911359125436, 0.028280795115542268, 0.03905384234856124, 0.034980609145044306, 0.055613650557648, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030385407975644485, 0.011246909903819824, 0.016986813274809665, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011511695217639062, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0725085872952278, 0.061722938471046374, 0.08544117150933983, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055889253018112206, 0.06521665732076998, 0.05395939349942802, 0.12045030551809888, 0.10063668166547857, 0.10281775224528589, 0.07600246868292915, 0.04874938485883662, 0.053936809511723194, 0.09551669048237843, 0.07630801119358199, 0.11133807285190434, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03133065814077984, 0.03468770736704985, 0.028595870466938234, 0.03961757438367908, 0.027345081184922182, 0.02663710934136021, 0.13554364740010005, 0.14198619501369114, 0.13926404256399805, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0009344351291611375, 0.0003892263461244827, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326595, 0.03138950541346186, 0.03634091500798842, 0.0, 0.0, 0.0, 0.03383060691882123, 0.03955056880646135, 0.03721041577842188, 0.0818968007760088, 0.08003114951368417, 0.07712499243641413, 0.021906370923967966, 0.024483082906095355, 0.019575860637573772, 0.06549393905316525, 0.061729589426607445, 0.06036301339767869, 0.0, 0.0, 0.0, 0.009695024447087919, 0.010833938096958207, 0.009449803402120649, 0.007715771125591964, 0.010157896730316307, 0.007416686536787842, 0.12109753145692848, 0.1304161139054778, 0.1111001700851767, 0.0, 0.0, 0.0]}}
{"id": "63571486-9d98-4985-a93e-1bd02a985aa0", "fitness": 0.03898299781239158, "name": "EnhancedHybridDEPSO", "description": "Slightly adjusted the mutation factor control to enhance adaptability during optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base * (1 + 0.2 * (np.std(self.best_values) / 5.0))  # Adjusted mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03898 with standard deviation 0.05507.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09550949842070855, 0.161145660161643, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023745776374139105, 0.02487130338723431, 0.022343008726087188, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0711250010282245, 0.06085793655399019, 0.5440687718626118, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03874107358775947, 0.08594148016760361, 0.08321611387007632, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08675116352317302, 0.12179784035722818, 0.16457390665764504, 0.029916238289118602, 0.020000000000000018, 0.020000000000000018, 0.10329735307141052, 0.07815707579841424, 0.09710944423445167, 0.15657497119619246, 0.13453442527837634, 0.15743190452054634, 0.08128982088828907, 0.08065066497810436, 0.06808499948991875, 0.12194432919058718, 0.12227784156595012, 0.14151142174623166, 0.12285326935600227, 0.020000000000000018, 0.11602719003010775, 0.08450886882389408, 0.11021934657985843, 0.07667167264800068, 0.11167668007642395, 0.04776537639513412, 0.05388217018080055, 0.1444081374016829, 0.14108892018018548, 0.15104366200251618, 0.038669801718039354, 0.04396718207999828, 0.037550931636447404, 0.03905384234856124, 0.025376716946375333, 0.05614502664455434, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03244651280858046, 0.013515801684803819, 0.018596826942444022, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07478473371785188, 0.06094192702649481, 0.08362168051514618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.054635368775303395, 0.062005959253081055, 0.05650148319682291, 0.12754790233768565, 0.10170916093727356, 0.10281775224528589, 0.06906887578167242, 0.04857760706563963, 0.053936809511723194, 0.09551669048237843, 0.07226923330798785, 0.11140368711654103, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029954542639812676, 0.034034648604700846, 0.029646763324934655, 0.03961757438367908, 0.028639033692778315, 0.025482489423174326, 0.13343741139015264, 0.13123409970527322, 0.13533636082073086, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00020946908400898412, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326595, 0.03126339022459068, 0.03038440642721174, 0.0, 0.0, 0.0, 0.037027371201224346, 0.03753213255583987, 0.03431991507369958, 0.08252518370414963, 0.08003114951368417, 0.07712499243641413, 0.021264918173327096, 0.024483082906095355, 0.019575860637573772, 0.06541048692396234, 0.061729589427969134, 0.06081986037989895, 0.0, 0.0, 0.0, 0.00968006919372455, 0.010833938096958207, 0.009948757041048473, 0.008064498537687648, 0.010157896730316307, 0.007427401828041025, 0.11507444649646548, 0.1304161139054778, 0.11891992176531818, 0.0, 0.0, 0.0]}}
{"id": "75cb8760-4310-4095-86fd-b88e9183a3d0", "fitness": 0.039325159816620735, "name": "AdaptiveMultiSwarmOptimizer", "description": "Introduce adaptive multi-swarm architecture with dynamic role allocation to enhance exploration and exploitation balance throughout the optimization process.", "code": "import numpy as np\n\nclass AdaptiveMultiSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.swarm_roles = np.random.choice(['explorer', 'exploiter'], self.population_size)\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def adaptive_differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def adaptive_particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic role-based velocity adaptation\n            if self.swarm_roles[i] == 'explorer':\n                velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            else:\n                velocity_control_factor = 0.5 + 0.5 * np.tanh(crowding_distance)\n            \n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n            # Reassign roles for dynamic adaptability\n            self.swarm_roles = np.random.choice(['explorer', 'exploiter'], self.population_size)\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.adaptive_differential_evolution_step(func)\n            self.adaptive_particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03933 with standard deviation 0.05935.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.11201521428497363, 0.10038716857081686, 0.14955891550073053, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02140426299215903, 0.020485789481381023, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022618317378153008, 0.08062314177053087, 0.637227988933899, 0.10991388391785062, 0.020000000000000018, 0.025765650531831996, 0.020000000000000018, 0.059228015506152754, 0.08594148016760361, 0.07622394446464964, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023415299470896378, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10216637373679904, 0.12207604273859884, 0.15941767900703385, 0.029447780491396736, 0.020000000000000018, 0.02559678477250682, 0.09503881444425999, 0.08340099656151212, 0.11207726016049624, 0.1317883881051195, 0.13323277534341382, 0.176917078888585, 0.0788489258221382, 0.06212043341898732, 0.08992854412663276, 0.11263727053142814, 0.1290906994094897, 0.12725359715260054, 0.020000000000000018, 0.020000000000000018, 0.10546521226162009, 0.1039885766796741, 0.10866699972470284, 0.07877006976065859, 0.06994469443671891, 0.07291720072052033, 0.05377622312072672, 0.1438526290318487, 0.14780776711570753, 0.15394674560350396, 0.04027118577990507, 0.020000000000000018, 0.03246664228944274, 0.04359749202508789, 0.02704999503721406, 0.05573632015543584, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02517538069569636, 0.023612369863890703, 0.014906119109436733, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018674246038901887, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07518393070168428, 0.05981860776512249, 0.0835604677656202, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07133406946030807, 0.06147825531143891, 0.06461478414308663, 0.1235286047747941, 0.09508869504853279, 0.10281775224528589, 0.06171461608223794, 0.0372735587368378, 0.053936809511723194, 0.09270517315189897, 0.07530507471422199, 0.11135121371648049, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030487271025994578, 0.029075136101813226, 0.029754740778071387, 0.02588322925221842, 0.02473701989029775, 0.02941839426736248, 0.16228562657105894, 0.13481661973535974, 0.13386999777181108, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0016871729851206663, 0.0004693179136299186, 0.00010511672940993755, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.032047641737162014, 0.030586067399454575, 0.031495913823681554, 0.0, 0.0, 0.0, 0.03149164793169523, 0.03815641279506621, 0.03482878538968914, 0.08212606562664282, 0.08196826654407896, 0.07733193515743708, 0.022078630680130495, 0.024404052083568772, 0.018537595280963992, 0.07173279605476368, 0.06235009110719436, 0.06330600347433224, 0.0, 0.0, 0.0, 0.010053598273898512, 0.01101655837983595, 0.009759312752482874, 0.007869180486414384, 0.01023357063152841, 0.007642403747734061, 0.11163461607301339, 0.1304161139054778, 0.11439161776908857, 0.0, 0.0, 0.0]}}
{"id": "0d70f93f-ab37-4038-a30b-8914bc7f7397", "fitness": 0.03956622453663807, "name": "EnhancedHybridDEPSO", "description": "Integrate adaptive learning rates and mutation factors in DE and PSO steps for enhanced convergence control.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.3 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.3  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03957 with standard deviation 0.05730.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10055323199981259, 0.14120547742793066, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020771891687047517, 0.02373078922586147, 0.02576640742790204, 0.021168750825439453, 0.020000000000000018, 0.020000000000000018, 0.06365741001833725, 0.06277742965510702, 0.5756519436155385, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10832180052346274, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12814877166871497, 0.1570328723561084, 0.16239099140312163, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10329552894617167, 0.08369021575230506, 0.09858360857452186, 0.15011863818328708, 0.13323277534341382, 0.14151934072403238, 0.08520701271166109, 0.06639701605244908, 0.0817354903772215, 0.11531526671305958, 0.1438879223304198, 0.13519566834275054, 0.139420111217199, 0.020000000000000018, 0.11594922933596508, 0.13836789056187881, 0.10771317398508329, 0.08040942536375217, 0.0848468692468839, 0.04690790534062084, 0.06371303004920292, 0.1438526290318487, 0.14140759918192103, 0.14085983455029516, 0.048672674841795494, 0.03628101475425605, 0.027771618063111125, 0.03937842394439228, 0.03463307327275911, 0.05564880733411004, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027803164316473783, 0.013522172056331105, 0.01836561338969145, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010186242277746338, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07228475746211604, 0.0607245958957654, 0.08301781893193005, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05951929529550737, 0.06212042823879882, 0.056204302846735166, 0.1322058521527668, 0.1036465732015327, 0.10281775224528589, 0.075637670726308, 0.045262726850203605, 0.053936809511723194, 0.09295287428555654, 0.07146773622258307, 0.09888006397811966, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028613951378444025, 0.030549687161482764, 0.03053325367751336, 0.039265935172684174, 0.0251582913609667, 0.025502069460339283, 0.13846781358257576, 0.1514700700470597, 0.14896667144205789, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022830885802772594, 7.251808907993151e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028481256524238052, 0.032950924961966055, 0.029890571760543994, 0.0, 0.0, 0.0, 0.03640328636268508, 0.03753213255583987, 0.039558326315252135, 0.08099392965114627, 0.07993725186144518, 0.07712499243641413, 0.021921783109802417, 0.02430783411451931, 0.019054228987886668, 0.06598186791354055, 0.06320796261944339, 0.06040086346766638, 0.0, 0.0, 0.0, 0.00967350014305357, 0.0109200656155789, 0.00986051887381778, 0.008168890637502257, 0.010051284513262426, 0.007429505376167933, 0.1112398058338967, 0.1304161139054778, 0.11568806520217112, 0.0, 0.0, 0.0]}}
{"id": "ef7e0169-dc63-4cf8-8203-d127bc2a3eaa", "fitness": 0.03874143392721516, "name": "EnhancedHybridDEPSO", "description": "Enhance velocity updating by incorporating a random perturbation component to boost exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2, r3 = np.random.rand(3)  # Additional random factor\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social + 0.1 * r3) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03874 with standard deviation 0.05597.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.11492887647739536, 0.09879403520589125, 0.15563250969657627, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02407399618407391, 0.020158788287173213, 0.020000000000000018, 0.021062419885162775, 0.020000000000000018, 0.020000000000000018, 0.08140630193755849, 0.07912047401041489, 0.5646373300630901, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.10086208663817786, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11609688863955114, 0.16331147346710284, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07932796414964427, 0.07324227683377416, 0.0765580851861205, 0.14745365552639156, 0.14315923047024715, 0.11879639174152312, 0.08941108059227332, 0.06571159057516074, 0.07104936389514038, 0.13691830041338449, 0.11231612729102936, 0.12475767168263063, 0.020000000000000018, 0.020000000000000018, 0.13801220165874495, 0.1470103917218063, 0.10946655823400775, 0.08520381371379071, 0.0876885320290508, 0.04838000717622126, 0.05425397418723277, 0.1472218653591656, 0.1349619864309648, 0.12847871672443067, 0.053603766341713266, 0.03218619108025833, 0.033738960309258825, 0.04021037761222146, 0.038929528496664756, 0.058780456601661424, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03266491865510002, 0.01386266366986666, 0.021271380164782694, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01199348557582991, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08279289879538831, 0.06098133772781478, 0.07570004226975213, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05670108274876484, 0.06976074601713866, 0.05395939349942802, 0.12205054752394917, 0.09526501312138025, 0.10588467954458536, 0.06406273400695117, 0.03877460885196893, 0.053936809511723194, 0.0957610821936552, 0.08246899390159412, 0.10947500656521891, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02569893211196228, 0.0347019700548975, 0.03283523299566293, 0.039500960337111146, 0.02320815756471295, 0.02478124914051949, 0.1344349994944345, 0.1503972832474736, 0.1403294665629623, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002249876884270585, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028229874290385926, 0.035460364295597735, 0.030110247457620143, 0.0, 0.0, 0.0, 0.032566891889642346, 0.03753213255583987, 0.038922240611508396, 0.08402442835565427, 0.07986115213145273, 0.07810369655860327, 0.02089890047118559, 0.024395760919610043, 0.01867687212664393, 0.06583148344077838, 0.06311835055474657, 0.06166491899817117, 0.0, 0.0, 0.0, 0.009728938182045122, 0.01100250056418417, 0.009885441451964017, 0.008136655007303983, 0.010051284513262426, 0.0075500831785756395, 0.11619717782090566, 0.1304161139054778, 0.10657390805516731, 0.0, 0.0, 0.0]}}
{"id": "71846a0a-1ceb-45ce-8b30-09277eb6a86e", "fitness": -Infinity, "name": "AdvancedHybridDEPSO", "description": "Integrate Levy flight-based dynamic escapism and adaptive learning in DEPSO to enhance exploration and convergence efficiency.", "code": "import numpy as np\n\nclass AdvancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def levy_flight(self, size):\n        # Using Levy flight to introduce large jumps\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            levy_step = self.levy_flight(self.dim) * (1 - self.f_evals / self.budget)\n\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor + levy_step\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 92, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {}}
{"id": "8e690b9e-102d-477e-aa24-915570e8a616", "fitness": 0.03695882553980009, "name": "RefinedHybridDEPSO", "description": "Integrate an adaptive neighborhood search strategy to dynamically adjust exploration and exploitation during different convergence stages.", "code": "import numpy as np\n\nclass RefinedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.7\n        adaptive_scale = 0.3 * (1 - self.f_evals / self.budget)\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + adaptive_scale\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget)\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 1.5 * r1 * (self.best_positions[i] - self.population[i])\n            social = 1.5 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            # Calculate local neighborhood exploration factor\n            neighborhood_indices = np.random.choice(self.population_size, self.population_size // 4, replace=False)\n            neighborhood_distance = np.mean([np.linalg.norm(self.population[i] - self.population[j]) for j in neighborhood_indices])\n            \n            # Dynamic control based on neighborhood distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(neighborhood_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 93, "feedback": "The algorithm RefinedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03696 with standard deviation 0.04337.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08474106018006611, 0.1027902224335483, 0.17241553430388823, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02624492179558391, 0.029819285028536813, 0.020000000000000018, 0.021174228355158253, 0.020000000000000018, 0.023284291534945822, 0.07297839189356126, 0.05611178467117195, 0.07328127084169889, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0205199311100841, 0.13902175997624477, 0.10832180052346274, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.10393609976332185, 0.15733623905592642, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.02723803516096679, 0.09977151642964399, 0.10262792082830852, 0.09392177243255917, 0.15060018401559316, 0.14460835608545608, 0.1230101183892569, 0.08483301176539437, 0.08082545344111536, 0.05942641528226178, 0.11709025305856446, 0.1260261232376133, 0.12414367506726454, 0.020000000000000018, 0.03813382865882542, 0.1394418509532227, 0.13660668384261954, 0.086270622601469, 0.11706737976236292, 0.06527120746322768, 0.04616535580723691, 0.09552611818322054, 0.14632530412203726, 0.11765541228214882, 0.143113489291535, 0.04999869364696341, 0.02451535907197444, 0.0399522881172365, 0.04204360226687942, 0.032100262821798564, 0.056137940826931354, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028634357822553413, 0.013460027014910114, 0.014309786859879492, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01175320403574065, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08101602495338667, 0.06086117731469132, 0.07507822005753861, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058365662335239654, 0.06628281545621517, 0.05964186196636523, 0.12339620221644321, 0.09719639070863095, 0.10298278260966665, 0.06908326653729735, 0.04370787406503385, 0.054642198181019785, 0.0924979366366131, 0.07747288267817143, 0.09688058540087152, 0.03208891264728864, 0.010000000000000009, 0.010000000000000009, 0.025531725294570706, 0.033976344330914565, 0.03605166890521061, 0.040181450868245316, 0.02332765510653756, 0.024735249329491005, 0.1455263772295804, 0.13123409970527322, 0.13804130800700054, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0022876844361170434, 0.0004170346303379313, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.030800680794743407, 0.033023146383846624, 0.03149464647253131, 0.0, 0.0, 0.0, 0.03203118138113692, 0.03753213255583987, 0.03525515877847407, 0.08094003271825045, 0.08003018652011618, 0.07785818458346838, 0.02203646719332919, 0.024192448856156457, 0.02082850845312767, 0.06626563683206488, 0.06116737337282585, 0.06557447183565901, 0.0, 0.0, 0.0, 0.010007745611174013, 0.010618216925484814, 0.009922479637991422, 0.008115066209761324, 0.010051284513262426, 0.007591564411334573, 0.1164222606496057, 0.1304161139054778, 0.1069944727704718, 0.0, 0.0, 0.0]}}
{"id": "95e00e39-16ff-4b0a-91cb-6dbda4430219", "fitness": 0.03972448789143687, "name": "EnhancedHybridDEPSO", "description": "Introduce a dynamic crossover rate based on the fitness diversity to enhance exploration in Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            fitness_std = np.std(self.best_values) + 1e-9  # Prevent division by zero\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (1 + 0.5 * (fitness_std / np.max(self.best_values)))  # Dynamic crossover rate based on fitness diversity\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03972 with standard deviation 0.05625.", "error": "", "parent_ids": ["8cfad4bc-5720-4a64-84ee-ede4159f3cd7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09548019360906634, 0.21298653304369142, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.028567191725297536, 0.020000000000000018, 0.020000000000000018, 0.03067231673726356, 0.06090747270934471, 0.0629345344101937, 0.5439929185886174, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04834601760585666, 0.08594148016760361, 0.0989799418979751, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12109459164630887, 0.16274191586177078, 0.1638799832154344, 0.02849324248935825, 0.020000000000000018, 0.023783992455458036, 0.09297379712189235, 0.08740710798082152, 0.06972447244211366, 0.1314109920733625, 0.13409011228285939, 0.14146233930794172, 0.06951326177966588, 0.0598309067617212, 0.07682666024563867, 0.11972062280354545, 0.11103034668390821, 0.14343755221625853, 0.12236911376606263, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825113262242, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.039851397710076286, 0.031235080838346252, 0.055613645143364865, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028189293365222468, 0.013732278743885384, 0.01809771255178927, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010101118461646741, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901017665, 0.06125927032537304, 0.08506791165462158, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06100337753445795, 0.06204022707579171, 0.05395939349942802, 0.12754790273435246, 0.10049801370107436, 0.10281775224528589, 0.06906887936676553, 0.04857760706563963, 0.053936809511723194, 0.10264046154172901, 0.072397174699103, 0.1109510359164525, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02896588857204563, 0.03632836199117595, 0.02964671008097408, 0.03961757438367908, 0.027206801911722756, 0.025481546363020025, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00012585803839360032, 0.00038913938647544555, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.03110960165714205, 0.03038440642721174, 0.0, 0.0, 0.0, 0.034081151819716826, 0.03788570828423754, 0.034319915037420934, 0.08189680077626971, 0.08003114951368417, 0.07712499243641413, 0.02192121767798616, 0.024483082906095355, 0.019575860637573772, 0.06615752005792364, 0.061729589426607445, 0.06039162359781969, 0.0, 0.0, 0.0, 0.00968008128186082, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11635803522833232, 0.1304161139054778, 0.1062276650369065, 0.0, 0.0, 0.0]}}
{"id": "4a8dc78d-769c-4171-ad64-3802daf27636", "fitness": 0.038409690471550816, "name": "EnhancedHybridDEPSO", "description": "Introduced a fitness diversity-based adaptive scaling factor for velocity control to enhance convergence in EnhancedHybridDEPSO.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)  # Dynamic mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            fitness_std = np.std(self.best_values) + 1e-9  # Prevent division by zero\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (1 + 0.5 * (fitness_std / np.max(self.best_values)))  # Dynamic crossover rate based on fitness diversity\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))  # Adaptive inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            diversity_factor = np.std(self.best_values) / (np.abs(np.mean(self.best_values)) + 1e-9)  # Adaptive scaling based on fitness diversity\n            scaling_factor = 1.2 * (1 + diversity_factor)  # Scaling factor for velocity diversification\n\n            # Calculate crowding distance to control exploration\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            \n            # Dynamic control based on crowding distance\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  # Diversity-based reinitialization\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03841 with standard deviation 0.05697.", "error": "", "parent_ids": ["95e00e39-16ff-4b0a-91cb-6dbda4430219"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09403823573503955, 0.20128080860984, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03472952947068331, 0.027735960627869094, 0.020000000000000018, 0.020000000000000018, 0.024200116040113073, 0.03067231673726356, 0.06620659621594827, 0.08718864192981979, 0.5773757444660367, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08594148016760361, 0.0989799418979751, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07692651759206948, 0.16274191586177078, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07301587325972558, 0.0917313126893744, 0.0925095022135255, 0.13148513908093806, 0.14192938645819553, 0.1478612449986949, 0.06951326177966588, 0.06525020966808337, 0.07860980611297885, 0.1383877108028807, 0.13919616384101519, 0.15199422253390482, 0.020000000000000018, 0.020000000000000018, 0.07330433776432921, 0.1470103917218063, 0.10829979209594198, 0.08687819367796379, 0.07095696813042351, 0.04694729441739098, 0.05470495023051869, 0.1493063393163263, 0.1349619864309648, 0.1738807625562364, 0.05630879457420379, 0.027886942184766728, 0.029320087581985232, 0.027777775474184474, 0.023756746883114466, 0.03910155267332782, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028189293365222468, 0.013918491985605463, 0.020132812372776865, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06942141699086302, 0.0519382741800265, 0.07501186036207397, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06444223248127012, 0.06164045633893589, 0.05443570247197105, 0.11869262382913237, 0.09439080260100441, 0.10281775224528589, 0.05865186180619175, 0.043827434012773, 0.053936809511723194, 0.09805103052878228, 0.07204596274898056, 0.09673575287649216, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0289839085063065, 0.035429648350058573, 0.029689740987514424, 0.03955369977179457, 0.0278555283327373, 0.025376798764682573, 0.13319877038690553, 0.1503972832474736, 0.13631361986263146, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0004184427989832873, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.029826028633369694, 0.030163622104217414, 0.02994405764252106, 0.0, 0.0, 0.0, 0.034081151819716826, 0.03753213255583987, 0.034215952184717624, 0.08072778292416571, 0.07965841969894782, 0.07712499243641413, 0.02309494223289421, 0.024192448856156457, 0.01849767221278642, 0.06552616496207608, 0.062021694640530756, 0.060255042879574505, 0.0, 0.0, 0.0, 0.009679396897783854, 0.010843049513398872, 0.009885441451964017, 0.00814261954825457, 0.010114802116684252, 0.00743479250564183, 0.11635803522833232, 0.1304161139054778, 0.10796649196735697, 0.0, 0.0, 0.0]}}
{"id": "c137807c-c7c1-4786-8efb-484c47a09927", "fitness": 0.03971748256119617, "name": "EnhancedHybridDEPSO", "description": "Introduce an adaptive population size and a novel restart mechanism in EnhancedHybridDEPSO to enhance exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.initial_population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.initial_population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(len(self.population)):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(len(self.population)):\n            indices = np.random.choice(len(self.population), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            fitness_std = np.std(self.best_values) + 1e-9\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (1 + 0.5 * (fitness_std / np.max(self.best_values)))\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(len(self.population)):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.initial_population_size, self.dim))\n            self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, self.dim))\n\n    def adaptive_population_management(self):\n        if self.f_evals / self.budget > 0.7:\n            current_size = len(self.population)\n            if current_size > self.dim:\n                self.population = self.population[:self.dim]\n                self.velocities = self.velocities[:self.dim]\n                self.best_positions = self.best_positions[:self.dim]\n                self.best_values = self.best_values[:self.dim]\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n            self.adaptive_population_management()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03972 with standard deviation 0.05625.", "error": "", "parent_ids": ["95e00e39-16ff-4b0a-91cb-6dbda4430219"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.09548019360906634, 0.21298653304369142, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023576570137820774, 0.023817299137918968, 0.028567191725297536, 0.020000000000000018, 0.020000000000000018, 0.03067231673726356, 0.06090747270934471, 0.0629345344101937, 0.5439929185886174, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04834601760585666, 0.08594148016760361, 0.0989799418979751, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03952070214882453, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12109459164630887, 0.16274191586177078, 0.1638799832154344, 0.02849324248935825, 0.020000000000000018, 0.023783992455458036, 0.09297379712189235, 0.08740710798082152, 0.06972447244211366, 0.1314109920733625, 0.13409011228285939, 0.14146233930794172, 0.06951326177966588, 0.0598309067617212, 0.07682666024563867, 0.11972062280354545, 0.11103034668390821, 0.14343755221625853, 0.12236911376606263, 0.020000000000000018, 0.11602719003010775, 0.1470103917218063, 0.10884677519573505, 0.08880535241289078, 0.11150825113262242, 0.04776537690280014, 0.054279678248511654, 0.1438526290318487, 0.1349619864309648, 0.1589139162928075, 0.038669801718039354, 0.0552166206398671, 0.03462062017049039, 0.039851397710076286, 0.031235080838346252, 0.055613645143364865, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028189293365222468, 0.013864719756531363, 0.017905755292271452, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010780152338818128, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07379544901017665, 0.06037084639250201, 0.08506791165462158, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06100337753445795, 0.06204022707579171, 0.05395939349942802, 0.12754790273435246, 0.10018262325568505, 0.10281775224528589, 0.06906887936676553, 0.04857760706563963, 0.053936809511723194, 0.10264046154172901, 0.07329530322923039, 0.1109024799215601, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02896588857204563, 0.03632836199117595, 0.029489696169114232, 0.03961757438367908, 0.027206801911722756, 0.024640285494433645, 0.13336588564014873, 0.1503972832474736, 0.13865767091849168, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00012585803839360032, 0.00038913938647544555, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028384521192326817, 0.03110960165714205, 0.03038440642721174, 0.0, 0.0, 0.0, 0.034081151819716826, 0.03788570828423754, 0.034319915037420934, 0.08189680077626971, 0.08003114951368417, 0.07712499243641413, 0.02192121767798616, 0.024483082906095355, 0.019575860637573772, 0.06615752005792364, 0.061729589426607445, 0.06039162359781969, 0.0, 0.0, 0.0, 0.00968008128186082, 0.010833938096958207, 0.009885441451964017, 0.008142145109170662, 0.010157896730316307, 0.00743479250564183, 0.11635803522833232, 0.1304161139054778, 0.1062276650369065, 0.0, 0.0, 0.0]}}
{"id": "ba0107a5-fcec-46eb-a518-d3259319929c", "fitness": 0.03369405038395885, "name": "EnhancedAdaptiveDEPSO", "description": "Introduce adaptive scaling of exploration-exploitation balance by dynamically adjusting weights and mutation factor based on convergence progress and population diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base * (1 + np.std(self.best_values) / (np.mean(self.best_values) + 1e-9))  # Adaptive mutation factor\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n\n            fitness_std = np.std(self.best_values) + 1e-9\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (1 + (fitness_std / np.max(self.best_values)))\n            \n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + 0.5 * np.exp(-0.05 * self.f_evals / self.budget)  # Exponentially decaying inertia weight\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n\n            # Dynamic scaling factor\n            scaling_factor = 1.5 * (1 - np.tanh(np.std(self.population)))\n            velocity_control_factor = 1 + 0.5 * (1 - self.f_evals / self.budget)\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        # Diversity-based reinitialization\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:  \n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03369 with standard deviation 0.04012.", "error": "", "parent_ids": ["95e00e39-16ff-4b0a-91cb-6dbda4430219"], "operator": null, "metadata": {"aucs": [0.08474809454384546, 0.07602291716929865, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020861065909616894, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.052377091758063155, 0.07661841477229359, 0.047339700007405505, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023508059923133207, 0.08594148016760361, 0.057929235093625686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0852010876128354, 0.09618656022194638, 0.13084903150896143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08032553569626355, 0.130327197066628, 0.10065147132261221, 0.13988776965129746, 0.13323277534341382, 0.14627352392653847, 0.06844334524236362, 0.04811300465860091, 0.06948158571820073, 0.1245665476566089, 0.12281956907713254, 0.13102897518613632, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15365988600029534, 0.07411279958544814, 0.07747301456052835, 0.06527120746322768, 0.07386688159921784, 0.048235459302178985, 0.1438526290318487, 0.14200624233991987, 0.134262242769276, 0.04105392463384472, 0.02339265962039716, 0.0317521933121383, 0.02396089930620038, 0.01790405919860827, 0.03910155267332782, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.032148687270895926, 0.016595998785592037, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06973424657320393, 0.052692729346808576, 0.0748255917388666, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0682700594818556, 0.054949089572750465, 0.11880698817842572, 0.09384823169585399, 0.10281775224528589, 0.05780722334462718, 0.03518359929680204, 0.053936809511723194, 0.07896945735270666, 0.06599491587631146, 0.09141549977667962, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03560331133156969, 0.04998866254107981, 0.028299512911530766, 0.024895242935785933, 0.022487143875263516, 0.024640285494433645, 0.13336307214810517, 0.14114506115266412, 0.13454324894506497, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.026699896500181675, 0.030164903653411734, 0.029890571760543994, 0.0, 0.0, 0.0, 0.033206873796298275, 0.03924002592490572, 0.034215952184717624, 0.08072778292416571, 0.07965934090175464, 0.07712499243641413, 0.02210760035124726, 0.024198135784835872, 0.018449874749746464, 0.06541275284647496, 0.05775643297460331, 0.05966882349753466, 0.0, 0.0, 0.0, 0.009667320184581052, 0.010618216925484814, 0.009975593139899153, 0.00805304531771811, 0.010051284513262426, 0.007425585659668998, 0.11424471213511067, 0.1304161139054778, 0.10762392937958143, 0.0, 0.0, 0.0]}}
{"id": "447c396b-cb04-4504-8edc-ac0776f1ad2a", "fitness": 0.036823008277340405, "name": "ImprovedHybridDEPSO", "description": "Improved exploration and exploitation using adaptive control strategies and dynamic parameter adjustments in a hybrid DE-PSO framework.", "code": "import numpy as np\n\nclass ImprovedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, self.dim * 3)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.7\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.3 * np.random.rand() * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            fitness_std = np.std(self.best_values) + 1e-9\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (1 + fitness_std / (np.max(self.best_values) + 1e-9))\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.4 + (0.6 * (1 - self.f_evals / self.budget))\n            cognitive = 1.5 * r1 * (self.best_positions[i] - self.population[i])\n            social = 1.5 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.0 + 0.1 * np.sin(2 * np.pi * self.f_evals / self.budget)\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.3 * np.exp(-crowding_distance)\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.6 and np.std(self.best_values) < 1e-4:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 98, "feedback": "The algorithm ImprovedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03682 with standard deviation 0.04285.", "error": "", "parent_ids": ["95e00e39-16ff-4b0a-91cb-6dbda4430219"], "operator": null, "metadata": {"aucs": [0.1061139672542768, 0.09509335900099969, 0.13327711018576682, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04425756356313204, 0.022996195787853724, 0.020000000000000018, 0.020000000000000018, 0.020399531188868947, 0.020000000000000018, 0.06773396421508393, 0.07166406046746898, 0.07434744599186105, 0.0452344509368402, 0.06845113360526367, 0.020000000000000018, 0.02239979700404815, 0.08594148016760361, 0.07251999522286667, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1509445345507694, 0.1185667351800781, 0.13782322272703607, 0.02914783289835854, 0.020000000000000018, 0.030563453432364773, 0.08072694858327945, 0.09029337639278823, 0.0785534606569459, 0.1334681500596716, 0.1516363311024943, 0.13152782196639157, 0.09474146877882661, 0.09686309823025685, 0.07590317375261624, 0.13619307396079816, 0.10330917787237581, 0.13234917518597156, 0.020000000000000018, 0.020000000000000018, 0.09877622048172607, 0.12101279053638048, 0.09391696702469265, 0.08531933680527293, 0.06527120746322768, 0.15859189809644247, 0.05615071492674961, 0.14503477027332334, 0.14035908787890317, 0.15475448018179316, 0.039391419142716266, 0.038709068627014176, 0.03775852637996846, 0.03588883929990472, 0.03433415047396149, 0.051090632988528784, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011939042632694297, 0.010731553714081965, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01020191171872964, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08205180487110209, 0.08113059875338269, 0.07367788087900562, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05485733389539671, 0.06293420165528474, 0.057605823519352506, 0.12393638050694722, 0.09998276825434604, 0.10514511588171771, 0.06363529372589727, 0.040384125137594484, 0.05801833367457332, 0.0831294126642459, 0.08249020565296172, 0.10052060663655549, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03465570104116078, 0.0396605426145652, 0.029727822462472964, 0.02912790699195511, 0.024458941679626478, 0.026324613923927376, 0.14128008953974047, 0.13123409970527322, 0.13714457280798176, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0002497061801449707, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03779577982572657, 0.030163622104217414, 0.029890571760543994, 0.0, 0.0, 0.0, 0.031325022204060415, 0.046343363419250605, 0.034215952184717624, 0.08098118981066549, 0.07965841969894782, 0.08430029781132409, 0.020806169371402228, 0.02424259887725655, 0.027679073480967542, 0.06501016208547095, 0.05775643297460331, 0.06051432219083408, 0.0, 0.0, 0.0, 0.010123842630744284, 0.010618216925484814, 0.009433151669329232, 0.007364112003816259, 0.010051284513262426, 0.007668378978009205, 0.11563000013682645, 0.1304161139054778, 0.10614411811830704, 0.0, 0.0, 0.0]}}
{"id": "70a3ca74-16b8-4432-b26b-f0fa760014a4", "fitness": -Infinity, "name": "AdaptiveEnhancedHybridDEPSO", "description": "Integrate adaptive population size control with dynamic learning rates to improve convergence in EnhancedHybridDEPSO.", "code": "import numpy as np\n\nclass AdaptiveEnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = max(4, self.dim * 2)\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.initial_population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, dim))\n        self.best_positions = np.copy(self.population)\n        self.global_best_position = None\n        self.best_values = np.full(self.initial_population_size, np.inf)\n        self.global_best_value = np.inf\n        self.f_evals = 0\n        self.population_size = self.initial_population_size\n\n    def evaluate(self, func, pos):\n        if self.f_evals < self.budget:\n            value = func(pos)\n            self.f_evals += 1\n            return value\n        return np.inf\n\n    def update_positions(self, func):\n        for i in range(self.population_size):\n            fitness_value = self.evaluate(func, self.population[i])\n            if fitness_value < self.best_values[i]:\n                self.best_values[i] = fitness_value\n                self.best_positions[i] = self.population[i]\n\n            if fitness_value < self.global_best_value:\n                self.global_best_value = fitness_value\n                self.global_best_position = self.population[i]\n\n    def differential_evolution_step(self, func):\n        F_base = 0.8\n        for i in range(self.population_size):\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            F = F_base + 0.2 * (np.std(self.population) / 5.0)\n            mutant = x1 + F * (x2 - x3)\n            mutant = np.clip(mutant, self.lb, self.ub)\n            fitness_std = np.std(self.best_values) + 1e-9\n            crossover_rate = 0.9 * (1 - self.f_evals / self.budget) * (1 + 0.5 * (fitness_std / np.max(self.best_values)))\n            trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n            trial_fitness = self.evaluate(func, trial)\n            if trial_fitness < self.best_values[i]:\n                self.population[i] = trial\n                self.best_values[i] = trial_fitness\n\n    def particle_swarm_optimization_step(self):\n        for i in range(self.population_size):\n            r1, r2 = np.random.rand(2)\n            inertia_weight = 0.5 + (0.5 * (1 - self.f_evals / self.budget))\n            cognitive = 2.0 * r1 * (self.best_positions[i] - self.population[i])\n            social = 2.0 * r2 * (self.global_best_position - self.population[i])\n            scaling_factor = 1.2\n            \n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            crowding_distance = np.min(distances[distances > 0])\n            velocity_control_factor = 1 + 0.5 * (1 - np.tanh(crowding_distance))\n            self.velocities[i] = scaling_factor * (inertia_weight * self.velocities[i] + cognitive + social) * velocity_control_factor\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lb, self.ub)\n\n        if self.f_evals / self.budget > 0.5 and np.std(self.best_values) < 1e-5:\n            self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def adapt_population_size(self):\n        if self.f_evals / self.budget < 0.5:\n            self.population_size = max(4, int(self.initial_population_size * 0.75))\n        elif self.f_evals / self.budget < 0.75:\n            self.population_size = self.initial_population_size\n        else:\n            self.population_size = min(self.budget - self.f_evals, int(self.initial_population_size * 1.25))\n        self.population = self.population[:self.population_size]\n        self.velocities = self.velocities[:self.population_size]\n        self.best_positions = self.best_positions[:self.population_size]\n        self.best_values = self.best_values[:self.population_size]\n\n    def __call__(self, func):\n        while self.f_evals < self.budget:\n            self.adapt_population_size()\n            self.update_positions(func)\n            self.differential_evolution_step(func)\n            self.particle_swarm_optimization_step()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 99, "feedback": "An exception occurred: IndexError('index 15 is out of bounds for axis 0 with size 15').", "error": "IndexError('index 15 is out of bounds for axis 0 with size 15')", "parent_ids": ["95e00e39-16ff-4b0a-91cb-6dbda4430219"], "operator": null, "metadata": {}}
