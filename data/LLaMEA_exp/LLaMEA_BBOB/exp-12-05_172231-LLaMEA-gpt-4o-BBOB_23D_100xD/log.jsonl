{"id": "74d7ea42-030b-4770-8eab-b4df89e8c81d", "fitness": 0.04240995771451406, "name": "HybridPSOSA", "description": "A hybrid metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) for efficiently exploring and exploiting the search space.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Decrease temperature\n            T *= alpha\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.104226008972508, 0.09001049162514752, 0.08197134320299426, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06330150289393455, 0.02924396712203836, 0.157333529705445, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003161571868389279, 0.003072577230725404, 0.013337196165510656, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12264143020628615, 0.13898063547334694, 0.1290161024337353, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0726906557130439, 0.062136375400526855, 0.07277491195576802, 0.10543263187718921, 0.13805522514093327, 0.09946728262151894, 0.06298497974914608, 0.06649099548472526, 0.0671423821089322, 0.11989741714348279, 0.11127080687786084, 0.11152557033343946, 0.11439910226843242, 0.00043478260869567187, 0.11910047163885196, 0.06927656491980527, 0.05217275076458816, 0.06307392922085253, 0.025286192833486654, 0.0889586856143344, 0.04676353708370007, 0.14128969328762075, 0.15158308601580184, 0.13936039396917, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7fe1934b-3d64-48ef-827e-08885fc95665", "fitness": 0.03604231483575938, "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with adaptive PSO parameters for improved convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update with adaptive inertia weight\n                r1, r2 = np.random.rand(2)\n                w = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Decrease temperature\n            T *= alpha\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["74d7ea42-030b-4770-8eab-b4df89e8c81d"], "operator": null, "metadata": {"aucs": [0.08973413175513578, 0.08954392519765664, 0.08488129039652592, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.025199881596399187, 0.03794385520175758, 0.015738041099322753, 0.00043478260869567187, 0.00043478260869567187, 0.0004362667263648756, 0.003471427303087471, 0.004005269598443273, 0.032545509664090866, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11018010637089992, 0.10245446137899583, 0.10062682624266495, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.057898823968806856, 0.06814792016856108, 0.058171396277560516, 0.13109285948073035, 0.09895116038567242, 0.12440381963233538, 0.04946912571177975, 0.04797672752864168, 0.051135072020299654, 0.11306316129947092, 0.10656189394307325, 0.10960211731569658, 0.0746453640925614, 0.029309052919095135, 0.02799330328777594, 0.06275383346270624, 0.04468026462253638, 0.06008668902905889, 0.02575810805869383, 0.07849694699818743, 0.04250357135916427, 0.1435937772164576, 0.13867928197913093, 0.13809401358098516, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b4dda74f-4f5d-4155-bac0-8703328c68f4", "fitness": 0.04034315492057769, "name": "HybridPSOSA", "description": "HybridPSOSA Enhanced: Improved exploration by adjusting the SA cooling rate.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.995  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Decrease temperature\n            T *= alpha\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["74d7ea42-030b-4770-8eab-b4df89e8c81d"], "operator": null, "metadata": {"aucs": [0.09295762373707495, 0.08534620336875975, 0.07962171413171604, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.02383977696713635, 0.009111219364616674, 0.06643243269451671, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015411109654599575, 0.00043478260869567187, 0.0051189699133201705, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11634577915862065, 0.12358077779207233, 0.11654816470641538, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07217169002467239, 0.07605017677396009, 0.07743321528356639, 0.11183646932798352, 0.12038704123913313, 0.10409194195381988, 0.05879649468587855, 0.05406968370387877, 0.04319741986349113, 0.11196097234170554, 0.12194359150841683, 0.11035365411528664, 0.11494127739753834, 0.09223513788330029, 0.11518312009496734, 0.06777643463565863, 0.06287489544071678, 0.04959118066733781, 0.025195777690051657, 0.08989838485136104, 0.048515516072479614, 0.1439384491703144, 0.1435850744480469, 0.13827882709743966, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "db0eb0aa-8883-44f6-b135-1336aad869cb", "fitness": 0.036042314835758385, "name": "HybridPSOSA", "description": "Enhance particle velocity update with dynamic inertia to improve convergence speed.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update with dynamic inertia\n                r1, r2 = np.random.rand(2)\n                inertia = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                self.velocities[i] = (inertia * self.velocities[i] +\n                                      c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Decrease temperature\n            T *= alpha\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["74d7ea42-030b-4770-8eab-b4df89e8c81d"], "operator": null, "metadata": {"aucs": [0.08973413175513578, 0.08954392519765664, 0.08488129039652592, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.025199881596399187, 0.03794385520175758, 0.015738041099322753, 0.00043478260869567187, 0.00043478260869567187, 0.0004362667263648756, 0.003471427303087471, 0.004005269598443273, 0.032545509664090866, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11018010637089992, 0.10245446137899583, 0.10062682624266495, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05789882396881696, 0.06814792016856186, 0.058171396277560294, 0.13109285948073035, 0.0989511603856752, 0.12440381963233538, 0.04946912571177975, 0.04797672752864168, 0.051135072020299654, 0.11306316129947713, 0.1065618939429851, 0.10960211731569658, 0.0746453640925614, 0.029309052919095135, 0.027993303287774607, 0.06275383346270624, 0.04468026462253638, 0.06008668902905889, 0.02575810805869383, 0.07849694699818743, 0.04250357135916427, 0.1435937772164576, 0.13867928197913093, 0.1380940135809834, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5c60c6b8-63c4-4658-9cfb-0cf5c89dc442", "fitness": 0.04363055671199434, "name": "HybridPSOSA", "description": "A hybrid metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive cooling for efficiently exploring and exploiting the search space.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - eval_count / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["74d7ea42-030b-4770-8eab-b4df89e8c81d"], "operator": null, "metadata": {"aucs": [0.11565921747873242, 0.10921648907366466, 0.10545267978587891, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06751364145888539, 0.027480695634733432, 0.025560750479681538, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005922544839388477, 0.00043478260869567187, 0.05391661940101666, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1499435109251097, 0.12610650926109612, 0.10038117865641727, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06936905276545391, 0.06588328479426153, 0.07519585577248145, 0.10972335954233092, 0.12385691979535096, 0.09102547599152844, 0.058349289478121125, 0.05063692961029731, 0.04020762766952268, 0.11051412127980564, 0.10927666462566243, 0.11861676267049848, 0.12105123153577657, 0.11143332219085278, 0.12313895646171047, 0.07916316361388853, 0.06595289129575421, 0.07428616210843086, 0.03453017313331286, 0.11301864414528762, 0.05501137312619331, 0.1484914176815113, 0.15522030233107564, 0.13953659848358857, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "fde4e343-c74a-4a73-958f-b4f2b7fa8c9a", "fitness": 0.04415266942526981, "name": "HybridPSOSA", "description": "A hybrid algorithm combining PSO and SA with adaptive cooling, enhanced by modifying the personal best update condition for better exploration.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - eval_count / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["5c60c6b8-63c4-4658-9cfb-0cf5c89dc442"], "operator": null, "metadata": {"aucs": [0.09785416368668298, 0.07351200994708706, 0.09446498238372181, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07645504531749403, 0.21134794993576178, 0.05017857787852653, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.011688351015774368, 0.004333117883625781, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003161422506311684, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12069644222911469, 0.11436076964709152, 0.11979426533388138, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07768454262116176, 0.05701890565856049, 0.07324535549207256, 0.10513516749327567, 0.11163036684937788, 0.10562011823864492, 0.06451620010080283, 0.0501224567890447, 0.04129204693905408, 0.12341161274431112, 0.1145249623446315, 0.120602983733896, 0.12247191901011434, 0.08609569016297225, 0.11445236541437576, 0.08747112270099122, 0.04472553852728833, 0.060223763730235524, 0.03053903465471508, 0.0909504006924271, 0.04827258481228913, 0.15453546671088103, 0.1520973063307295, 0.14885301518945593, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "99d9bc39-6d85-4f75-84c2-425af5ece987", "fitness": 0.05961601805664591, "name": "HybridPSOSA", "description": "Introduced dimension-wise learning factors to enhance the PSO updating mechanism for more nuanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - eval_count / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.09.", "error": "", "parent_ids": ["fde4e343-c74a-4a73-958f-b4f2b7fa8c9a"], "operator": null, "metadata": {"aucs": [0.16771126558635252, 0.1113041163963806, 0.1687124818543292, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.5170926828561702, 0.4501936856390507, 0.0776866573293048, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.025655818844426026, 0.00043478260869567187, 0.02234473521924174, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00409473743104849, 0.004073795011471648, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005169961556213187, 0.004029853335453137, 0.1189682922363604, 0.13010156269863515, 0.20086702536791756, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09260934769377482, 0.057515659111228024, 0.08425270696524856, 0.12792563076824304, 0.11816029428544361, 0.11816102593366484, 0.044354514466927175, 0.05093314021757456, 0.04501092636230075, 0.11053527122891427, 0.09879398743668033, 0.10921164861807209, 0.09758394511747515, 0.09183377393249881, 0.10424569096055447, 0.07456259220681516, 0.12209993961553511, 0.07839580315068062, 0.03427134411112864, 0.05238254702521017, 0.10801429837845777, 0.15528303124249843, 0.1462989015324756, 0.14756278226779085, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "482f8064-fd13-4172-bbd8-757742460e77", "fitness": 0.055155135021940555, "name": "HybridPSOSA", "description": "Integrate time-varying inertia weights and enhanced cooling schedules for improved convergence stability and solution quality.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w_max, w_min, c1, c2 = 0.9, 0.4, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.98  # Enhanced cooling rate for SA\n\n        while eval_count < self.budget:\n            w = w_max - (w_max - w_min) * (eval_count / self.budget)  # Time-varying inertia weight\n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            T *= alpha\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_ids": ["99d9bc39-6d85-4f75-84c2-425af5ece987"], "operator": null, "metadata": {"aucs": [0.08843791474894203, 0.07819061632474722, 0.09644419289857742, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08207475378601192, 0.8327853831965965, 0.5317396219297421, 0.00043478260869567187, 0.0004756566493993031, 0.00043478260869567187, 0.009520483058762186, 0.0035990965981771428, 0.011556814108797608, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1179561570548674, 0.1381612752489081, 0.12565879003099523, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06892360154307542, 0.06460502189551576, 0.05399959870201354, 0.10647520235063712, 0.10772416214014024, 0.09858217447944162, 0.08159180332469596, 0.04812756193787293, 0.0381758578916489, 0.09488086995613076, 0.10250304220831286, 0.09848989517669193, 0.04633351595444424, 0.046969003837964984, 0.035203180329941186, 0.059100386172624586, 0.07149406154738558, 0.05891739704116017, 0.024625200026878735, 0.04085257200290038, 0.08049761885901063, 0.1372919454298357, 0.13602962752498038, 0.13795827430754337, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0139e22a-53f5-47a7-83b6-648ef7a5f120", "fitness": 0.06527000391754406, "name": "HybridPSOSA", "description": "Enhanced the cooling mechanism by incorporating a dynamic T adjustment based on function evaluations to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.10.", "error": "", "parent_ids": ["99d9bc39-6d85-4f75-84c2-425af5ece987"], "operator": null, "metadata": {"aucs": [0.18606069625112087, 0.16471906013577364, 0.16968189161309855, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0011819585071103367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.2744561073787686, 0.6221015049742452, 0.3409735449054895, 0.0034774637974115397, 0.00043478260869567187, 0.00043478260869567187, 0.009562136661898757, 0.038060361448601476, 0.0059522932680473595, 0.00043478260869567187, 0.0009738366084933725, 0.00043478260869567187, 0.0015779671542835993, 0.00043478260869567187, 0.0018865236815753805, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004455758908996632, 0.00043478260869567187, 0.21482953043356057, 0.18226205139016338, 0.1681369431704457, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09810796827773471, 0.06940670424348516, 0.0764734540320241, 0.1160965083237534, 0.11182229098672825, 0.12911723827343935, 0.06700589612944163, 0.0453510437680813, 0.054487528945603825, 0.11268862718255335, 0.10823135880053047, 0.11363300855760516, 0.10238451743759802, 0.09882904070181686, 0.09959925941143566, 0.07759038616582692, 0.1178317402483936, 0.07766430828011939, 0.02954596004109744, 0.052435224061807006, 0.11048235777398874, 0.14472682118032254, 0.14059019523307392, 0.14595591847485334, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5713fa20-9d60-4b02-92dc-4278a98066c7", "fitness": 0.060697050526703045, "name": "HybridPSOSA", "description": "Introduced adaptive particle velocity bounds and dynamic inertia weight adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n        self.max_velocity = (self.upper_bound - self.lower_bound) / 10.0\n\n    def __call__(self, func):\n        eval_count = 0\n        w = 0.9  # Initial inertia weight for PSO\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                w = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -self.max_velocity, self.max_velocity)  # Adaptive velocity bounds\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.08.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.17007230353400726, 0.16488341702510312, 0.16697507736779482, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010842628654204045, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.30404551237741984, 0.05136344439824747, 0.3943602813089492, 0.00043478260869567187, 0.00915247613733916, 0.008168009819303323, 0.025957882322294124, 0.02529532804486201, 0.038290630629052136, 0.00043478260869567187, 0.00043478260869567187, 0.0044349044588957165, 0.005456793515961178, 0.0010909530538674161, 0.0009053035329095183, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0011462664680568224, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007231524698687597, 0.0004452274465102102, 0.00043478260869567187, 0.19266214647977176, 0.18453642992240915, 0.1839320828253671, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06543544571087034, 0.08266510707127228, 0.0553782832134726, 0.13326030550993007, 0.11587346900919449, 0.12685992905769083, 0.09257086966302108, 0.09024449137532586, 0.06652770136068564, 0.11580738775312893, 0.1170718761167372, 0.11472425545891429, 0.11349040934004173, 0.11427846118196838, 0.12606114768804477, 0.1326189981304594, 0.06139420570295784, 0.04877623557434696, 0.053784895881098915, 0.1120711475421019, 0.05979773456258475, 0.1351412136390554, 0.14733244843559024, 0.1427353851146278, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "1d2a4f9c-e60d-4c8d-825c-d2c9c1a69e7b", "fitness": 0.06435854833260105, "name": "HybridPSOSA", "description": "Adjusted the acceptance probability in Simulated Annealing to enhance exploration capabilities.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / (T / 2)):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.10.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.16288047276292927, 0.15962713262751693, 0.16968189161309855, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0011819585071103367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.2744561073787686, 0.6221015049742452, 0.3409735449054895, 0.0034774637974115397, 0.00043478260869567187, 0.00043478260869567187, 0.009562136661898757, 0.038060361448601476, 0.0059522932680473595, 0.00043478260869567187, 0.0009738366084933725, 0.00043478260869567187, 0.0015779671542835993, 0.00043478260869567187, 0.0018865236815753805, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001982731159435591, 0.0004455758908996632, 0.00043478260869567187, 0.1886530621628979, 0.18810183075388132, 0.16099325439991174, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09810796827773471, 0.06899046717323709, 0.0764734540320241, 0.12525778816697053, 0.11497498803717332, 0.10505504662151, 0.04705134531314026, 0.05969428242762442, 0.054947079555020206, 0.11342222912714162, 0.11278161508283713, 0.10943094427697286, 0.10380173642779367, 0.09786561350802259, 0.09959925941143566, 0.07326875788755927, 0.11421740910158695, 0.07962500474420242, 0.03357680670572194, 0.053941011094831404, 0.110724211785039, 0.1453887958225919, 0.14506331633452108, 0.14537800362391284, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2e84c1ad-64a3-4258-a552-0668c07bc949", "fitness": 0.05517123472609533, "name": "HybridPSOSA", "description": "Introduced adaptive velocity scaling in PSO updates to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                velocity_scale = 1 - (eval_count / self.budget)  # Adaptive velocity scaling\n                self.velocities[i] = (w * self.velocities[i] * velocity_scale +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 11, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.07.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.20893218550475456, 0.19359524170741016, 0.2056426253211191, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.010347246281174782, 0.00043478260869567187, 0.00204098112555684, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08254092633770871, 0.12174801686034686, 0.06641331982477927, 0.00043478260869567187, 0.00043478260869567187, 0.011454962079966435, 0.014331871888871306, 0.004489270281293201, 0.007798126965417818, 0.0005198483638451101, 0.002576359857219601, 0.00531302785035459, 0.01577933411442678, 0.003298034259829441, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.009033807390454451, 0.005534105164834768, 0.1858834060750929, 0.20493178958713154, 0.21330364651643552, 0.0006476268525237305, 0.00043478260869567187, 0.00043478260869567187, 0.0736449621951707, 0.07562176371987628, 0.0858260738448835, 0.11430062676571295, 0.11582006741488315, 0.12135974198128285, 0.06339906996661704, 0.08770437639651174, 0.04629392225595297, 0.11479521868922393, 0.11210694463745952, 0.10772858673651997, 0.10710271256695014, 0.10584948068143962, 0.10694894716332937, 0.07943168262901568, 0.1251085127677185, 0.08430886885608768, 0.03219072028714853, 0.051158749092817035, 0.1190325856865242, 0.14525164349410624, 0.14583185562703638, 0.16448646139465606, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "26fcd55f-530a-439f-91f7-9ce87772d032", "fitness": 0.04035978603770971, "name": "HybridPSOSA", "description": "Improved global best update strategy by introducing a probabilistic update based on a decreasing threshold to enhance convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best with a probabilistic approach\n                if score < self.global_best_score or np.random.rand() < (1 - eval_count / self.budget):\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.06.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.06072949457938648, 0.0798540957789583, 0.07102820403312227, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06092817942769746, 0.24938114971298353, 0.2647497716425866, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0048186132459736575, 0.0037726048546710134, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10297306535903095, 0.09562986538498242, 0.1197615388927441, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.047240380885399946, 0.049452208094134975, 0.05447290819191786, 0.12234971631993108, 0.11662172485752054, 0.11087058040062892, 0.06365418755630659, 0.05667559495279284, 0.05718379517521677, 0.09751318128589659, 0.09537266029039015, 0.09686799056620576, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08219108841230216, 0.04252965425808741, 0.05237430892124928, 0.07457213418711706, 0.0932658055024772, 0.044554598357087305, 0.13818487375688893, 0.14257888285000064, 0.136360432633584, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4587a4e9-4a09-4f05-9d1b-7f94754ec618", "fitness": 0.04216503661019756, "name": "HybridPSOSA", "description": "Enhanced the velocity update step by introducing inertia adaptation based on the number of evaluations to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                w_adapted = 0.5 + 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (w_adapted * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.09164507684180756, 0.09792120670739424, 0.11525534382268598, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08822977906510066, 0.08839207209282429, 0.07374122344737966, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0021140694878071242, 0.023174020821162156, 0.0006741925600005638, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1306108874007147, 0.1258529522596611, 0.1255383881138772, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07816591462841194, 0.06551898530414968, 0.056560879138454645, 0.12512585194246784, 0.12845317847455573, 0.09880874659229744, 0.04938867201171371, 0.05407814528815935, 0.05101943507462947, 0.10372944276754725, 0.10626703810491855, 0.10374899056983578, 0.09958093965495407, 0.01357555802350463, 0.08402057562248189, 0.0675255689494132, 0.10127297509704813, 0.07273665144659414, 0.027584112702679353, 0.05089202195320208, 0.09248154476103199, 0.13559474537746363, 0.14436509472108272, 0.146586181194168, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "91ec314c-dd9f-4faf-a62f-b5a5222d4af5", "fitness": 0.05241272748036651, "name": "HybridPSOSA", "description": "Introduced a dynamic inertia weight adjustment mechanism in PSO for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - (0.9 - 0.4) * (eval_count / self.budget)  # Dynamic inertia weight\n\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 14, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.11.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.049816483362931874, 0.06750000143127832, 0.08674741614717352, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6303748248901211, 0.6373019871338585, 0.040433877413939556, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004268841184589478, 0.007224114694291406, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12862788211698672, 0.09675684035828458, 0.10809453888771658, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07623655366924953, 0.07147473800617066, 0.05992384572484222, 0.10569290299531275, 0.10264712308848867, 0.10651996494280613, 0.06300806905674528, 0.0372103397667819, 0.035299020061558606, 0.09877545960357903, 0.10697624523950111, 0.10546305927373734, 0.044112907975096705, 0.04765301799608612, 0.04679530907122531, 0.06116660423780995, 0.0851930650700844, 0.05722070856379102, 0.023089150285504734, 0.04241026119331803, 0.08257092274481992, 0.1493558474276897, 0.1509722031088213, 0.1407152953404569, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d55d1fff-ac03-48e4-acfa-66e0e8e9f199", "fitness": 0.04952942511966215, "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with dynamic particle adaptation and stochastic velocity components for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                dynamic_factor = np.random.uniform(0.8, 1.2)  # Dynamic adaptation\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      dynamic_factor * c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 15, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.17259090277697375, 0.15530598031850928, 0.16662202115428915, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04022521961464942, 0.07103726596395454, 0.05346478547437572, 0.020158131694397174, 0.00043478260869567187, 0.00043478260869567187, 0.03951741236058559, 0.01899963686857442, 0.04352737948976637, 0.00043478260869567187, 0.00043478260869567187, 0.000968964388935678, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010663162178266017, 0.0017974748686963027, 0.0015859413317244053, 0.1713615227155304, 0.14805394709792485, 0.1606369540374467, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08288254778366333, 0.07400071843746248, 0.08921488051549242, 0.1190224729455659, 0.11355080841142895, 0.12481856906799016, 0.04806262360043445, 0.07776593842228585, 0.054042772603268396, 0.10363182072754729, 0.10901579880057155, 0.11052099701546159, 0.11074102785238471, 0.10225391463965672, 0.09438668494048952, 0.08076547081056618, 0.1151250807490174, 0.07388403247786712, 0.03531812990236671, 0.05023343648265377, 0.05106892539201846, 0.1527959152833629, 0.1562820175310502, 0.1563359069793424, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f8fb96e1-a773-49c5-8527-98ce780a6a68", "fitness": 0.034868132633800154, "name": "HybridPSOSA", "description": "Introduce adaptive inertia weight and diversity-driven perturbation to enhance exploration and exploit convergence balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n        w_min, w_max = 0.4, 0.9  # Adaptive inertia weight bounds\n\n        while eval_count < self.budget:\n            w = w_max - ((w_max - w_min) * eval_count / self.budget)  # Adaptive inertia weight\n            diversity = np.mean(np.std(self.particles, axis=0))  # Population diversity measure\n\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                if np.random.rand() < diversity:  # Diversity-based perturbation probability\n                    candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    eval_count += 1\n\n                    # Acceptance probability\n                    if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                        self.personal_best_positions[i] = candidate_position\n                        self.personal_best_scores[i] = candidate_score\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.0954931294181065, 0.08463714997745686, 0.06937281150089347, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04104876573580596, 0.04957873704615412, 0.038129083366194916, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.006029188596593182, 0.007748957250373278, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0971837522746698, 0.11469687601132073, 0.09385488598750547, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0667330724280848, 0.07297975774740462, 0.07014671482577695, 0.1156990955524948, 0.1017391259780267, 0.10837858340310624, 0.042664956847316415, 0.03759627363531326, 0.04401158191739385, 0.10134368045079734, 0.10040570563687357, 0.095916117660099, 0.0443543054194141, 0.011038550400875424, 0.04816844367495876, 0.06650256137707755, 0.08011427232887125, 0.05297902801192378, 0.020275263944777522, 0.0401970752052363, 0.03890536358605989, 0.15114769159062869, 0.1453281434386563, 0.14001989088563016, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5e1b3ec6-1557-42d6-b39f-62fc5aa317d5", "fitness": 0.05241272748036651, "name": "HybridPSOSA", "description": "Introduced adaptive inertia weight adjustment based on evaluation progress to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.11.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.049816483362931874, 0.06750000143127832, 0.08674741614717352, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6303748248901211, 0.6373019871338585, 0.040433877413939556, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004268841184589478, 0.007224114694291406, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12862788211698672, 0.09675684035828458, 0.10809453888771658, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07623655366924953, 0.07147473800617066, 0.05992384572484222, 0.10569290299531275, 0.10264712308848867, 0.10651996494280613, 0.06300806905674528, 0.0372103397667819, 0.035299020061558606, 0.09877545960357903, 0.10697624523950111, 0.10546305927373734, 0.044112907975096705, 0.04765301799608612, 0.04679530907122531, 0.06116660423780995, 0.0851930650700844, 0.05722070856379102, 0.023089150285504734, 0.04241026119331803, 0.08257092274481992, 0.1493558474276897, 0.1509722031088213, 0.1407152953404569, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0dbbc537-244d-44a2-8b54-b74a6843d616", "fitness": 0.01591135771635432, "name": "HybridPSOSA", "description": "Enhanced PSO-SA by improving dynamic cooling with entropy-based strategy and adaptive learning rates for better convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            entropy = -np.sum(self.personal_best_scores / np.sum(self.personal_best_scores) * np.log(self.personal_best_scores / np.sum(self.personal_best_scores)))\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * (1 + entropy) * np.random.rand(self.dim)  # Adaptive learning factor\n                c2_i = c2 * (1 - entropy) * np.random.rand(self.dim)  # Adaptive learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + entropy)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.009316171224067804, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.015693598815593512, 0.03619155253941664, 0.021315056507817842, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05028935673592416, 0.05193712307018039, 0.045903120925160024, 0.07182413293392909, 0.06741360020113385, 0.06704399908926761, 0.015878653729028747, 0.010324286190200094, 0.01963963101596733, 0.06622886519940041, 0.05680962585477867, 0.058935505274003375, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.010099064802697955, 0.009594450592343984, 0.010231571476975176, 0.008589812940997588, 0.008076706264687927, 0.007377294810194335, 0.1309056389287635, 0.13751484242352852, 0.138049311422756, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9e143b88-3d33-4115-a54d-5f31f08239d8", "fitness": 0.06635756954338541, "name": "HybridPSOSA", "description": "Introduced a sinusoidal cooling schedule in the Simulated Annealing component to enhance exploration by dynamically modulating the temperature.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.1 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.12.", "error": "", "parent_ids": ["0139e22a-53f5-47a7-83b6-648ef7a5f120"], "operator": null, "metadata": {"aucs": [0.19403684422491585, 0.14709788265686596, 0.15920669552297773, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.000817887889550839, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7538958672674445, 0.5443570736220966, 0.07621297968305107, 0.00043478260869567187, 0.0018369067961226948, 0.0021081047627249383, 0.027252008928394966, 0.02886247363976724, 0.011750838112397632, 0.00043778784068482235, 0.00043478260869567187, 0.00043478260869567187, 0.0005687791806404663, 0.0004951583568489903, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16915867165718135, 0.1861321155760639, 0.15298168220546393, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09153876598627686, 0.07646424777098748, 0.07046865341254749, 0.11916982718942792, 0.1040040722731802, 0.14472400723459145, 0.07922153907629881, 0.06483834663109955, 0.055202116238642907, 0.11407834623860669, 0.10895375540123775, 0.10781874836996608, 0.07446202547635983, 0.07722365786281327, 0.12838893523132322, 0.07501142412794393, 0.11736116511456562, 0.07933118868136813, 0.030666141887877973, 0.04727412184711799, 0.1092482981403422, 0.13773615069076228, 0.15124972248934, 0.14305651356700944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "591b3528-a6f1-4c4e-b193-a3ed16871f88", "fitness": 0.033288091197303166, "name": "HybridPSOSA", "description": "Incorporated a dynamic inertia weight in PSO to balance exploration and exploitation based on evaluation progress.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                w = 0.5 + 0.4 * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.1 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["9e143b88-3d33-4115-a54d-5f31f08239d8"], "operator": null, "metadata": {"aucs": [0.08525727197757016, 0.06105790526741972, 0.055181861915734376, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07409813241009666, 0.07829291247198888, 0.03758436508763918, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.013240232082581405, 0.0041136315683338864, 0.00454975616671871, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08663330603678376, 0.10676773506537995, 0.08839377834927553, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07802272319231118, 0.062252658547167994, 0.06018516727582801, 0.11475504795490932, 0.10422725221621454, 0.09978504773510155, 0.05184091467281082, 0.038902914882800066, 0.04761033700480055, 0.09093152050315378, 0.09406202759719196, 0.0892952630044509, 0.00043478260869567187, 0.00043478260869567187, 0.009624013437355194, 0.05813128162788517, 0.0639368835191616, 0.04762751752331751, 0.02182053340528889, 0.03768511720083112, 0.08087796593922159, 0.1453240304684449, 0.13539273139703312, 0.1527589895705901, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e0c61c7c-aa22-4b73-907f-9597cb4393bc", "fitness": 0.06957318013330994, "name": "HybridPSOSA", "description": "Enhanced adaptive cooling by incorporating a dynamic adjustment factor based on evaluation progress to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 21, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["9e143b88-3d33-4115-a54d-5f31f08239d8"], "operator": null, "metadata": {"aucs": [0.1713358798904996, 0.1349011644095004, 0.1605149930540769, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6980584704066908, 0.8028990450836812, 0.1846118068744177, 0.0025570987744917284, 0.005804289166125409, 0.010873854577614472, 0.03189822699222766, 0.003636301882029125, 0.0014054961048731718, 0.0005251241316905908, 0.005418601594724182, 0.002061063970955068, 0.00043478260869567187, 0.003710088754979024, 0.0009174912947272906, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005558070076493449, 0.0032515140201975212, 0.16827917608530696, 0.17165916018707061, 0.13816882647875828, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09316522315764542, 0.06292664234515954, 0.0786414552098722, 0.13865706494302, 0.1279467724043739, 0.10778610678173028, 0.04511163260140916, 0.06948977957194646, 0.046594992213625175, 0.11205732711930749, 0.11047176107330292, 0.10479360375858249, 0.09290069552685765, 0.0833974052591886, 0.12229693117099227, 0.0741988282264684, 0.11539615375079482, 0.07707405793628819, 0.03262276676952314, 0.050576139811540965, 0.10747001413300905, 0.15255132932508197, 0.14051065745181968, 0.14828380048840173, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d773ac56-2098-4678-bf27-a88f760c0929", "fitness": 0.04594977743103239, "name": "HybridPSOSA", "description": "Improved HybridPSOSA by increasing the randomness in the velocity update to enhance global exploration.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]) +\n                                      np.random.uniform(-0.1, 0.1, self.dim))  # Increased randomness\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 22, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1413389136233537, 0.13714277306031852, 0.12548918524095964, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12391521252874738, 0.07039051116727535, 0.09215468292372309, 0.00043478260869567187, 0.0017370424267063589, 0.00043478260869567187, 0.029168274439364206, 0.0010104196962097411, 0.011918677521342236, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.006070193710052685, 0.00662323212963023, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007980613877951459, 0.001451948682985038, 0.00043478260869567187, 0.16853171024850122, 0.13903041690380646, 0.13123708605739737, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07213004268534429, 0.08215855737137467, 0.07892407066676599, 0.10921220869130532, 0.09529362281430953, 0.11393059046653675, 0.04817320897651434, 0.06248058525512712, 0.05232894838087243, 0.10305363544342028, 0.11241093325801987, 0.11522611504995162, 0.10517003472722442, 0.07926595239568834, 0.10246495266641986, 0.07560814233130853, 0.07723908549255964, 0.07582087097404833, 0.029807081251886913, 0.05187673464791975, 0.04943793263156693, 0.13557333082811107, 0.14431442206836997, 0.13499631334195183, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "937d249b-9d1a-4754-af39-4b8df02f136c", "fitness": 0.05848895300082867, "name": "HybridPSOSA", "description": "Incorporate velocity clamping to enhance stability and convergence in the hybrid PSO-SA algorithm.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n        v_max = (self.upper_bound - self.lower_bound) * 0.1  # Max velocity\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.velocities[i] = np.clip(self.velocities[i], -v_max, v_max)  # Velocity clamping\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.07.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.2064054223159193, 0.18153933604358996, 0.18863801628977928, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.31483825851610603, 0.06846235038548198, 0.2693568363211929, 0.00043478260869567187, 0.001827001985501675, 0.005609507407947301, 0.008597003643077805, 0.003983161734788854, 0.04661677810113363, 0.012934709262516608, 0.00043478260869567187, 0.0033310428805354286, 0.001576319274365745, 0.018343710929368928, 0.0025280714557213146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004811023707642081, 0.0010159399520653922, 0.00043478260869567187, 0.18323672793877077, 0.16899898616183917, 0.19858237588332328, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0806047855915949, 0.09417769494418848, 0.09444799016271788, 0.1212274663658075, 0.12168315642864302, 0.13571226014337212, 0.06115345160518182, 0.05630591997951795, 0.05650502023789161, 0.12466886483799333, 0.12154195776681775, 0.12566277262224768, 0.12935634715734146, 0.12724724041930202, 0.12405553452874207, 0.038409510082511034, 0.06276752762081583, 0.04900617652645134, 0.031644699494189354, 0.06505316463926392, 0.04870381868816587, 0.1416368474481129, 0.1478546083606721, 0.14880608978267107, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "903ebfd5-784f-4962-af48-ea6b00a9c711", "fitness": 0.04395278430035758, "name": "HybridPSOSA", "description": "Refined adaptive cooling and enhanced diversity by adjusting the PSO parameters dynamically based on the evaluation progress.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n            w = (0.9 - 0.4 * (eval_count / self.budget))  # Dynamic inertia weight adjustment\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 24, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.10.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.07872084338976548, 0.05326953455362582, 0.05995948503410997, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8205120696308288, 0.0408564077364042, 0.03227433954390091, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001880408688117008, 0.001905810099924965, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09142732334817061, 0.12339424154912482, 0.09235298807101733, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06861857422377593, 0.057847946250031645, 0.05987192814916853, 0.1143928535467047, 0.10857099196571984, 0.09558282908782567, 0.0571871322743599, 0.06611929101765013, 0.04592137428430487, 0.0967106477854126, 0.09764744594843489, 0.09880683508437615, 0.017188452922921926, 0.00756652879779407, 0.058253068507278294, 0.04521767030019874, 0.05201272588603467, 0.059178421268197834, 0.029463713683796966, 0.033634547438136875, 0.06288962089306649, 0.14238520876222038, 0.14214937230686597, 0.1347428810747393, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "22bfc67f-3434-42b6-a7d1-cbbd0cacfb9c", "fitness": -Infinity, "name": "HybridPSOSA", "description": "Enhanced adaptive cooling by incorporating a more aggressive dynamic adjustment factor based on evaluation progress to improve convergence speed.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - 1.5 * (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 25, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {}}
{"id": "55e74510-a54c-4f12-8fb9-7dcdafd0794e", "fitness": 0.04869482451618656, "name": "HybridPSOSA", "description": "Introducing diversity by adding small Gaussian noise to positions before evaluation to enhance local search escape.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position with added noise\n                noisy_position = self.particles[i] + np.random.normal(0, 0.01, self.dim)\n                score = func(noisy_position)\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 26, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.14437533701095306, 0.14136542353589898, 0.1357182618436521, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08669220004451172, 0.07636642222819279, 0.10526918169452149, 0.00043478260869567187, 0.003542637098001733, 0.00043478260869567187, 0.012774230365251493, 0.015663825054462177, 0.017311244451713725, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003616169210774123, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010425088809735694, 0.00043478260869567187, 0.16438646376028065, 0.16632525963567046, 0.1651275036772233, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07224197240435426, 0.0821414518624306, 0.07140879217978735, 0.12044127142407879, 0.10806026919219003, 0.12661896413419638, 0.0715782913702161, 0.05645941394757126, 0.07358752929994905, 0.1098629355262124, 0.10392127655101313, 0.10084855370843793, 0.09205578523412083, 0.1057922506396074, 0.10454163633211944, 0.07212794590602278, 0.055272821559063656, 0.07514885667911408, 0.03371602272014329, 0.047044728348717424, 0.11012089304043604, 0.14562370849446438, 0.15916959756635396, 0.15431790246579324, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a9a5c27d-fe51-48ab-8c1b-51c9cdf4fdda", "fitness": -Infinity, "name": "HybridPSOSA", "description": "Refine the velocity update by introducing a cross-dimensional coupling term for improved convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                cross_term = np.cross(self.velocities[i], self.global_best_position - self.particles[i])  # Cross-dimensional coupling term\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]) +\n                                      0.1 * cross_term)  # Added cross-dimensional coupling term\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 27, "feedback": "An exception occurred: ValueError('incompatible dimensions for cross product\\n(dimension must be 2 or 3)').", "error": "ValueError('incompatible dimensions for cross product\\n(dimension must be 2 or 3)')", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {}}
{"id": "2a5cb973-8049-4d92-95a6-6f5c9b3f3631", "fitness": 0.04704869884114985, "name": "HybridPSOSA", "description": "Improved exploration by introducing a small random perturbation to the global best position in PSO updates.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * ((self.global_best_position + np.random.uniform(-0.1, 0.1, self.dim)) - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 28, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1514911009120392, 0.14568428596888405, 0.14505124498565858, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06284273581721445, 0.09238147250529594, 0.11103019986504137, 0.00043478260869567187, 0.0020605689564013874, 0.00043478260869567187, 0.01621051502406201, 0.018028690817130433, 0.007860136750825975, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0023577885528340836, 0.004962503836295373, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004616379828226158, 0.00043478260869567187, 0.00043478260869567187, 0.16682129205685237, 0.16177393402627982, 0.13689031830253462, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06435855511897282, 0.07518871748084699, 0.08572047352346701, 0.11245367796502836, 0.11560402957707394, 0.1060018699265074, 0.06432695031895908, 0.06633434403396621, 0.052597889101151374, 0.10803653676672087, 0.10581648752626616, 0.11288205354022218, 0.10326198896631611, 0.08673788473973298, 0.10047703947132125, 0.0734506887013644, 0.08687284584882116, 0.07830050983802006, 0.03197168208258572, 0.05102070729730224, 0.0500852308994737, 0.1284750503119474, 0.1355566514742068, 0.1521529822140817, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "444506e6-034b-46e4-87e7-624b4a89b5bd", "fitness": 0.06480171684690655, "name": "HybridPSOSA", "description": "Adjusted the probability factor for updating the personal best to improve convergence speed in HybridPSOSA.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.2:  # Increased to 20% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.16862023349861255, 0.15552518010526217, 0.139617704530955, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7250892140653988, 0.7154444563699063, 0.08102790427043838, 0.00043478260869567187, 0.0045261999209874615, 0.0082005837761715, 0.010043568665431546, 0.019668670139012634, 0.0061234377863627065, 0.00043478260869567187, 0.0034655265883219988, 0.00043478260869567187, 0.002062347920849361, 0.0016956076266678721, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006208369821847359, 0.0006382216326165091, 0.00043478260869567187, 0.14523880600427008, 0.13729045495002756, 0.16480980071966578, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09795533824095992, 0.06835880409106687, 0.08078512559701923, 0.11525756910620888, 0.11885218946432141, 0.10353055775959508, 0.06012228054261293, 0.04423101312064459, 0.0528981058152429, 0.10940639152904263, 0.11056737206790024, 0.09964525137015734, 0.08381808758192821, 0.07660371166659863, 0.09703065555052337, 0.06552391680551528, 0.08069264605281734, 0.07682685250446275, 0.031123045199106913, 0.04937808742591443, 0.09606759847284885, 0.1474540549724691, 0.14564642221155022, 0.15163108462344865, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "426a365a-95b1-4726-a8e0-c704f0909b83", "fitness": 0.06744535266396993, "name": "HybridPSOSA", "description": "Introduce a random reinitialization step to potentially escape local optima and explore new areas of the search space.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Random reinitialization\n            if eval_count % (self.budget // 10) == 0:\n                self.particles[np.random.randint(self.pop_size)] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 30, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.17507300507727763, 0.14176933210424925, 0.16276534034264656, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6980584704066908, 0.8028990450836812, 0.0759064675068547, 0.0005387936037111185, 0.008493236115150293, 0.015136046562958194, 0.036719203681676804, 0.008784554744520445, 0.0016703633587547007, 0.00043478260869567187, 0.0014492959735404876, 0.0010668886941294087, 0.00043478260869567187, 0.0012919755823690426, 0.003203577640072619, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001405657442740904, 0.0016257833014313716, 0.0025718302786497116, 0.1488677919798006, 0.15591031729341454, 0.13559230203416628, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07966386722483765, 0.055142319682977003, 0.08582500988449027, 0.13552821188798658, 0.11979297635078534, 0.10971359306462214, 0.04599966499489894, 0.0756322470222579, 0.048445168886164125, 0.10999912368159526, 0.10765848271420742, 0.10523010815440592, 0.0912333498087422, 0.08596229020614099, 0.12461591108796366, 0.07339496667206058, 0.11211102385373972, 0.07593550055397191, 0.03215679933056237, 0.05058505574812011, 0.10661793804608288, 0.15105215337913913, 0.13726796779665318, 0.14439803513885496, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "13e7c5b4-a051-4a1d-96e9-89eea692d4e7", "fitness": 0.06738707850592446, "name": "HybridPSOSA", "description": "Adjusted the learning factor update strategy in PSO for better convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim) * (1 - eval_count/self.budget)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 31, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.17897281986516522, 0.15743557029859534, 0.16288787505171742, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07911892819409883, 0.7443867442485996, 0.7222977429925546, 0.00043478260869567187, 0.008007037130658978, 0.00043478260869567187, 0.00993185311742606, 0.001617681684043304, 0.0011815596267563677, 0.00043478260869567187, 0.00043478260869567187, 0.002729214859245599, 0.0035949609514377423, 0.0060673726620116275, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0020937339758960727, 0.0005819536741621389, 0.13507909208109015, 0.15789456049096529, 0.15532550690023483, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10207613053528175, 0.068785495885618, 0.0824097698478019, 0.12729989272101028, 0.1154675575974069, 0.1322862928248857, 0.059095463687195315, 0.05379959932955125, 0.04647654451860039, 0.11588497780007889, 0.10982585329691097, 0.108457339779229, 0.07585806369783388, 0.0771504759671825, 0.12194108814326421, 0.07304981042241332, 0.11746936163311827, 0.07880972602609626, 0.030814611631183153, 0.04798629345246053, 0.10889156522840826, 0.14816330863972382, 0.14950011781393258, 0.1581226258818439, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a05e14d1-4595-4619-995c-4983026be13f", "fitness": 0.06521692399725759, "name": "HybridPSOSA", "description": "Improved convergence by introducing a momentum factor in velocity update and adjusting cooling schedule based on stagnation detection to enhance performance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2, momentum = 0.5, 1.5, 1.5, 0.1  # Added momentum factor\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n        stagnation_count = 0\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n                    stagnation_count = 0  # Reset stagnation\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (momentum * self.velocities[i] +  # Introduced momentum\n                                      w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n                        stagnation_count = 0  # Reset stagnation\n\n            # Adaptive cooling with stagnation detection\n            stagnation_count += 1\n            if stagnation_count > 10:  # Adjust cooling if stagnant\n                T *= alpha * 0.9\n            else:\n                T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 32, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.14.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1339535322787042, 0.10481280783580371, 0.13829345974099105, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8219599849764723, 0.8413146555366033, 0.05376607324496252, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.008721169261582173, 0.0022472595404602336, 0.007436361649905576, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12864069262660682, 0.1626563068145792, 0.14076457248339735, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07942916498761288, 0.07007825696845171, 0.0825006194490836, 0.1242024091103644, 0.13116210294596664, 0.12194551125698194, 0.06902275253506163, 0.045094671558641775, 0.040087403428090695, 0.10529112143486064, 0.10182645278111602, 0.1083104721464776, 0.08387195643949763, 0.08855836605535738, 0.05766007443675336, 0.07150852128108609, 0.09753223002536582, 0.06845427166198814, 0.030620164476294454, 0.047206983025201654, 0.10171092385549219, 0.13755300213868427, 0.14175034715340096, 0.1300216987476014, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c3c9f5ff-4460-4d92-97aa-3b05297dcbe2", "fitness": 0.053272596751687634, "name": "HybridPSOSA", "description": "Slightly adjust cooling strategy and learning factors to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.7, 1.3  # PSO parameters adjusted\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.98  # Cooling rate for SA, slightly decreased\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 33, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.2060497583484846, 0.1806757423060702, 0.17697322184003306, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004697339223943553, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0791508628334111, 0.13300092877826597, 0.15462698763018856, 0.006714403907272404, 0.00043478260869567187, 0.0021267571949101782, 0.01642325902926689, 0.017492701860454374, 0.01180056408114738, 0.011100747771576214, 0.009399092004279463, 0.00043478260869567187, 0.0066840645351875505, 0.01408114026733187, 0.014834593789341266, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005605837799685931, 0.0026868986808757933, 0.004335473959829472, 0.17306120754970833, 0.1710002383530227, 0.15139699855467736, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08252638763479592, 0.0664249696106507, 0.06257321470766108, 0.12259827549323765, 0.12716530713155383, 0.1478713576423577, 0.09248628901233391, 0.08486545399446876, 0.054719943860363496, 0.10809232672045788, 0.11063287810493139, 0.10885364656876151, 0.09589169158521638, 0.10246651301001453, 0.12365486192815767, 0.0788035206658948, 0.10343026569942082, 0.07397370542146253, 0.01672432796216372, 0.048370912648791675, 0.04866403379012196, 0.1391221106312166, 0.13560675302165548, 0.1445926930807302, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5aa35a58-a191-489a-b7d6-a3f450727717", "fitness": 0.05816128232424746, "name": "HybridPSOSA", "description": "Refined dynamic adjustment factor by amplifying the effect of progress using a sine function for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(10 * np.pi * eval_count / self.budget))  # Change in this line\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 34, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.08.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1585147471731888, 0.16591779840808396, 0.17044505393608367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.49640525535287594, 0.04893419907414387, 0.26993669472901305, 0.0016176922588400089, 0.008947299273436515, 0.00043478260869567187, 0.01118091604635496, 0.006436890075993795, 0.03126740075500667, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003797183331487375, 0.006039442466210687, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0016072997534790634, 0.00043478260869567187, 0.15274809761472818, 0.18065708089248467, 0.1547917343399351, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09462300171319704, 0.07522808936702896, 0.07535432815123033, 0.1114968529837439, 0.12407014631220603, 0.10863699656257031, 0.09255740225064901, 0.06409267640597616, 0.06687912318723033, 0.11419720454841031, 0.10823402814019611, 0.10869002001042116, 0.07551195557538448, 0.08340206623936763, 0.1239265657709534, 0.07731501623026993, 0.11139226222964305, 0.07735996806013512, 0.03138976972910135, 0.05240078133013115, 0.106725435319166, 0.14034722871569094, 0.13821658329668562, 0.1428417788655164, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "1d05f481-8886-42e0-84fe-8b9744142c0f", "fitness": 0.06749192212824731, "name": "HybridPSOSA", "description": "Improved dynamic adjustment with non-linear cooling rate to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling with non-linear update\n            T *= alpha * (1 - (eval_count / self.budget)**2.5) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.16102558960263058, 0.15297508130772175, 0.1491292356826598, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6980491293339706, 0.8029091825917472, 0.13157028683855554, 0.0062902647072763385, 0.01995230987228669, 0.0005363715204891317, 0.031104049939912448, 0.014478225701996084, 0.00043478260869567187, 0.0068657822738940055, 0.011987966934427385, 0.0006578045665484034, 0.00043478260869567187, 0.0024461237976101113, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0012263421948787157, 0.00043478260869567187, 0.0011667305546703144, 0.1684993666813268, 0.16234448319076666, 0.13010775814995668, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09195226857481276, 0.06351873394328933, 0.07415600103813291, 0.11461539115711994, 0.12058347717431617, 0.12237506874524273, 0.04775721266392974, 0.07530723688525265, 0.04608165249808771, 0.10737917509432915, 0.1060357508166726, 0.10417907636371282, 0.07158160558874438, 0.06789932559008127, 0.09617640787481951, 0.0736172703025273, 0.12023721983415792, 0.07713845145885723, 0.031820266098894656, 0.05009503155657358, 0.10463915040087712, 0.15082859473887644, 0.14131814876428073, 0.13462987758341405, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "72b581e3-1a40-43e3-b4f8-6c5ffdbe0304", "fitness": 0.04600397710740349, "name": "HybridPSOSA", "description": "Enhanced hybrid algorithm with dynamically adjusted inertia weight and adaptive mutation for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w_init, w_end = 0.9, 0.4  # Adjusted inertia weight range\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = w_init - (w_init - w_end) * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation with adaptive mutation\n                perturbation_scale = T * (1 - eval_count / self.budget)  # Adaptive mutation scale\n                candidate_position = self.particles[i] + np.random.normal(0, perturbation_scale, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.10.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.06468896601871621, 0.061018478619587646, 0.06483668548770227, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0004404905123781555, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08208602278901567, 0.7827816588334582, 0.03933999972725144, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00107643993208828, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09017947316102437, 0.11619576251859454, 0.0963871312381478, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06764921278870761, 0.06326862945112144, 0.06267250871410734, 0.1024703756063916, 0.1252483824155839, 0.10099232879064424, 0.05588080893432423, 0.05317491383181372, 0.05303086519208555, 0.10347164810503451, 0.10075297777008196, 0.1089802700632082, 0.04838287985736767, 0.053119680015345505, 0.038533003388684706, 0.045380356253194254, 0.08882438447355212, 0.06661340965972373, 0.020751844504135364, 0.03896017975240518, 0.0810274502780517, 0.12972915542261165, 0.14704280046194762, 0.1412102206432233, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "f5de41a7-fe22-4a5e-95fd-edae587d02d0", "fitness": 0.05869636075933349, "name": "HybridPSOSA", "description": "Optimize exploration and exploitation balance by adjusting the probability of personal best updates based on improvement magnitude.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                improvement = (self.personal_best_scores[i] - score) / abs(self.personal_best_scores[i])\n                if score < self.personal_best_scores[i] or np.random.rand() < min(0.1 + improvement, 1.0):  # Adjusted probability\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 37, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.09.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.16061848093848796, 0.15369395986943846, 0.17999559738059578, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.24057821787452693, 0.08306945976804636, 0.6114293591119879, 0.0006728262048093514, 0.0057107596972841845, 0.00043478260869567187, 0.00872948913866134, 0.013378085141073082, 0.004353120103354313, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.011740507937854638, 0.0015313117817324917, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0011056921657118801, 0.00126065339347603, 0.1585806373283516, 0.17659182772619353, 0.15811246213030639, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09704234312152893, 0.06086990816203286, 0.05790557577366773, 0.13172370194486438, 0.11598280043405862, 0.11323840041578048, 0.05205959077484945, 0.06857778488158306, 0.062143657266696906, 0.10733108491796861, 0.10895953014541093, 0.11144132782383209, 0.08596795215326025, 0.08534687093967719, 0.10328151175661981, 0.07578869462512361, 0.11396325040467259, 0.07707405793628819, 0.032749254571146746, 0.05076623546139192, 0.11307353384607333, 0.14762952778314764, 0.1378324713731972, 0.1311929822063761, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "408b0e22-9051-4251-a1cf-4bdfc20e1c1d", "fitness": 0.03818784061402261, "name": "HybridPSOSA", "description": "Improved dynamic balance through adaptive velocity scaling and non-linear stochastic influences for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update with adaptive scaling\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                scale_factor = 1 + 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n                self.velocities[i] = (w * self.velocities[i] * scale_factor +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation with non-linear influence\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim) * np.random.rand()\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling with non-linear dynamic adjustment\n            T *= alpha * (1 - (eval_count / self.budget)**1.5) * (1 + 0.2 * np.cos(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 38, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.13587453826894902, 0.08737805688319167, 0.09374227753190911, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08201372438836507, 0.0049542106679904, 0.08504527400774209, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0033158252322812443, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006805240273257684, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.13154221463104565, 0.11140537872674927, 0.12707491907241786, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06403293315235203, 0.06391879014758362, 0.06213413283906366, 0.10902380237326825, 0.10113645701756091, 0.09549377664654934, 0.061137748326781094, 0.04343937154977995, 0.05777152071845393, 0.1082122637870403, 0.10799134722531922, 0.0935212764714215, 0.06434853475653224, 0.06168355937992542, 0.04209452588152818, 0.06272612577616121, 0.08984655273201225, 0.06054559537656978, 0.029452352113675584, 0.0364863894553199, 0.03897627502646095, 0.14070065033777823, 0.1363145736008572, 0.1394220695579257, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "1598c02b-3200-4a54-b3b8-a9a8d839cbd3", "fitness": 0.05684586662304844, "name": "HybridPSOSA", "description": "Slight adjustment in cooling rate and global best update rule to enhance convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.98  # Slightly adjusted cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score or np.random.rand() < 0.05:  # Small probability to update global best\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 39, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.09.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1697251839417473, 0.13229607645170505, 0.12809658994296835, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0009008048150500603, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.655019666030941, 0.32304607174274425, 0.05335111723765018, 0.00043478260869567187, 0.009910504049771007, 0.00043478260869567187, 0.005219073767966598, 0.005483314696324015, 0.008809865031160435, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001749765201290554, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.14998882614661768, 0.14455125108406708, 0.13241493673503224, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07452324829584067, 0.06423048031236867, 0.061651428340424586, 0.12892058826529795, 0.1339584156841913, 0.13325806211728353, 0.06881257597162338, 0.05118549843280995, 0.05514507625382181, 0.10977054705265588, 0.1099099811911588, 0.11033039379099352, 0.09988565981208641, 0.10989504670009842, 0.0691602651028671, 0.05859332633072978, 0.10416289829737435, 0.06869049077089151, 0.03035140454245644, 0.04901491058657581, 0.048680326750229486, 0.14653060091261483, 0.13631869673208707, 0.13501160165101356, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7152ca09-3aae-476f-b51b-fb9d97ee8bb4", "fitness": 0.06902932700307317, "name": "HybridPSOSA", "description": "Refined the acceptance probability condition in simulated annealing to incorporate a more adaptive threshold for updates.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                acceptance_probability = np.exp((self.personal_best_scores[i] - candidate_score) / T) * (0.5 + 0.5 * (eval_count / self.budget))\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < acceptance_probability:\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 40, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.17497731534625893, 0.1349011644095004, 0.16140004786275752, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6980584704066908, 0.8028990450836812, 0.1846118068744177, 0.0025570987744917284, 0.005804289166125409, 0.010873854577614472, 0.03189822699222766, 0.0037763285726751805, 0.0015046283422545104, 0.0005251241316905908, 0.005418601594724182, 0.002061063970955068, 0.00043478260869567187, 0.003710088754979024, 0.0009174912947272906, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005558070076493449, 0.0032515140201975212, 0.15427514329174108, 0.17244054048633917, 0.14171343794144697, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08200572930861016, 0.06865546450263815, 0.07709672627585185, 0.11448127465438751, 0.12556577649702172, 0.11545839932436064, 0.04511163260140916, 0.07127040203887858, 0.05173511034472278, 0.1089583977270786, 0.10770298852649729, 0.10827998679797812, 0.09290069552685765, 0.0833974052591886, 0.12256818623572008, 0.07691401418264532, 0.11648648910762394, 0.07320593322800639, 0.02866819663365694, 0.050034601521770306, 0.11391415794449467, 0.13490148955553682, 0.14473047184191934, 0.1466325778551799, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "93a1d07c-d7f5-4fcc-8977-1cc914770068", "fitness": 0.06864051523483038, "name": "HybridPSOSA", "description": "Enhanced adaptive cooling with a sinusoidal adjustment factor to dynamically modulate exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.25 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.18488260773755794, 0.14437312266168878, 0.16828655055659147, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7040865739428752, 0.8393089644766347, 0.07234622703222948, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.026778080038006302, 0.0028108989189448153, 0.01484277160416736, 0.00043478260869567187, 0.000662579252851625, 0.0006616195677369152, 0.00043716643981139836, 0.011759813277627984, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1647351622445301, 0.17188458221898817, 0.14926686308356985, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09917249986437404, 0.06368593459862792, 0.08036948228484242, 0.11593437219929004, 0.1223048229698811, 0.12271720278433917, 0.052564550366596796, 0.08227763456574888, 0.05020898709301491, 0.10623007534549311, 0.10278364750762514, 0.11116627198461326, 0.09236625492712591, 0.09648139890984186, 0.10802602740679268, 0.07211685843671223, 0.10137466464463696, 0.07204414589957686, 0.03097572591245279, 0.044653469246259014, 0.09981574702138596, 0.13854794133696136, 0.14862551263581258, 0.15663724243370836, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "bf5b7a6e-c0ac-4a0a-a664-b4d71ee31a60", "fitness": 0.06693599551814214, "name": "HybridPSOSA", "description": "Improved dynamic cooling factor by incorporating exponential decay based on progress for enhanced convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * np.exp(-0.02 * eval_count / self.budget)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 42, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.10.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.18240877324906712, 0.1785736004831313, 0.17499675020193328, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007969488421846194, 0.0004652265147820911, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.31125008667703424, 0.6220266535538933, 0.33583447749625817, 0.00043478260869567187, 0.013200556182913048, 0.0007352878537962848, 0.037567433244397264, 0.017168032107525155, 0.006190210819916775, 0.00043478260869567187, 0.005893601205222088, 0.001124055825672321, 0.0009855700925028854, 0.0038710581954669587, 0.0010255924480413459, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0024012442196926775, 0.00043478260869567187, 0.0038830063773868106, 0.18989264556258945, 0.19068968003568953, 0.19246770036894367, 0.0005026136141897952, 0.00043478260869567187, 0.00043478260869567187, 0.11738010922178888, 0.06224402100969828, 0.06985409781339924, 0.11125238531638237, 0.11445845853893222, 0.11892474613144577, 0.07902226182280725, 0.05665239320055204, 0.053136873650627914, 0.10721432851947987, 0.11006136358732521, 0.11307995762016121, 0.09163017211325375, 0.08807638508437621, 0.11442234539441165, 0.07612341557940416, 0.12048536907581364, 0.08127923485267274, 0.034539365182952086, 0.052529153560423314, 0.11730729528102168, 0.1473315775974422, 0.1438941735237178, 0.15410660584721814, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "69e4ee33-b6f2-4898-b776-b1bf1561e9dc", "fitness": 0.03523018948540497, "name": "HybridPSOSA", "description": "Introduce momentum adaptation to enhance convergence by dynamically adjusting velocity inertia weight based on evaluation progress.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 43, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.08155061501452898, 0.06689926585085315, 0.07525376349004864, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0460753617857802, 0.07957506341113008, 0.03662251742605194, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0013814505843577907, 0.0005590562803894361, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09418094730216187, 0.09720216117783054, 0.09089492485246964, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08437987005142333, 0.0572170787143812, 0.07451628386566922, 0.11650302537207669, 0.11888235655300627, 0.12310403637024525, 0.05581758427780281, 0.04408086942315825, 0.06666459632238242, 0.09136724730937795, 0.09620914286952331, 0.09880493666060963, 0.03705829021486318, 0.04317043254053954, 0.010526138242268446, 0.05449035981850692, 0.07111162434450125, 0.06030229237491924, 0.01878980051920298, 0.03619353066350517, 0.078463431365967, 0.13639650060695352, 0.13981617475090635, 0.1364259560200256, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9e0bf9c0-b2ec-40d2-b0c7-af73f157a1df", "fitness": 0.06957318013330994, "name": "HybridPSOSA", "description": "Enhanced adaptive cooling by incorporating a dynamic adjustment factor based on evaluation progress to balance exploration and exploitation with improved initialization strategy.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 44, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1713358798904996, 0.1349011644095004, 0.1605149930540769, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6980584704066908, 0.8028990450836812, 0.1846118068744177, 0.0025570987744917284, 0.005804289166125409, 0.010873854577614472, 0.03189822699222766, 0.003636301882029125, 0.0014054961048731718, 0.0005251241316905908, 0.005418601594724182, 0.002061063970955068, 0.00043478260869567187, 0.003710088754979024, 0.0009174912947272906, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005558070076493449, 0.0032515140201975212, 0.16827917608530696, 0.17165916018707061, 0.13816882647875828, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09316522315764542, 0.06292664234515954, 0.0786414552098722, 0.13865706494302, 0.1279467724043739, 0.10778610678173028, 0.04511163260140916, 0.06948977957194646, 0.046594992213625175, 0.11205732711930749, 0.11047176107330292, 0.10479360375858249, 0.09290069552685765, 0.0833974052591886, 0.12229693117099227, 0.0741988282264684, 0.11539615375079482, 0.07707405793628819, 0.03262276676952314, 0.050576139811540965, 0.10747001413300905, 0.15255132932508197, 0.14051065745181968, 0.14828380048840173, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0b6c3393-dc45-4d92-bf9a-a1ada319de18", "fitness": 0.05475827362275733, "name": "HybridPSOSA", "description": "Enhanced adaptive cooling by incorporating a dynamic adjustment factor based on evaluation progress to balance exploration and exploitation with increased perturbation flexibility.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T * np.random.rand(), self.dim)  # Increased perturbation flexibility\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 45, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.07.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.15835857323135227, 0.16045473515162845, 0.1785433575202423, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0027956768421941725, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0556520410374981, 0.3277262387371458, 0.23435391949396478, 0.00043478260869567187, 0.00043478260869567187, 0.0018428410393950267, 0.03332270816590133, 0.02962494018905959, 0.02675258893882959, 0.0016975325143927522, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005740842923717349, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007105427035411727, 0.001133842684489128, 0.17939050691638103, 0.184951066117939, 0.1568000603408679, 0.00043478260869567187, 0.00043478260869567187, 0.001329341019421837, 0.06804071357330788, 0.0662247921197836, 0.1172452422271193, 0.1271355844272316, 0.10566749078658577, 0.11504922635049442, 0.06721802142491529, 0.06980748328342168, 0.06199726572160946, 0.09750218191536986, 0.1117066235644113, 0.10886623716279542, 0.08423157402908954, 0.08906470962079172, 0.10036611018209418, 0.07731520250293, 0.06203369214159549, 0.07206333961097555, 0.060763001201217026, 0.05061771842961327, 0.05081696504073707, 0.1418902582352991, 0.1358238026910661, 0.14096352904406606, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a4d9131b-e1e5-4b49-871b-56024016b6b0", "fitness": 0.05566951135390622, "name": "HybridPSOSA", "description": "Introducing a dynamic learning factor and adaptive neighborhood search to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5\n        T = 1.0\n        alpha = 0.99\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                dynamic_c1 = c1 * (0.5 + 0.5 * np.sin(2 * np.pi * eval_count / self.budget))\n                c1_i = dynamic_c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                candidate_position = self.particles[i] + np.random.normal(0, T * (0.5 + 0.5 * np.sin(2 * np.pi * eval_count / self.budget)), self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 46, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.09.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1701362033066145, 0.13319053448232487, 0.17020902236498203, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005024321731111892, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10733638305285875, 0.647419911711558, 0.06788258486603649, 0.00043478260869567187, 0.00043478260869567187, 0.0017124226131995934, 0.013818208321226488, 0.0077285257492254456, 0.005704717365464962, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.010157731838339124, 0.007181363663379403, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16122252658252245, 0.15006910629946357, 0.1513247508423755, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09078228832553736, 0.07291092851269931, 0.07660509823950079, 0.10989775360689058, 0.11298263636852712, 0.11053264231027826, 0.07978061752027199, 0.05720165276723732, 0.03260987088272527, 0.1073844609304927, 0.11557560249723442, 0.11511267167427452, 0.0839607512738928, 0.07750016705636742, 0.10830562611988781, 0.06767741955215312, 0.058035400982138996, 0.07479820325400277, 0.03089753280393359, 0.045503912967341686, 0.10599298791530365, 0.15046654651596425, 0.1504316524525915, 0.15374892424105724, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "25291680-89e2-48f9-8c4f-f62d53e14315", "fitness": 0.0666154379358545, "name": "HybridPSOSA", "description": "Introduce a non-linear cooling schedule by modifying the cooling rate, improving balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**3) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))  # Modified cooling rate\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 47, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.1593051757321059, 0.12662837244152136, 0.1563178204981278, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6980474928204929, 0.8029112918834975, 0.093725382750393, 0.01202731145994218, 0.0012567291840672734, 0.0013450201043649912, 0.013259414413886117, 0.018543222511562152, 0.004553667751013624, 0.0004607942018270972, 0.005522872268065693, 0.00043478260869567187, 0.004002181055444365, 0.0022406309075483355, 0.0005347548118832535, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0021399075109447274, 0.00043478260869567187, 0.001842446319051727, 0.1614938580295232, 0.1519839885242813, 0.15222826489333008, 0.00043478260869567187, 0.0007539607881894561, 0.00043478260869567187, 0.10371964540511847, 0.06464463804193676, 0.08144411142248986, 0.11124846706815972, 0.12022743422866855, 0.11539357178738452, 0.04637296274146452, 0.07176770392826093, 0.04451872882475805, 0.10707056905390877, 0.0983088677314291, 0.10819776853976648, 0.08513289859269679, 0.0663755984495118, 0.09987875583825234, 0.07428471744852505, 0.1130197551147143, 0.0767378530331837, 0.029402462427184695, 0.04897452338802433, 0.10689232631225898, 0.14795927046936408, 0.14949674398388602, 0.14324803147212106, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "367910a2-c1f1-44aa-87c6-38b4e2337871", "fitness": 0.03523018948540497, "name": "HybridPSOSA", "description": "Introduce a dynamic inertia weight for PSO to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 48, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.08155061501452898, 0.06689926585085315, 0.07525376349004864, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0460753617857802, 0.07957506341113008, 0.03662251742605194, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0013814505843577907, 0.0005590562803894361, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09418094730216187, 0.09720216117783054, 0.09089492485246964, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08437987005142333, 0.0572170787143812, 0.07451628386566922, 0.11650302537207669, 0.11888235655300627, 0.12310403637024525, 0.05581758427780281, 0.04408086942315825, 0.06666459632238242, 0.09136724730937795, 0.09620914286952331, 0.09880493666060963, 0.03705829021486318, 0.04317043254053954, 0.010526138242268446, 0.05449035981850692, 0.07111162434450125, 0.06030229237491924, 0.01878980051920298, 0.03619353066350517, 0.078463431365967, 0.13639650060695352, 0.13981617475090635, 0.1364259560200256, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "07776a96-023a-479a-97ef-91c565c9616e", "fitness": 0.06738707850592446, "name": "HybridPSOSA", "description": "A hybrid PSO and SA approach with adaptive cooling enhanced by dynamic learning rates for exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] + \n                                      (1 - eval_count / self.budget) * c1_i * (self.personal_best_positions[i] - self.particles[i]) +  # Dynamic learning rate adjustment\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 49, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.17897281986516522, 0.15743557029859534, 0.16288787505171742, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07911892819409883, 0.7443867442485996, 0.7222977429925546, 0.00043478260869567187, 0.008007037130658978, 0.00043478260869567187, 0.00993185311742606, 0.001617681684043304, 0.0011815596267563677, 0.00043478260869567187, 0.00043478260869567187, 0.002729214859245599, 0.0035949609514377423, 0.0060673726620116275, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0020937339758960727, 0.0005819536741621389, 0.13507909208109015, 0.15789456049096529, 0.15532550690023483, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10207613053528175, 0.068785495885618, 0.0824097698478019, 0.12729989272101028, 0.1154675575974069, 0.1322862928248857, 0.059095463687195315, 0.05379959932955125, 0.04647654451860039, 0.11588497780007889, 0.10982585329691097, 0.108457339779229, 0.07585806369783388, 0.0771504759671825, 0.12194108814326421, 0.07304981042241332, 0.11746936163311827, 0.07880972602609626, 0.030814611631183153, 0.04798629345246053, 0.10889156522840826, 0.14816330863972382, 0.14950011781393258, 0.1581226258818439, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7881ef9a-9ab4-4277-806b-1dd3099a387d", "fitness": 0.06905271693367186, "name": "HybridPSOSA", "description": "Introduced velocity adaptation inspired by successful solutions to enhance convergence rate in HybridPSOSA.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptation_factor = 0.9 + 0.1 * (self.global_best_score / (self.personal_best_scores[i] + 1e-9))  # New adaptation factor\n                self.velocities[i] = (w * self.velocities[i] * adaptation_factor +  # Updated velocity adaptation\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 50, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.17921230798396748, 0.12951864744549846, 0.16081431949368163, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7026578920857678, 0.8470985419742024, 0.07585912805531636, 0.005299437448161748, 0.002842807069631359, 0.00371677322856101, 0.023766113310928483, 0.0031516230517405486, 0.00488854953754192, 0.0005699787798707501, 0.00043478260869567187, 0.01777617701098755, 0.0028880936549567915, 0.0036501009155486264, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.001420355713571575, 0.004477891656983757, 0.00043478260869567187, 0.14671932415735423, 0.16520371580374726, 0.14152491898114916, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07944329228475033, 0.0746469504189653, 0.08678134879330213, 0.13273802652051447, 0.12174851343717819, 0.11718312224367167, 0.06762138945352791, 0.06067672083146802, 0.08658285255448273, 0.11226332347063506, 0.10805324103298952, 0.10444717996803177, 0.1036061047935547, 0.08044141537550964, 0.1084334226079986, 0.07460604792044612, 0.11246194185358682, 0.07854471991038126, 0.030989063962659213, 0.050546576282876954, 0.1070153292249032, 0.15870462249123196, 0.1388802290801895, 0.1405843569175672, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "bb7ac46f-aec8-4073-93e2-3eca89f4312b", "fitness": 0.05025277887754581, "name": "HybridPSOSA", "description": "Introduce adaptive velocity scaling and diversity maintenance to enhance convergence speed and robustness.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0\n        alpha = 0.99\n\n        while eval_count < self.budget:\n            if eval_count % 10 == 0:  # Adaptive velocity scaling\n                velocity_scaling = 1 + 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n                \n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                self.velocities[i] = velocity_scaling * (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < 0.05:  # Introduce diversity\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 51, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.12.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.05186358475329278, 0.04049886308921391, 0.07735269211376739, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8323872782611942, 0.6102649727404317, 0.0750219485882575, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010716551109632988, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09494886637385169, 0.09384746937530564, 0.07902846726429391, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07162421238088768, 0.0516068896146018, 0.0540926603035351, 0.09659946410031772, 0.10218660352325826, 0.12322979528509581, 0.06319772195718698, 0.05057045379261327, 0.046960103688031274, 0.0950028574131675, 0.10333406761429531, 0.10590458601672059, 0.000534642512034611, 0.03682045057981509, 0.004004108458337874, 0.04798700232120645, 0.05128841975317877, 0.034276502884686755, 0.028853315028917192, 0.02912556506367525, 0.031158405234037123, 0.13724885180916402, 0.13886960571998086, 0.14091625732754565, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9e279e57-3c20-42b9-9510-a326d789ae50", "fitness": 0.0347984648504247, "name": "HybridPSOSA", "description": "Introduce a dynamic inertia weight `w` update mechanism in PSO for better convergence control.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            # Dynamic inertia weight update\n            w = 0.9 - 0.5 * (eval_count / self.budget)\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 52, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.09219506636318331, 0.06466550163809903, 0.0852892995581962, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04607465749685935, 0.07957654683499527, 0.047683901887627056, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0037650047858078795, 0.0011730038352864014, 0.0012863404421289415, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08052456773136363, 0.12303531144987212, 0.08545067016067287, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06946428479439515, 0.05320370279980424, 0.06390473370945826, 0.10562524583179489, 0.11584612615973533, 0.09904669309384095, 0.054842982108567084, 0.02944081852941627, 0.06194099152255561, 0.09316478861635125, 0.09382757681922316, 0.09397981001370881, 0.025853710913835037, 0.07160126391800592, 0.006672043965305741, 0.05039292584197741, 0.06196378365271793, 0.051522958303170885, 0.019861668232087237, 0.04172487513818213, 0.08682484640913912, 0.14029057257358657, 0.14018413316547362, 0.1479368870211092, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "808e0cd9-8d76-4c9c-9019-fe9d844fe455", "fitness": 0.07039955205398721, "name": "HybridPSOSA", "description": "Improved energy landscape exploration by introducing non-linear velocity scaling based on progress.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i])) * (1 + 0.1 * np.tanh(eval_count / self.budget))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["e0c61c7c-aa22-4b73-907f-9597cb4393bc"], "operator": null, "metadata": {"aucs": [0.14808493338176354, 0.1331261394494454, 0.13172216404282255, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005512399778039301, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7534537270672842, 0.7776238043724975, 0.3387129417664393, 0.00043478260869567187, 0.00043478260869567187, 0.005718693701385558, 0.009707432723257803, 0.03223411002884091, 0.015012845652620843, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0010228099278166702, 0.004063027344950787, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1269529459648978, 0.16637636696760005, 0.160266208470901, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08764018640422522, 0.08489571029870369, 0.0735965906539614, 0.1276834089049289, 0.12424363485643375, 0.11647472127672276, 0.08557326305243729, 0.07223285476717911, 0.04112223303782392, 0.10760120228864212, 0.10887593560797426, 0.1046063447761385, 0.07574485148657384, 0.08644974836769626, 0.09479777705511938, 0.07448330670863745, 0.10737423943117985, 0.07604362906575779, 0.028851944304233657, 0.0500033962987424, 0.09943800219956422, 0.13562193647260046, 0.14426456982685432, 0.14260582642635877, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7f93fc27-b689-4bc8-81da-adb1ccf58f8b", "fitness": 0.053493052297619914, "name": "HybridPSOSA", "description": "Refined exploration by incorporating adaptive velocity scaling based on the inverse of the evaluation progress.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i])) * (1 + 0.1 * np.tanh(eval_count / self.budget)) * (1 / (1 + eval_count / self.budget))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["808e0cd9-8d76-4c9c-9019-fe9d844fe455"], "operator": null, "metadata": {"aucs": [0.19144967614764652, 0.17478830821868063, 0.18843796086645082, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.177397974548951, 0.13768341046766697, 0.07437698771190715, 0.00043478260869567187, 0.00043478260869567187, 0.01062535950902499, 0.01809241412340512, 0.00043478260869567187, 0.029416427190650518, 0.0013294888807214855, 0.00043478260869567187, 0.00043478260869567187, 0.0034764012616693707, 0.013123030080256615, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003778741139601527, 0.00043478260869567187, 0.00043478260869567187, 0.175283305614083, 0.18791131918289672, 0.1543578003327727, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09144850908037683, 0.0913697870436353, 0.0849294487247908, 0.11415244468669594, 0.10948776681280237, 0.11510594226334991, 0.07618984541941398, 0.048888160137092074, 0.04735059763206073, 0.09855613419629838, 0.11933527564892832, 0.09905760188548773, 0.09970899291305235, 0.09484123410919698, 0.08673773701608534, 0.0736746848266786, 0.11381868245886384, 0.08365689014583633, 0.03232365348719868, 0.05078488739382736, 0.11793300543908647, 0.15653319047299974, 0.13793012617346123, 0.1522435187067681, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c038a6f7-d7e0-4a22-b4d0-3ba04c295147", "fitness": 0.062170762014350824, "name": "HybridPSOSA", "description": "Enhanced convergence control by adjusting PSO inertia weight based on remaining budget proportion.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = ((w * (1 - eval_count / self.budget)) * self.velocities[i] +  # Adjusted inertia weight\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i])) * (1 + 0.1 * np.tanh(eval_count / self.budget))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 55, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.10.", "error": "", "parent_ids": ["808e0cd9-8d76-4c9c-9019-fe9d844fe455"], "operator": null, "metadata": {"aucs": [0.17933735014020868, 0.176132727096184, 0.1723621234059154, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1565546130918266, 0.7514150133998969, 0.07638371452382908, 0.005781533275616257, 0.0009801865265620657, 0.004995045868583237, 0.014774077765165261, 0.004660684685883987, 0.011991315564011118, 0.01243015752067611, 0.0010860765922848792, 0.00043478260869567187, 0.01854155609075825, 0.0027390254638612888, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0035995579448874215, 0.003942923350642058, 0.004568854321676419, 0.17320509626873948, 0.19194384005836895, 0.19502620737251208, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09317727471728299, 0.06440819598954695, 0.06601435338100914, 0.12326405406118268, 0.12519431043173967, 0.11706965787294499, 0.05665046965200571, 0.05195580863625293, 0.06940371660107703, 0.10784102168791121, 0.1123208288324431, 0.1049221557100738, 0.09087384601326631, 0.09629869520484535, 0.10245352482941483, 0.07403653246764985, 0.12691258005849992, 0.07871592521123638, 0.03275904616230707, 0.05081648122744964, 0.1114183747722155, 0.1427785998370712, 0.14976801622361346, 0.15348536729804263, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4f09bc27-fb58-4e76-bced-38ea72f7788a", "fitness": 0.062170762014350824, "name": "HybridPSOSA", "description": "Enhanced velocity update rule by introducing dynamic inertia weight based on convergence progress.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                w_dynamic = w * (1 - eval_count / self.budget)  # Dynamic inertia weight\n                self.velocities[i] = (w_dynamic * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i])) * (1 + 0.1 * np.tanh(eval_count / self.budget))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 56, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.10.", "error": "", "parent_ids": ["808e0cd9-8d76-4c9c-9019-fe9d844fe455"], "operator": null, "metadata": {"aucs": [0.17933735014020868, 0.176132727096184, 0.1723621234059154, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1565546130918266, 0.7514150133998969, 0.07638371452382908, 0.005781533275616257, 0.0009801865265620657, 0.004995045868583237, 0.014774077765165261, 0.004660684685883987, 0.011991315564011118, 0.01243015752067611, 0.0010860765922848792, 0.00043478260869567187, 0.01854155609075825, 0.0027390254638612888, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0035995579448874215, 0.003942923350642058, 0.004568854321676419, 0.17320509626873948, 0.19194384005836895, 0.19502620737251208, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09317727471728299, 0.06440819598954695, 0.06601435338100914, 0.12326405406118268, 0.12519431043173967, 0.11706965787294499, 0.05665046965200571, 0.05195580863625293, 0.06940371660107703, 0.10784102168791121, 0.1123208288324431, 0.1049221557100738, 0.09087384601326631, 0.09629869520484535, 0.10245352482941483, 0.07403653246764985, 0.12691258005849992, 0.07871592521123638, 0.03275904616230707, 0.05081648122744964, 0.1114183747722155, 0.1427785998370712, 0.14976801622361346, 0.15348536729804263, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a571c096-2979-4804-b855-c4eb06d47ed6", "fitness": 0.06357178249895365, "name": "HybridPSOSA", "description": "Enhanced exploration by implementing non-linear scaling in velocity update with cosine modulation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) +\n                                      c2_i * (self.global_best_position - self.particles[i])) * (1 + 0.1 * np.cos(np.pi * eval_count / self.budget))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 57, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_ids": ["808e0cd9-8d76-4c9c-9019-fe9d844fe455"], "operator": null, "metadata": {"aucs": [0.15601773501303084, 0.1462406634840795, 0.14529065836826205, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00086037205846623, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8497543610760149, 0.5675387616105289, 0.023228383760013904, 0.00043478260869567187, 0.00043478260869567187, 0.005254636734260076, 0.003907962157824851, 0.018246688875760975, 0.009414211888789437, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005196265379906806, 0.010537025786147125, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.17901026618591886, 0.15373519856244267, 0.12806702437385808, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06873046017325501, 0.06651342977124086, 0.06851789202924052, 0.12147987780169056, 0.1162852918460846, 0.12741884520652458, 0.076475423749509, 0.05467755198159985, 0.06574921739729844, 0.10585673624390557, 0.10227702961337226, 0.10462735762982944, 0.047796679482292825, 0.09643297419551089, 0.07707759850336593, 0.07111754716452157, 0.1076229973902062, 0.07180360706263733, 0.029517602796966247, 0.0438281135300812, 0.10520151063912264, 0.1439718033699603, 0.14959546031003368, 0.1383800732428465, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e9984310-74d0-4c35-9202-ff2642c0b1da", "fitness": 0.07403394271007648, "name": "HybridPSOSA", "description": "Enhanced velocity profile adaptation and adaptive learning factors for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 58, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.15.", "error": "", "parent_ids": ["808e0cd9-8d76-4c9c-9019-fe9d844fe455"], "operator": null, "metadata": {"aucs": [0.16013092612590885, 0.1429148657545155, 0.13274197056387516, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7425699776181058, 0.7872309947438507, 0.6850756439243237, 0.00043478260869567187, 0.00043478260869567187, 0.0006092910066402002, 0.00043478260869567187, 0.008136832691138185, 0.02165878511960151, 0.0004960442851291713, 0.0005842564161291364, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12113315377148726, 0.145323709616055, 0.16298676763664444, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07987053727702476, 0.07507932111128768, 0.07403883210061235, 0.12883926528402634, 0.13147135566701984, 0.11039496190252773, 0.05194762528148977, 0.05022424795428693, 0.040696105869400645, 0.1078433948466464, 0.10353138747964508, 0.1136608513425148, 0.07363968872876503, 0.06509370466282427, 0.1177791427332413, 0.07841687843044776, 0.106805184451509, 0.07775908704589929, 0.028223784340284497, 0.047710647536440054, 0.11253193283786234, 0.14895513359697365, 0.13447648841647863, 0.14507848825924075, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "00fe4190-5dd9-45d7-9dbe-04b6e63352fa", "fitness": 0.04317661261527977, "name": "HybridPSOSA", "description": "Introduced adaptive momentum increment to enhance convergence speed and stability.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i] * (1 + eval_count/self.budget)  # Adaptive momentum increment\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.10.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.05668486449808652, 0.06938912143990306, 0.06656358487948655, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7566264737656394, 0.08395516658276314, 0.025782080665843088, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10006086337810971, 0.10806615835285693, 0.09129693546361328, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08660685514021893, 0.059631243132420964, 0.05794842441139969, 0.10675500344677602, 0.10165863586953372, 0.10363639014689474, 0.05491091341905663, 0.04391843303023135, 0.07373659594164661, 0.10560435262704682, 0.10087702974059465, 0.10401482846755006, 0.00043478260869567187, 0.00043478260869567187, 0.01787025205999948, 0.04142556705731448, 0.08754289960759731, 0.0502250363295319, 0.024055473679664763, 0.03445840797273869, 0.06875402629431393, 0.13164996297338882, 0.14421006276091553, 0.13297437820848412, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6f181871-782c-4bb5-b0d3-ba6095bfb479", "fitness": 0.034642169153018036, "name": "HybridPSOSA", "description": "Introduce dynamic inertia weight adjustment to improve convergence speed and balance exploration-exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                w = 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic inertia weight adjustment\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.05849287136067227, 0.04643933063666539, 0.09741022508772368, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04608144296819472, 0.07957597559120255, 0.16857805050120467, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004776001206110658, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07773296730337098, 0.11574448572666673, 0.08159110724394669, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06441165391224335, 0.06161244039058955, 0.06355098677316107, 0.10391226326332026, 0.1178852926799352, 0.10193660756958178, 0.06078094202283413, 0.03537594234067709, 0.03747215794021708, 0.09520941696662544, 0.09867577367360036, 0.09744537374200912, 0.00043478260869567187, 0.03938473645954754, 0.0230146524960948, 0.05564187731546688, 0.05488414985646639, 0.054512972523877545, 0.022074084475383726, 0.03522512588409743, 0.07188404526217529, 0.13915952151219002, 0.13041757040077817, 0.13638961219153656, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7d38ec5f-0b0f-4279-b603-af7917bee389", "fitness": 0.033174289331910786, "name": "HybridPSOSA", "description": "Introduced adaptive inertia weight adjustment in PSO to enhance convergence speed and solution precision.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.9, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            w = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 61, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.06782394202671882, 0.05714978832105, 0.0538047765090347, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04608467734948496, 0.07957758781452173, 0.0367472572091988, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0023668381679220474, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09003253918620413, 0.12238619602327161, 0.10271416408687217, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06615397993988548, 0.062254062837009516, 0.0699109172242155, 0.09406180695057687, 0.109314855750276, 0.09940607321508099, 0.05860360598417069, 0.05029255835848945, 0.04494272333732663, 0.09675787424096771, 0.08979539037803774, 0.10167304869292426, 0.006531279197752982, 0.00043478260869567187, 0.031838554575740474, 0.05052422240133281, 0.057946848664835904, 0.06139176583581418, 0.01707780626221056, 0.031168084846718624, 0.08016907085831715, 0.1410026160828265, 0.14898970666860378, 0.14309769116105275, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "145de5be-c5c6-45ff-84d2-454267aca7b7", "fitness": 0.06296181666262293, "name": "HybridPSOSA", "description": "Introducing dynamic inertia weight and stochastic tunneling to enhance exploration-exploitation and global search capabilities.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n        \n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n        W_max, W_min = 0.9, 0.4  # Max and min inertia weights\n        \n        while eval_count < self.budget:\n            w = W_max - (W_max - W_min) * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n            if np.random.rand() < 0.05:  # Stochastic tunneling with a small probability\n                self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                self.global_best_score = func(self.global_best_position)\n                eval_count += 1\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 62, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.15.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.06779325248676527, 0.05059821559533961, 0.08500438203035254, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6605336099792709, 0.8300536031864518, 0.792678666348079, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.014958555060909373, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08193113546220498, 0.08861076264818069, 0.09212369056780456, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06264231236316731, 0.05345447701150696, 0.05516406890016523, 0.11030595679732469, 0.12235403227633523, 0.09822821952687222, 0.05230220304225208, 0.04907925236567323, 0.05513313441708212, 0.0944918658566386, 0.09918336855960685, 0.09797263715420623, 0.007630533127640504, 0.03039942563762299, 0.03610331346971263, 0.05803974070255624, 0.05578351851693597, 0.056037231360177575, 0.020597288386266732, 0.03617978498493024, 0.08240583708785632, 0.13613463257849845, 0.13930212612336346, 0.14351822696666516, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "57bf63de-5e5d-4053-b5ed-7595b83b81e2", "fitness": 0.04993797577243474, "name": "HybridPSOSA", "description": "Incorporate global best influence decay to enhance exploration in early stages and focus on exploitation later.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                decay_factor = 1 - (eval_count / self.budget)  # Add global best influence decay\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor * decay_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.17955576828204223, 0.15679158306203567, 0.16113032426315554, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06765214662009045, 0.15922826002505452, 0.06950512476968451, 0.00043478260869567187, 0.00043478260869567187, 0.006362809414641846, 0.020227394385436193, 0.0027756619364818214, 0.016382501239644354, 0.010921733088091412, 0.00043478260869567187, 0.00043478260869567187, 0.0024559453183171653, 0.0015592005595433944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16630734423389015, 0.1325989166392756, 0.16822954694972758, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07606019277605636, 0.08292126646996067, 0.06420430795442433, 0.11829356859679996, 0.10154059517368019, 0.1275256998990113, 0.07316509532195081, 0.06355830213620561, 0.05084212454104109, 0.11172069579990895, 0.10447823673774426, 0.10906567289954439, 0.10293716290325983, 0.09516180000885432, 0.09322476967283844, 0.0729217321043254, 0.11615173327344086, 0.08184643811676995, 0.031820514822361035, 0.04651075997071408, 0.11732881006160911, 0.144351933388136, 0.1353235277399254, 0.13898201098136465, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c5a02bc4-6731-448f-bdfc-852a634c7163", "fitness": 0.057096992932725854, "name": "HybridPSOSA", "description": "Fine-tuned adaptive cooling and updated perturbation strategy for enhanced exploration-exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.98  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                perturbation_scale = (0.5 + 0.5 * np.sin(np.pi * eval_count / self.budget))\n                candidate_position = self.particles[i] + np.random.normal(0, T * perturbation_scale, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 64, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.11.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.1747919414761394, 0.15459599811357283, 0.1496015377476556, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00045356638726923304, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.035226312549078376, 0.8266111675183369, 0.07319485762967515, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.02392295677081091, 0.004492107856591487, 0.01674878004167113, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.008984011815117099, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005049837058688222, 0.15080715158283453, 0.14042020667976518, 0.16951786602579177, 0.0013396500855665794, 0.00043478260869567187, 0.00043478260869567187, 0.0893336823702906, 0.07956858991339533, 0.061533101552256886, 0.10957850209697817, 0.15588371983871696, 0.10293402835946952, 0.07048982379591384, 0.04359760134399748, 0.050042346028586815, 0.09344490971274666, 0.10231892116639518, 0.09413458506734773, 0.08393298591815912, 0.10082260413293442, 0.09496816310291978, 0.07372319343332889, 0.061071408755976275, 0.07550813539492918, 0.031529117595289424, 0.04979529961934337, 0.10849257521586686, 0.14498762964090073, 0.1379777180573145, 0.15018870957919783, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4d53d561-d8fd-4fde-93f2-d0c4b40ff1d9", "fitness": -Infinity, "name": "HybridPSOSA", "description": "Refinement introduces a dynamic population size adjustment based on remaining budget to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            current_pop_size = int(self.pop_size * (1 + 0.1 * np.sin(np.pi * eval_count / self.budget)))  # Dynamic pop size\n            for i in range(current_pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(current_pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 65, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {}}
{"id": "e23b74b6-c4c9-4e50-8527-0eb0daa900ec", "fitness": 0.032427998175505485, "name": "HybridPSOSA", "description": "Introduce dynamic adaptation of the inertia weight to further enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                w_dynamic = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight\n                self.velocities[i] = (w_dynamic * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 66, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.05389239103398247, 0.04935830409897002, 0.05633370065879717, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08210461766502508, 0.07957789578727281, 0.03677220660562874, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.005552735458763447, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08012293624368416, 0.09603843486539987, 0.10132811091756633, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.062447223823799525, 0.052298983165103285, 0.06095588712428168, 0.10933213783075424, 0.1089605169512039, 0.11466163537553709, 0.053561784255447, 0.04164048611254323, 0.03918593893250921, 0.09541390807364325, 0.09853047439719687, 0.09351420742716388, 0.022309134648926032, 0.020808524812015228, 0.00043478260869567187, 0.05556113864155576, 0.047853270238547685, 0.05645509408317362, 0.018595489963163958, 0.03223841799807503, 0.07620679878180914, 0.13816717742512352, 0.13358402836854189, 0.1444957551320586, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e6dfefd3-700d-4e00-a7b7-2ae999a6903d", "fitness": 0.03678326767596016, "name": "HybridPSOSA", "description": "Fine-tune hybridization by incorporating a dynamic inertia weight and cooling rate adaptation for enhanced optimization.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.9, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 67, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.09.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.0334480670571593, 0.024395368979769794, 0.028797498936414367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0822295276419982, 0.07958473054960435, 0.7144717005385071, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07202196962781415, 0.06803304932203169, 0.06600306161812808, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05808336235813327, 0.05775135137399423, 0.05086775975957114, 0.1030954419126473, 0.11100348911113245, 0.10307547525620242, 0.054599870469166034, 0.03037167910862515, 0.03619910053936681, 0.08943261618225595, 0.08305509595067628, 0.0934142525733116, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.039124356585087505, 0.03857335707162446, 0.03623833309038005, 0.014806954122320914, 0.01849842270078128, 0.036134945121257256, 0.1370249385443879, 0.1378349995015281, 0.13196362750003587, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c4f72031-b6c1-4ee7-b55b-63aef0123266", "fitness": 0.06369138860226878, "name": "HybridPSOSA", "description": "Introduced adaptive inertia weight based on evaluation progress to enhance the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                # Change: Added adaptive inertia weight\n                w_adaptive = w * (1 - eval_count / self.budget) + eval_count / self.budget * 0.1\n                self.velocities[i] = (w_adaptive * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.11.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.1824959090317011, 0.18499087099263234, 0.18960518963017303, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.18430091066194054, 0.7927831643066557, 0.07541173383263, 0.009632931602673533, 0.00043478260869567187, 0.005572527900924995, 0.011597082085571975, 0.03072809742197047, 0.006122628401581731, 0.0018725015517514487, 0.00043478260869567187, 0.00043478260869567187, 0.014964425080222443, 0.015764609016946873, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0011365163047178939, 0.002277231530644852, 0.14102010765384054, 0.17595840459074463, 0.17436192169355846, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09625193573261026, 0.0701760258840598, 0.07120460652864735, 0.1333596088832132, 0.12198468362494608, 0.11787563916601806, 0.0652363086552874, 0.07207992264930552, 0.07274569973633116, 0.11219757263681429, 0.10700222954705563, 0.1111827083472745, 0.07115609628503039, 0.09492939031977443, 0.11486875366666072, 0.07118100456340137, 0.11726589848987334, 0.0777164235288278, 0.030209375594042687, 0.05129364590622787, 0.11440647233948797, 0.15418603762607908, 0.16010754911563074, 0.16395693159369562, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0d8640e4-b0a4-4d18-b3ad-ccf81e8f1f18", "fitness": 0.04134333983106294, "name": "HybridPSOSA", "description": "Introduced adaptive inertia weight and gradient-based perturbation to balance exploration-exploitation and enhance convergence rate.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                w_adaptive = 0.9 - 0.8 * eval_count / self.budget  # Adaptive inertia\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w_adaptive * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                gradient = (self.personal_best_positions[i] - self.particles[i]) * 0.1  # Gradient-based perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim) + gradient\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.11536537916278233, 0.12232031138766641, 0.0985359733101221, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07362862858258923, 0.055733936666648165, 0.05297923730080367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002362129783029965, 0.0046228705758425415, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0024808327511762762, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006134449397064978, 0.00043478260869567187, 0.00043478260869567187, 0.13903807652918498, 0.12540524761271166, 0.12309982646527662, 0.00043478260869567187, 0.00043478260869567187, 0.0008036096306512919, 0.06593814580542046, 0.05563362814896189, 0.0791402671060516, 0.11055239595241484, 0.12299180007140653, 0.1263239705468514, 0.061086806627852264, 0.07224434875913888, 0.06668010866891805, 0.09681968075665515, 0.10412380437303637, 0.10407894783499794, 0.06919651286273898, 0.05641614797304728, 0.06021433441044022, 0.06124909235322851, 0.08615300718760233, 0.06017479569388762, 0.02685828168549409, 0.04327565583689297, 0.09180051472483053, 0.13571842831131575, 0.1450636421503525, 0.14321403660115073, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "242e07e3-40a8-4571-b68a-d1de34f7d40b", "fitness": 0.06004275054909875, "name": "HybridPSOSA", "description": "Improved exploration by adding inertia weight decay in PSO for better convergence over iterations.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = ((w * (0.9 - 0.4 * (eval_count / self.budget))) * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 70, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.10.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.14511572349791813, 0.16305828587968074, 0.20535355867231686, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6850802974894106, 0.17191972986433213, 0.1697864679644029, 0.00043478260869567187, 0.0028509502328810665, 0.005127937222592527, 0.02561684691815791, 0.00043478260869567187, 0.01221130624079525, 0.0006276149193181757, 0.0004637994875862361, 0.00043478260869567187, 0.001820478961234273, 0.014419367209350664, 0.015237120101133428, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003910429644712443, 0.0013913295416495552, 0.0007701426438369019, 0.13436706670454035, 0.17310418949155182, 0.16318689487692928, 0.00043478260869567187, 0.0006360577174848725, 0.00043478260869567187, 0.10240618741248653, 0.06360181208795856, 0.06714475047328106, 0.11092013079727858, 0.11893732486934783, 0.12075693751141392, 0.05942527730006275, 0.05610641591939902, 0.04604647333783263, 0.11303499220751467, 0.0988514606153591, 0.11138198155903645, 0.08666204163786595, 0.08353334357078024, 0.09257705671188687, 0.07293744684507697, 0.09918764032017646, 0.07758860888761798, 0.03121752907096753, 0.04811296000713139, 0.11604164951506102, 0.14815597540992087, 0.14406854416545145, 0.14702155619429869, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "6ca88bfc-8765-41ad-841b-e50c73b9924d", "fitness": 0.05188783665718737, "name": "HybridPSOSA", "description": "Added directional bias and increased the probability of updating personal best to focus the search.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.2:  # 20% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                direction_bias = 0.1 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor +\n                                      direction_bias)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 71, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.08.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.12850288743947524, 0.15550272273291754, 0.12485404429884817, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07226135304775638, 0.5012904151931774, 0.21798008324949858, 0.0008216877825355517, 0.00043478260869567187, 0.002969069621883924, 0.013326449293707188, 0.010932620556521444, 0.028281685913610688, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006619635333197094, 0.00043478260869567187, 0.0009232024536087735, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11219193127953231, 0.151557602924977, 0.14039009238142108, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07137058673857732, 0.07051436384137555, 0.0772974161576272, 0.10465709401323597, 0.0950995047603479, 0.11017137822330336, 0.04930337876312396, 0.040625922871114106, 0.04266126793651792, 0.10625953296838753, 0.09631765228524136, 0.11075971836128284, 0.09673406829199649, 0.07124778775497465, 0.06419762892409753, 0.06934383576863756, 0.10634183265694763, 0.07939541341466105, 0.03051779574963709, 0.04878284708457914, 0.10196869641891937, 0.1431252452997721, 0.13947049859381822, 0.13339991725826217, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "38ffa4b2-da4a-4c67-85a9-8b2eb2157e46", "fitness": 0.05352403305589787, "name": "HybridPSOSA", "description": "Introduced adaptive inertia weight and dynamic cooling schedule to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.9, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.97  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**3) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 72, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.13.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.0660152036812156, 0.06676325219045043, 0.060795188444661585, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0821445182505991, 0.817035395186669, 0.7289991366442561, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003547048055113966, 0.00043478260869567187, 0.0012585647496647923, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08522223337515955, 0.0835468146073971, 0.09630684123361177, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06773684363495946, 0.05908302574196789, 0.06195608775194039, 0.08985017987493771, 0.11973462934262546, 0.11485503523903906, 0.06695255771551312, 0.052990077433934246, 0.04399493330355253, 0.09712802567209489, 0.0950718128158008, 0.09544209489729694, 0.020409528210178274, 0.010688498634235488, 0.017285025019674993, 0.04762107858027398, 0.06140381802407935, 0.05636991925612189, 0.03553081845623085, 0.0344430966327226, 0.06829419997243802, 0.155781690949509, 0.1366509575437317, 0.13673529238124904, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "5f726e70-bc99-417a-95fe-c945864ba93b", "fitness": 0.03361446316204068, "name": "HybridPSOSA", "description": "HybridPSOSA+: Incorporates dynamic inertia and enhanced diversity via Lvy flights to improve global search capabilities.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - 0.5 * (eval_count/self.budget)  # Dynamic inertia weight\n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  \n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                levy_flight = np.random.standard_normal(self.dim) * np.random.uniform(0.1, 0.3, self.dim)\n                candidate_position = self.particles[i] + levy_flight + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 73, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.0790233580462536, 0.07144074927582456, 0.06651104826322052, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04482535207418614, 0.03993627005607614, 0.05331928647714268, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.002961974079656482, 0.0004479690606671305, 0.00411966029510813, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11528038899869508, 0.1193723377606637, 0.0871477782409329, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.057362102234982504, 0.059060896718876155, 0.06626977737312245, 0.09661253200431874, 0.09883925085691214, 0.1085008635919269, 0.05118723172134232, 0.04873272709619847, 0.0361868716831063, 0.09174544945915464, 0.0993262532479926, 0.09248803679434947, 0.03569416529002434, 0.019540765645919778, 0.03270034342408967, 0.047885458747198406, 0.08235814811777242, 0.046779009417474815, 0.014518973530139756, 0.033883871546509736, 0.08842379937803857, 0.1357480790370058, 0.14120880242300715, 0.13514959178599462, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "cf5f2a41-0b46-4789-8b1a-4717660db5ad", "fitness": 0.034642169153018036, "name": "HybridPSOSA", "description": "Introduced dynamic inertia weight adaptation for enhanced convergence speed and precision.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                w = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight adaptation\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 74, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.05.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.05849287136067227, 0.04643933063666539, 0.09741022508772368, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04608144296819472, 0.07957597559120255, 0.16857805050120467, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004776001206110658, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07773296730337098, 0.11574448572666673, 0.08159110724394669, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06441165391224335, 0.06161244039058955, 0.06355098677316107, 0.10391226326332026, 0.1178852926799352, 0.10193660756958178, 0.06078094202283413, 0.03537594234067709, 0.03747215794021708, 0.09520941696662544, 0.09867577367360036, 0.09744537374200912, 0.00043478260869567187, 0.03938473645954754, 0.0230146524960948, 0.05564187731546688, 0.05488414985646639, 0.054512972523877545, 0.022074084475383726, 0.03522512588409743, 0.07188404526217529, 0.13915952151219002, 0.13041757040077817, 0.13638961219153656, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ad0d482b-48c7-4817-a126-4d162109fcb2", "fitness": 0.0353808021209574, "name": "HybridPSOSA", "description": "Introduce dynamic inertia weight and stochastic acceptance threshold to refine exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                \n                # Dynamic inertia weight\n                w = 0.9 - (0.5 * (eval_count / self.budget))  # Change 1\n\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Stochastic acceptance threshold\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / (T + np.random.rand())):  # Change 2\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 75, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.061161450249596405, 0.05566756235364945, 0.05624326511391797, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08401362968158099, 0.058997490469160474, 0.08317604314656146, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0029950857941938303, 0.005872406038975542, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.11000469338142438, 0.0970440864088794, 0.07731628209866614, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06127246909765727, 0.056919220060260955, 0.05736178199681574, 0.09752453810611217, 0.11979292073048198, 0.10024286052886189, 0.05460969037777097, 0.055985842186330625, 0.04524856299170332, 0.0935386371431205, 0.09449688806338186, 0.09801194480509046, 0.05034579630199576, 0.0512040285382529, 0.05030879855938153, 0.05294875679060085, 0.07186865162193079, 0.06030572721744687, 0.022588276981824418, 0.03481462105609512, 0.07219511646071342, 0.15699266733556394, 0.13699000661032312, 0.14327099788887043, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ee68b5e1-9b56-45cc-910d-a232d6c49ce9", "fitness": -Infinity, "name": "HybridPSOSA", "description": "Refined HybridPSOSA with dynamic population resizing and enhanced local search for improved convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.init_pop_size = 20\n        self.pop_size = self.init_pop_size\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n        \n    def resize_population(self, eval_count):\n        scale_factor = 0.5 + 0.5 * np.sin((np.pi * eval_count) / self.budget)\n        self.pop_size = int(self.init_pop_size * scale_factor)\n        self.particles = self.particles[:self.pop_size]\n        self.velocities = self.velocities[:self.pop_size]\n        self.personal_best_positions = self.personal_best_positions[:self.pop_size]\n        self.personal_best_scores = self.personal_best_scores[:self.pop_size]\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5\n        T = 1.0\n        alpha = 0.99\n\n        while eval_count < self.budget:\n            self.resize_population(eval_count)\n            \n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 76, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {}}
{"id": "762fa814-9493-4ab7-a52b-d662126e3606", "fitness": 0.06366203167055245, "name": "HybridPSOSA", "description": "Introduced adaptive inertia weight to balance exploration and exploitation dynamically based on progress.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                w_adaptive = w * (1 - eval_count / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (w_adaptive * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 77, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.11.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.18039957393538075, 0.18636701775375786, 0.17052952201555227, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0007198974131482627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.16539647071220098, 0.8061720727868369, 0.07643977686882919, 0.016165398239036066, 0.002759748549657437, 0.0009148570046418891, 0.0300547551589202, 0.006562254148087088, 0.004577588170870506, 0.001568212004643743, 0.001878709911703802, 0.00043478260869567187, 0.008479824763666821, 0.02541520670122932, 0.00260427664847529, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0023577876210463256, 0.0015803472676373387, 0.0074577076806902065, 0.15636640724501727, 0.19375546181226866, 0.1904092172232369, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08983868779261128, 0.07606882744310284, 0.0753453665095909, 0.12689618570689454, 0.1301582898208461, 0.14370047401136732, 0.06445402580643789, 0.04975942863078853, 0.04799758742100457, 0.10835891833906175, 0.11290727644719412, 0.10730916755081565, 0.09163361290822747, 0.10241651000838548, 0.1013274699115938, 0.07169978065642302, 0.11729297907333291, 0.07637408644944121, 0.031764481404794154, 0.050379792026933545, 0.11152026407860094, 0.1406235107297168, 0.15055025426090518, 0.15592242904647635, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ca534020-392d-43ba-811d-27a10afc95e7", "fitness": 0.06465341944185604, "name": "HybridPSOSA", "description": "Introduce variance reduction in the velocity update to stabilize convergence and prevent premature stagnation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor) * 0.99  # Slight variance reduction\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 78, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.148377377486957, 0.13356114788263063, 0.13571140096987167, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6199130646470271, 0.8213545887081954, 0.07402184743589935, 0.00043478260869567187, 0.00043478260869567187, 0.006732075430532336, 0.016756631004594125, 0.03240070804279227, 0.002973266650060591, 0.00043478260869567187, 0.00043478260869567187, 0.0004366920605507474, 0.0031794336377028998, 0.009761317726384222, 0.0008989306524782581, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00046494944540287353, 0.0008299646638273428, 0.13928711647109848, 0.16425237298989503, 0.13946909529031926, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07499455757584061, 0.05896059338473225, 0.07931074773280311, 0.12010466293919653, 0.10820747530937569, 0.10465821244246098, 0.06585932541079254, 0.056757031887058385, 0.053937975064069055, 0.10906677605011206, 0.11003465934834056, 0.10401891542448027, 0.08977021868344348, 0.07722952908662517, 0.10765225693322167, 0.07337302289996817, 0.11695599677039947, 0.0784253918887221, 0.031430096839968114, 0.050051939572792636, 0.0973760461185097, 0.14100599894750643, 0.14060933737690362, 0.14226475527791893, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2b6b6099-24b9-46fb-97f2-dddc2249f484", "fitness": 0.0635849330815691, "name": "HybridPSOSA", "description": "Introducing a dynamic cooling schedule for improved simulated annealing effectiveness.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.3 * np.sin(5 * np.pi * eval_count / self.budget))  # Slightly increased sine multiplier\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 79, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.14429460257586046, 0.11257083973033266, 0.11901184355478944, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6373070315856553, 0.8155233901412464, 0.07314855669211517, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.012210176720575339, 0.019142029870986343, 0.0008095129766499953, 0.00043478260869567187, 0.00043478260869567187, 0.0005642013658535561, 0.011043910233551446, 0.008082621435107407, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.14478827755884893, 0.16172893644308595, 0.15100439841034297, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09192230787098676, 0.057464653560187484, 0.050058343688162865, 0.10790942207289644, 0.14508856739187637, 0.12104204811645047, 0.05814859711717635, 0.050881650688914926, 0.05373346347677854, 0.10983421611723743, 0.10670261591319752, 0.10540361506880658, 0.0793911514700476, 0.07712521552853346, 0.08743862274449843, 0.06156299998484649, 0.10649477487591352, 0.07282919610931315, 0.030258778834545974, 0.050624648218028145, 0.10348285988991468, 0.14168698087213893, 0.14409492612658192, 0.13935737075398236, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8d568c2d-28cd-40fd-9d04-05bbd3a2dfea", "fitness": 0.03317116680223165, "name": "HybridPSOSA", "description": "Introduce adaptive inertia weight for PSO to improve convergence and exploration balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 80, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.0667166210206106, 0.06392022562251676, 0.05006414268358239, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08209939432705948, 0.0795764687112549, 0.036702929881012536, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0027737178709311694, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09171922285470491, 0.10835121243605794, 0.0970519383972056, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06347314290248407, 0.06635167672023012, 0.07154125501626185, 0.10522275690265581, 0.10757873203000268, 0.10184523824633052, 0.05216578116903947, 0.06398112937245615, 0.05103260101424345, 0.09514172556741418, 0.09340127502627715, 0.09457053705900187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05577099317530809, 0.05886481071616756, 0.0578923664177714, 0.018089411258902954, 0.03210258372363828, 0.07598330902449002, 0.13881345546806734, 0.1440321672670154, 0.1436671009214615, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d362fa52-c007-4a1c-8939-b94bfddf93ad", "fitness": 0.0746574650689929, "name": "HybridPSOSA", "description": "Enhanced population diversity through dynamic particle reinitialization to avoid premature convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 81, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.15.", "error": "", "parent_ids": ["e9984310-74d0-4c35-9202-ff2642c0b1da"], "operator": null, "metadata": {"aucs": [0.14732989261514928, 0.125255977845095, 0.11862195635699968, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7575186749616518, 0.8004820147657804, 0.730292234586732, 0.005739146895586411, 0.003346683951478857, 0.00043478260869567187, 0.002888204361259028, 0.008187763790544533, 0.010472619765153346, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003997981592515076, 0.14730971400703363, 0.17755246608737696, 0.1437581367647368, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09763236155931043, 0.08089563168319691, 0.06817762776058667, 0.11659587150602835, 0.12180915474914411, 0.11709778175131325, 0.05106282046822497, 0.048782991338765624, 0.03319832481014817, 0.10446104015091096, 0.10121978343561511, 0.11636765761729317, 0.0825317221928672, 0.0871814438826255, 0.09972931593880552, 0.07391197096270563, 0.10884649071455388, 0.07530808751509999, 0.027634043313683687, 0.04530599667241719, 0.09348254155736113, 0.14873321454794564, 0.1402677468521637, 0.13800256955267143, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c84d59bf-cd57-4fdb-b468-fb8e94dce3ee", "fitness": 0.03327926194069405, "name": "HybridPSOSA", "description": "Improved convergence by introducing a dynamic inertia weight to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                w = 0.9 - 0.4 * (eval_count / self.budget)  # Dynamic inertia weight\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 82, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.055648257271833756, 0.05404336689368805, 0.051752764533443574, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08265617281257565, 0.07954865590307547, 0.0852174931541555, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.012059699953046565, 0.000798030267737726, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09298293922600309, 0.09932239502412277, 0.10375380196314932, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.062275213626293735, 0.061679915159178256, 0.06145280574577516, 0.10460256194719952, 0.11740090969167916, 0.10174612671272176, 0.06213073690540771, 0.0573969745526719, 0.054115779599359426, 0.09553346315225908, 0.08815171867984406, 0.10079873290994246, 0.00043478260869567187, 0.024059123514237002, 0.00043478260869567187, 0.04071147435932865, 0.06669976160116797, 0.04896051758540043, 0.02013411549537547, 0.030975071820823374, 0.05013531389347525, 0.13181381513357604, 0.1412459712134858, 0.13934665768880627, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "a15ff0dd-014e-49a5-a7be-aa7c0ddd7ccc", "fitness": 0.03398338639121023, "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with dynamic inertia weight and adaptive cooling for improved convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - 0.5 * eval_count / self.budget  # Dynamic inertia weight\n            for i in range(self.pop_size):\n                score = func(self.particles[i])\n                eval_count += 1\n\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 83, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.07447750331163006, 0.06118232702224269, 0.06182460120729527, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08264765580163269, 0.07954336217897473, 0.036705999594080274, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.008332043511736997, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09202605610125059, 0.10362699268204933, 0.1031706781663786, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07236204525492096, 0.05943531371432531, 0.06406523831180666, 0.09925020330987555, 0.11833620714026882, 0.0953648157861291, 0.058575171369382395, 0.0453137945626666, 0.039197568420407336, 0.09429209634634095, 0.09444634765267002, 0.09728895501130963, 0.00043478260869567187, 0.037836570550278004, 0.024827685381871523, 0.052941941481819965, 0.0641746880168037, 0.04967490773119054, 0.02446089432375609, 0.03710079288182422, 0.0733322081540364, 0.13853532890573061, 0.14915310209177568, 0.13634420245154422, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c68f0c46-7f22-4644-ab20-6921983ab349", "fitness": 0.06884077259353188, "name": "HybridPSOSA", "description": "Enhanced adaptive strategy by adjusting the inertia weight `w` based on the number of evaluations.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                w = 0.5 * (1 - eval_count / self.budget)  # Adjusted inertia weight\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 84, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.12.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.17918873358358112, 0.19029596739099897, 0.18383758430533015, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.5665094283640695, 0.7919643339020795, 0.07644926254860995, 0.013906038229053341, 0.00043478260869567187, 0.01900465130205964, 0.02310538841645149, 0.01950070806308546, 0.008633260050187164, 0.00043478260869567187, 0.00043478260869567187, 0.003166649559645074, 0.013701324832985917, 0.006904843138120564, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00048145790502907015, 0.00043478260869567187, 0.0007725704568630753, 0.1748139406417929, 0.1804740905590544, 0.17937664887947335, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08742721050109337, 0.06169741992836619, 0.06895975431687673, 0.11564544141069344, 0.12746798337232412, 0.12614056336051271, 0.056716318053188886, 0.06295961879339418, 0.05793727603169452, 0.10670979537932512, 0.11210113467283855, 0.11099789874556043, 0.0957982896529499, 0.098213706654936, 0.11911719593196035, 0.07333324096124727, 0.11793845767766009, 0.07475692927891087, 0.03171886252614453, 0.05119080401017939, 0.11056980820050177, 0.14976348404700512, 0.1477116241923322, 0.14696723125395417, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7e5cdabd-58b0-461a-9d81-a32babbe06d9", "fitness": 0.03398338639121023, "name": "HybridPSOSA", "description": "Introduce adaptive inertia weight in PSO to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            w = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 85, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.07447750331163006, 0.06118232702224269, 0.06182460120729527, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08264765580163269, 0.07954336217897473, 0.036705999594080274, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.008332043511736997, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09202605610125059, 0.10362699268204933, 0.1031706781663786, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07236204525492096, 0.05943531371432531, 0.06406523831180666, 0.09925020330987555, 0.11833620714026882, 0.0953648157861291, 0.058575171369382395, 0.0453137945626666, 0.039197568420407336, 0.09429209634634095, 0.09444634765267002, 0.09728895501130963, 0.00043478260869567187, 0.037836570550278004, 0.024827685381871523, 0.052941941481819965, 0.0641746880168037, 0.04967490773119054, 0.02446089432375609, 0.03710079288182422, 0.0733322081540364, 0.13853532890573061, 0.14915310209177568, 0.13634420245154422, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ebd7370d-1a78-49aa-b324-d2f17b58c827", "fitness": 0.07272985232925847, "name": "HybridPSOSA", "description": "Enhanced PSO-SA convergence by increasing global exploration with a slightly lower SA cooling rate.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.98  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 86, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.14.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.14225155145593105, 0.14210928281862345, 0.13096076092548625, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.771164735708221, 0.837771135322839, 0.47882859566791236, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.010432602368350086, 0.016466704548307898, 0.012888213144581107, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0014314034578930546, 0.1585480925850291, 0.16449891849154685, 0.156576711356067, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0781271632552003, 0.05767768781007743, 0.07802640465568822, 0.11788109770512434, 0.12273099839602786, 0.12436372426680553, 0.057743461039036714, 0.06689407849930828, 0.07233050168250543, 0.10826541836691994, 0.0982578328208853, 0.10246210639920994, 0.0800898006009283, 0.055951326309927496, 0.10284016168482035, 0.07356228753547012, 0.10730273735425011, 0.08154025497803141, 0.03034037482456986, 0.04805484678532412, 0.10801152635799438, 0.14674279970042636, 0.13865703987198552, 0.1395496376509554, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b457762d-1909-434f-8962-a4858cc0236f", "fitness": 0.04560827292402113, "name": "HybridPSOSA", "description": "Enhanced particle adaptation using dynamic learning rates and increased global exploration for improved convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim) * (1.2 - 0.4 * (eval_count / self.budget))  # Dynamic learning factor\n                c2_i = c2 * np.random.rand(self.dim) * (1.2 - 0.4 * (eval_count / self.budget))  # Dynamic learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T * (1.5 - eval_count / self.budget), self.dim)  # Increased exploration\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 87, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.07.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.12933347752140445, 0.11440496342617779, 0.11559456795544909, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0759488134436519, 0.4119864322039254, 0.08665891272357207, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004909217861665982, 0.011122170840909051, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005179224381532954, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0017028012865415443, 0.00043478260869567187, 0.00043478260869567187, 0.13267661357987393, 0.15462136136110793, 0.10169411250818383, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06074360825783043, 0.06325117017816684, 0.06980213440851457, 0.09967843962883105, 0.10653001191687828, 0.11841464100930277, 0.07835161368304988, 0.039859167575042265, 0.053438672360611394, 0.09134131020539271, 0.10182545040856772, 0.09911795794855527, 0.08526230808467994, 0.06810519024881856, 0.04777209170071506, 0.06612922215214423, 0.08150560860089251, 0.05697188261256758, 0.0324576402466249, 0.04515877291905934, 0.041088331716534365, 0.14269664338032195, 0.13306026428677553, 0.14484475854467949, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8d991409-5bac-479d-8654-25eadc8e7f78", "fitness": 0.05308964312989738, "name": "HybridPSOSA", "description": "Enhanced exploitation and exploration balance through adaptive velocity scaling and increased diversity.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                velocity_scaling = 0.8 * (1 - eval_count / self.budget)  # Adaptive velocity scaling\n                self.velocities[i] = (w * self.velocities[i] * velocity_scaling +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.1:  # Increased reinitialization probability\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 88, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.17937219256121917, 0.20204720679879773, 0.1791355924667971, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1129168480758993, 0.10435470986497675, 0.10954941092068116, 0.00043478260869567187, 0.00043478260869567187, 0.0027545451440875723, 0.016610152345685858, 0.017425749137717106, 0.011740534771038424, 0.00043478260869567187, 0.003570919760547575, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0041693423753964565, 0.003815482254429514, 0.0021840441006041322, 0.2098832033840834, 0.20804565670071962, 0.18900503292548143, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07485978929727577, 0.08368997748426443, 0.06640964699868757, 0.1267547824387114, 0.11939080329702612, 0.10426832178141365, 0.04911201689525668, 0.05419583498422609, 0.05206251155797159, 0.11079738551857743, 0.10357939444804332, 0.10734140521821822, 0.10778460565507864, 0.0825121636381626, 0.10025775389276548, 0.0696342119091129, 0.11239712865209783, 0.0847432208757567, 0.031878711599404475, 0.04737342139307321, 0.11668202265894156, 0.15274293363710667, 0.14747639400710877, 0.1464509830566023, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "c1265ace-d8a4-4e8f-b8cb-a176d4ea397a", "fitness": 0.05212610646120073, "name": "HybridPSOSA", "description": "Improved local exploration by integrating dimension-wise adaptive velocity scaling in the PSO update.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                dim_scaling = np.random.rand(self.dim)  # New line for dimension-wise scaling\n                self.velocities[i] = (w * self.velocities[i] * dim_scaling +  # Modified line using dim_scaling\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 89, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.17533497206540183, 0.19045175184881868, 0.18975562396153545, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1572872493763524, 0.050375009019090866, 0.1471158544270066, 0.006158524565391343, 0.0034059178073531093, 0.0022828494849835845, 0.00959709745353754, 0.013682572281565553, 0.00043478260869567187, 0.00043478260869567187, 0.0026854067310189134, 0.00043478260869567187, 0.0009059182792193754, 0.008243947695745657, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0030427941535297043, 0.00043478260869567187, 0.00043478260869567187, 0.19227467981383373, 0.18312804876453959, 0.17788166751499657, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06426385280492553, 0.0748323591081077, 0.0752083658639634, 0.10895833170495384, 0.11403865211337694, 0.11759253745340348, 0.07514340545669174, 0.050044079806155106, 0.06791113520722758, 0.11027414143228542, 0.10630663779183258, 0.11178194451946122, 0.13156192814824252, 0.08213308572693856, 0.10167923392548084, 0.07542056391669494, 0.11372543648394717, 0.07954336446675803, 0.03364806970257628, 0.05298485090985594, 0.05457015257067688, 0.13814289822090087, 0.144471857373207, 0.14218941699399812, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "e6ed73f8-5280-4620-b283-a96c2b6617df", "fitness": 0.04271319254302715, "name": "HybridPSOSA", "description": "Introduced an adaptive inertia weight strategy to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                w = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 90, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.10.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.05458164363568618, 0.059157056961651966, 0.03993249925835307, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8471955797264404, 0.07954382337891774, 0.0468794910565592, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005639180280923028, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08496786901126874, 0.10404388950250887, 0.10042313699528937, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06307618159924244, 0.05729978032698968, 0.058969488898466205, 0.11790130802389664, 0.11208046010779593, 0.09345428845080894, 0.057831320425940524, 0.03817055924871415, 0.035951949260001004, 0.09434372054604945, 0.0948570886025365, 0.10145151384447615, 0.0007135078232974879, 0.00043478260869567187, 0.0008487239458108142, 0.04648306318602213, 0.0678034318857127, 0.06511282869290014, 0.023363178527888162, 0.03038557113933249, 0.072934122089374, 0.13809918110219588, 0.13623959480998982, 0.13373357126661445, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ff685f2f-a91e-4932-b69a-87a894ee25c2", "fitness": 0.0641067074712273, "name": "HybridPSOSA", "description": "Utilize adaptive mutation control for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T * (1 - eval_count / self.budget), self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 91, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.10.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.16758574557809047, 0.13904609481233232, 0.1500659205699747, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.5202098485067382, 0.487171192967058, 0.4263341799932262, 0.00044647588004054217, 0.0005042382074905705, 0.00043478260869567187, 0.003638980948706072, 0.015550946220337591, 0.0158831365981148, 0.00043478260869567187, 0.0009533583041049232, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12539164752787957, 0.1563115279465136, 0.14945454009824377, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09832779727499952, 0.06055118402747195, 0.08610024358397173, 0.11831966908430736, 0.1495019314140429, 0.1024451086346746, 0.05143774852324101, 0.05553039687362149, 0.05299930595445601, 0.10994196180263494, 0.09993241744124692, 0.10913839460646535, 0.10942914040885843, 0.07106251280734122, 0.10500648293540682, 0.0732746432350474, 0.0999470960012685, 0.07773043487395215, 0.028601773793277774, 0.046824752936010516, 0.1047116123535532, 0.14467057667955696, 0.15117191548736442, 0.13613017694978558, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "9dddb159-b341-494c-acde-7a396834bf4a", "fitness": 0.04048638578194056, "name": "HybridPSOSA", "description": "Introduce stochastic inertia weight to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                w = np.random.uniform(0.4, 0.9)  # Stochastic inertia weight\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 92, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.10234205129733354, 0.10255863384072117, 0.08166273835666604, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06089208793120493, 0.024037394809936607, 0.2907709453519144, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.007019961424554744, 0.014370165534938195, 0.0010595141330747015, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10717085048447628, 0.09412124658772447, 0.09059679539957477, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050280838048247234, 0.06311184365182998, 0.0722585379238242, 0.1198645952914914, 0.11198319578087712, 0.12108852645617718, 0.05786279820285467, 0.05287554516976445, 0.03773992230243439, 0.10411004906625909, 0.09994979210861166, 0.10231940818065532, 0.08864392654686681, 0.02923430473072086, 0.043861675180940085, 0.07916609065704827, 0.07005048594259555, 0.05524553457508996, 0.056519659531195865, 0.04545130969534317, 0.04143381719410111, 0.13596501207569978, 0.13976842641672205, 0.1439799225052062, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "8161bf9b-2408-407e-b3d4-0798e9b5638c", "fitness": 0.0746574650689929, "name": "HybridPSOSA", "description": "Improved velocity update strategy by introducing dimension-wise adaptive inertia to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        c1, c2 = 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                w_dim = 0.5 * np.ones(self.dim)  # Adaptive inertia\n                self.velocities[i] = (w_dim * self.velocities[i] +  \n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 93, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.15.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.14732989261514928, 0.125255977845095, 0.11862195635699968, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7575186749616518, 0.8004820147657804, 0.730292234586732, 0.005739146895586411, 0.003346683951478857, 0.00043478260869567187, 0.002888204361259028, 0.008187763790544533, 0.010472619765153346, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003997981592515076, 0.14730971400703363, 0.17755246608737696, 0.1437581367647368, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09763236155931043, 0.08089563168319691, 0.06817762776058667, 0.11659587150602835, 0.12180915474914411, 0.11709778175131325, 0.05106282046822497, 0.048782991338765624, 0.03319832481014817, 0.10446104015091096, 0.10121978343561511, 0.11636765761729317, 0.0825317221928672, 0.0871814438826255, 0.09972931593880552, 0.07391197096270563, 0.10884649071455388, 0.07530808751509999, 0.027634043313683687, 0.04530599667241719, 0.09348254155736113, 0.14873321454794564, 0.1402677468521637, 0.13800256955267143, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "d99616ba-ae5e-459f-ae99-7b3fbfb3a30f", "fitness": 0.06356590213167249, "name": "HybridPSOSA", "description": "Improved global exploration by adjusting initial velocity range to enhance search efficiency.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-2, 2, (self.pop_size, self.dim))  # Changed initial velocity range\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 94, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.14533688700559044, 0.13597239567756436, 0.13987845856961034, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0008465729211807327, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7007441448123145, 0.6357099766661454, 0.1897640924453997, 0.00043478260869567187, 0.00043478260869567187, 0.002212580946848952, 0.0067248922758007534, 0.022537268646561914, 0.016531978966132788, 0.00043478260869567187, 0.0006467893942597724, 0.00043478260869567187, 0.001294411711660115, 0.00043478260869567187, 0.0012942312078777496, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.12126330602807978, 0.1453427192445127, 0.13391378014613908, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0712978500867888, 0.08270714743050434, 0.06115260852274673, 0.11318218450389161, 0.12225441697030237, 0.12138053275904104, 0.06179642050463219, 0.04013807269636527, 0.05009375368053537, 0.09827569717694351, 0.10670980701487265, 0.10601672232212445, 0.07309113709069293, 0.09160410337520142, 0.09908548202112144, 0.077684585249443, 0.10140093809939021, 0.07838812565845965, 0.029924487722467807, 0.049884483729434104, 0.1077272516974841, 0.14581168523099197, 0.1386531621164454, 0.13499155028529353, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "7a99a1e3-0204-4170-9f92-fc81c548dc2e", "fitness": 0.06588851750641088, "name": "HybridPSOSA", "description": "Enhanced exploitation by modifying the adaptive cooling factor in Simulated Annealing to focus more on global exploration in the early stages.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.3 * np.sin(5 * np.pi * eval_count / self.budget))  # Modified factor\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 95, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.13.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.14891953531992974, 0.1259447735983127, 0.17129809867420887, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7309540230667262, 0.7978283953432745, 0.07101319542523465, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0069396433299967475, 0.00881604428472238, 0.005314143194031562, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0029643073503508033, 0.004515086526711176, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.14991461397231132, 0.16811055315194645, 0.14133333464658526, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08663647509362582, 0.05709101250027859, 0.06719970126317987, 0.11149372019469261, 0.13106098494598428, 0.11411718042493313, 0.05306841005997387, 0.06523954307866009, 0.06937668011579812, 0.10888556372114855, 0.10529037395975871, 0.10589511446842981, 0.0938849370621655, 0.06874609865987824, 0.08922493394819486, 0.06836131581226079, 0.11938027688356467, 0.07353099179048261, 0.02439191110198291, 0.05333542504156119, 0.10501477706179552, 0.1427651936331611, 0.1443139226866571, 0.13702036037342036, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "ee7e3a7e-326a-4a31-8cd6-edfef7e8166b", "fitness": 0.04271319254302715, "name": "HybridPSOSA", "description": "Introduce adaptive inertia weight for dynamic balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.5, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                w = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 96, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.10.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.05458164363568618, 0.059157056961651966, 0.03993249925835307, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.8471955797264404, 0.07954382337891774, 0.0468794910565592, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0005639180280923028, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08496786901126874, 0.10404388950250887, 0.10042313699528937, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06307618159924244, 0.05729978032698968, 0.058969488898466205, 0.11790130802389664, 0.11208046010779593, 0.09345428845080894, 0.057831320425940524, 0.03817055924871415, 0.035951949260001004, 0.09434372054604945, 0.0948570886025365, 0.10145151384447615, 0.0007135078232974879, 0.00043478260869567187, 0.0008487239458108142, 0.04648306318602213, 0.0678034318857127, 0.06511282869290014, 0.023363178527888162, 0.03038557113933249, 0.072934122089374, 0.13809918110219588, 0.13623959480998982, 0.13373357126661445, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "aba4986a-99a4-41fe-9692-6516769ba503", "fitness": 0.0492981742807462, "name": "HybridPSOSA", "description": "Improved convergence by adjusting the velocity update with an increased inertia weight to enhance exploration.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.7, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 97, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.11.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.08564454434811053, 0.06587532992789158, 0.07946125176759344, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.35197144740832875, 0.870325035961744, 0.052595558763110284, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0006677614950437727, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09412157980436109, 0.09999759574906752, 0.11406986380989237, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06415092910883846, 0.051749932474513094, 0.07145187957498345, 0.12051663254713008, 0.11171901000066631, 0.10620848690605489, 0.06300868401198567, 0.04740383384616509, 0.0458256906445782, 0.0973788258013294, 0.09871433397132678, 0.10130753554812288, 0.00045529265709898237, 0.003352978558427422, 0.00043478260869567187, 0.045470979055700966, 0.06731174154640085, 0.06519438817739054, 0.02423559184564672, 0.0415382346263119, 0.07524105727031072, 0.14027531791822367, 0.14182224030336366, 0.13344846104488162, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "1e7419a4-8a75-47d2-823a-dd6122a9fbea", "fitness": 0.02387326648738819, "name": "HybridPSOSA", "description": "Introduced dynamic inertia weight adjustment and a diversity-inducing mechanism to improve global exploration.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.9, 1.5, 1.5  # PSO parameters\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:  # 10% chance to update\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                c2_i = c2 * np.random.rand(self.dim)  # Dimension-wise random learning factor\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                inertia_weight = w * (1 - eval_count / self.budget) + 0.4  # Dynamic inertia weight\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.05:\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 98, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.02730528652607911, 0.012478610174033622, 0.0010492487791241567, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08266261944560716, 0.02705387271963766, 0.038500053668422796, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04677680814345142, 0.056923598177279544, 0.059698989682438364, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05317861951310432, 0.05378056853999602, 0.059643748415913245, 0.0978543760634859, 0.09214107945517558, 0.09210368340525865, 0.04311532903543336, 0.03341504665575945, 0.03066926494045974, 0.08459772537936106, 0.0821275964899747, 0.09069303035902487, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.017915829827432672, 0.028931008399121216, 0.024735248328656034, 0.012703958365069656, 0.01505490924938202, 0.01328930926429639, 0.14194219308686695, 0.13243631904053188, 0.147836386396354, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "88f19aaf-4505-4dec-8412-e2b31593e8f8", "fitness": 0.02782243403585048, "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with improved inertia weight adjustment and reinitialization criteria.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.global_best_position = np.copy(self.particles[0])\n        self.personal_best_scores = np.full(self.pop_size, float('inf'))\n        self.global_best_score = float('inf')\n\n    def __call__(self, func):\n        eval_count = 0\n        w, c1, c2 = 0.9, 1.5, 1.5  # Adjusted inertia weight\n        T = 1.0  # Initial temperature for SA\n        alpha = 0.99  # Cooling rate for SA\n\n        while eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Evaluate current position\n                score = func(self.particles[i])\n                eval_count += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i] or np.random.rand() < 0.1:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n\n            for i in range(self.pop_size):\n                # PSO update\n                r1, r2 = np.random.rand(2)\n                c1_i = c1 * np.random.rand(self.dim)\n                c2_i = c2 * np.random.rand(self.dim)\n                adaptive_factor = (1 + 0.2 * np.tanh(eval_count / self.budget))\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1_i * (self.personal_best_positions[i] - self.particles[i]) * adaptive_factor +\n                                      c2_i * (self.global_best_position - self.particles[i]) * adaptive_factor)\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n                # Simulated Annealing perturbation\n                candidate_position = self.particles[i] + np.random.normal(0, T, self.dim)\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate_position)\n                eval_count += 1\n\n                # Acceptance probability\n                if candidate_score < self.personal_best_scores[i] or np.random.rand() < np.exp((self.personal_best_scores[i] - candidate_score) / T):\n                    self.personal_best_positions[i] = candidate_position\n                    self.personal_best_scores[i] = candidate_score\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n                # Dynamic particle reinitialization\n                if eval_count % 100 == 0 and np.random.rand() < 0.1:  # Adjusted reinitialization criteria\n                    self.particles[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    self.velocities[i] = np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive cooling\n            T *= alpha * (1 - (eval_count / self.budget)**2) * (1 + 0.2 * np.sin(5 * np.pi * eval_count / self.budget))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 99, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["d362fa52-c007-4a1c-8939-b94bfddf93ad"], "operator": null, "metadata": {"aucs": [0.031601833700968474, 0.026625681161168036, 0.02868910138809122, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0825945603671866, 0.0795703576728789, 0.07319585259377359, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07666623205285739, 0.07148686784379465, 0.07482283655711652, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05808336235813327, 0.0520844463831176, 0.048827288706622674, 0.10041040509034804, 0.10858157260885826, 0.10060834751664915, 0.05625592768813237, 0.036881919026719, 0.037041989928742525, 0.09091698474631205, 0.08042609323792826, 0.08896296928549063, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.028814257562467582, 0.03862836311415341, 0.027371071706285832, 0.013720409450078241, 0.02304027607998249, 0.04586589798743457, 0.1321447108780338, 0.1362824212842073, 0.13475234303848382, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
