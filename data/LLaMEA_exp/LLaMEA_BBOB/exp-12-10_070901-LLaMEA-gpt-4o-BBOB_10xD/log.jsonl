{"id": "3fbc4e91-fe0c-412e-892b-dfb2a30db2e0", "fitness": 0.0393208629254829, "name": "ChaoticSwarmOptimizer", "description": "A dynamic swarm-based optimizer that adapts particle velocities using chaotic maps for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 0, "feedback": "The algorithm ChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03932 with standard deviation 0.04478.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.12680160378942573, 0.09498580728927819, 0.15505046293813907, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04016868952622932, 0.026001652244227347, 0.025245252594442436, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08247993377863883, 0.07072821966847587, 0.0540661829810003, 0.029035187105996507, 0.03549402779727506, 0.020000000000000018, 0.05644522459888124, 0.0975566737525293, 0.0801574870362417, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13633070884706366, 0.0979547753313732, 0.1664791616606035, 0.031566156126180966, 0.03070138458187055, 0.025813571276924296, 0.10176778378278473, 0.08761323527532738, 0.09154042616767155, 0.14047228458466465, 0.13323277534341382, 0.15501517706408463, 0.07899953914465119, 0.07990382579724953, 0.09084341667524387, 0.1282387735476721, 0.1260009823549174, 0.12573827585468034, 0.020000000000000018, 0.020000000000000018, 0.1252122316460047, 0.16051303937720207, 0.08512114642417234, 0.10804397803334387, 0.07132923323376017, 0.14141744354015084, 0.06127001046702896, 0.1438526290318487, 0.1398009349395528, 0.15475448018179316, 0.053239719292167975, 0.040866334957386674, 0.03589597403359546, 0.05328286329573828, 0.03778314918060888, 0.05413378052861961, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05455127993397513, 0.023498563545603868, 0.029653634151949326, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08925416275156328, 0.07260910072813775, 0.09733884864051756, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06339255841545255, 0.06726052086509426, 0.12026034736099656, 0.10069699287670786, 0.10988090510433923, 0.0650627494574948, 0.04527071975624064, 0.056979887998892975, 0.09664688771728247, 0.08794536997002278, 0.09999176638909701, 0.11114742074827755, 0.010000000000000009, 0.010000000000000009, 0.028960255472856078, 0.029733656475296466, 0.03547217486638987, 0.02936651728057782, 0.02441216056352591, 0.025392003337624924, 0.1470228818692657, 0.13980978191351479, 0.1342982775704411, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010524600490273928, 0.0, 0.005718974529538623, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0036539775161475996, 0.004079236054479463, 0.0010741400244660415, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.037344030333171685, 0.03657834644830105, 0.031186591973036193, 0.0, 0.0, 0.0, 0.03766450772218899, 0.03753213255583987, 0.034979367832985386, 0.08588499692243279, 0.08762041770859308, 0.08056429098297557, 0.03257668632169075, 0.029481087136694506, 0.02515506535242895, 0.08655612180662242, 0.07990910024242992, 0.06128338559661106, 0.0, 0.0, 0.0, 0.012285999264444847, 0.009759835894226021, 0.012348945781120335, 0.00913808314763187, 0.010060421927010843, 0.010693754608301353, 0.12134636971152413, 0.1304161139054778, 0.10843482450235598, 0.0, 0.0, 0.0]}}
{"id": "988849c3-27d0-4b0c-a721-5fe9746d2a0c", "fitness": 0.03977389419973497, "name": "ChaoticSwarmOptimizer", "description": "An enhanced chaotic swarm optimizer that introduces adaptive inertia weight for improved convergence.", "code": "import numpy as np\n\nclass ChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 1, "feedback": "The algorithm ChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03977 with standard deviation 0.04562.", "error": "", "parent_ids": ["3fbc4e91-fe0c-412e-892b-dfb2a30db2e0"], "operator": null, "metadata": {"aucs": [0.1268592655916223, 0.09360891628888002, 0.1550414961915103, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0334922990336185, 0.03113371710243129, 0.024754089012575142, 0.02244785765374846, 0.020000000000000018, 0.020000000000000018, 0.08237334020542719, 0.06962617375162095, 0.05368360151579832, 0.029175087082047635, 0.035077415495081254, 0.020000000000000018, 0.06275415075251956, 0.10367416302226706, 0.07443619193263384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14291086604517778, 0.10026020441846162, 0.1654690294294241, 0.038586660183838384, 0.02856709612587205, 0.027803089491964084, 0.08072694858327945, 0.0863116411064907, 0.08956352481671248, 0.13805888464372207, 0.13862997612663264, 0.13746331266268152, 0.08434188699867295, 0.07990382579724953, 0.07342168294630469, 0.14629608645447945, 0.12697038085792245, 0.13901420385776675, 0.020000000000000018, 0.020000000000000018, 0.12425199317397129, 0.16293268878090605, 0.08272506165747417, 0.11757412319835192, 0.0730892069649921, 0.17633867874535492, 0.06803324248689369, 0.15757221501681018, 0.13589170657517036, 0.15475448018179316, 0.05007504667171081, 0.046369186211399294, 0.03137850932729125, 0.05202909473734718, 0.038820587281444885, 0.05143649230382852, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05390553903138562, 0.025201174529013604, 0.03882029238936047, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0894402807620277, 0.06941787392766718, 0.09341216600876079, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0750565825864099, 0.06599969987798238, 0.060954234977931954, 0.11974040729315538, 0.09808601398915584, 0.11047308865501382, 0.06861188585475975, 0.042775600297805694, 0.05394885274165173, 0.10649572696751874, 0.08990494587802134, 0.10083708862607854, 0.11007866776517583, 0.010000000000000009, 0.010000000000000009, 0.030071264606467585, 0.030001793593528614, 0.03703645007382772, 0.02874199867051841, 0.02430578962362362, 0.024944541505123152, 0.14309000767653557, 0.13581031756674633, 0.13981276186729075, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00705798828739701, 0.0, 0.005851401074501106, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005260709967006116, 0.003911772343126119, 0.0008969076755284133, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03646659963948462, 0.03604424510412807, 0.03111777062123844, 0.0, 0.0, 0.0, 0.04069674542604251, 0.04161464675168092, 0.030040532532473185, 0.0856214168429581, 0.08617216010100737, 0.07821590211232132, 0.0326705658131482, 0.03166686367564242, 0.025355630815468544, 0.0822633238474425, 0.08013852667311627, 0.0686089372962948, 0.0, 0.0, 0.0, 0.01214301618533653, 0.00965672941512108, 0.012401293425279514, 0.008430318161165462, 0.010051284513262426, 0.011187024784552246, 0.11375694143871473, 0.1304161139054778, 0.13076135287812296, 0.0, 0.0, 0.0]}}
{"id": "96750f2e-551b-4e0f-8c6e-cf22510f5159", "fitness": 0.0068038520634734765, "name": "EnhancedChaoticSwarmOptimizer", "description": "An enhanced chaotic swarm optimizer introducing dynamic population size and adaptive learning rates based on logistic chaos for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            if evaluations > 0 and evaluations % (self.budget // 5) == 0:\n                self.population_size = max(5, int(self.population_size * 0.9))\n                chaotic_factor = np.random.rand(self.population_size)\n                \n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                self.cognitive_coefficient = 1.2 + 0.3 * chaotic_factor[i]  # Adapt cognitive coefficient\n                self.social_coefficient = 1.2 + 0.3 * chaotic_factor[i]  # Adapt social coefficient\n                \n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00680 with standard deviation 0.07577.", "error": "", "parent_ids": ["988849c3-27d0-4b0c-a721-5fe9746d2a0c"], "operator": null, "metadata": {"aucs": [0.125088521198788, 0.09837493278637277, 0.15492695577401794, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02815627066653148, 0.03320270150363569, 0.03719727849741461, 0.020000000000000018, 0.020000000000000018, 0.02277861497492073, 0.08189444463018025, 0.07012151178964043, 0.055953072843003215, 0.029266814117200557, 0.034960699314810606, 0.020000000000000018, 0.06740021824031106, 0.08594148016760361, 0.09404993241987436, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12961449663590574, 0.1001680322772509, 0.17498329329535578, 0.04077887106421452, 0.03377561524869477, 0.030750782267502497, 0.0852260620832831, 0.0863116411064907, 0.07015575039186472, 0.14171572516857656, 0.15039958006987808, 0.15622000298741368, 0.07876653100794362, 0.07990382579724953, 0.0739783776237819, 0.12239253651237159, 0.11674857351256374, 0.13239826688299983, 0.020000000000000018, 0.07746582761693832, 0.12221908469718956, 0.19738857709623503, 0.08862993705583233, 0.10821362307456528, 0.06669792863969803, 0.13917550807863477, 0.056492493752391515, 0.1438526290318487, 0.15307268314997358, 0.15475448018179316, 0.04348464864979318, 0.04800689394851332, 0.030475395018464746, 0.04697625163294139, 0.03641449955317322, 0.05602523322207764, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06319208955761813, 0.03027608431371831, 0.03989429605734529, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07884413771864174, 0.06876250205363177, 0.08156857145496521, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06366370672267219, 0.06437505137323074, 0.06326421049556652, 0.12276773187743717, 0.10061554420480856, 0.10741810312633415, 0.07004187995585087, 0.05166080856036681, 0.05939290546496534, 0.09815913852231117, 0.09119199458088656, 0.10642638059252518, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02838972260402306, 0.03075112693596016, 0.030291683505848988, 0.02975531866212988, 0.025454112997436495, 0.025643170774084734, 0.16360664480752962, 0.13424897478823627, 0.14345895279675236, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.09415230384687057, -0.10000000000000009, -0.09191279038034939, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.09468096834476647, -0.10000000000000009, -0.0992013095187172, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.058914974921172814, -0.057008333998221694, -0.06479706584611167, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.05119528772062254, -0.05288151179767797, -0.06372222361765245, -0.004655671430696007, -0.0070007218066820975, -0.013993644085418921, -0.07067893180351947, -0.06423487280035967, -0.0692298036153749, -0.014892833057809085, -0.007837337601883654, -0.024445883210504116, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009, -0.08684292110629732, -0.08800663757934624, -0.08642731754397226, -0.09061036005353595, -0.08853749927103749, -0.08889046141874068, 0.028136447224941352, 0.04360419350548539, 0.04658111959460021, -0.10000000000000009, -0.10000000000000009, -0.10000000000000009]}}
{"id": "f4eb5c4d-146a-4db7-a65b-cba4e08d23d2", "fitness": 0.03920985588378218, "name": "ChaoticSwarmOptimizer", "description": "A modified chaotic swarm optimizer that incorporates a diversity control mechanism in velocity update for enhanced exploration.", "code": "import numpy as np\n\nclass ChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                # Introducing a diversity control mechanism in velocity update\n                diversity = np.std(self.positions, axis=0)\n                self.velocities[i] = inertia + cognitive + social + 0.1 * diversity\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 3, "feedback": "The algorithm ChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03921 with standard deviation 0.04495.", "error": "", "parent_ids": ["988849c3-27d0-4b0c-a721-5fe9746d2a0c"], "operator": null, "metadata": {"aucs": [0.14088962504144942, 0.0918621659618889, 0.1528005421912374, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026197277318830148, 0.04261124189717913, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030503139339005392, 0.08635511566527354, 0.08184302292515955, 0.05489744765694782, 0.029534447595433777, 0.0332288093051204, 0.020000000000000018, 0.05856184652831753, 0.08594148016760361, 0.07986160480354298, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13723014692297764, 0.11224971141510476, 0.16977249086376656, 0.031164622454136315, 0.023173718278612254, 0.03995895791740112, 0.08072694858327945, 0.0863116411064907, 0.09522093701363676, 0.14518246700295623, 0.14508310310674033, 0.12620037728437328, 0.07081856376945783, 0.08868265800044439, 0.06881293470312944, 0.1297768336507431, 0.1028845716050748, 0.1435303181481581, 0.020000000000000018, 0.020000000000000018, 0.1191974172386534, 0.184961527360595, 0.08049374733013248, 0.11195148246538533, 0.10830233158518321, 0.04616535580723691, 0.056492493752391515, 0.1438526290318487, 0.1557304534165621, 0.15475448018179316, 0.05600454747056349, 0.04352871717282536, 0.03650667579148059, 0.050901915601516134, 0.03881377789304519, 0.05100262304305625, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05837312424574248, 0.025778487863697408, 0.04370376251852304, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011000590937206844, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09091152059415675, 0.07582265704044333, 0.0959760274922068, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06668641094202277, 0.06147825531143891, 0.05444244719326008, 0.11985630684410009, 0.10928773539149583, 0.10505744953340168, 0.06699192862765047, 0.04246236511721069, 0.054394573147263925, 0.10320314549831866, 0.08633725236462231, 0.09363309912589868, 0.10142500684379285, 0.010000000000000009, 0.010000000000000009, 0.02776138284390428, 0.029378085179250224, 0.04110774314763366, 0.02630185623628989, 0.02375700211418974, 0.02474505647755576, 0.1525252781104648, 0.13772774821186007, 0.14155281664566743, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.008696378155741202, 0.0, 0.006843893140853763, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0050877439061960406, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.034159207224734534, 0.03636994116437142, 0.030414653228004962, 0.0, 0.0, 0.0, 0.032256716260685714, 0.03753213255583987, 0.04154364308780811, 0.08527388990070339, 0.09486893348997738, 0.07756337208921726, 0.031192975101210774, 0.03254902131029003, 0.027764296646674458, 0.07437376062538503, 0.07794534275733012, 0.06645621004675861, 0.0, 0.0, 0.0, 0.010306788991200522, 0.009777218024937029, 0.012298252270371957, 0.008728125776256812, 0.010051284513262426, 0.01039733106984675, 0.12345626031368628, 0.1304161139054778, 0.11079732637511708, 0.0, 0.0, 0.0]}}
{"id": "282e7443-2df0-4725-89c2-bc058f3b706d", "fitness": 0.03973932851781766, "name": "ChaoticSwarmOptimizer", "description": "A refined chaotic swarm optimizer that adjusts the cognitive coefficient dynamically for enhanced convergence.", "code": "import numpy as np\n\nclass ChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                self.cognitive_coefficient = 1.2 + 0.3 * chaotic_factor[i]  # Changed line: Adapt cognitive coefficient\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 4, "feedback": "The algorithm ChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03974 with standard deviation 0.04578.", "error": "", "parent_ids": ["988849c3-27d0-4b0c-a721-5fe9746d2a0c"], "operator": null, "metadata": {"aucs": [0.1268592655916223, 0.09360891628888002, 0.1550414961915103, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03500757352403017, 0.03113371710243129, 0.024754089012575142, 0.02244785765374846, 0.020000000000000018, 0.020000000000000018, 0.08237334020542719, 0.06962617375162095, 0.05368360151579832, 0.029175087082047635, 0.035077415495081254, 0.020000000000000018, 0.06275415075251956, 0.10367416302226706, 0.07443619193263384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14291086604517778, 0.10026020441846162, 0.1654690294294241, 0.038586660183838384, 0.02856709612587205, 0.027803089491964084, 0.08072694858327945, 0.0863116411064907, 0.08983164858726911, 0.13805888464372207, 0.13862997612663264, 0.13746331266268152, 0.08434188699867295, 0.07990382579724953, 0.07342168294630469, 0.14629608645447945, 0.12697038085792245, 0.13901420385776675, 0.020000000000000018, 0.020000000000000018, 0.12425199317397129, 0.16293268878090605, 0.08272506165747417, 0.1175738159897538, 0.0730892069649921, 0.19336236704155652, 0.06803324248689369, 0.15757221501681018, 0.13589170657517036, 0.15475448018179316, 0.05007504667171081, 0.046369186211399294, 0.03137850932729125, 0.05116223938399844, 0.038820587281444885, 0.05143649230382852, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05390553903138562, 0.02519838343332448, 0.03881805242009373, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010003172741421484, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0894402807620277, 0.06934572395484184, 0.09341216600876079, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06448371491860039, 0.060954234977931954, 0.11974040729315538, 0.09809308288786811, 0.11047308865501382, 0.06861188585475975, 0.04282099731448075, 0.053936809511723194, 0.10649572696751874, 0.08780393841034273, 0.10083708862607854, 0.11029110623387861, 0.010000000000000009, 0.010000000000000009, 0.030071264606467585, 0.029709228229589435, 0.03703645007382772, 0.02817658250600219, 0.02430578962362362, 0.02492421220379082, 0.14111631077981246, 0.13581031756674633, 0.13940128210836766, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.006248091503652242, 0.0, 0.005851401074501106, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005261131284844067, 0.003911772343126119, 0.0008347896567920676, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03646659963948462, 0.03604424510412807, 0.03111777062123844, 0.0, 0.0, 0.0, 0.04069674542604251, 0.04161464675168092, 0.03289432509522372, 0.08370807249326484, 0.08536504361665453, 0.07642484596923071, 0.03355132002794081, 0.03166686367564242, 0.024660397044028448, 0.0822633238474425, 0.08013852667311627, 0.07247638036823634, 0.0, 0.0, 0.0, 0.01214301618533653, 0.00965672941512108, 0.012375849608622036, 0.008709568513404986, 0.010051284513262426, 0.011240789301887544, 0.1112398058338967, 0.1328541780228243, 0.13076135287812296, 0.0, 0.0, 0.0]}}
{"id": "429cc005-0500-47e1-9a9d-68ebd9d3d72b", "fitness": 0.02294613165669624, "name": "EnhancedChaoticSwarmOptimizer", "description": "Enhanced Chaotic Swarm Optimizer with adaptive chaotic factors and dynamic population size for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.adaptive_chaotic_factor = np.random.rand(self.initial_population_size)\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        population_size = self.initial_population_size\n\n        while evaluations < self.budget:\n            # Dynamic adjustment of population size\n            if evaluations % (self.budget // 10) == 0 and population_size < self.budget // 2:\n                population_size += 1\n                self.positions = np.vstack((self.positions, np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))))\n                self.velocities = np.vstack((self.velocities, np.random.uniform(-1, 1, (1, self.dim))))\n                self.personal_best_positions = np.vstack((self.personal_best_positions, self.positions[-1]))\n                self.personal_best_scores = np.append(self.personal_best_scores, np.inf)\n                self.adaptive_chaotic_factor = np.append(self.adaptive_chaotic_factor, np.random.rand())\n\n            for i in range(population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(population_size):\n                self.adaptive_chaotic_factor[i] = self.logistic_map(self.adaptive_chaotic_factor[i])\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * self.adaptive_chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * self.adaptive_chaotic_factor[i] * (self.global_best_position - self.positions[i])\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02295 with standard deviation 0.05770.", "error": "", "parent_ids": ["988849c3-27d0-4b0c-a721-5fe9746d2a0c"], "operator": null, "metadata": {"aucs": [0.12617175243620893, 0.09469108042478913, 0.15457911006820213, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0394852868234119, 0.025907406759100082, 0.025056374890610744, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08197238107665017, 0.07004605836468247, 0.053976016685442385, 0.028917847013710807, 0.03527862118320613, 0.020000000000000018, 0.056005358866512145, 0.09737797846660723, 0.07944482987189416, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13569082442011104, 0.09764130145692951, 0.1652820811696587, 0.031407715631301736, 0.030539242391236177, 0.02292979928160488, 0.11360527664437081, 0.08759515757853786, 0.09121075623401442, 0.1402736921937492, 0.13323277534341382, 0.15394918430962035, 0.07400995964208978, 0.07990382579724953, 0.09007520606300945, 0.12801634358345537, 0.12536964059049438, 0.1256854334956331, 0.020000000000000018, 0.020000000000000018, 0.12365441722589732, 0.18865732362387921, 0.08494233001037033, 0.10780640537557484, 0.06816683982409688, 0.13998765812042724, 0.061201305834969966, 0.1438526290318487, 0.1397473838660681, 0.15475448018179316, 0.05304738181760682, 0.040764245750272377, 0.0357446646387678, 0.05252159400249279, 0.03726766911985946, 0.053844361011613606, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052136839600639195, 0.022769523926290614, 0.028667792647373735, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08876004105242619, 0.0720715869041666, 0.09625372726383741, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06336398672733301, 0.06707050475987042, 0.11977756388520389, 0.1003681938608938, 0.10956573510201362, 0.06437671887998941, 0.04502887312824466, 0.056855680713702395, 0.09617703488714857, 0.08744411101010807, 0.09974952110628821, 0.10983381788141688, 0.010000000000000009, 0.010000000000000009, 0.02916200643944733, 0.02971692614703214, 0.035188486632576566, 0.029052497503391783, 0.02438503173765516, 0.02532145063010749, 0.1462968454195953, 0.1390531040716112, 0.13427623229831798, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.03884720004054354, -0.050000000000000044, -0.043969018152959505, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.04613739144172513, -0.04566491353078894, -0.04885872622400478, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.010706646770676675, -0.01150127649357624, -0.01714831205927636, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.01032571119487491, -0.010560634144305414, -0.013215657344973986, 0.04027812661249652, 0.04201827041690309, 0.03471278152592627, -0.01568879910059473, -0.019003576608001005, -0.02350674659494123, 0.04111153586143601, 0.034121432050009726, 0.014452126563139323, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044, -0.03706864770705409, -0.03974275430783347, -0.03700437009226465, -0.04035748429611008, -0.039403296904721996, -0.038738598153313486, 0.07752586124967153, 0.0870101537054816, 0.06397111544410505, -0.050000000000000044, -0.050000000000000044, -0.050000000000000044]}}
{"id": "58b6e7c7-18f1-40b9-bebc-1a738463d49a", "fitness": 0.0365877768534597, "name": "ChaoticSwarmOptimizer", "description": "Introduce LÃ©vy flight distribution to enhance exploration capabilities in the Chaotic Swarm Optimizer for better convergence.", "code": "import numpy as np\n\nclass ChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_step = self.levy_flight(self.dim)\n                self.velocities[i] = inertia + cognitive + social + levy_step\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 6, "feedback": "The algorithm ChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03659 with standard deviation 0.04228.", "error": "", "parent_ids": ["988849c3-27d0-4b0c-a721-5fe9746d2a0c"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.10783599228237617, 0.14925801007861228, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023780039777378192, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08229980403078063, 0.0931252052771745, 0.07517186106011853, 0.02863421374228603, 0.020000000000000018, 0.020000000000000018, 0.04932765936068717, 0.08594148016760361, 0.08712496821177151, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13251855529015688, 0.11882554058190975, 0.14601868642268756, 0.03213706505640568, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.08631266900021362, 0.07681275014291666, 0.1367083005683718, 0.13848155381350613, 0.13047005253610966, 0.07841409523923859, 0.07990382579724953, 0.07330209425142897, 0.11205586464406281, 0.0962049791308377, 0.14130729319067414, 0.020000000000000018, 0.020000000000000018, 0.03207418584218602, 0.11385462794497925, 0.08612481325948773, 0.09132489110438857, 0.06527120746322768, 0.04616535580723691, 0.06361371187996245, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05344932115792833, 0.03392426887360889, 0.028466339936944918, 0.06690672759306437, 0.050211035094007594, 0.05039885659558796, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.160693005636535, 0.032623627693970314, 0.025816854433586278, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06772219515044176, 0.062015259490581176, 0.08269028186549388, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0649173370459768, 0.054550442982546965, 0.11869262382913237, 0.10228821691122536, 0.10281775224528589, 0.05756835603815702, 0.046295524367995555, 0.053936809511723194, 0.0968934643980407, 0.07416220585936406, 0.10929406684252796, 0.013549467509806457, 0.010000000000000009, 0.010000000000000009, 0.025597591409038167, 0.029043163533977734, 0.036649167089412016, 0.027224734603843337, 0.026363077196554396, 0.024640285494433645, 0.13141309820135194, 0.1415843517054023, 0.14591046746191383, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0002787486179390841, 0.002904171724694593, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006970966656718036, 0.0029053126307674315, 0.0008960651444805956, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02930002300937895, 0.041053439958503746, 0.025359924564145486, 0.0, 0.0, 0.0, 0.036826174825020264, 0.039463564127133144, 0.03372372426934189, 0.08438702537788534, 0.08271802501191206, 0.07582052609272094, 0.020213094208609728, 0.024618087584421744, 0.02302358009965022, 0.07067217864914799, 0.06803573515716355, 0.05264623437562377, 0.0, 0.0, 0.0, 0.009777003324397904, 0.0105773621415165, 0.009717047180126448, 0.010574994773310475, 0.010051284513262426, 0.010586299137608446, 0.11363655302237774, 0.1304161139054778, 0.11473079680185672, 0.0, 0.0, 0.0]}}
{"id": "a186cf41-22d7-4a60-9985-29c17f642a75", "fitness": 0.040340726324728175, "name": "EnhancedChaoticSwarmOptimizer", "description": "An improved chaotic swarm optimizer that dynamically adjusts coefficients based on swarm diversity for more efficient convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.cognitive_coefficient = 1.0 + 0.5 * (diversity / self.dim)\n            self.social_coefficient = 1.0 + 0.5 * (1 - diversity / self.dim)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04034 with standard deviation 0.04699.", "error": "", "parent_ids": ["988849c3-27d0-4b0c-a721-5fe9746d2a0c"], "operator": null, "metadata": {"aucs": [0.10238326272820297, 0.09198052979285676, 0.1677519031184156, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024213897310865096, 0.027908000814046208, 0.024932907436000407, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07641678175561706, 0.0558393769810851, 0.052695442450129804, 0.06561745354087545, 0.03349823888037007, 0.020000000000000018, 0.06035937826777005, 0.08594148016760361, 0.10216695385644925, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1385195791421876, 0.12741891619607737, 0.18946406520822445, 0.024697829643268943, 0.023893435330133994, 0.02822160942735874, 0.0941127822382859, 0.09018356167558184, 0.07540484293234018, 0.1457737308218645, 0.15520115089908249, 0.13278756849150952, 0.08785285742265758, 0.07990382579724953, 0.08154477036883179, 0.13285168946534864, 0.12875577243334424, 0.160780524473235, 0.020000000000000018, 0.020000000000000018, 0.11141884675428737, 0.19554911620143456, 0.13589064961497432, 0.10242547491539034, 0.0757986657205757, 0.12438760008304628, 0.09333880829290508, 0.1601204905112894, 0.15107422320243447, 0.15475448018179316, 0.0555623558274968, 0.043468041550024594, 0.05622877593646902, 0.052390615605015345, 0.03792142888465788, 0.06438487858101294, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.043407595786301933, 0.018135110643322294, 0.03596555648908717, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09074469856372658, 0.0697368465223498, 0.09069516943285794, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05949623658384584, 0.06493638368230481, 0.06282446015720755, 0.13362657276147327, 0.1075416905703106, 0.10309014229066749, 0.08420193607342252, 0.042786716449061846, 0.056878822358494285, 0.09165131694588258, 0.09779256936317804, 0.1180437623251287, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04118579972390368, 0.034670940088081914, 0.04967116642788316, 0.02601957729700144, 0.03367738567597667, 0.02468913470622014, 0.1361415894072754, 0.14344700335010918, 0.1418886421851644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009798363194122417, 0.0, 0.004662835193180448, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005912908016341256, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038357873507001705, 0.039810818612911136, 0.0292001177654716, 0.0, 0.0, 0.0, 0.03636011128822769, 0.040040760516733775, 0.03851322992700157, 0.08606439464351001, 0.08751318036230815, 0.0808363904584799, 0.038521842426871844, 0.03038370639120902, 0.024442342963732266, 0.08484685915097467, 0.0802372664171529, 0.06631487705564965, 0.0, 0.0, 0.0, 0.012779505033529426, 0.01048076921851293, 0.011832028889214308, 0.008221286956967, 0.011129423112316461, 0.011220573878046758, 0.11944960503600599, 0.1304161139054778, 0.12951430543041642, 0.0, 0.0, 0.0]}}
{"id": "c530ce7d-ba8f-49ee-8b08-5c4aced89a27", "fitness": 0.03981208965037543, "name": "EnhancedChaoticSwarmOptimizer", "description": "Enhanced chaotic swarm optimizer with adaptive population size to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, max(10, dim))  # Adaptive population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.cognitive_coefficient = 1.0 + 0.5 * (diversity / self.dim)\n            self.social_coefficient = 1.0 + 0.5 * (1 - diversity / self.dim)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03981 with standard deviation 0.04583.", "error": "", "parent_ids": ["a186cf41-22d7-4a60-9985-29c17f642a75"], "operator": null, "metadata": {"aucs": [0.11103066896262548, 0.10066577243078045, 0.22389164920006221, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03874846645336527, 0.03456784392582135, 0.020000000000000018, 0.020000000000000018, 0.030349125007245403, 0.02183156071950232, 0.08185542706171789, 0.06375740963417376, 0.14624206103908355, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08473134110613811, 0.08831460118670431, 0.08515793895958379, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.033471353997832076, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11553474421043208, 0.14809435003627414, 0.1368203460350983, 0.02816427890565676, 0.020000000000000018, 0.022462112433058512, 0.08388334684561793, 0.09320220509064969, 0.09707067812041825, 0.1484518511085372, 0.14337497156368495, 0.14472396075027605, 0.09799213544818686, 0.07318866610956565, 0.08281925890408648, 0.13153993785781926, 0.12042520311436045, 0.13569029405855604, 0.028226823757342756, 0.020000000000000018, 0.1497111620012369, 0.1051433585769651, 0.08174712103307857, 0.07988957054999224, 0.07369985861848138, 0.07017578396964552, 0.09163882520663325, 0.16151149744967686, 0.17281296585032346, 0.12757672238385565, 0.06470872267461625, 0.03755602546521497, 0.03274414835027639, 0.050175871390005566, 0.02890839594485417, 0.06147501923958132, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06701026842357027, 0.024672019662873246, 0.03796446982934898, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07136883904250524, 0.08088082827707865, 0.08447194838338035, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08036760391277242, 0.0628565153990095, 0.07052371961202653, 0.13422173983100538, 0.09726223405843482, 0.10818025701584288, 0.06575392397604407, 0.04700897282754768, 0.05683499879315279, 0.0826858467542343, 0.090265635991292, 0.1193798696397641, 0.01744778527355051, 0.010000000000000009, 0.010000000000000009, 0.02673748538873033, 0.050787983439890105, 0.031020248793653837, 0.03103337424514363, 0.020882400964189696, 0.060883258478688584, 0.12685821239783968, 0.13329011936094726, 0.13614388261851185, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009798363194122417, 0.0, 0.004662835193180448, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005912908016341256, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038357873507001705, 0.039810818612911136, 0.0292001177654716, 0.0, 0.0, 0.0, 0.03636011128822769, 0.040040760516733775, 0.03851322992700157, 0.08606439464351001, 0.08751318036230815, 0.0808363904584799, 0.038521842426871844, 0.03038370639120902, 0.024442342963732266, 0.08484685915097467, 0.0802372664171529, 0.06631487705564965, 0.0, 0.0, 0.0, 0.012779505033529426, 0.01048076921851293, 0.011832028889214308, 0.008221286956967, 0.011129423112316461, 0.011220573878046758, 0.11944960503600599, 0.1304161139054778, 0.12951430543041642, 0.0, 0.0, 0.0]}}
{"id": "3dc1871b-e3ad-4d64-aaee-138fddd886f8", "fitness": 0.04024429799312631, "name": "EnhancedChaoticSwarmOptimizer", "description": "This update enhances convergence by incorporating a hyperbolic tangent scaling for cognitive and social coefficients based on swarm diversity.", "code": "import numpy as np\n\nclass EnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.cognitive_coefficient = 1.0 + 0.5 * np.tanh(diversity / self.dim)\n            self.social_coefficient = 1.0 + 0.5 * (1 - np.tanh(diversity / self.dim))\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04024 with standard deviation 0.04642.", "error": "", "parent_ids": ["a186cf41-22d7-4a60-9985-29c17f642a75"], "operator": null, "metadata": {"aucs": [0.10810150571891253, 0.11753992726705875, 0.1519560769402143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027291540728794583, 0.03257814549532834, 0.02496074961240169, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07872558012428632, 0.06128167316899091, 0.052716698525247074, 0.08702326488221557, 0.032588637560577505, 0.020000000000000018, 0.05509870120786586, 0.08594148016760361, 0.10062973549788179, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14732265870266403, 0.11817189850589782, 0.1937226506689902, 0.026112743656908743, 0.032281548252933834, 0.028395109241771355, 0.08733506624483534, 0.09072442557118254, 0.11120465019119619, 0.1522513352458268, 0.14650537319762746, 0.136888564956686, 0.08064849366177218, 0.07990382579724953, 0.08122419711930373, 0.14598421312550314, 0.12206933992350888, 0.13996073152610167, 0.020000000000000018, 0.020000000000000018, 0.13651473213112264, 0.19271310603895697, 0.10047583402899274, 0.12018217458409819, 0.10983075826790956, 0.06297669971880682, 0.06129726670558844, 0.14958467862606284, 0.14021273414440383, 0.15475448018179316, 0.055903840881012634, 0.047748181896077435, 0.029260132777858106, 0.051683238746679794, 0.03478466119030377, 0.06283909309884206, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04458395805951776, 0.018655173325271224, 0.03644314307934238, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02214573162476574, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08921443156656905, 0.06342128286215232, 0.09330419401897028, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06629723002344023, 0.06275077444324939, 0.08019945417938812, 0.1264044299612892, 0.10693922430764646, 0.10300274536210707, 0.08112942386526922, 0.05303880575165276, 0.057216991551974794, 0.09838305182150231, 0.0847633881146237, 0.10458923683533872, 0.02375237513266637, 0.010000000000000009, 0.010000000000000009, 0.042782741814468284, 0.03341789166576847, 0.05068421408697721, 0.02842321729783459, 0.030552646494021563, 0.024682470110930832, 0.13809285381987746, 0.142535149891181, 0.14367441925645508, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.009796592966578532, 0.0, 0.004970609376482971, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006192508114839956, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03834552511320899, 0.039850885602225605, 0.029503283248328294, 0.0, 0.0, 0.0, 0.03678355345982509, 0.04451513628595083, 0.03179832113474901, 0.08577109245576153, 0.08631229383430095, 0.07932364856176666, 0.03186475446869552, 0.03169247380067264, 0.024302386784971097, 0.08695725228456819, 0.08012000053426638, 0.0648070623239475, 0.0, 0.0, 0.0, 0.012851074097590232, 0.010475650747989507, 0.011638667166220529, 0.0081625173058264, 0.011286550154720243, 0.011249735984016906, 0.11498257831746062, 0.1304161139054778, 0.12981529265474134, 0.0, 0.0, 0.0]}}
{"id": "e178b536-7ab2-4d75-8ca4-a3ebfdb3a63b", "fitness": 0.0401321225255936, "name": "DualChaoticSwarmOptimizer", "description": "A dual-chaotic strategy swarm optimizer using dual logistic maps for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass DualChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        secondary_chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.cognitive_coefficient = 1.0 + 0.5 * (diversity / self.dim)\n            self.social_coefficient = 1.0 + 0.5 * (1 - diversity / self.dim)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                secondary_chaotic_factor[i] = self.logistic_map(secondary_chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i] * secondary_chaotic_factor[i]  # Dual chaotic influence\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 10, "feedback": "The algorithm DualChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04013 with standard deviation 0.04714.", "error": "", "parent_ids": ["a186cf41-22d7-4a60-9985-29c17f642a75"], "operator": null, "metadata": {"aucs": [0.10024377912443183, 0.09341397459922973, 0.16738457306163357, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034972265788985935, 0.027660599494689353, 0.023835088313597375, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07622044416847784, 0.0575251515375359, 0.051944463118237305, 0.03632995500702063, 0.0328149431277428, 0.020000000000000018, 0.06014610040237667, 0.08594148016760361, 0.1042882613951106, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13839091280068483, 0.12701458796517107, 0.18667300462739578, 0.032249742504330325, 0.023220592429682663, 0.03881154620249505, 0.09583299640409249, 0.09278826373252624, 0.07893524763395765, 0.15645636569236254, 0.1542099385175686, 0.1363026641086782, 0.08511843127866991, 0.08204475354157081, 0.06727800076672674, 0.14699396409987897, 0.1142207496325901, 0.14830103088094548, 0.020000000000000018, 0.020000000000000018, 0.11788246911731304, 0.19988087383586817, 0.1358985103274165, 0.10231142807688542, 0.07198994963158323, 0.12583235278143268, 0.07305390993211769, 0.14755453731730428, 0.19916318862120763, 0.15475448018179316, 0.057575139899603056, 0.03987486128544504, 0.041494068407551654, 0.05351991365369557, 0.03680362458779429, 0.0645423413771915, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.038100737144508345, 0.017841250227197514, 0.03518322289785447, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01608761157111649, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09056224060593354, 0.06455760127907606, 0.09846105829179008, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06779454346854208, 0.05737779988548919, 0.13545193715651282, 0.10724201287942581, 0.10431281445584573, 0.07749532160280492, 0.04427265660990021, 0.05959025249702843, 0.10125271971997152, 0.09033319835871201, 0.09989505742059368, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03943057317906662, 0.03719237618336846, 0.045398151113065666, 0.025937313815037832, 0.03381399064525614, 0.024804498394171093, 0.13925800328800664, 0.13569803657406898, 0.14351861854043946, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010327661489088147, 0.0, 0.0048353978214663584, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0057416214677801225, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03982714129380993, 0.040258827109636464, 0.029761568666221483, 0.0, 0.0, 0.0, 0.03118010407859373, 0.04550615199381847, 0.0329966831808578, 0.08870547422543851, 0.08760734000321624, 0.08097489605368002, 0.04104246617574814, 0.029969008040598655, 0.02562206062922978, 0.08505462028436228, 0.07736821486550738, 0.07150190026632897, 0.0, 0.0, 0.0, 0.012635909820934765, 0.010337627167013475, 0.012686162752969521, 0.007786433003266757, 0.011349454149005234, 0.01101627102461089, 0.1112398058338967, 0.1304161139054778, 0.11763047809064231, 0.0, 0.0, 0.0]}}
{"id": "c4b7eff7-7135-40b2-8c54-8b6eaa3b6761", "fitness": 0.03972660405257176, "name": "EnhancedChaoticSwarmOptimizer", "description": "An improved chaotic swarm optimizer with dynamically adjusted coefficients and stochastic velocity updates for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.cognitive_coefficient = 1.0 + 0.5 * (diversity / self.dim)\n            self.social_coefficient = 1.0 + 0.5 * (1 - diversity / self.dim)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = 0.5 + 0.5 * chaotic_factor[i]  # Adapt inertia weight\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social + np.random.normal(0, 0.1, self.dim)  # Stochastic velocity update\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03973 with standard deviation 0.04634.", "error": "", "parent_ids": ["a186cf41-22d7-4a60-9985-29c17f642a75"], "operator": null, "metadata": {"aucs": [0.10413764766530531, 0.08998048274752568, 0.16823691253783124, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02731858584023139, 0.024066015241953065, 0.029292287116567062, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07684425646729365, 0.057100265268360206, 0.05243210744311677, 0.026879867357200493, 0.03901241063317995, 0.020000000000000018, 0.05865543074308288, 0.08594148016760361, 0.10169979193574119, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1400159649404532, 0.13206851560014998, 0.19340920513790227, 0.020000000000000018, 0.020903973178943103, 0.04360837104744675, 0.10199544991978204, 0.08962771630199684, 0.07015575039186472, 0.15109641715039368, 0.15090058598443534, 0.1457727903892334, 0.0793198361615538, 0.07990382579724953, 0.0963088145748161, 0.1349059199740552, 0.1216631464682757, 0.15287564630521955, 0.020000000000000018, 0.020000000000000018, 0.11536106890918052, 0.19983668667566723, 0.14163546839130414, 0.09854709087873215, 0.0711096643360637, 0.07104645275696075, 0.08458407853525718, 0.1438526290318487, 0.13878583791664922, 0.15730958464366152, 0.06325121867588335, 0.04714423558919778, 0.034457651955806634, 0.048204889198167344, 0.03495695464159487, 0.06562612883972563, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.043141999979495416, 0.018163107733462747, 0.035440908557306416, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08978566203801619, 0.06376831461517485, 0.09353135028939041, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05897889636677145, 0.07096069405698313, 0.060740313700426096, 0.1476604119348014, 0.10845889897517436, 0.10721651573496405, 0.07502784417402109, 0.04928533337609953, 0.05799865491678391, 0.09839236955815744, 0.09040491761322922, 0.10048511829633244, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04508276204031081, 0.031735347714981876, 0.0533449271008416, 0.026125408355180735, 0.032634905115261015, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.13705495464832385, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.008328398003798476, 0.0, 0.004697323666428832, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005929011210252244, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03933807386951105, 0.03901139374188223, 0.02966225061887684, 0.0, 0.0, 0.0, 0.0421581369964279, 0.0400061625082645, 0.04110142012281559, 0.08704856726456511, 0.08975369362620045, 0.08128251724383018, 0.03231979137440266, 0.03154024370157482, 0.022663773070964788, 0.0855414572004084, 0.08089577205150933, 0.07068935071216165, 0.0, 0.0, 0.0, 0.012424056732867284, 0.010610361942223867, 0.012001450103811928, 0.008242558677467815, 0.011193222901180966, 0.011235221907817228, 0.114337738289087, 0.1304161139054778, 0.1139722021546753, 0.0, 0.0, 0.0]}}
{"id": "bfbc57a3-6234-4d33-bfb2-b432045f9385", "fitness": 0.03944133381842033, "name": "DynamicInertiaChaoticSwarmOptimizer", "description": "A dynamic inertia chaotic swarm optimizer that adapts the population size and mutation step based on convergence to enhance exploratory and exploitative capabilities.", "code": "import numpy as np\n\nclass DynamicInertiaChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.max_population_size = 40\n        self.min_population_size = 10\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def mutate_positions(self):\n        mutation_strength = 0.1 * (self.upper_bound - self.lower_bound) * (1 - self.evaluations / self.budget)\n        mutation = np.random.uniform(-mutation_strength, mutation_strength, self.positions.shape)\n        self.positions += mutation\n\n    def update_population_size(self):\n        diversity = self.calculate_swarm_diversity()\n        if diversity < 0.1:\n            new_size = max(self.min_population_size, self.positions.shape[0] - 1)\n        else:\n            new_size = min(self.max_population_size, self.positions.shape[0] + 1)\n        if new_size != self.positions.shape[0]:\n            indices = np.argsort(self.personal_best_scores)[:new_size]\n            self.positions = self.positions[indices]\n            self.velocities = self.velocities[indices]\n            self.personal_best_positions = self.personal_best_positions[indices]\n            self.personal_best_scores = self.personal_best_scores[indices]\n\n    def __call__(self, func):\n        self.evaluations = 0\n        chaotic_factor = np.random.rand(self.positions.shape[0])\n        \n        while self.evaluations < self.budget:\n            for i in range(self.positions.shape[0]):\n                score = func(self.positions[i])\n                self.evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            self.update_population_size()\n            \n            for i in range(self.positions.shape[0]):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                inertia_weight = self.initial_inertia_weight * (1 - (self.evaluations / self.budget))\n                inertia = inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            self.mutate_positions()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 12, "feedback": "The algorithm DynamicInertiaChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03944 with standard deviation 0.04472.", "error": "", "parent_ids": ["a186cf41-22d7-4a60-9985-29c17f642a75"], "operator": null, "metadata": {"aucs": [0.09649839407606409, 0.1108482214298846, 0.14569730827742067, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.046756435304340815, 0.02674854163091478, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023341135091986875, 0.07988163023137418, 0.06062633416206775, 0.05346932860574982, 0.030968811775659577, 0.0429917369692262, 0.020000000000000018, 0.03760166830439515, 0.08594148016760361, 0.09012472529947357, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13778053205762508, 0.138089171114832, 0.13935816503078724, 0.027230943127248275, 0.03184494605478361, 0.025440804781549864, 0.09342692015933152, 0.0863116411064907, 0.07015575039186472, 0.1373739690758563, 0.1468687283193819, 0.13263646689716213, 0.09066699957592173, 0.09882250240005475, 0.0971613253034812, 0.14132529424471518, 0.1090783477072873, 0.1567927155927923, 0.020000000000000018, 0.020000000000000018, 0.09030535376011473, 0.16744707435848472, 0.09997656596291937, 0.1169972842749607, 0.07714728808004423, 0.08289673679020881, 0.13335992206601177, 0.14477600238845922, 0.13589170657517036, 0.15475448018179316, 0.047215932754526624, 0.04095584975591593, 0.029062933920907863, 0.05258079315507502, 0.043842455185041485, 0.06012210098824855, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04319505085349318, 0.02097819990946148, 0.02139093442564932, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012055919141169658, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09304505424329546, 0.06940813846337146, 0.07857986593150446, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.054832081659703436, 0.06381977339594624, 0.05584922267540804, 0.13738227707433737, 0.10725965848021612, 0.10476101540176042, 0.06455156551663732, 0.04491939710119597, 0.05863110383459813, 0.10069823754314211, 0.08821266733128141, 0.10494782896977795, 0.1153469272350679, 0.010000000000000009, 0.010000000000000009, 0.030372876769507506, 0.04425828354876471, 0.03360069425929024, 0.04755206611235474, 0.0289638130589992, 0.025322161805695242, 0.13244820879428942, 0.1312417380767249, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015076588169172567, 0.0005354498238047123, 0.013964143260504991, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.044049624405503196, 0.04164294574291316, 0.03755577990127723, 0.0, 0.0, 0.0, 0.038723412462414064, 0.038273989870634795, 0.03192950782414594, 0.08598244838782632, 0.0834119052376705, 0.0850397033984468, 0.026944799610432613, 0.030787901134098572, 0.023491926422496423, 0.07405045687191503, 0.0818850685081901, 0.07094994782369413, 0.0, 0.0, 0.0, 0.012610415676680309, 0.011415552783821115, 0.01163950370098421, 0.010649297493121712, 0.010962167957957125, 0.008658484587452997, 0.12278668433470075, 0.14195770645330985, 0.10775122444915164, 0.0, 0.0, 0.0]}}
{"id": "383056be-6656-4dca-a883-184e3ee9e06b", "fitness": 0.040917984553731565, "name": "AdaptiveChaoticSwarmOptimizer", "description": "A novel adaptive chaotic swarm optimizer that utilizes dynamic inertia weight and diversity-driven coefficients to enhance convergence and exploitation.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 13, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04092 with standard deviation 0.04705.", "error": "", "parent_ids": ["a186cf41-22d7-4a60-9985-29c17f642a75"], "operator": null, "metadata": {"aucs": [0.11891444192232503, 0.11070433910061583, 0.16553230440507416, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02746666183857871, 0.025713855901100313, 0.028310745864121745, 0.020000000000000018, 0.020063589712732477, 0.020000000000000018, 0.07599630699025117, 0.0489976392595759, 0.051203124643527054, 0.10339639888195762, 0.03239311658678734, 0.020000000000000018, 0.06342257419693997, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027365025645070817, 0.020000000000000018, 0.043185983919733384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1349696507821737, 0.13076840035396453, 0.183150013732989, 0.026906296941451413, 0.031496402578967686, 0.037528046509002766, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.17727941830935212, 0.15762104625585782, 0.1399538727480164, 0.08544507142843694, 0.07990382579724953, 0.07953094709372321, 0.16689912437587995, 0.11618982659882537, 0.14690525153072853, 0.020000000000000018, 0.10920405913436293, 0.12616854897734353, 0.1897807158226663, 0.10641585374467, 0.10872066653430368, 0.06947504323702869, 0.08634625945524532, 0.10054245305042953, 0.15366869050555865, 0.1430240829426731, 0.15475448018179316, 0.04839486587644681, 0.040433452319290075, 0.032157362004347045, 0.05315297443016276, 0.03530297133652793, 0.06281680322270589, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04844031957300843, 0.01708630760918839, 0.038182530043348595, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020571222028526348, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08951246177118277, 0.06476316201200272, 0.09372687176396188, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.08802384992455037, 0.06967844250781285, 0.13564424644551631, 0.1081132584915756, 0.10303932132932037, 0.07391516666539033, 0.04476961705113636, 0.0542729532809767, 0.09787099431904622, 0.08509127006048545, 0.11116935641674397, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041930971572320064, 0.0347543636971831, 0.04828662665799344, 0.03183628551195772, 0.03320151186376952, 0.025994721683279765, 0.1397364698205884, 0.13256066407439093, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005925795956316038, 0.0, 0.007054495573385, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004875659578649771, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03852681535497249, 0.03949982888992498, 0.030338172776899208, 0.0, 0.0, 0.0, 0.04245104108310971, 0.04735202966067309, 0.04099103175357488, 0.08827451279974796, 0.08706506426706384, 0.07998667367644918, 0.024711370162866064, 0.03457589406032613, 0.027539637705877307, 0.07779264903284355, 0.08043157682621238, 0.0682757966341262, 0.0, 0.0, 0.0, 0.012794490380470425, 0.010160222190639168, 0.011851171329768873, 0.008587929237127145, 0.010860136093378214, 0.010822874198213928, 0.12165987256037458, 0.1304161139054778, 0.11240126546848062, 0.0, 0.0, 0.0]}}
{"id": "40d8fe7a-6168-4703-ac81-f0c34c072676", "fitness": 0.03799297290913995, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhanced Adaptive Chaotic Swarm Optimizer with multi-chaotic map integration and velocity clamping to improve convergence and stability.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n    \n    def tent_map(self, x):\n        return 1 - np.abs(1 - 2 * x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factors = np.random.rand(self.population_size, 2)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factors[i, 0] = self.logistic_map(chaotic_factors[i, 0])\n                chaotic_factors[i, 1] = self.tent_map(chaotic_factors[i, 1])\n                chaotic_mix = (chaotic_factors[i, 0] + chaotic_factors[i, 1]) / 2\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_mix\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_mix * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_mix * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)  # Velocity clamping\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03799 with standard deviation 0.04351.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.09516840456274411, 0.09143752517259918, 0.1443914916809993, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029117449224243308, 0.020949333105811818, 0.02600180940440877, 0.020000000000000018, 0.021044648207690475, 0.020000000000000018, 0.05887227199859124, 0.04458010216151054, 0.050864699606852914, 0.020000000000000018, 0.03317564335778456, 0.020000000000000018, 0.04701674330841088, 0.08594148016760361, 0.07626329161761936, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12151087866480426, 0.10796982795552823, 0.16976369813581427, 0.025195634608657258, 0.02312942858000322, 0.03548339338948159, 0.129500312547278, 0.0863116411064907, 0.07015575039186472, 0.14703651507314763, 0.13323277534341382, 0.12430961988093836, 0.08824832172593144, 0.07990382579724953, 0.06680269500801128, 0.12914872826426516, 0.1005635503515685, 0.12886482371931218, 0.020000000000000018, 0.020000000000000018, 0.035520804936263195, 0.15876489068096478, 0.08561386515154457, 0.0949380542245093, 0.07336561959757293, 0.056584842199613794, 0.08512834808491965, 0.1607416260119099, 0.1515676738067866, 0.15475448018179316, 0.049821167429479396, 0.05575301508968411, 0.03336648242814644, 0.056330935644296476, 0.038927613486081425, 0.06629014179285886, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012237588449678705, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011240321554339405, 0.012728292049701273, 0.010896642541067258, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09815615256787336, 0.07377912120275087, 0.0836600980542136, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05616488982446921, 0.08679339000365094, 0.0542294361458201, 0.1296977923966851, 0.10506740699277373, 0.10461153075278229, 0.07250426675106214, 0.056233459562151644, 0.05678379967196212, 0.11750612460911247, 0.09401292872608669, 0.10729221174717418, 0.06687574458906709, 0.010000000000000009, 0.01991057204165758, 0.02641048758698472, 0.03636221545049212, 0.03376549294155207, 0.0296532732640451, 0.024568736180304418, 0.027724916656192145, 0.13230441194292197, 0.13941101751899354, 0.1337832524086161, 0.01068654766648136, 0.010000000000000009, 0.010000000000000009, 0.011140001712134917, 0.004142507914086324, 0.011304556422257583, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04587556157371897, 0.05180076468203776, 0.04464255736788825, 0.0, 0.0, 0.0, 0.03704240320787533, 0.03832593686096519, 0.0343325257369389, 0.08438736220770382, 0.08988531752620754, 0.08733053744199859, 0.03418606662813717, 0.032745062813376635, 0.024135004421603434, 0.08574109672920538, 0.08234396079298123, 0.07515372804451825, 0.0, 0.0, 0.0, 0.01086881545191587, 0.011166220604771016, 0.012469829946944011, 0.0076796264642660095, 0.010051284513262426, 0.011442690028049651, 0.1281448879076733, 0.1304161139054778, 0.11524973075051581, 0.0, 0.0, 0.0]}}
{"id": "badc6c5f-6bd3-4153-bfcf-ab62f0d2506d", "fitness": 0.03947729222812605, "name": "EnhancedChaoticSwarmOptimizer", "description": "An enhanced chaotic swarm optimizer leveraging adaptive mutation and cooperative learning for improved convergence and diversity maintenance.", "code": "import numpy as np\n\nclass EnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_mutation(self, position):\n        mutation_strength = 0.1 * np.random.randn(self.dim)\n        return position + mutation_strength\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                cognitive_part = chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social_part = chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                cooperation_part = chaotic_factor[i] * (np.mean(self.positions, axis=0) - self.positions[i])\n                \n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_part + social_part + cooperation_part\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n                \n                # Apply adaptive mutation to promote exploration\n                if np.random.rand() < 0.1:\n                    self.positions[i] = self.adaptive_mutation(self.positions[i])\n                    self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03948 with standard deviation 0.04484.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.1305803752105521, 0.08161371262481709, 0.14025824808494636, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03519476089971518, 0.03313412404880167, 0.02221584534271981, 0.03627435886065822, 0.020000000000000018, 0.03697754875411963, 0.08614086736256144, 0.0677652729861492, 0.06496336335398256, 0.037575557620165845, 0.020000000000000018, 0.020000000000000018, 0.031503068136510715, 0.08594148016760361, 0.08131301219735154, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.032760249720371615, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15100465883644032, 0.11160149070274261, 0.17478479386481327, 0.05217831717691235, 0.020000000000000018, 0.028561220017150557, 0.08072694858327945, 0.0863116411064907, 0.07579457968536474, 0.1336250315625671, 0.17865378439303103, 0.14311234728475386, 0.07388478470195337, 0.07990382579724953, 0.07102636121219941, 0.12979972097968362, 0.117364320989374, 0.1353700099767391, 0.020000000000000018, 0.020000000000000018, 0.1248910482161536, 0.1837695319335182, 0.08418577957219209, 0.0895133107273659, 0.07515600087522445, 0.05425066214261054, 0.056492493752391515, 0.1438526290318487, 0.1376993658037654, 0.15475448018179316, 0.04631064393118034, 0.041974639164001015, 0.04546180814397216, 0.05068377422849235, 0.033997023863163944, 0.047485569991724486, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06202371684180663, 0.03126531500513363, 0.028652796550048265, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013516785890787975, 0.015518253856132591, 0.01016412524127086, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.10216731787340283, 0.07348107498368117, 0.10229246644010648, 0.010000000000000009, 0.010000000000000009, 0.014693593808928429, 0.057144000280154206, 0.0631962870275733, 0.056874027401422556, 0.11957709948102702, 0.10673208616713081, 0.10694649472705042, 0.06355020372609388, 0.04269009034898985, 0.053936809511723194, 0.10805593565331117, 0.0978817217183332, 0.11109735894139161, 0.10843745021876783, 0.010000000000000009, 0.010000000000000009, 0.03049362206800421, 0.030067218694937337, 0.03303938225739733, 0.027745762029122156, 0.026241557722728404, 0.02494354779074015, 0.13330161058675605, 0.13592313608152184, 0.13446285843363726, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.017599939801959064, 0.0031321350791998492, 0.01101542600285188, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.002430157776105113, 0.002698751784668718, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04112099693293392, 0.04029343777121741, 0.03909084117894579, 0.0, 0.0, 0.0, 0.03466598907755081, 0.03890816811400877, 0.0332320606073806, 0.08874518553698352, 0.09266706239151601, 0.08561829241531671, 0.03569020437935577, 0.03168721633372418, 0.027378604784895066, 0.0880164153576366, 0.08756351653673133, 0.0785785301472558, 0.0, 0.0, 0.0, 0.013070876216614624, 0.011188735394324412, 0.013001188081543824, 0.008923884506267132, 0.010051284513262426, 0.008887875270246148, 0.12633016412956943, 0.1304161139054778, 0.11058391608740048, 0.0, 0.0, 0.0]}}
{"id": "3a636379-2965-43a5-8b1a-b4a4555ea30c", "fitness": 0.04078390131622281, "name": "AdaptiveChaoticSwarmOptimizer", "description": "A subtle enhancement to the adaptive chaotic swarm optimizer by introducing a minor adjustment in the velocity update equation to improve convergence.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                # Modified line\n                self.velocities[i] = inertia + cognitive + social + 0.001 * np.random.uniform(-1, 1, self.dim)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04078 with standard deviation 0.04663.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.118899459510166, 0.11073025283989868, 0.16555033307782363, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02737791876408069, 0.02562186542187761, 0.028325586563240246, 0.020000000000000018, 0.02001785023787206, 0.020000000000000018, 0.07599143356880544, 0.04900264112324304, 0.0512018088049655, 0.10337466750693214, 0.03238900177937554, 0.020000000000000018, 0.06342257419693997, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02847105770189373, 0.020000000000000018, 0.04425320737914373, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1349823420214793, 0.13079915967740985, 0.18315733516426957, 0.026988260979891265, 0.0315019689543935, 0.03757089617511189, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.17701366006936226, 0.15780969201484352, 0.1399885254055253, 0.08499406564085488, 0.07990382579724953, 0.07925694491820112, 0.13604178181833715, 0.11911550244619373, 0.1272676366426867, 0.020000000000000018, 0.10915969907152412, 0.1260881476047202, 0.18964895043781416, 0.10641813679313106, 0.10869944961952338, 0.06947278797072098, 0.08640538861646518, 0.1005775067255179, 0.15800947261836118, 0.14155957865259428, 0.15475448018179316, 0.0489345806036835, 0.040416231952334236, 0.03213879902341077, 0.053142640718487844, 0.03529924034449072, 0.0628185503109705, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04845473213298068, 0.017081486554441305, 0.038191036559627745, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020571222028526348, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08952415809040803, 0.06476809326998767, 0.09371322671908655, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0877487733978336, 0.07017909827836977, 0.13570236132829638, 0.10810784735034329, 0.10302794012317651, 0.07395861212371913, 0.044782844165496716, 0.05430840452668351, 0.09259089851267122, 0.09909296273076251, 0.11082564283719587, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041941280168739326, 0.034776452455460016, 0.0482926543025155, 0.03184378108538777, 0.03321374549012068, 0.02599207105850132, 0.1373466426454033, 0.13230206623471918, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005927226576842193, 0.0, 0.0070591460775597525, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004876831240569812, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03853616334839305, 0.039502369547739, 0.030347846579674487, 0.0, 0.0, 0.0, 0.04247543704454604, 0.047405825415638425, 0.04097378199505797, 0.08828616148692403, 0.08714570980358327, 0.0799886453056311, 0.024711198515297794, 0.03457345819365831, 0.027622914002679688, 0.08025075517174585, 0.08196203547614755, 0.07044463449899707, 0.0, 0.0, 0.0, 0.012795336327027895, 0.010160691183301984, 0.011849524841087034, 0.008590483907831348, 0.010861436484798648, 0.010824249411454212, 0.12402188046040186, 0.1304161139054778, 0.11149290629074837, 0.0, 0.0, 0.0]}}
{"id": "b046567f-2314-4ed7-92c4-b658a430193c", "fitness": 0.038792918513285916, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhanced Adaptive Chaotic Swarm Optimizer with Nonlinear Adaptive Parameters and Memory-based Chaotic Disturbance for Improved Exploration-Exploitation Balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.chaotic_memory = np.random.rand(self.population_size)\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = np.tanh(diversity / self.dim)\n            self.cognitive_coefficient = 2.0 - adaptive_factor\n            self.social_coefficient = 1.0 + adaptive_factor\n            \n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(self.chaotic_memory[i])\n                self.chaotic_memory[i] = chaotic_factor[i]\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                \n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03879 with standard deviation 0.04468.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.1222082978574448, 0.09218916219741513, 0.14750948608347758, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.042394317342799415, 0.02739504240099333, 0.02212871492277546, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08517832328486508, 0.08687903751608506, 0.056529501193720466, 0.028675904582382783, 0.034666804718755606, 0.020000000000000018, 0.03846230707888054, 0.09168472752339207, 0.09686788160880955, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029020409096295885, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12739923255446883, 0.10405207056358534, 0.1727178295317613, 0.034581510558478246, 0.020000000000000018, 0.03625225325028747, 0.10007707466779092, 0.0863116411064907, 0.09374445812933263, 0.13535441136113524, 0.13323277534341382, 0.14500066869094497, 0.07116143490228122, 0.07990382579724953, 0.07593023931740517, 0.13333281656154317, 0.11562870843154827, 0.1341586856638236, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.18096195461322906, 0.10552214039343655, 0.12868832730291402, 0.08010017014652238, 0.06798264755346484, 0.06825236686987357, 0.16057894786575988, 0.14399516141232416, 0.15892395658146374, 0.038669801718039354, 0.03490633305766844, 0.030443482965428315, 0.04617020348953971, 0.03995584558952758, 0.05170555373977492, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05548715358783174, 0.025868440775902002, 0.03493317182218103, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08905096365651644, 0.06801099257770682, 0.07765060161905779, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057252187146923594, 0.06990832420572946, 0.054602180484262686, 0.12332628921696287, 0.10763064180892723, 0.10542380709110366, 0.06558283364715789, 0.04079337761160662, 0.05573437634957157, 0.09807344546090391, 0.09277178186615276, 0.09651934660551897, 0.12028591739845895, 0.010000000000000009, 0.010000000000000009, 0.03032697645683302, 0.031248873868562455, 0.03966867756163173, 0.03296364996760259, 0.0241014664012148, 0.025155501131869373, 0.13334092240739193, 0.13508110579326182, 0.15212557754124711, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00923601787620465, 0.0, 0.006802998127437454, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004326214006349471, 0.0036636035074658624, 0.0006267900604655097, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03647312647273493, 0.03438379282185222, 0.03522458121438565, 0.0, 0.0, 0.0, 0.030827884961280083, 0.04949229871687533, 0.03582083081855447, 0.08749018515310558, 0.08679141850160899, 0.08385579975660817, 0.031212097938538408, 0.031281336324370024, 0.02159737067276357, 0.07611078701095964, 0.07984464669365121, 0.06863263199047098, 0.0, 0.0, 0.0, 0.012567855587962251, 0.009758949773324477, 0.012224858476812317, 0.008301046920727972, 0.010081704025570515, 0.010763158230068681, 0.11713512586573471, 0.1304161139054778, 0.12392214225770659, 0.0, 0.0, 0.0]}}
{"id": "a2021e44-3591-4d1b-9978-0601915c7877", "fitness": 0.0405761253682687, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "An enhanced adaptive chaotic swarm optimizer using hybrid chaotic maps and self-adaptive parameters for improved exploration and exploitation. ", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def tent_map(self, x):\n        mu = 2.0\n        return mu * x if x < 0.5 else mu * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        alternate_chaos = True\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                if alternate_chaos:\n                    chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                else:\n                    chaotic_factor[i] = self.tent_map(chaotic_factor[i])\n                alternate_chaos = not alternate_chaos\n                \n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04058 with standard deviation 0.04602.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11372981957480666, 0.11343948310355445, 0.16651188830494645, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.031183919981737862, 0.02609044118318049, 0.028310745864121745, 0.020000000000000018, 0.020000000000000018, 0.024965762390116608, 0.06671759316085057, 0.04850691038730193, 0.05122090064625151, 0.10339639888195762, 0.033795755244715675, 0.020000000000000018, 0.05727520958342158, 0.08594148016760361, 0.11179796376536022, 0.03965835533922213, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1385763949263732, 0.13584122639912766, 0.18491476114752414, 0.04111166056594018, 0.03518314997921068, 0.025200249692964305, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.1649459500386129, 0.1551467669488643, 0.13644216718310898, 0.07857231306556312, 0.08249813603781075, 0.07953094709372321, 0.14100768118648677, 0.11053362270843603, 0.13930449569579084, 0.020000000000000018, 0.10560898564648258, 0.12616854897734353, 0.16088579998108377, 0.09047513179095856, 0.10851703677707136, 0.07074020903559841, 0.08348525283232688, 0.09645584085331871, 0.15366869050555865, 0.14296897919985796, 0.15475448018179316, 0.047680603209443895, 0.04547400454732753, 0.03332287835695125, 0.050047076475443486, 0.046001219876736776, 0.06359113053400345, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041082981615620295, 0.0241381453263243, 0.038924629076562134, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020571222028526348, 0.013447616357308068, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09405092441988783, 0.06468318763396763, 0.08938576629619988, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06548548025284462, 0.05607996567422391, 0.1333338461620761, 0.11322265993752822, 0.10325842588152612, 0.07322965009157167, 0.05945667678895772, 0.05648845772821687, 0.09519735277658592, 0.09470764118042452, 0.10811925372794862, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041930971572320064, 0.04020953110469061, 0.049510959960111456, 0.02871860544240934, 0.03277971650650369, 0.026293406195552205, 0.1357823684790158, 0.14102521388917078, 0.1458429805108139, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.006189833240557774, 0.0007222799048065554, 0.009371406069827226, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005297196723058395, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04401466090871242, 0.0405197970937492, 0.03175013666982973, 0.0, 0.0, 0.0, 0.04316706443869878, 0.04727891676187934, 0.04157156526666839, 0.08826436246287583, 0.08729276279326226, 0.08475883266110662, 0.025237336854740722, 0.03457589406032613, 0.021920508515643977, 0.08534436520201838, 0.07470846796496022, 0.0756778744513169, 0.0, 0.0, 0.0, 0.012787157315806486, 0.00962950170601018, 0.011797717098565697, 0.0094617082861721, 0.01080538650901064, 0.010885009294342884, 0.12168922692684747, 0.1304161139054778, 0.10935804756122536, 0.0, 0.0, 0.0]}}
{"id": "8532c0fd-6846-4b92-9c8c-418418926e09", "fitness": 0.04053948418484264, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Improved chaotic mapping by introducing a sinusoidal transformation to enhance exploration and convergence balance.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n    \n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = np.sin(self.logistic_map(chaotic_factor[i]))  # Modified line\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 19, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04054 with standard deviation 0.04640.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.13347957247731101, 0.11927203677054765, 0.17338372029126192, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03284142619990593, 0.027666378388721324, 0.026195170217857222, 0.02648089039661694, 0.020000000000000018, 0.020000000000000018, 0.0764639419236629, 0.05094986678782876, 0.05093052988840985, 0.038470311067463236, 0.031514978612270816, 0.020000000000000018, 0.052239381758852566, 0.11191108089342128, 0.08118590337075926, 0.02417597472175903, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16054527585980027, 0.13159958032519625, 0.1759225997437477, 0.028778325986962283, 0.02839544350547729, 0.043242922787427474, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.15085980837355994, 0.16267078189481632, 0.12838855319934095, 0.08336679571788497, 0.07990382579724953, 0.07938730451711717, 0.1435580536580301, 0.11940983359762158, 0.13738841097953924, 0.020000000000000018, 0.020000000000000018, 0.1345302923754912, 0.1619461654102642, 0.08783550338446733, 0.11487960063569302, 0.07049625457329567, 0.09885006862566481, 0.08949508278910823, 0.14747331455652357, 0.13817028898284522, 0.15475448018179316, 0.050155734202832924, 0.05058814268770395, 0.036353076968255515, 0.05214778186297442, 0.03759617105092561, 0.06422561408900629, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04968584271775622, 0.01848993528889087, 0.03759190824602754, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02185175603120204, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.091019727029224, 0.06646446275537488, 0.09698959726105738, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05655165621886271, 0.06452039514859398, 0.054049529650307626, 0.1453686679554328, 0.11612222336466227, 0.10385488210240168, 0.07862495240153355, 0.04497780766302484, 0.059257635428371036, 0.10588257378930688, 0.09217025456984074, 0.09992269809562615, 0.09212689765779658, 0.010000000000000009, 0.012563850739135796, 0.04255095075055171, 0.03621541593711752, 0.05178436432080946, 0.02705976411173605, 0.03408287019206979, 0.026198627406329833, 0.13389925349134346, 0.1550944929878254, 0.14478456703113673, 0.010000000000000009, 0.010000000000000009, 0.011430900791652876, 0.0064862904796322285, 0.0, 0.007042901294054826, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005731897491103699, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03951514833408032, 0.040350237920819265, 0.03170537864638534, 0.0, 0.0, 0.0, 0.03874167488302105, 0.04603100126782156, 0.04085712339436298, 0.08650903645115537, 0.08562923568676128, 0.08335468114528477, 0.03017904165652252, 0.03243019525648505, 0.026728940030333437, 0.08751291189499544, 0.07928023229898462, 0.06769077530318268, 0.0, 0.0, 0.0, 0.012991237590838312, 0.0103611294914977, 0.01265752213848248, 0.008077204725396858, 0.01140405012378265, 0.01100248757121236, 0.11925191048306061, 0.1304161139054778, 0.11613117115737193, 0.0, 0.0, 0.0]}}
{"id": "ef4e429b-30f7-4ea4-bfe5-264cc1733f32", "fitness": 0.038258282843214114, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Enhanced chaotic factor initialization to improve convergence performance.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.uniform(0.4, 0.6, self.population_size)  # Changed initialization\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 20, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03826 with standard deviation 0.04522.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11774701884673078, 0.1106161179784505, 0.15821278195939836, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.046110400435314, 0.026390430048759295, 0.024932256343770387, 0.0239487017837251, 0.020000000000000018, 0.020000000000000018, 0.0725556030548481, 0.04922716013370487, 0.05127516442365998, 0.08314265153129807, 0.020000000000000018, 0.020000000000000018, 0.06505657219997663, 0.1097098780557968, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.041224194606036546, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1327613606559236, 0.12558681653045878, 0.15731037643348178, 0.02360097292156771, 0.028338781197051577, 0.020000000000000018, 0.09901936054723193, 0.0863116411064907, 0.0731409129852042, 0.14605976227907136, 0.1682444476139352, 0.13413539411608388, 0.07919093269157396, 0.0806492768138003, 0.0859632581309866, 0.1326084834923671, 0.12552929282779157, 0.15866906596740504, 0.020000000000000018, 0.02933227331001087, 0.052522550717608474, 0.16626216269681005, 0.11144947627515367, 0.10426918933286333, 0.06639212033231179, 0.12870250994278054, 0.09937340354334023, 0.1438526290318487, 0.15392318574275077, 0.15475448018179316, 0.05593825988553425, 0.0397359362179972, 0.040980911831568934, 0.03406950790154839, 0.02481587139478436, 0.04250780353248729, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029818678523465092, 0.017319291041023477, 0.020624052978835627, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01058926266503013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0777082255243734, 0.05513955273641391, 0.07835391313289353, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06547103753073069, 0.06791598114600628, 0.06001446356652618, 0.1288582816427275, 0.09398361715168446, 0.10281775224528589, 0.0676854819974636, 0.042340350609161304, 0.053950919205646986, 0.0840132576035384, 0.0753999074948305, 0.08942440895055215, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031167370800922245, 0.04065142715667169, 0.028894576237534775, 0.025022049254059486, 0.023457121394627745, 0.02516503261952796, 0.14368172893500175, 0.14294363985460445, 0.14235712844938997, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0006152788422301159, 0.0, 0.0002139989968784617, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0024261555425465486, 3.563833273856343e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.032344983946950845, 0.030719985469667588, 0.026716666255872656, 0.0, 0.0, 0.0, 0.031044064435059915, 0.039138608377898954, 0.0321468656975985, 0.0858657432402995, 0.08228557452316065, 0.07341036771685139, 0.021825123511933997, 0.028975367407366392, 0.023445458720237844, 0.07479403022498576, 0.0701080545029672, 0.05197532369581215, 0.0, 0.0, 0.0, 0.010208096306332126, 0.00887812605525018, 0.01016035170626528, 0.00831670921826455, 0.010054873627102667, 0.008782256721991955, 0.11914016486533252, 0.1304161139054778, 0.11702729849019722, 0.0, 0.0, 0.0]}}
{"id": "9faecd0b-44a6-4918-addb-b7a5a8420565", "fitness": -Infinity, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "An enhanced adaptive chaotic swarm optimizer that incorporates Levy flight and adaptive convergence threshold to improve exploration and exploitative balancing.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / abs(v)**(1 / beta)\n        return 0.01 * step * (L - self.positions)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_jump = self.levy_flight(self.global_best_position)\n                self.velocities[i] = inertia + cognitive + social + levy_jump\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 21, "feedback": "An exception occurred: ValueError('could not broadcast input array from shape (20,5) into shape (5,)').", "error": "ValueError('could not broadcast input array from shape (20,5) into shape (5,)')", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {}}
{"id": "f7ffe996-ebe8-4a96-89df-32ec4a72e4ca", "fitness": -Infinity, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "An enhanced adaptive chaotic swarm optimizer that implements multi-chaotic systems and dynamic population resizing for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        return 4.0 * x * (1 - x)\n\n    def tent_map(self, x):\n        return 2 * x if x < 0.5 else 2 * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.initial_population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.initial_population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            population_size = max(4, int(self.initial_population_size * (1 - diversity)))\n            self.positions = self.positions[:population_size]\n            self.velocities = self.velocities[:population_size]\n            self.personal_best_positions = self.personal_best_positions[:population_size]\n            self.personal_best_scores = self.personal_best_scores[:population_size]\n            chaotic_factor = chaotic_factor[:population_size]\n\n            for i in range(population_size):\n                if evaluations % 2 == 0:\n                    chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                else:\n                    chaotic_factor[i] = self.tent_map(chaotic_factor[i])\n                    \n                inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = inertia_weight * self.velocities[i]\n                cognitive = 1.5 * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = 1.5 * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 22, "feedback": "An exception occurred: IndexError('index 4 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 4 is out of bounds for axis 0 with size 4')", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {}}
{"id": "02e4fa88-35dc-4a4d-86d2-92637ecf5855", "fitness": -Infinity, "name": "ImprovedAdaptiveChaoticSwarmOptimizer", "description": "Improved adaptive chaotic swarm optimizer incorporating a rank-based velocity update mechanism and a mutation strategy to enhance exploration and convergence.", "code": "import numpy as np\n\nclass ImprovedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def rank_based_update(self, i, rank):\n        rank_factor = (self.population_size - rank) / self.population_size\n        new_position = self.positions[i] + rank_factor * (self.global_best_position - self.positions[i])\n        return np.clip(new_position, self.lower_bound, self.upper_bound)\n\n    def apply_mutation(self, position):\n        mutation_probability = 0.1\n        if np.random.rand() < mutation_probability:\n            mutation = np.random.uniform(-0.1, 0.1, self.dim)\n            position += mutation\n        return np.clip(position, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            scores = []\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                scores.append((score, i))\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            scores.sort()\n            for rank, (score, i) in enumerate(scores):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] = self.rank_based_update(i, rank)\n                self.positions[i] = self.apply_mutation(self.positions[i])\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 23, "feedback": "An exception occurred: AttributeError(\"'ImprovedAdaptiveChaoticSwarmOptimizer' object has no attribute 'cognitive_coefficient'\").", "error": "AttributeError(\"'ImprovedAdaptiveChaoticSwarmOptimizer' object has no attribute 'cognitive_coefficient'\")", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {}}
{"id": "43be6119-6506-427d-bf6b-314d6beb2a8c", "fitness": 0.03758345320969883, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Enhanced chaotic swarm optimizer by introducing adaptive velocity scaling to improve convergence speed without compromising exploration.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = (inertia + cognitive + social) * (1 + adaptive_factor)  # Modified line\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 24, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03758 with standard deviation 0.04374.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11751791002997192, 0.08454413736531763, 0.14442004950260257, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04690458970662714, 0.02068744669643252, 0.022702653532553074, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09242794619829198, 0.08992077637962947, 0.05964976738139727, 0.02794181021404385, 0.03339087428483567, 0.020000000000000018, 0.03782832826157889, 0.08594148016760361, 0.07651871506468011, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13089569950890478, 0.08948557080337338, 0.1745800066048142, 0.03423799389599025, 0.02838285409366692, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.091980389981133, 0.13816750918130027, 0.13323277534341382, 0.14932166669058744, 0.07872385846256014, 0.07990382579724953, 0.07754430746755947, 0.1176243878086839, 0.09511115993897024, 0.13768886136172698, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1681873032186616, 0.08191516716654745, 0.11151594548630195, 0.06889955640369128, 0.1392455832671894, 0.0719317821394827, 0.1438526290318487, 0.13934365508978108, 0.15475448018179316, 0.049512254974273584, 0.036398373832369546, 0.030757675085618774, 0.0412380905423011, 0.03178799217373851, 0.05758370300818938, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0680471109459535, 0.031964994975696714, 0.05707017561483696, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08304535192992146, 0.06397595571152825, 0.0921732023192603, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.056670486970557765, 0.06147825531143891, 0.05432970339597332, 0.12175082597680276, 0.09974075850833086, 0.10440974098093248, 0.07732337744012918, 0.03644403487247472, 0.05739352122192598, 0.11060707454696528, 0.07865972187344739, 0.08808362825722371, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02641375067979579, 0.030879602639922066, 0.029322511846810895, 0.027359353398836106, 0.02370408665557744, 0.024971079389849993, 0.1340940414031886, 0.15891499306934576, 0.1388230119130428, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.000381324634209923, 0.001283709312822623, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0004814772488151986, 0.005537243959183091, 0.0010043655808089635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0362289255004673, 0.04150260937506045, 0.03068003970835509, 0.0, 0.0, 0.0, 0.03300539377616074, 0.03813944493736032, 0.03965883403035353, 0.08306535199101972, 0.08201624919187933, 0.07861218294994932, 0.0264503334706242, 0.027146387704296893, 0.023044186457351068, 0.07630634842057915, 0.07108246135642093, 0.05928829793631929, 0.0, 0.0, 0.0, 0.010203073569661658, 0.009557253258017817, 0.011011046873395602, 0.007628219076717624, 0.010084124440072229, 0.010571552186131039, 0.13021689643010803, 0.1304161139054778, 0.11453196114649988, 0.0, 0.0, 0.0]}}
{"id": "ef753a9c-f3b6-4358-8037-f264a2f30dfe", "fitness": 0.038051506850667854, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "A refined adaptive chaotic swarm optimizer using non-linear inertia weight decay and elite learning to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def non_linear_inertia_weight_decay(self, chaotic_factor):\n        return self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor**2\n\n    def elite_learning_strategy(self, elite_position, position, chaotic_factor):\n        return chaotic_factor * (elite_position - position)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n            \n            elite_index = np.argmin(self.personal_best_scores)\n            elite_position = self.personal_best_positions[elite_index]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.non_linear_inertia_weight_decay(chaotic_factor[i])\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                elite_learning = self.elite_learning_strategy(elite_position, self.positions[i], chaotic_factor[i])\n                \n                self.velocities[i] = inertia + cognitive + social + elite_learning\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03805 with standard deviation 0.04390.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.12315745591257665, 0.08746461267203098, 0.14532821687996533, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04143101915337499, 0.0248095873020876, 0.02045515697424638, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08281473194056088, 0.07334577294353806, 0.05979078927096526, 0.029053429595945257, 0.025412314777533695, 0.020000000000000018, 0.035502876486523616, 0.08594148016760361, 0.08463418674455225, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12733801174101667, 0.10908635171913805, 0.18109490449037025, 0.03615162484731815, 0.020372975725066467, 0.028411341615842467, 0.08491276293889027, 0.08810947467972907, 0.11288452895241619, 0.13820835985839397, 0.17338544556817792, 0.14040799645197932, 0.08084130808470091, 0.07990382579724953, 0.08584781375500361, 0.14170052198989735, 0.104766599448334, 0.13044213552349015, 0.020000000000000018, 0.020000000000000018, 0.04409765548810296, 0.16057677220241084, 0.09800141887476688, 0.094236196692146, 0.08474000027496176, 0.07234328428870729, 0.09394559320942908, 0.16040323513455035, 0.13589170657517036, 0.15475448018179316, 0.05832873347228029, 0.03392426887360889, 0.030767689107638496, 0.05017886003950667, 0.035326690383945425, 0.047023616075792196, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0687289996742938, 0.03159369325801664, 0.02614227684423409, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012652319112707477, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08304704111750416, 0.06751330213409956, 0.0831443084068395, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05897169571546823, 0.06469452286311683, 0.05402472010917403, 0.12528221607247925, 0.10854976333217436, 0.10344471649293308, 0.06625673247856678, 0.03904534776637103, 0.053936809511723194, 0.09729262544073625, 0.0847443425922012, 0.09325716982926846, 0.04540191674123051, 0.010000000000000009, 0.010000000000000009, 0.026364139618464733, 0.034371774746836614, 0.02789978590970421, 0.030203120076561008, 0.0235233933910024, 0.025242525719053388, 0.13174221672157604, 0.13123409970527322, 0.13642128590938896, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004124366981375305, 0.0021259007466868374, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00023213509179409453, 0.005194666759901989, 0.007856999838746881, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03734201900582479, 0.04014832990641726, 0.032536505210580824, 0.0, 0.0, 0.0, 0.03387873268566599, 0.03883064486446519, 0.03729470485202557, 0.08721379201591817, 0.08432471242772377, 0.07785472077068112, 0.02975170682811734, 0.031627038838522914, 0.021179027589781074, 0.07964821592932614, 0.08176851472578006, 0.05757858173905417, 0.0, 0.0, 0.0, 0.01006300998681231, 0.010205745665182064, 0.01114915380072301, 0.007780846964360655, 0.010120662107801048, 0.009394018860105158, 0.1147991454160514, 0.1304161139054778, 0.11241079005502486, 0.0, 0.0, 0.0]}}
{"id": "d159fc70-08d5-4190-b588-a0f56206eaca", "fitness": 0.038258282843214114, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Enhanced chaotic factor initialization for improved convergence in swarm optimization.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.uniform(0.4, 0.6, self.population_size)  # Changed initialization of chaotic_factor\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 26, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03826 with standard deviation 0.04522.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11774701884673078, 0.1106161179784505, 0.15821278195939836, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.046110400435314, 0.026390430048759295, 0.024932256343770387, 0.0239487017837251, 0.020000000000000018, 0.020000000000000018, 0.0725556030548481, 0.04922716013370487, 0.05127516442365998, 0.08314265153129807, 0.020000000000000018, 0.020000000000000018, 0.06505657219997663, 0.1097098780557968, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.041224194606036546, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1327613606559236, 0.12558681653045878, 0.15731037643348178, 0.02360097292156771, 0.028338781197051577, 0.020000000000000018, 0.09901936054723193, 0.0863116411064907, 0.0731409129852042, 0.14605976227907136, 0.1682444476139352, 0.13413539411608388, 0.07919093269157396, 0.0806492768138003, 0.0859632581309866, 0.1326084834923671, 0.12552929282779157, 0.15866906596740504, 0.020000000000000018, 0.02933227331001087, 0.052522550717608474, 0.16626216269681005, 0.11144947627515367, 0.10426918933286333, 0.06639212033231179, 0.12870250994278054, 0.09937340354334023, 0.1438526290318487, 0.15392318574275077, 0.15475448018179316, 0.05593825988553425, 0.0397359362179972, 0.040980911831568934, 0.03406950790154839, 0.02481587139478436, 0.04250780353248729, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.029818678523465092, 0.017319291041023477, 0.020624052978835627, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01058926266503013, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0777082255243734, 0.05513955273641391, 0.07835391313289353, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06547103753073069, 0.06791598114600628, 0.06001446356652618, 0.1288582816427275, 0.09398361715168446, 0.10281775224528589, 0.0676854819974636, 0.042340350609161304, 0.053950919205646986, 0.0840132576035384, 0.0753999074948305, 0.08942440895055215, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031167370800922245, 0.04065142715667169, 0.028894576237534775, 0.025022049254059486, 0.023457121394627745, 0.02516503261952796, 0.14368172893500175, 0.14294363985460445, 0.14235712844938997, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0006152788422301159, 0.0, 0.0002139989968784617, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0024261555425465486, 3.563833273856343e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.032344983946950845, 0.030719985469667588, 0.026716666255872656, 0.0, 0.0, 0.0, 0.031044064435059915, 0.039138608377898954, 0.0321468656975985, 0.0858657432402995, 0.08228557452316065, 0.07341036771685139, 0.021825123511933997, 0.028975367407366392, 0.023445458720237844, 0.07479403022498576, 0.0701080545029672, 0.05197532369581215, 0.0, 0.0, 0.0, 0.010208096306332126, 0.00887812605525018, 0.01016035170626528, 0.00831670921826455, 0.010054873627102667, 0.008782256721991955, 0.11914016486533252, 0.1304161139054778, 0.11702729849019722, 0.0, 0.0, 0.0]}}
{"id": "0775846b-5b16-41bf-835f-3c92622debc0", "fitness": -0.027551680682112178, "name": "RefinedChaoticSwarmOptimizer", "description": "A chaotic swarm optimizer enhanced with adaptive learning rates and opposition-based learning to improve exploration and convergence.", "code": "import numpy as np\n\nclass RefinedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n    \n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / (self.dim + 1e-9)\n            cognitive_coefficient = 1.0 + adaptive_factor\n            social_coefficient = 2.0 - adaptive_factor\n            learning_rate = 0.5 * (1.0 + chaotic_factor)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += learning_rate[i] * self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n                \n                # Opposition-based learning\n                opposition_positions = self.opposition_based_learning(self.positions[i])\n                opposition_score = func(opposition_positions)\n                evaluations += 1\n                if opposition_score < score:\n                    self.positions[i] = opposition_positions\n                    if opposition_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = opposition_score\n                        self.personal_best_positions[i] = opposition_positions\n                    if opposition_score < self.global_best_score:\n                        self.global_best_score = opposition_score\n                        self.global_best_position = opposition_positions\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 27, "feedback": "The algorithm RefinedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02755 with standard deviation 0.11531.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.12859181173049972, 0.17514311759708567, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02291941086838445, 0.020000000000000018, 0.020000000000000018, 0.0332586523701599, 0.02073185965305302, 0.020000000000000018, 0.051666463446072064, 0.04104277342486273, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04357060495805487, 0.08594148016760361, 0.07176623627902845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13708218638707503, 0.1207749189671844, 0.14506558023280858, 0.03539648546481089, 0.03371436410346762, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.1066601040596652, 0.13887067487772076, 0.13595959423995763, 0.13969951640979783, 0.06080619899773476, 0.07990382579724953, 0.08196931432009502, 0.14336911788275641, 0.13403302645197668, 0.13242789396263333, 0.10473331167227184, 0.020000000000000018, 0.10302948315996485, 0.11626704765180651, 0.0911997699107705, 0.09902953257650038, 0.06527120746322768, 0.05970377650830594, 0.08214136882506551, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.04506034651489843, 0.057165557467726114, 0.03537718521277866, 0.05796060804131997, 0.047712083137254835, 0.057278842008517517, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012608826753838231, 0.010835919026735641, 0.011508818493136452, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010265828905549945, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07807328451011675, 0.0592802519740494, 0.07592108830158195, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05624295917106026, 0.06160452506730962, 0.06659543437539173, 0.12435417467213772, 0.09409818384460567, 0.10626099180266035, 0.0638259776322333, 0.042137811529708635, 0.05403230148210614, 0.10879792914824549, 0.11089946124535399, 0.11539075772831842, 0.035264493560560606, 0.010000000000000009, 0.010000000000000009, 0.026759993049566444, 0.029140645261493847, 0.04264416531710169, 0.02596823613053223, 0.02657063298135942, 0.02572453318487178, 0.1319112040724686, 0.1386488196176755, 0.13410752911491708, 0.010000000000000009, 0.010000000000000009, 0.010968204887787159, -0.193979321051728, -0.197950130243433, -0.19731833592197567, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1509696882923779, -0.14476817870999992, -0.14550368366440813, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15536127340798722, -0.15235964669354574, -0.16112693113043797, -0.09374539622733802, -0.09037261165205468, -0.09687596071618576, -0.17118299844191287, -0.16054081398907405, -0.16767346355324975, -0.09315522889952343, -0.09706192979820383, -0.0993560531225619, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18816295383770543, -0.18809741682501557, -0.18555949720459286, -0.18994813832782276, -0.18768600717441242, -0.1904680722986658, -0.0559625193021569, -0.043207726894507026, -0.06914377246338255, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "2a16583e-fe3d-4401-a743-8194679cf937", "fitness": 0.040448122562359405, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Enhanced Adaptive Chaotic Swarm Optimizer by fine-tuning the inertia weight range for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.5  # Modified from 0.4 to 0.5\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 28, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04045 with standard deviation 0.04606.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11881232269219766, 0.11070345781087143, 0.1652621972645636, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03328205597529166, 0.025911580782708832, 0.028911542849250793, 0.020000000000000018, 0.020013447197795853, 0.020000000000000018, 0.07657299029663223, 0.050042140409093716, 0.05133051016298562, 0.10342338506683091, 0.03317740718954154, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04322702649021548, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1330175159859951, 0.12989608374392025, 0.1835024615983335, 0.026954032062898814, 0.039944681918112845, 0.029668655746160844, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.16131412122331623, 0.1571845965523022, 0.14669696992626957, 0.09846453738084038, 0.07990382579724953, 0.0795310482203998, 0.11913329315517873, 0.11235364140748261, 0.1361479803416521, 0.020000000000000018, 0.1098943117947343, 0.12458105126910912, 0.17160727235512718, 0.0916008330169984, 0.11073100442830508, 0.07014432518337488, 0.0883809265883454, 0.10049093051894886, 0.1461196341302713, 0.16309347590431134, 0.15475448018179316, 0.04936394245194353, 0.04383075194029884, 0.03274172880253934, 0.05332882394172589, 0.03519916620605956, 0.06293639977945087, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04946773611387345, 0.01778660011012856, 0.03813367773132881, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020571222028526348, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08938907954175912, 0.0640465967236793, 0.09376470831209371, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.08518595547198016, 0.06680544802898292, 0.13588307709112923, 0.10921810936171539, 0.10289109983626332, 0.07272127862300293, 0.04775362208871259, 0.06007228700586309, 0.09588399659826063, 0.08905590917701023, 0.09905200309191908, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.040620242723176325, 0.033001181653194656, 0.047983321006718094, 0.033108272083493206, 0.033175489258083224, 0.024928130249930458, 0.13141309820135194, 0.13371249008010688, 0.13822846608725792, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00566427261698732, 0.0, 0.006354592850491669, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005215681014131501, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038432202334614085, 0.039284062375779194, 0.030305855963443817, 0.0, 0.0, 0.0, 0.04277656355140147, 0.045691754417867214, 0.037739036212877886, 0.08735517499524359, 0.08694593264060502, 0.07733850008114662, 0.02449738946787461, 0.031860328487398726, 0.02252281697991676, 0.0802671701574813, 0.07957501615227502, 0.06448740000023234, 0.0, 0.0, 0.0, 0.012935587101966073, 0.010194333229636254, 0.011976717095465106, 0.008614076379442559, 0.010832941315607303, 0.011044834626090516, 0.1143960046378879, 0.13264210831369394, 0.11781584975313608, 0.0, 0.0, 0.0]}}
{"id": "09b627e5-677c-48ee-8d35-ba54c7254d90", "fitness": 0.03789596493567489, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Introduced adaptive velocity scaling using swarm diversity to enhance convergence and precision.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i] * (1 + adaptive_factor)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 29, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03790 with standard deviation 0.04389.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11751791002997192, 0.09127939429883891, 0.14442004950260257, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04690458970662714, 0.02068744669643252, 0.022702653532553074, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08878315905740664, 0.07649811669575246, 0.05959649416065871, 0.02794181021404385, 0.03339087428483567, 0.020000000000000018, 0.04377505545410709, 0.08594148016760361, 0.07651871506468011, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.126522103416693, 0.10301419345582064, 0.1745800066048142, 0.03423799389599025, 0.02838285409366692, 0.023596219355707992, 0.08719357601805877, 0.0863116411064907, 0.09901183377363665, 0.13991648155177727, 0.13323277534341382, 0.14932166669058744, 0.07660262469449097, 0.07990382579724953, 0.07754430746755947, 0.1385783024861592, 0.10275604343905942, 0.13768886136172698, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1681873032186616, 0.08191516716654745, 0.11151594548630195, 0.07439000434587628, 0.1392455832671894, 0.0719317821394827, 0.1456288394218166, 0.13934365508978108, 0.15475448018179316, 0.049512254974273584, 0.036398373832369546, 0.02657375009670604, 0.04410180742930281, 0.03304529170069004, 0.062011756441985866, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061916481516221866, 0.030782924192303218, 0.05616001655960934, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08464181280875704, 0.0683211840108191, 0.07884949926337581, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.061935957401528685, 0.06147825531143891, 0.05790123323414986, 0.12313889294751246, 0.101691591945131, 0.10512091351379271, 0.07064896970028967, 0.043122589993559335, 0.05426716334427095, 0.11060707454696528, 0.07865972187344739, 0.09458169357545787, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026373150660514044, 0.03393022471549334, 0.03061268707376885, 0.02774626669883129, 0.023912221010822243, 0.02577981588795919, 0.13390659176567699, 0.145861243385217, 0.13901120266790412, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.000381324634209923, 0.001283709312822623, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005650076742502841, 0.0016235992335649208, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03820532195506321, 0.04150260937506045, 0.03348672980483569, 0.0, 0.0, 0.0, 0.036569818257732534, 0.03813944493736032, 0.04061369574942153, 0.08365979884112718, 0.08226140356952671, 0.08097761128628012, 0.02788502854802255, 0.029173663102459835, 0.025309240772956265, 0.07630634842057915, 0.07133675264791262, 0.05928829793631929, 0.0, 0.0, 0.0, 0.010550760986861585, 0.009557253258017817, 0.01105966048756779, 0.007640287206135632, 0.01054621877398032, 0.01057285829717769, 0.1290064743056708, 0.1304161139054778, 0.10865588994051423, 0.0, 0.0, 0.0]}}
{"id": "50ca4aae-d2a9-4b3e-be1e-0b96d3baa9b0", "fitness": 0.04084063062189472, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Enhanced adaptive chaotic swarm optimizer by refining the cognitive coefficient update mechanism for better convergence.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + 0.5 * adaptive_factor  # Change made here\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 30, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04084 with standard deviation 0.04663.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11658013394195355, 0.11070433910061583, 0.16553230440507416, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029725642673662955, 0.025713855901100313, 0.028310745864121745, 0.020000000000000018, 0.020063589712732477, 0.020000000000000018, 0.07599630699025117, 0.0489976392595759, 0.051203124643527054, 0.10339639888195762, 0.03239311658678734, 0.020000000000000018, 0.06342257419693997, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027365025645070817, 0.020000000000000018, 0.043185983919733384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1349696507821737, 0.13076840035396453, 0.183150013732989, 0.026906296941451413, 0.031496402578967686, 0.037528046509002766, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.1627187236898101, 0.15762104625585782, 0.1399538727480164, 0.08544507142843694, 0.07990382579724953, 0.07953094709372321, 0.16689912437587995, 0.11618982659882537, 0.14535887516573387, 0.020000000000000018, 0.10920405913436293, 0.12616854897734353, 0.16965402358665527, 0.10641585374467, 0.10990364094562888, 0.06857706995653867, 0.08634625945524532, 0.10054245305042953, 0.15366869050555865, 0.1430240829426731, 0.15475448018179316, 0.04839486587644681, 0.040433452319290075, 0.031144886268193228, 0.05209568864877878, 0.03505969226432559, 0.06324264712504901, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.048434283117634425, 0.01708719878227427, 0.038182443532360555, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020571222028526348, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0890360491290052, 0.06476316201200272, 0.09143062806485136, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05793358870811682, 0.08802384992455037, 0.06970764997709855, 0.1322738938937904, 0.11326725367006563, 0.10345239274606444, 0.07392536279771533, 0.0505850381256745, 0.054055660956574325, 0.10114197007840997, 0.08509127006048545, 0.11116935641674397, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041930971572320064, 0.0337609351536976, 0.04828662665799344, 0.03388524129650039, 0.03320151186376952, 0.02471000476638674, 0.13637853532474364, 0.14109616156513727, 0.13438001859401705, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005765440512429887, 0.0, 0.007054495573385, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004876379002513032, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03852681535497249, 0.03949982888992498, 0.030527628696613962, 0.0, 0.0, 0.0, 0.04245104108310971, 0.04735202966067309, 0.040752024659428954, 0.08827451279974796, 0.08766428325682152, 0.07897851954397506, 0.028340045300133343, 0.035253038548732185, 0.027539637705877307, 0.07779264903284355, 0.08043157682621238, 0.0682757966341262, 0.0, 0.0, 0.0, 0.012794490380470425, 0.010160222190639168, 0.01188884511182886, 0.008614147024273433, 0.010860136093378214, 0.011070094866682756, 0.12165987256037458, 0.1304161139054778, 0.11239918352533418, 0.0, 0.0, 0.0]}}
{"id": "169680a8-b6db-4b58-a5ca-a066d67fdd28", "fitness": 0.03864549615564426, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhanced Adaptive Chaotic Swarm Optimizer utilizing Levy Flights for improved exploration and adaptive chaotic inertia for better convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            conscious_increment = np.random.rand(self.population_size) < 0.1\n            \n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                if conscious_increment[i]:\n                    levy_step = self.levy_flight(self.dim)\n                    self.positions[i] += levy_step * (self.positions[i] - self.global_best_position)\n                \n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = adaptive_factor * (self.personal_best_positions[i] - self.positions[i])\n                social = (2.0 - adaptive_factor) * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03865 with standard deviation 0.04607.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.1301821007986388, 0.11062177605786716, 0.1580142208716936, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03491897319330062, 0.029834187125893363, 0.026950688177113546, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0767698695058826, 0.06853320470391477, 0.05045956923488859, 0.07984435669476109, 0.020000000000000018, 0.020000000000000018, 0.06621335542491835, 0.1114498165297394, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04118266383200986, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14599603033380948, 0.14135483277162664, 0.17382580598412756, 0.03389244608254616, 0.028930162741236942, 0.020617608704061374, 0.09706269956339386, 0.0863116411064907, 0.07607195849530302, 0.14858258967177818, 0.16559697827483932, 0.13188529909366054, 0.08736889230970424, 0.08104362264070142, 0.08776253606620543, 0.13402526449985575, 0.12596852313958862, 0.15532693994766678, 0.020000000000000018, 0.029349990707956408, 0.036136063401985385, 0.1988060805273243, 0.10936844725501826, 0.09157488113008028, 0.06527120746322768, 0.08908729408808314, 0.09941939683749756, 0.14536441763320884, 0.1481132911537617, 0.16129412217185157, 0.0471332060565669, 0.04884918889198986, 0.029160270061260984, 0.026673436779179105, 0.01975696983273778, 0.04829017193056884, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04977191511734924, 0.013460150617197297, 0.04746597976814415, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0860749373569355, 0.06195283151480224, 0.09068186223178498, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06530753102801867, 0.06760685839368596, 0.05395939349942802, 0.12387340982420159, 0.09756675071791943, 0.103594182727893, 0.06487468576371891, 0.04466176958003454, 0.05476906174813767, 0.08630521101278854, 0.07311390884082358, 0.09316500316227294, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027954369050403383, 0.03064697919214443, 0.030138403335362884, 0.026026518737377824, 0.022621028169306445, 0.025014591865557878, 0.14934236348828944, 0.14694765544095278, 0.13764478992026963, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006987316770131757, 0.005860676349888738, 0.000114030491275674, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02922750408456376, 0.03199832035434225, 0.023293398373646523, 0.0, 0.0, 0.0, 0.032680163079743196, 0.04200922226553705, 0.0343098643579256, 0.08778679026430924, 0.08028835307549509, 0.0747507828354026, 0.02232426365033391, 0.025888403985405595, 0.02202425317572776, 0.0726723602181667, 0.05894294016492463, 0.05062052808543516, 0.0, 0.0, 0.0, 0.009803663200448898, 0.009080305478473272, 0.009866891633661945, 0.008461492438810891, 0.010179442421091922, 0.009214390773798486, 0.12266356657870658, 0.1304161139054778, 0.10937497623675796, 0.0, 0.0, 0.0]}}
{"id": "eb68c02c-4ddc-4c42-8e35-29b725e7e104", "fitness": 0.04021972639689908, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Enhanced inertia weight dynamics to improve convergence speed.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i] * np.sin(adaptive_factor * np.pi)\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 32, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04022 with standard deviation 0.04565.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.1114599162113794, 0.12390796063873066, 0.16300483249438258, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.032740871078073, 0.024600087985282126, 0.028342627572422452, 0.021828176206789784, 0.020000000000000018, 0.020000000000000018, 0.07163775617743795, 0.04568418189953438, 0.051192384192777385, 0.0708512889312215, 0.036558802862962425, 0.020000000000000018, 0.05530284980824629, 0.13752181961818655, 0.10850411953409145, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14900531377096116, 0.118003958061621, 0.17790172967007378, 0.030913639547140104, 0.03361000439206874, 0.028254829371717527, 0.08313437680611313, 0.10883555284174651, 0.09330166600727263, 0.13715516373291092, 0.1509749851465948, 0.12863921798409816, 0.09483260156644646, 0.07990382579724953, 0.0911933864219644, 0.1300448724409603, 0.14167921894617985, 0.1373470663560452, 0.020000000000000018, 0.10382446361511011, 0.12419277063454615, 0.12615312547615443, 0.09282934241912699, 0.10234045662985514, 0.08082438556046723, 0.07123690800642668, 0.057055361074780486, 0.1650293414738535, 0.13994043829732727, 0.15475448018179316, 0.0619506647971142, 0.04051524553181951, 0.034881162107646135, 0.05183477037815609, 0.03379682622269342, 0.061954044253439755, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04582234031019505, 0.016545656365210548, 0.035474559622443835, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01791636225543447, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08902612957615963, 0.06377866130626553, 0.08177820002704506, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.062159537697516254, 0.07508906397207038, 0.062201151842608327, 0.13063770019329723, 0.10551420881922413, 0.10365640974123536, 0.07030252803910375, 0.038480631969127654, 0.05585343922749175, 0.10437538120473489, 0.09576209362372157, 0.10065971801984508, 0.028282446968104558, 0.010000000000000009, 0.010000000000000009, 0.04288380830101357, 0.03678075826584659, 0.04533008575245878, 0.02666636582227211, 0.032840849198503386, 0.0261424491771729, 0.13675295842005997, 0.1369854886879831, 0.1450028936823451, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.006225228013122308, 0.0, 0.007195838268370225, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0035890285297626168, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038653395262066015, 0.039640709558783405, 0.03034890693732395, 0.0, 0.0, 0.0, 0.04340291084149228, 0.04653635721528271, 0.03951621775045422, 0.08867137492259158, 0.08853817895260718, 0.07999698883013961, 0.026887927153474434, 0.035035536779519316, 0.02850822977185785, 0.08391091179816401, 0.08177464592959216, 0.07112460276848975, 0.0, 0.0, 0.0, 0.012727310008784909, 0.010159319081954221, 0.012026761725973945, 0.008703674841939901, 0.010886564434640644, 0.010828444141945393, 0.12589515169342447, 0.1304161139054778, 0.11257582379148279, 0.0, 0.0, 0.0]}}
{"id": "b0d85cf1-77f6-4e45-a193-1ebf1da19cff", "fitness": 0.03957171658033657, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhanced Adaptive Chaotic Swarm Optimizer utilizing chaos-enhanced exploration and a dynamic adaptive inertia weight for improved convergence and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.chaotic_map_choice = np.random.choice(['logistic', 'sine'])\n\n    def logistic_map(self, x):\n        return 4.0 * x * (1 - x)\n\n    def sine_map(self, x):\n        return np.sin(np.pi * x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def chaotic_update(self, x):\n        if self.chaotic_map_choice == 'logistic':\n            return self.logistic_map(x)\n        elif self.chaotic_map_choice == 'sine':\n            return self.sine_map(x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            cognitive_coefficient = 1.5 + adaptive_factor\n            social_coefficient = 1.5 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.chaotic_update(chaotic_factor[i])\n                inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = inertia_weight * self.velocities[i]\n                cognitive = cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03957 with standard deviation 0.04512.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.1512319065644493, 0.10016691337662431, 0.17458554030310014, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03857915204944817, 0.02177248695353229, 0.026132207244876304, 0.030136941053698685, 0.024704517598281073, 0.020000000000000018, 0.05865584293585813, 0.04131079419090411, 0.04956030618232932, 0.020000000000000018, 0.032746028470574506, 0.020000000000000018, 0.028791204816945415, 0.08594148016760361, 0.09624793318174096, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1325914952651399, 0.1062365247275936, 0.16922796160529363, 0.029496311596376446, 0.020696743076665913, 0.026758234081348475, 0.08072694858327945, 0.0863116411064907, 0.09675427613964172, 0.15479166498883545, 0.13323277534341382, 0.12200464365955488, 0.0859335734225658, 0.07990382579724953, 0.06815963274515624, 0.12122113217078723, 0.12531434265950825, 0.12283399157033115, 0.10386679470447635, 0.020000000000000018, 0.11677675555477574, 0.16257710095914657, 0.09040452030524704, 0.0895133107273659, 0.07906695198570246, 0.06597506445010215, 0.0717560205793688, 0.15373743511308535, 0.14510851268790248, 0.16234551865788094, 0.041116348934921776, 0.04148907759229192, 0.042035220106177995, 0.053525704272958, 0.05059120089171376, 0.06256202932438815, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026461906013964143, 0.011679557417937136, 0.02257217110869958, 0.010000000000000009, 0.011178141436925526, 0.010000000000000009, 0.010105067829589753, 0.01415071467674578, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08672104057837449, 0.07646914171299446, 0.09229048353589608, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058426132648745854, 0.06147825531143891, 0.05395939349942802, 0.1243414254003875, 0.1110254972809398, 0.10895931256862657, 0.07276011949155314, 0.06975393920474626, 0.05686953318769494, 0.10379474344626471, 0.09064307233152857, 0.10556034352155219, 0.12161505400934813, 0.010000000000000009, 0.010000000000000009, 0.02714842182376853, 0.04498496324702117, 0.046961331587083155, 0.029165565699952323, 0.030121412809781756, 0.030374160739835343, 0.138170379591109, 0.13624335207750404, 0.13544979206542296, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010246425394944136, 0.002254091332377084, 0.009983913892958496, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 9.530980285266111e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04555076400006697, 0.044277976623634085, 0.03468889911272688, 0.0, 0.0, 0.0, 0.03994530293274279, 0.03783752062066992, 0.035320294228731064, 0.08877647444050452, 0.09537172895882617, 0.08336504333221806, 0.027048154545894265, 0.029745267059290925, 0.036105151621240616, 0.08697739086951728, 0.08316269321056635, 0.07268735178623242, 0.0, 0.0, 0.0, 0.012766930738497662, 0.011610530678769382, 0.013136111572934817, 0.008482679908437762, 0.010732749946983478, 0.010788033456191615, 0.1181778931487466, 0.13602658765045073, 0.11768854415412877, 0.0, 0.0, 0.0]}}
{"id": "a2d9fe42-6a7a-4ea8-93ea-0e89524c9258", "fitness": 0.04081973737300316, "name": "AdaptiveChaoticSwarmOptimizer", "description": "Enhanced Adaptive Chaotic Swarm Optimizer with time-varying coefficients and improved velocity update for better convergence.", "code": "import numpy as np\n\nclass AdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Random factor used\n                social = self.social_coefficient * np.random.rand() * (self.global_best_position - self.positions[i])  # Random factor used\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 34, "feedback": "The algorithm AdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04082 with standard deviation 0.04665.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.1530232138662907, 0.10696940190061155, 0.14922995952009332, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04552808674471043, 0.027661786476813832, 0.023840121185254914, 0.032406152544420475, 0.022837880498474905, 0.02280154762574027, 0.07470552155937549, 0.04967725606764073, 0.05043527099957634, 0.02701800276770261, 0.032794486790488686, 0.020000000000000018, 0.053662784910907924, 0.14314268200282632, 0.08721322287443545, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14822341024769514, 0.1408795608202149, 0.17673889442264334, 0.03610200568713262, 0.0344402194509692, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.0720688039285804, 0.16554966744945487, 0.147246444276955, 0.13027355892258752, 0.1083091405493356, 0.07990382579724953, 0.08608372046034574, 0.1478004301515603, 0.11830655451585359, 0.12191976134240401, 0.020000000000000018, 0.09998684217928289, 0.12194699355256011, 0.19048796785568411, 0.1059365164236632, 0.0895133107273659, 0.08709556063092261, 0.05716662148102758, 0.09459135121596318, 0.1438526290318487, 0.14296897919985796, 0.15475448018179316, 0.052575298158554884, 0.044767781189568034, 0.03716816939648426, 0.046755278517078946, 0.04966622089781325, 0.06441484457502411, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02664110163838218, 0.016054879799847876, 0.027043411892490266, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012972929253848409, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09317980716134389, 0.07205422335949763, 0.11004974241608645, 0.010000000000000009, 0.010000000000000009, 0.013215476553480432, 0.05817663870783729, 0.0641783988544552, 0.06305884157480601, 0.13734888015017943, 0.1091720050396674, 0.10283113167984281, 0.063990718964416, 0.04721983685332409, 0.06187816918759903, 0.09346511980268712, 0.09634239787397192, 0.10823819569819204, 0.10985422302766534, 0.010000000000000009, 0.010000000000000009, 0.027535523304282106, 0.04064645750521578, 0.04354249132911914, 0.03111677430992499, 0.030528110762442662, 0.026240599266037168, 0.13141309820135194, 0.13274248838267266, 0.14189691446420705, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01411569835472648, 0.0, 0.014261513544194027, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0033959773380568548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04370850012642291, 0.03865624453514627, 0.037248695348770955, 0.0, 0.0, 0.0, 0.039959547307946486, 0.03900576474947737, 0.033389350744164714, 0.08328013476276441, 0.09287153079351629, 0.0830943492439582, 0.027687884954439856, 0.03203068993703584, 0.03616065924217782, 0.08891768977029857, 0.07242951350810412, 0.08090056291752068, 0.0, 0.0, 0.0, 0.011738020224783874, 0.010213292845168365, 0.012822455236337182, 0.011090370434302721, 0.010474162606571413, 0.01086827746553043, 0.11591664164533055, 0.1322427464545045, 0.11047360019994545, 0.0, 0.0, 0.0]}}
{"id": "cb435294-e0b5-41f1-9b57-8b387c254147", "fitness": 0.04096853854802704, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "An enhanced adaptive chaotic swarm optimizer integrating LÃ©vy flight for improved exploration and faster convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                if np.random.rand() < 0.1:  # Add Levy flight with a small probability\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04097 with standard deviation 0.04714.", "error": "", "parent_ids": ["383056be-6656-4dca-a883-184e3ee9e06b"], "operator": null, "metadata": {"aucs": [0.11943663765709034, 0.11070433910061583, 0.16553230440507416, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0274676830572379, 0.025713855901100313, 0.028310745864121745, 0.020000000000000018, 0.020063589712732477, 0.020000000000000018, 0.07602821720414654, 0.04899762667387397, 0.05119631361065091, 0.10339639888195762, 0.032384415202552974, 0.020000000000000018, 0.06342257419693997, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027393505805070273, 0.020000000000000018, 0.043185983919733384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13496974265821993, 0.13076614962909727, 0.183150013732989, 0.026906296941451413, 0.031496402578967686, 0.03752959792352839, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.17730853733425567, 0.15762104625585782, 0.1399538727480164, 0.08541899802427011, 0.07990382579724953, 0.07953094709372321, 0.16689912437587995, 0.11618982659882537, 0.14679913735526273, 0.020000000000000018, 0.10931995547660933, 0.12616854897734353, 0.18979439807803178, 0.10642065262331779, 0.108594786680687, 0.06947674038290852, 0.08614526715139936, 0.10054245305042953, 0.15366869050555865, 0.1430240829426731, 0.15475448018179316, 0.04839486587644681, 0.040433452319290075, 0.0321620695380731, 0.05317339136122767, 0.03530214674085985, 0.06282317837649731, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04842936948862886, 0.017076843735821634, 0.038199520000167575, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020571222028526348, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08950936135940324, 0.06480376280976119, 0.09372077927391287, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.08802384992455037, 0.0697194269702317, 0.13487429235824777, 0.1081132584915756, 0.10336416700623685, 0.07149084860380428, 0.044775297864642405, 0.054250012544084125, 0.1003011023482171, 0.09232455826150732, 0.1111107099123213, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041930971572320064, 0.03475202454950532, 0.04831299134352651, 0.031837430911013875, 0.033216637077566946, 0.025995976379960872, 0.14364619967762138, 0.1333596719392951, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005925533797029314, 0.0, 0.007042779553406264, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004875998265572723, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03852671535389662, 0.03949982888992498, 0.03040306330360254, 0.0, 0.0, 0.0, 0.04245104108310971, 0.04769839023599909, 0.040933620611798505, 0.08828812965246502, 0.08695027608203088, 0.08002558696094919, 0.0247110170314212, 0.03457589406032613, 0.02640168388417219, 0.07779264903284355, 0.08113443711254897, 0.06758160090008292, 0.0, 0.0, 0.0, 0.01279449076192296, 0.010160222190639168, 0.011851329184194737, 0.008573648101299458, 0.010860136093378214, 0.010824222976457354, 0.12165987256037458, 0.1304161139054778, 0.11234189825957985, 0.0, 0.0, 0.0]}}
{"id": "a2fef325-0bbd-4c37-96c7-efe4435ecfb7", "fitness": 0.041027491923545954, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Incorporate a dynamic probability factor for Levy flight to balance exploration and exploitation dynamically.  ", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04103 with standard deviation 0.04724.", "error": "", "parent_ids": ["cb435294-e0b5-41f1-9b57-8b387c254147"], "operator": null, "metadata": {"aucs": [0.11891444192232503, 0.11070433910061583, 0.16553230440507416, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02746666183857871, 0.025713855901100313, 0.028310745864121745, 0.020000000000000018, 0.020063589712732477, 0.020000000000000018, 0.07599630699025117, 0.0489976392595759, 0.051196791720327206, 0.10339639888195762, 0.03239311658678734, 0.020000000000000018, 0.06342257419693997, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027365025645070817, 0.020000000000000018, 0.043185983919733384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13540576456645814, 0.13076840035396453, 0.183150013732989, 0.026906296941451413, 0.031496402578967686, 0.03752959792352839, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.17727941830935212, 0.15762104625585782, 0.1399538727480164, 0.08545852523225417, 0.07990382579724953, 0.07953094709372321, 0.16689912437587995, 0.11618982659882537, 0.14631594137388093, 0.020000000000000018, 0.10920405913436293, 0.12616854897734353, 0.1897807158226663, 0.10641585374467, 0.10861886815540545, 0.0697857300975826, 0.08634625945524532, 0.10054245305042953, 0.15366869050555865, 0.1430240829426731, 0.15475448018179316, 0.05026878814228519, 0.040433452319290075, 0.0321620695380731, 0.053109880097529705, 0.035475132554666944, 0.06283580091470087, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0484369345870449, 0.01709768848500548, 0.038212950967725035, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020571222028526348, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08951085598800901, 0.06477344269572682, 0.09370614054252047, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.08305045597901217, 0.06898914611875218, 0.13487429235824777, 0.11065412373062111, 0.10328520731027258, 0.07149084860380428, 0.044640279334342337, 0.054052876826329976, 0.1003011023482171, 0.09547792847720471, 0.1111107099123213, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.041930971572320064, 0.03507556325959782, 0.04831299134352651, 0.03180451004600249, 0.033216637077566946, 0.02599961160606712, 0.14364653733361277, 0.1356134441168244, 0.13782095802950212, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005926743818112312, 0.0, 0.007054495573385, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004869629369927964, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03855031216342719, 0.03949982888992498, 0.030338172776899208, 0.0, 0.0, 0.0, 0.04221319625643971, 0.04735202966067309, 0.0408624845358162, 0.08828812965246502, 0.08706839883680417, 0.08074141874720653, 0.024745177272647245, 0.03457589406032613, 0.027548108061266507, 0.07871368718318772, 0.07539547635211075, 0.0682757966341262, 0.0, 0.0, 0.0, 0.012732939172169888, 0.010160222190639168, 0.011852484433033328, 0.00861896676419649, 0.010860136093378214, 0.01111492927626867, 0.12199912622737041, 0.1304161139054778, 0.11930954425344464, 0.0, 0.0, 0.0]}}
{"id": "f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d", "fitness": 0.041119672653934077, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce a hybrid chaotic mutation operator and adaptive velocity scaling for enhanced convergence in dynamic environments.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04112 with standard deviation 0.04663.", "error": "", "parent_ids": ["a2fef325-0bbd-4c37-96c7-efe4435ecfb7"], "operator": null, "metadata": {"aucs": [0.11745957328468815, 0.11040922731175096, 0.1701252152106304, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03291207424714515, 0.02327136567072674, 0.03204136693238657, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07796638760546415, 0.055381379619548476, 0.052000356470014664, 0.10397547974108168, 0.02958859994368357, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.02384665442243683, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037202665944635616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13916910940912464, 0.13168124326473618, 0.183247417330482, 0.0254511620779454, 0.029336012346050544, 0.03336519853409581, 0.08072694858327945, 0.0863116411064907, 0.09786765690397803, 0.14914111512448003, 0.17153715314934315, 0.1324345901601217, 0.08957100005668683, 0.07990382579724953, 0.08081654996395427, 0.1383790592780647, 0.11688047359401987, 0.13883438469077503, 0.020000000000000018, 0.10941720761639606, 0.12353530483973685, 0.16539952253666568, 0.09021113911263268, 0.10736494634856342, 0.09527839720538944, 0.08331671860364454, 0.10007266157172756, 0.1586492688249166, 0.13589170657517036, 0.15475448018179316, 0.05932356581075382, 0.05681972910288724, 0.031030924983557306, 0.05345614524586895, 0.03525290955506566, 0.06189228936837066, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05276634206892328, 0.020875817129623275, 0.03933476518243628, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018497208004439325, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0896873472861851, 0.06813713614918404, 0.09135803135281295, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05753698539658325, 0.07846924941457534, 0.06657473161300487, 0.12933426075695298, 0.10990395440769163, 0.11879189742443774, 0.07323679527915805, 0.05110659378857174, 0.053936809511723194, 0.09245607701590175, 0.09335403509623896, 0.11277670805220541, 0.060455420637501645, 0.010000000000000009, 0.010000000000000009, 0.034975568888160335, 0.03079255694156602, 0.04323725238514886, 0.030846187842658468, 0.032107552470124756, 0.024892165502281682, 0.1474705998537721, 0.14324451639430635, 0.14160595283392008, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003954191587382527, 0.0006077600610808753, 0.002270676097009816, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006096362552707957, 0.0, 0.0002447294089051866, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03653084333583834, 0.03796499578803203, 0.030130598165299505, 0.0, 0.0, 0.0, 0.04479019655296124, 0.03974140236287138, 0.039341090915463894, 0.08780669388682683, 0.08850160641079075, 0.07529534423506745, 0.0278685427526435, 0.03940584164566485, 0.021618389308496355, 0.08496007051848398, 0.07578976112621749, 0.0639153263110418, 0.0, 0.0, 0.0, 0.01294275512177423, 0.010329248841959626, 0.012316723242187244, 0.008904380195278616, 0.010651168295786273, 0.011061177233124386, 0.11697269215414108, 0.1304161139054778, 0.11995797585464585, 0.0, 0.0, 0.0]}}
{"id": "19f32d98-bc0e-49f3-b070-2c4e07f5715c", "fitness": 0.039547545200056704, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhance convergence by dynamically adjusting mutation scale based on swarm diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity):\n        mutation_scale = 0.1 + 0.1 * diversity\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03955 with standard deviation 0.04566.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.11018696922322702, 0.11044405266198476, 0.15910788087825567, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0304266311360728, 0.024229588390855206, 0.022595049743882045, 0.027001406176842657, 0.022887214934291356, 0.020000000000000018, 0.07722299462224613, 0.05672088224979799, 0.052142798503182486, 0.10497469494855838, 0.02889678596824785, 0.020000000000000018, 0.055682932859515866, 0.08594148016760361, 0.11179796376536022, 0.020494460825176475, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03769339345564515, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15388934212244632, 0.14026344880687214, 0.16550069397568246, 0.03397510656727365, 0.027920465520658078, 0.03358340149067118, 0.08466582393015143, 0.0863116411064907, 0.09353430676559948, 0.15171951472143552, 0.15663473576857878, 0.1324335857675908, 0.09439659873714712, 0.07990382579724953, 0.08081743232172645, 0.13621149013102174, 0.1029064944743956, 0.12757933997321946, 0.020000000000000018, 0.040859040282686276, 0.12320036555438973, 0.2077884169308054, 0.10415825107128285, 0.10104808398423126, 0.06527120746322768, 0.07017223838949094, 0.1008895139420879, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.043220509171813304, 0.03963128631127699, 0.03171735219273386, 0.04366747550457806, 0.02974320496900018, 0.06319013445661004, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05347687719827443, 0.021047581832970064, 0.040143362195041554, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01456918691263942, 0.015772975944397527, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0932194218231569, 0.07608554124611433, 0.09875867673514671, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05666314716541487, 0.061966784648266215, 0.05732071614075718, 0.12381167768306456, 0.11214486810319668, 0.10966581937995112, 0.06689077687500256, 0.04901577804705537, 0.053936809511723194, 0.100703940559975, 0.08417996806183237, 0.1037180324342919, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.031110682041541327, 0.03396412150943573, 0.036660769190633546, 0.025035480771441687, 0.0415043418691452, 0.024640285494433645, 0.13141309820135194, 0.13766664709991572, 0.14026828803564384, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0017472188074535433, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005153649574464625, 0.0023847117482769242, 0.0032661621484143533, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.037218336455556944, 0.03604399715968842, 0.028797619847929612, 0.0, 0.0, 0.0, 0.03971763741474277, 0.037551636404690614, 0.03385623816290495, 0.08991286667412635, 0.08685542202598684, 0.07692733292293397, 0.03206426688362929, 0.026635327094863492, 0.01904204319465297, 0.07785958613428112, 0.06940408543661447, 0.0654387918995667, 0.0, 0.0, 0.0, 0.010359583343478862, 0.009963997784428469, 0.010379338938343086, 0.00884001905419085, 0.010051284513262426, 0.011976627418666341, 0.11281319690264657, 0.13147465858502017, 0.1114281454676348, 0.0, 0.0, 0.0]}}
{"id": "d73a8334-1b4d-485d-9f43-23b73cc3a8c3", "fitness": 0.03917329185308779, "name": "QuantumEnhancedAdaptiveChaoticSwarmOptimizer", "description": "Integrate a quantum-inspired probability model to enhance exploration and exploitation balance in dynamic swarm behaviors.", "code": "import numpy as np\n\nclass QuantumEnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n    \n    def quantum_behavior(self, position, global_best):\n        alpha = np.random.rand(self.dim)\n        return alpha * position + (1 - alpha) * global_best\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n                social = np.random.rand() * (self.global_best_position - self.positions[i])\n                \n                if np.random.rand() < 0.5:\n                    self.positions[i] = self.quantum_behavior(self.positions[i], self.global_best_position)\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 39, "feedback": "The algorithm QuantumEnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03917 with standard deviation 0.04535.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.10485715849220512, 0.11001879076190746, 0.15615369522836264, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03570565455197483, 0.022052611553690316, 0.02891558759314028, 0.028246240652850974, 0.02126052282861224, 0.020000000000000018, 0.08091868072387698, 0.05633240720860755, 0.05213385747493793, 0.026911671870327614, 0.03399271548099447, 0.020000000000000018, 0.06001134796898777, 0.08594148016760361, 0.10016426685187285, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029927453820379757, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14857187087733204, 0.16567309277767805, 0.1623499312816099, 0.02710910438471703, 0.024062920055488046, 0.024068671415030662, 0.09439087514386035, 0.08852734086879621, 0.11106167895801289, 0.14776566917595912, 0.1408712895466434, 0.13428846243746262, 0.09713422102914682, 0.07990382579724953, 0.07969272575371389, 0.12779190187073197, 0.1278477883299335, 0.14185880080133018, 0.020000000000000018, 0.020000000000000018, 0.09926256151893598, 0.19566911906580686, 0.07652377870494442, 0.09698710583810422, 0.08618878719484957, 0.1039507077890609, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.16039399041126556, 0.04191897639058351, 0.03539379815992594, 0.035566822578542934, 0.05567108788768893, 0.040293510255348663, 0.06094511503429034, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0327830260165346, 0.02477484597772195, 0.022703363896606654, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020114491512618016, 0.011528476852047165, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0944053361792776, 0.08013215907023141, 0.08076613640660435, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.06586080741280176, 0.12296167534102198, 0.10404219938104364, 0.10809655466940815, 0.06959118340795245, 0.04126606534396926, 0.05397842135960507, 0.10427627516448523, 0.09567811814064286, 0.10133450312480885, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03276874343058778, 0.033344548787442974, 0.03621954025139329, 0.034841148626512775, 0.028121098693710378, 0.026275214243702827, 0.13141309820135194, 0.14405126718432504, 0.13556933041617758, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011054587317970377, 0.0, 0.006727883164256099, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038757992579104616, 0.04489390978644214, 0.04008846857481985, 0.0, 0.0, 0.0, 0.03656642438554736, 0.039494988950667276, 0.03520814547996165, 0.08756990087499306, 0.08473882463387117, 0.08232063460972772, 0.03471472426509792, 0.02824512243909505, 0.02419850564219561, 0.07701603815992941, 0.067367328586875, 0.07595731162016395, 0.0, 0.0, 0.0, 0.012386830342870803, 0.012520227974526121, 0.013523986536682742, 0.00979240571291351, 0.010051284513262426, 0.010584834564910217, 0.1237139678602367, 0.1304161139054778, 0.10902825628752044, 0.0, 0.0, 0.0]}}
{"id": "fc2ed9b0-16e3-4540-a485-60fb004b0fde", "fitness": 0.037122306013833865, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce stochastic multi-swarm interaction and adaptive chaos scaling to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.sub_swarms = 5  # Number of sub-swarms\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n\n        while evaluations < self.budget:\n            # Evaluate each particle\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            # Divide population into sub-swarms for enhanced exploration\n            sub_swarm_size = self.population_size // self.sub_swarms\n            for swarm in range(self.sub_swarms):\n                local_start = swarm * sub_swarm_size\n                local_end = local_start + sub_swarm_size\n                local_best_position = self.positions[local_start:local_end][np.argmin(self.personal_best_scores[local_start:local_end])]\n\n                for i in range(local_start, local_end):\n                    chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                    self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                    inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                    cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                    social = self.social_coefficient * chaotic_factor[i] * (local_best_position - self.positions[i])\n\n                    levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                    if np.random.rand() < levy_prob:\n                        levy_step = 0.01 * self.levy_flight(self.dim)\n                        self.positions[i] += levy_step\n\n                    self.velocities[i] = inertia + cognitive + social\n                    self.positions[i] += self.velocities[i]\n                    self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                    self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03712 with standard deviation 0.04323.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.10342569460743167, 0.10972659882429037, 0.12870203169184735, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034852798445794475, 0.021393385612907267, 0.021578310056273975, 0.020000000000000018, 0.020000000000000018, 0.035431703122917546, 0.07590529772264176, 0.05044295982708735, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.036167930243500845, 0.08594148016760361, 0.07106123791078511, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11784939014215812, 0.08712346351932165, 0.14370759216818474, 0.023252203024571094, 0.020000000000000018, 0.04058617221337313, 0.08072694858327945, 0.0863116411064907, 0.11275473169406014, 0.1521051177372732, 0.17041639305390988, 0.1324345901601217, 0.10397363720474062, 0.09056584159490311, 0.08081654996395427, 0.13013634644044514, 0.12292536285363898, 0.1321256648797644, 0.020000000000000018, 0.029051230052240085, 0.06987639757343, 0.16142063363556536, 0.09780776414120596, 0.08953184261342984, 0.06527120746322768, 0.07570190198337512, 0.06897253855283447, 0.14426305533840877, 0.1533945034795947, 0.15475448018179316, 0.05246628691296895, 0.03788945106758834, 0.03906915659246346, 0.0304087903520579, 0.031615754007508934, 0.04112440774903192, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023323839075517605, 0.019950473910947952, 0.015908509157266493, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010181281056694025, 0.011535009496804638, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08110496024860847, 0.06254106403461546, 0.06698144061180644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.0646568465013877, 0.0560756342153752, 0.12361888767926543, 0.09796708229638051, 0.10452476874274608, 0.06271274510126035, 0.052328300535187, 0.05888530492488442, 0.0947883451242576, 0.09263161860134672, 0.09868238076546487, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.026461233576617116, 0.03113188281308854, 0.029071219965963846, 0.02999985121524318, 0.055433258420588105, 0.025365039110797793, 0.1474705998537721, 0.13415178340431066, 0.14851906061000175, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0041362292400914935, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.003262286334951736, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.035460133506186486, 0.033846648262768286, 0.02827836407388684, 0.0, 0.0, 0.0, 0.04185435292513762, 0.03883664403104059, 0.03652576390639384, 0.08224998567930597, 0.08763489649540401, 0.08537985771957834, 0.029282520421991087, 0.02810288335781519, 0.027327872555333088, 0.08043415451319302, 0.06601862799679925, 0.07445149934634954, 0.0, 0.0, 0.0, 0.011451321218050148, 0.01005163944084042, 0.010487862136797643, 0.008320942899464723, 0.010051284513262426, 0.00847208033704272, 0.11690568386629052, 0.1304161139054778, 0.11395529363210244, 0.0, 0.0, 0.0]}}
{"id": "00465bc5-afc8-4d43-8100-b293d9cc17fc", "fitness": 0.04089759682450445, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Integration of dynamic chaotic factor scaling with enhanced levy flight probability for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.5 * (1 - adaptive_factor)  # Increased Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.02 * self.levy_flight(self.dim)  # Enhanced levy flight step size\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04090 with standard deviation 0.04645.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.11745957328468815, 0.11040922731175096, 0.17012072331457273, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03291207424714515, 0.02327136567072674, 0.03204136693238657, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07797494104885827, 0.055381379619548476, 0.052000360065152296, 0.10397547974108168, 0.02958859994368357, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.02384665442243683, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037202665944635616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13916910940912464, 0.13168124326473618, 0.183247417330482, 0.0254511620779454, 0.029336012346050544, 0.03336519853409581, 0.08072694858327945, 0.0863116411064907, 0.09144379771278499, 0.14914111512448003, 0.17153715314934315, 0.1324345901601217, 0.08957100005668683, 0.07990382579724953, 0.08081654996395427, 0.1383790592780647, 0.11688047359401987, 0.13883438469077503, 0.020000000000000018, 0.10941720761639606, 0.12356814437619623, 0.16539952253666568, 0.09021113911263268, 0.10736259159082506, 0.09527839720538944, 0.08331671860364454, 0.10007266157172756, 0.1586492688249166, 0.13589170657517036, 0.15475448018179316, 0.05932356581075382, 0.05681972910288724, 0.027307644955494093, 0.05328811275730172, 0.03509568887462278, 0.062083984097240696, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05256208479268676, 0.02102600004421107, 0.03934055905507572, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018497208004439325, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0896873472861851, 0.0683298611866684, 0.0919704314471399, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05525327034944272, 0.07846924941457534, 0.06657473161300487, 0.12933426075695298, 0.10889244428162148, 0.11300267990984336, 0.07323679527915805, 0.05107764422662253, 0.053936809511723194, 0.09616510085723218, 0.09392404645597952, 0.11235639414596887, 0.05485114646037348, 0.010000000000000009, 0.010000000000000009, 0.034975568888160335, 0.03079255694156602, 0.04257492433125065, 0.03128852623709577, 0.032107552470124756, 0.025021789083461532, 0.1474705998537721, 0.1423412921286462, 0.14045623437056864, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003951668387927931, 0.0007847651075139073, 0.002209651803564139, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006175406041205811, 0.0, 3.2524087666852e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03640775378533789, 0.03796499578803203, 0.030136751990212596, 0.0, 0.0, 0.0, 0.03743522429455526, 0.03959495805351754, 0.03928933267111889, 0.08661398304616286, 0.08850160641079075, 0.07517220693927418, 0.0271553411570018, 0.03940584164566485, 0.021252400351617573, 0.08457099656682376, 0.07578976112621749, 0.06164307111530887, 0.0, 0.0, 0.0, 0.012880383891819891, 0.010329248841959626, 0.01229629450130576, 0.008002231132610116, 0.010651168295786273, 0.011155432453979541, 0.11382702655638499, 0.13093035608278203, 0.11074945361895805, 0.0, 0.0, 0.0]}}
{"id": "e3c44cfa-9057-43b1-befb-3393f4e449c7", "fitness": 0.037177872745930395, "name": "EnhancedOppositionChaoticSwarmOptimizer", "description": "Integrate a dynamic opposition-based learning strategy with adaptive velocity scaling and chaotic mutation to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedOppositionChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n                # Opposition-based learning\n                if evaluations < self.budget:\n                    opposite_position = self.opposition_based_learning(self.positions[i])\n                    opposite_score = func(opposite_position)\n                    evaluations += 1\n                    if opposite_score < score:\n                        self.positions[i] = opposite_position\n                        if opposite_score < self.personal_best_scores[i]:\n                            self.personal_best_scores[i] = opposite_score\n                            self.personal_best_positions[i] = opposite_position\n                        if opposite_score < self.global_best_score:\n                            self.global_best_score = opposite_score\n                            self.global_best_position = opposite_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedOppositionChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03718 with standard deviation 0.04296.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.1351705790739931, 0.14885427979779964, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.024623129949807754, 0.022399001491866133, 0.020000000000000018, 0.020000000000000018, 0.025228899757320122, 0.020000000000000018, 0.05410323811488549, 0.04117949152036293, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02432612161088399, 0.08594148016760361, 0.09780608618828623, 0.022763089796398073, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03675501496077116, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03273444102395129, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1409203039028618, 0.11543466870050278, 0.13925889702953465, 0.025916640489481613, 0.038324148965703464, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.08233658545129019, 0.13305260819416243, 0.13323277534341382, 0.1297054408259729, 0.06805829776842875, 0.07990382579724953, 0.07448014029776917, 0.14158900330698476, 0.14748567403494117, 0.130392021487308, 0.11069229575675776, 0.02657144099683184, 0.05602184269192134, 0.10819636878037442, 0.0922705212364644, 0.0895133107273659, 0.06527120746322768, 0.057273985825382456, 0.08813288956643017, 0.1438526290318487, 0.1544121807070502, 0.15475448018179316, 0.05468838488612615, 0.04155900908638699, 0.03180409382151683, 0.05025176875003856, 0.051080237815740226, 0.0557501361332321, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01922899643887499, 0.011863605189260662, 0.015693574863975046, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01003372619604137, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07630231619648042, 0.06323419660279672, 0.07390452021745864, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05764948225341304, 0.06147825531143891, 0.06216515166789438, 0.12177099948502923, 0.09794841410113109, 0.10771409208798677, 0.07120661659852034, 0.03518359929680204, 0.053936809511723194, 0.1003124649666024, 0.1173377696531075, 0.10219398728208573, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0274613345704402, 0.032806786486677786, 0.027323172621887992, 0.027609659192359692, 0.023936076975020315, 0.024640285494433645, 0.13141309820135194, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00039113672544432987, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.041504667988397914, 0.038159212715014657, 0.03857616030507782, 0.0, 0.0, 0.0, 0.031121118339511145, 0.037839582644470404, 0.030964555287658846, 0.08450118117639438, 0.08654334385745188, 0.08239680653624692, 0.02364836877916876, 0.037207612546266144, 0.034016302210546634, 0.0866879902051838, 0.08669951171270629, 0.07674836403252128, 0.0, 0.0, 0.0, 0.010199406218979412, 0.009775827011254234, 0.009669034328113058, 0.010974740062151267, 0.010051284513262426, 0.008226637294494576, 0.11978276868874682, 0.1304161139054778, 0.1117421828751266, 0.0, 0.0, 0.0]}}
{"id": "1542dc38-44d2-426b-a335-c6c6ef750e0e", "fitness": 0.03827347575979819, "name": "QuantumEnhancedSwarm", "description": "Introduce quantum-inspired superposition for enhanced exploration and dynamic Levy flight adjustment for improved convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def quantum_superposition(self, position, global_best):\n        q_position = (position + global_best) / 2 + np.random.uniform(-1, 1, size=self.dim) * (global_best - position) / np.sqrt(2)\n        return np.clip(q_position, self.lower_bound, self.upper_bound)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n            \n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] = self.quantum_superposition(self.positions[i] + levy_step, self.global_best_position)\n                else:\n                    self.positions[i] = self.quantum_superposition(self.positions[i], self.global_best_position)\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 43, "feedback": "The algorithm QuantumEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03827 with standard deviation 0.04399.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.10664320089873092, 0.10130938718744642, 0.14562460096534136, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034663828403005525, 0.026963218310968484, 0.025420207142921925, 0.020000000000000018, 0.026334925656582575, 0.020000000000000018, 0.08432571727318972, 0.06480059385388481, 0.05977853751537776, 0.036104411207297904, 0.03730816622280542, 0.020000000000000018, 0.06768121492723778, 0.10454201235895455, 0.07471596303179984, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02199364468643128, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15672210863802183, 0.13540037867991284, 0.15049678243006992, 0.0314153418766685, 0.03901270305236526, 0.02231751013778749, 0.08072694858327945, 0.0863116411064907, 0.08034112931137061, 0.15260558772583266, 0.13323277534341382, 0.11878587591740286, 0.09095838239111576, 0.08963206072376506, 0.06641473505976814, 0.12013148336403079, 0.11326054264044583, 0.1374049770102963, 0.020000000000000018, 0.08554785266483989, 0.020000000000000018, 0.16316400043892598, 0.10968343607490905, 0.11729054143863182, 0.08831844507572062, 0.09054048706365647, 0.056492493752391515, 0.14827411178597405, 0.1513226562439136, 0.16725518204639944, 0.04078525077022788, 0.039624106457900266, 0.037319931172156706, 0.06769425016611397, 0.029394653847690688, 0.051871424852653836, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05906938662135375, 0.04011841800581517, 0.04051290882945724, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011521281964520846, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08304126980495141, 0.053030144359549114, 0.07921908422458623, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06053823668947311, 0.06847261877576682, 0.05550581847218472, 0.12421067889893178, 0.1041942757311678, 0.10310496461651664, 0.0795455269270916, 0.04646195719364987, 0.05427235670326014, 0.09268841495412761, 0.06679358541687219, 0.0983638205277424, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03503366571162403, 0.04102863933433709, 0.029329948797735428, 0.02758820024549835, 0.025809248638239635, 0.02539742292979641, 0.1390119321422364, 0.13640945326980958, 0.13818159053744428, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012451929583493948, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.003225012920278103, 0.0, 0.00016564415448439007, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.030827116398631782, 0.03769524109314415, 0.021023896561787603, 0.0, 0.0, 0.0, 0.034969213067003846, 0.0378648001145514, 0.03537229607539982, 0.08698567508005683, 0.08218987679802225, 0.07497884841134583, 0.021107673119993287, 0.028079186579168303, 0.018829165146643567, 0.0815526777151725, 0.06883324511381417, 0.05046878425928836, 0.0, 0.0, 0.0, 0.011860463984364356, 0.009531628804691938, 0.009611149987848622, 0.012643982089452499, 0.010057289969153893, 0.0105391656879944, 0.11745717625427321, 0.13646205741318962, 0.12587329992330099, 0.0, 0.0, 0.0]}}
{"id": "e40bdcc3-bb9e-46de-a6ee-645050e11d3a", "fitness": 0.038442971401658435, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce dynamic inertia weight adjustment and chaotic perturbation to the swarm's cognitive and social components for improved optimization precision.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.2\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.2\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def chaotic_perturbation(self, position, factor):\n        perturbation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + perturbation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n\n                inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                cognitive_coefficient = self.cognitive_coefficient_min + (self.cognitive_coefficient_max - self.cognitive_coefficient_min) * (1 - adaptive_factor)\n                social_coefficient = self.social_coefficient_min + (self.social_coefficient_max - self.social_coefficient_min) * adaptive_factor\n\n                inertia = inertia_weight * self.velocities[i]\n                cognitive = cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n\n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_perturbation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03844 with standard deviation 0.04411.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.11997286586280154, 0.09071842396794405, 0.13784047433543845, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03521320034533004, 0.02489581672834873, 0.020993542094268514, 0.020000000000000018, 0.031600788751585784, 0.020000000000000018, 0.08562054127737728, 0.11861952596323933, 0.05861024856915864, 0.026113003016878578, 0.03263170909874713, 0.020000000000000018, 0.03777136948776216, 0.08594148016760361, 0.08206609919542218, 0.023916308828532462, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12425032221814947, 0.1031169838644197, 0.18065358702789103, 0.020000000000000018, 0.020000000000000018, 0.032796595728054045, 0.08546523443515686, 0.08876896383686306, 0.09702350504434232, 0.13477123456109663, 0.1439418854827318, 0.15075332627090487, 0.08340494825962652, 0.07990382579724953, 0.07617666283320434, 0.13703964410109282, 0.10541718193233152, 0.14008255889845211, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1589392761068461, 0.09069973249201524, 0.1011571704463542, 0.07770550582469271, 0.09920826221258539, 0.06912721191807458, 0.1438526290318487, 0.13757266588306405, 0.15475448018179316, 0.0494983153152172, 0.03392426887360889, 0.03395926689917572, 0.047439375831603736, 0.041004811778632355, 0.04527008758880602, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058695067915407906, 0.028705573352461378, 0.03558618689256887, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08662509927806028, 0.06727899816492, 0.07637474488175722, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05538509852547657, 0.06895921230940427, 0.05558135938232778, 0.12335447189428905, 0.10693553172792647, 0.10913794972343449, 0.06432546856186871, 0.0384758567806226, 0.05587453624613237, 0.09821824938546686, 0.0895413255368922, 0.09501117529205427, 0.11660575527104344, 0.010000000000000009, 0.010000000000000009, 0.02568407687623031, 0.034587798280172444, 0.03400270788320858, 0.030163891672503995, 0.023529218525016105, 0.02500876316620193, 0.13218902983342717, 0.1338798111831042, 0.13740404580975218, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.006437011140874804, 0.0, 0.00588365043810013, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.003015049169814432, 0.004112114634503672, 0.0007566063647641563, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03506504587927606, 0.03520442937510293, 0.035370205673512345, 0.0, 0.0, 0.0, 0.039518742273408236, 0.04069099371915741, 0.031767959574421134, 0.09456490656347216, 0.08977500651776027, 0.08560594970813507, 0.0297896928323802, 0.02906694336079052, 0.023785456736062804, 0.08145396158164286, 0.08441313636091419, 0.06540684411689812, 0.0, 0.0, 0.0, 0.011902374736951438, 0.00994041939616419, 0.01226670517322792, 0.0076917549084075665, 0.010627765325611604, 0.010506759536901722, 0.12635958002151282, 0.1304161139054778, 0.12496072101491973, 0.0, 0.0, 0.0]}}
{"id": "67330cf4-0156-4caa-bb0c-dbc4f5c861f5", "fitness": 0.039147978484027464, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce a variable cognitive coefficient to improve adaptability and convergence rate.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_initial = 1.5  # Initial cognitive coefficient\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = self.cognitive_coefficient_initial + (0.5 * adaptive_factor)  # Update to adaptive\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03915 with standard deviation 0.04499.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.1316258131063498, 0.0917711973320513, 0.15409492417963022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04598701879010936, 0.032561922256007514, 0.021578310056273975, 0.021594714716220875, 0.020000000000000018, 0.020000000000000018, 0.08227634487255653, 0.07877402521510957, 0.05473713591937823, 0.02909702402868819, 0.03510071445563023, 0.020000000000000018, 0.06275415075251956, 0.09569608921525574, 0.07957377872879501, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1309325134273186, 0.09790309898761562, 0.16671271965829493, 0.04000158082635974, 0.02024197727431387, 0.0249480507093911, 0.08072694858327945, 0.09637111656640496, 0.08013349834836303, 0.13835420912892005, 0.14086476305903428, 0.13753485411479882, 0.07251617594955573, 0.07990382579724953, 0.07678053461539935, 0.1385676464847373, 0.11440357815274127, 0.15226079379313096, 0.020000000000000018, 0.020000000000000018, 0.12157812550204794, 0.16358071497238913, 0.08294325113279455, 0.09544946349110583, 0.06827807884404702, 0.1404937993913873, 0.06961104878907975, 0.1438526290318487, 0.1806935938569595, 0.15475448018179316, 0.04511068848814448, 0.03609071678423159, 0.02657375009670604, 0.05099155860829252, 0.036695989746456936, 0.052390535684015305, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05848062867701653, 0.0267893391753673, 0.03770052616333519, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010885444895898488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01754312486041898, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08974070738218942, 0.06960094054063448, 0.09951909567176842, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06735870017971168, 0.05452087267106431, 0.12299924597549616, 0.10666706047519825, 0.10717561734620784, 0.07035583767307374, 0.04088320557288627, 0.056809390828229556, 0.09290369307403723, 0.08826735265210917, 0.09673813553048816, 0.10625776517741636, 0.010000000000000009, 0.010000000000000009, 0.0308818557475109, 0.029043163533977734, 0.03376554882222649, 0.027342512528969243, 0.024535738852307865, 0.025472367734391987, 0.1359341352300335, 0.13224780152028714, 0.13648612848024044, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004854116771684236, 0.0, 0.0020893190694001307, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0057061360919103965, 0.0, 0.0010134656392665198, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03485095820014661, 0.035013453339838185, 0.03089288677067037, 0.0, 0.0, 0.0, 0.03967444693590383, 0.04040472851004895, 0.03477367368587425, 0.08361777035564444, 0.08788648481613626, 0.07837522808939246, 0.027644552980379156, 0.029594373195646173, 0.020834136009965087, 0.08765144153714277, 0.07992123007694862, 0.06223614756955864, 0.0, 0.0, 0.0, 0.013148798757639746, 0.009791959415675011, 0.012674236449339737, 0.009476034429583002, 0.010051284513262426, 0.011546638391942587, 0.1197698677267337, 0.1304161139054778, 0.11507850546941245, 0.0, 0.0, 0.0]}}
{"id": "9f23a35a-b74d-4663-9076-fe15c40ec6a2", "fitness": 0.03699320145583179, "name": "EnhancedAdaptiveChaoticSwarmOptimizerV2", "description": "Enhance convergence using adaptive chaotic dynamics and a dynamic neighborhood strategy for robust global exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def dynamic_neighborhood_strategy(self, idx):\n        best_neighbor_idx = idx\n        best_neighbor_score = self.personal_best_scores[idx]\n        for offset in [-1, 1]:\n            neighbor_idx = (idx + offset) % self.population_size\n            if self.personal_best_scores[neighbor_idx] < best_neighbor_score:\n                best_neighbor_score = self.personal_best_scores[neighbor_idx]\n                best_neighbor_idx = neighbor_idx\n        return self.personal_best_positions[best_neighbor_idx]\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                neighbor_best_position = self.dynamic_neighborhood_strategy(i)\n                social = self.social_coefficient * chaotic_factor[i] * (neighbor_best_position - self.positions[i])\n\n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03699 with standard deviation 0.04310.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.10928871627252024, 0.10952676600275424, 0.138289816025143, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03058284609456674, 0.02061928229242671, 0.022585721125480074, 0.02572800432347966, 0.020000000000000018, 0.035431703122917546, 0.06173160628120311, 0.05523355852030787, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.050250274548072627, 0.08594148016760361, 0.07106123791078511, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11754934103699755, 0.10329011783100595, 0.14863285582842745, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.11275473169406014, 0.13452315506456614, 0.1565194371097356, 0.11954834392376124, 0.07748599554377533, 0.07990382579724953, 0.06098555996691768, 0.11453780863445873, 0.10857592775444946, 0.12615497296613198, 0.1283298171349836, 0.029051230052240085, 0.06987639757343, 0.16142063363556536, 0.0962379281082042, 0.08953184261342984, 0.06527120746322768, 0.06377023477222221, 0.06897253855283447, 0.1738779879451724, 0.13962264488333176, 0.16879329842120816, 0.041219968249708305, 0.04443218174153918, 0.033006739675849994, 0.03882481635955004, 0.030752247607389926, 0.05596518018453123, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0141032498001471, 0.014286205972784405, 0.018895743711312196, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07043850985320577, 0.06268358708523847, 0.06988129924651343, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0559963275364177, 0.06554168614169509, 0.05859770116013008, 0.12247189859498375, 0.10012655179560215, 0.10546945371557381, 0.06209716679288635, 0.04712564951901077, 0.053936809511723194, 0.09607905995262112, 0.09108528584232789, 0.10192905681450415, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030326936019566264, 0.03187747719890366, 0.03609435601787736, 0.03342912698071987, 0.055525022436742844, 0.029226171175396276, 0.1474705998537721, 0.13491787828593582, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.028128724939842753, 0.033924553456649575, 0.028629478375437056, 0.0, 0.0, 0.0, 0.033846515960438195, 0.04365034589885641, 0.035392210818878556, 0.08236094317873677, 0.08772620583735691, 0.08491038154815067, 0.02501911645266519, 0.02852348827055251, 0.023020638578459485, 0.0783191898223008, 0.07308162991322764, 0.06479848211536943, 0.0, 0.0, 0.0, 0.010277485663385155, 0.009519719559284101, 0.010827751573930344, 0.008666055124534444, 0.011025054444770421, 0.008472663855987106, 0.11524993554004648, 0.1304161139054778, 0.11905988951580515, 0.0, 0.0, 0.0]}}
{"id": "e72c605d-d83d-4911-8ee7-7be243276180", "fitness": 0.040756239886851876, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce enhanced Levy flight dynamics with dynamic scaling to improve global search capabilities.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.1 * self.levy_flight(self.dim, beta=1.3)  # Adjusted Levy flight\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04076 with standard deviation 0.04661.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.11745957328468815, 0.11040922731175096, 0.17007776088253335, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03291207424714515, 0.02327136567072674, 0.03204136693238657, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0780644988038327, 0.055381379619548476, 0.0520004858622235, 0.10397547974108168, 0.02958859994368357, 0.020000000000000018, 0.05809746851691733, 0.08594148016760361, 0.11179796376536022, 0.02384665442243683, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037202665944635616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13916910940912464, 0.13168124326473618, 0.183247417330482, 0.0254511620779454, 0.029336012346050544, 0.03336519853409581, 0.08072694858327945, 0.0863116411064907, 0.08729763161513793, 0.14914111512448003, 0.17153715314934315, 0.1324345901601217, 0.08957100005668683, 0.07990382579724953, 0.08081654996395427, 0.1383790592780647, 0.11688047359401987, 0.13883438469077503, 0.020000000000000018, 0.10941720761639606, 0.12268627603303595, 0.16539952253666568, 0.09021113911263268, 0.10734551118064328, 0.09527839720538944, 0.08331671860364454, 0.10007266157172756, 0.1586492688249166, 0.13589170657517036, 0.16184743700980908, 0.05932356581075382, 0.05681972910288724, 0.027983256106973275, 0.051659544050633555, 0.03383549413222786, 0.06395251202180152, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05298749803135483, 0.020941626941404334, 0.03923551773283607, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018497208004439325, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0896873472861851, 0.06591601918881995, 0.09143868635991548, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05599186991137317, 0.07846924941457534, 0.06657473161300487, 0.12933426075695298, 0.1094125414684427, 0.11246942340091592, 0.07323679527915805, 0.048788826504570615, 0.05755533757823128, 0.0919013378186615, 0.09319937809369305, 0.12125161957400432, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.034975568888160335, 0.03079255694156602, 0.04323701666188473, 0.027222835627301434, 0.032107552470124756, 0.024640285494433645, 0.1474705998537721, 0.13405546007462799, 0.14157177061980886, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0038851515421769456, 0.0006495362177275643, 0.0013149289189569036, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006134571936820099, 0.0, 0.0002578048209375128, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.040511113452097014, 0.03796499578803203, 0.030130598165299505, 0.0, 0.0, 0.0, 0.040562068542093876, 0.03979620795048544, 0.03924283358949254, 0.08300121646448777, 0.08850160641079075, 0.07517220693927418, 0.030962092072905567, 0.03940584164566485, 0.0226869282590505, 0.08437457209819343, 0.07578976112621749, 0.060406976414452807, 0.0, 0.0, 0.0, 0.013113293851151453, 0.010329248841959626, 0.011977016813204067, 0.008895135534410459, 0.010651168295786273, 0.011391964825132272, 0.12270591401937225, 0.1304161139054778, 0.12031151683423369, 0.0, 0.0, 0.0]}}
{"id": "72f5c644-b049-48fb-85e6-ea2fa56b927e", "fitness": 0.040670345995734006, "name": "ImprovedChaoticSwarmOptimizer", "description": "Integrate a dynamic chaotic factor and nonlinear inertia adjustment to improve exploration-exploitation balance in swarm optimization.", "code": "import numpy as np\n\nclass ImprovedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.3\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient = 2.0\n        self.social_coefficient = 1.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def chaotic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1\n        chaotic_value = self.chaotic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_inertia_adjustment(self, eval_fraction):\n        return self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * (1 - eval_fraction)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            adaptive_factor = diversity / self.dim\n            self.cognitive_coefficient = 1.0 + adaptive_factor\n            self.social_coefficient = 2.0 - adaptive_factor\n\n            eval_fraction = evaluations / self.budget\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.chaotic_map(chaotic_factor[i])\n                inertia_weight = self.adaptive_inertia_adjustment(eval_fraction)\n                inertia = inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.2 * (1 - adaptive_factor)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:  \n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 48, "feedback": "The algorithm ImprovedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04067 with standard deviation 0.04625.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.11886194684387474, 0.11264792680903879, 0.16680880890284544, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03669667986119107, 0.02186437548932918, 0.031150439231169558, 0.020000000000000018, 0.02259732247684554, 0.025381147969201212, 0.0763625953117818, 0.05122366090724484, 0.0514685332962288, 0.10373697454369557, 0.030446636371462277, 0.020000000000000018, 0.05739598607443863, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13530357721337016, 0.1338036976592588, 0.18470421209526766, 0.02333483583116136, 0.030562896888714053, 0.040335349643182195, 0.08072694858327945, 0.0863116411064907, 0.07996169614844162, 0.15750389876080162, 0.1611763641063777, 0.13561951237515468, 0.08641780451821146, 0.07990382579724953, 0.0769666162114242, 0.13516805527022857, 0.10658256398524946, 0.1504165179384478, 0.020000000000000018, 0.11183634533790499, 0.11294307934297199, 0.1630762193422136, 0.08893304083913478, 0.10468333687081877, 0.06964463361536755, 0.08628133135673832, 0.09962332941360896, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.0546089088139432, 0.03920953666563998, 0.03915852165501077, 0.055312050746522234, 0.035806532440266214, 0.06329290314827363, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04780591846269833, 0.01776664057126298, 0.03615130150515933, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015839924526092508, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014191314895633078, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08881350299556023, 0.06733003080736244, 0.08750363315163245, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.060318404840955964, 0.08791254757147815, 0.06298326245783481, 0.1396627886659817, 0.10184875657665504, 0.11083341803044089, 0.07625114286959433, 0.04941874829779447, 0.06275825679714597, 0.09987021365248683, 0.09293858516803521, 0.11244400153420253, 0.04355121659535821, 0.010000000000000009, 0.010000000000000009, 0.038528817030031526, 0.031165473462645865, 0.0467530259216572, 0.027950001785396195, 0.03271819779210228, 0.02501561864641222, 0.16041023869321291, 0.1396424742536676, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.006398936091239538, 0.0, 0.004546552925063119, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004637590635533928, 0.0, 6.942187214209472e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.037646614392438216, 0.039043415310342056, 0.030082812412233872, 0.0, 0.0, 0.0, 0.044376227628943665, 0.04628767538819656, 0.03202961338023469, 0.0900973062454078, 0.0912838189651265, 0.0801151323923418, 0.027052141103648064, 0.030943092983248488, 0.026157879195890965, 0.07819628548702984, 0.08004165394522245, 0.0675490719245897, 0.0, 0.0, 0.0, 0.013141685536800618, 0.010289036496353487, 0.012166530361939376, 0.008760149463603262, 0.010962826968252015, 0.010957688419489076, 0.11991696531099605, 0.13400385905665313, 0.11778896368762748, 0.0, 0.0, 0.0]}}
{"id": "9b1107e8-ee21-496c-8b02-d616d4b47bb7", "fitness": 0.04115777074326354, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Integrate dynamic learning coefficients and chaotic perturbations to enhance exploration and exploitation balance for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04116 with standard deviation 0.04686.", "error": "", "parent_ids": ["f01ac770-4b85-4ebf-8fd0-a1eca5d6ba9d"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16865998096814616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07801454253562246, 0.0553122962098519, 0.05198315820751109, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.09485730377370705, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14463712210405333, 0.020000000000000018, 0.1086159632455298, 0.12676342425437725, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.026701114134553783, 0.053838723921108, 0.03551333365980991, 0.06251255694319513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052702310810223474, 0.020847090132434687, 0.039316127913145094, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.0690653278680835, 0.09080654473535488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05780285201293789, 0.08247904677910156, 0.06867912522087483, 0.13804028487350517, 0.10059146989951873, 0.11603057182456822, 0.07410737848799231, 0.055126236516060634, 0.053936809511723194, 0.09976547839093342, 0.08771993984301896, 0.10056258027619447, 0.06097698395185991, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.04354085641787209, 0.03083544610086375, 0.03247085960834395, 0.02491452834504637, 0.1460367740450299, 0.14995508500329047, 0.14920580819420282, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004255476537909475, 0.0006042807216090074, 0.0025435677552880787, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006201338235310883, 0.0, 6.427131687591903e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036761437563427646, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.04564205767772611, 0.041347738990614835, 0.034701169303381074, 0.08619032856391196, 0.08768521211623048, 0.07539063132411894, 0.027829751322100305, 0.038900516868527135, 0.022320025379924835, 0.08599548987369887, 0.07323695824976861, 0.063094016091916, 0.0, 0.0, 0.0, 0.01306696150149278, 0.010331259699854045, 0.012399266354949146, 0.008777970646403177, 0.01064139933457231, 0.011142454355775877, 0.11448749052965057, 0.1304161139054778, 0.12222123200721113, 0.0, 0.0, 0.0]}}
{"id": "2e3b8da3-e3c0-49a5-9163-9b15b538131d", "fitness": 0.04108132603762708, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce adaptive Levy flight scaling based on swarm convergence to improve exploration in challenging regions.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim) * (1 - diversity / self.dim)  # Adaptive Levy scaling\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04108 with standard deviation 0.04675.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16866509222631432, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07800790186790008, 0.0553122962098519, 0.05198315450129043, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.09375345644864819, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14484260575956454, 0.020000000000000018, 0.1086159632455298, 0.1269603247662059, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.02657375009670604, 0.05392814045449956, 0.035637848015218854, 0.062349200061542986, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05269754436541452, 0.020845738331918717, 0.03931337178317418, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.06915338691668804, 0.09080077133586373, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057799722063882064, 0.07601497663792411, 0.06867912522087483, 0.13067325257078477, 0.10073291480701796, 0.11602108881738815, 0.07236254908597861, 0.05508966344626354, 0.053936809511723194, 0.10023114093357544, 0.0928781892434648, 0.10080648814016302, 0.06065164822735625, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.043540949951378805, 0.030631852163321316, 0.03247085960834395, 0.02493693262410046, 0.1460367740450299, 0.14995508500329047, 0.14920580819420282, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004257327020190327, 0.0005981899732816487, 0.002581242404177342, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006186178395775399, 0.0, 6.393148347794142e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036892814086275205, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.04608720528643562, 0.041347738990614835, 0.03469355558974874, 0.08658829401566748, 0.08768521211623048, 0.07516949778166793, 0.027850163721997112, 0.038900516868527135, 0.022320025379924835, 0.08311768653504903, 0.07323695824976861, 0.06305228979195054, 0.0, 0.0, 0.0, 0.013060127078913797, 0.010331259699854045, 0.012412405557049477, 0.008708588829210218, 0.01064139933457231, 0.011113223604295563, 0.11294711924901635, 0.1304161139054778, 0.12030595489835338, 0.0, 0.0, 0.0]}}
{"id": "1698e1cf-34a0-41d4-bd7d-223ddb63f1a1", "fitness": 0.04097553812525088, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhanced adaptive chaotic swarm optimizer with refined chaotic mutation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.07  # Refined mutation scale for improved convergence\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04098 with standard deviation 0.04644.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11778139842521507, 0.1104076555802177, 0.1692578641423046, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03360149898302822, 0.02412803403870345, 0.03156804563715132, 0.020000000000000018, 0.020000000000000018, 0.02005501994326353, 0.07799510810382548, 0.05533990306682024, 0.05199003161719562, 0.1038571151655665, 0.029592263866609958, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020100457642676317, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037175994550844416, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13816899135658867, 0.13056802795568023, 0.18371573070784952, 0.026516755725450203, 0.029394158650579816, 0.032426446434147604, 0.08072694858327945, 0.0863116411064907, 0.09556631533749804, 0.15068378510125113, 0.17070701345009365, 0.13243464434186447, 0.0888993661252726, 0.07990382579724953, 0.0808165023582249, 0.15247219525144262, 0.12150862898462989, 0.12191976134240401, 0.020000000000000018, 0.10903908529966633, 0.12545174761656797, 0.16576056062168365, 0.09063465594466069, 0.1076196563448335, 0.09412658731609214, 0.08644380238554528, 0.10002596471766279, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05645855117535403, 0.05720349947202008, 0.02657375009670604, 0.053687642100029964, 0.03540979852692616, 0.0622651897822698, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05272844602030058, 0.020858600859754106, 0.03932361744046542, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08959505615418184, 0.06869774846093724, 0.09102862089445618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05730673855927404, 0.08197706709317965, 0.06534011354428049, 0.13758575945642815, 0.09967782997441221, 0.11688251092422786, 0.07267302434552736, 0.05419850546369398, 0.053936809511723194, 0.10274694818634278, 0.09126665409493218, 0.10617910868988834, 0.060816554357041475, 0.010000000000000009, 0.010000000000000009, 0.03471261360755251, 0.03072578176906604, 0.04342434078327939, 0.030849245820015914, 0.032324561402476526, 0.024905810041135124, 0.150337109615575, 0.13776159581533431, 0.1430853088626557, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004136314504359806, 0.0006074120471467603, 0.0024356419313069644, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006163538229389309, 0.0, 0.00013587073747434175, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03667074257305114, 0.03797173540735588, 0.030075743385240328, 0.0, 0.0, 0.0, 0.04714489671076816, 0.04012120926103757, 0.03570878608107497, 0.08690315986454034, 0.088149383113452, 0.07531753786885376, 0.02792765629665228, 0.039066330861079135, 0.021796384645279443, 0.08069646561978527, 0.07633959553005865, 0.05936879018973107, 0.0, 0.0, 0.0, 0.0130178395971976, 0.01033076159090529, 0.012366997431183968, 0.008828702391989074, 0.010645792822535638, 0.011110405468813034, 0.11629015852319369, 0.1304161139054778, 0.11640369798207884, 0.0, 0.0, 0.0]}}
{"id": "2bb98857-d96a-4c0d-ab03-d322c28359ac", "fitness": 0.03844373330405508, "name": "EnhancedAdaptiveDynamicInertiaSwarmOptimizer", "description": "Utilize dynamic inertia weight adjustment and adaptive chaotic perturbation with enhanced convergence metric to optimize exploitation in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDynamicInertiaSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.3\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.5\n        self.cognitive_coefficient_max = 2.5\n        self.social_coefficient_min = 1.5\n        self.social_coefficient_max = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def dynamic_inertia_weight(self, diversity, evaluations):\n        cycle_position = (evaluations % self.budget) / self.budget\n        return self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * cycle_position\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.dynamic_inertia_weight(diversity, evaluations)\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedAdaptiveDynamicInertiaSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03844 with standard deviation 0.04413.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.12380954644021047, 0.10461051426346046, 0.1540716606144923, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.021011509017475283, 0.021204252293494652, 0.021031980163499386, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0810578984978636, 0.06807389425740074, 0.057975449666793355, 0.029024524334054114, 0.031767671052776, 0.020000000000000018, 0.055811686352276735, 0.09139911049002247, 0.08703535043745092, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0282202203181956, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13357853791305419, 0.10142528476344892, 0.16264515601586793, 0.03698553248807113, 0.020366861014303517, 0.026216415911155755, 0.08382366288895426, 0.0863116411064907, 0.07611024997549254, 0.147236907255883, 0.13323277534341382, 0.14111647199337596, 0.07943872990939671, 0.07990382579724953, 0.07552612254070512, 0.14466998227502526, 0.11406924726030487, 0.14196195479208484, 0.020000000000000018, 0.020000000000000018, 0.12986509865872786, 0.16472605256521178, 0.08204515388384548, 0.1029979332011588, 0.06923343135320659, 0.05993151036561817, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.054892120464443805, 0.03392426887360889, 0.02657375009670604, 0.049667648388621366, 0.03661426010602964, 0.04750037757181402, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06058866958578679, 0.026782041737268725, 0.03961847236549021, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08942832626013142, 0.06875749285951438, 0.10180128303062175, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.054742294379524825, 0.06587533913423416, 0.05873637387144082, 0.12411998248485512, 0.10666519304359723, 0.10756014529127167, 0.06907067268761946, 0.04168411465092148, 0.056937999053902955, 0.10013701725336432, 0.08333530572493553, 0.08971264008049151, 0.11355341051638124, 0.010000000000000009, 0.010000000000000009, 0.030747092763673045, 0.037650628098608085, 0.031392249588771626, 0.026679350551169434, 0.024390411358627517, 0.024659897567862687, 0.13141309820135194, 0.13944756169745698, 0.13589314765007177, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004000631738668714, 0.000126052148210265, 0.0006818899537230916, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006640012228592784, 0.006433707840226899, 0.0008325854550984557, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03291247549521148, 0.03921262738310971, 0.031472410175470644, 0.0, 0.0, 0.0, 0.03446182412572096, 0.03753213255583987, 0.03551388022369095, 0.08588820410019549, 0.09162213649615647, 0.07546852190577225, 0.027985639559009123, 0.026166202016919105, 0.024717013691669232, 0.0887523021049611, 0.07517950102411108, 0.06248136084342859, 0.0, 0.0, 0.0, 0.011008301607736137, 0.009920436178515901, 0.01279306330040908, 0.007624135528947473, 0.010454671290810569, 0.011012146258057909, 0.11771426701744725, 0.1304161139054778, 0.12375439351981998, 0.0, 0.0, 0.0]}}
{"id": "720e494d-6c03-4e8e-b9e1-600f5e5c1cfa", "fitness": -Infinity, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce dynamic adjustment of population size based on swarm diversity to enhance convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            # Dynamic adjustment of population size based on diversity\n            self.population_size = max(10, int(20 * (1 + diversity)))\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 53, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {}}
{"id": "107061eb-6020-4cf9-bde4-2ef8e68a5f50", "fitness": 0.04115777074326354, "name": "EnhancedAdaptiveChaoticSwarmOptimizerV2", "description": "Introduce diversity-driven adaptive swarm size and self-organizing velocity updates to enhance exploration-exploitation dynamics in chaotic swarm optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def adaptive_population_size(self, diversity):\n        return int(self.initial_population_size * (1 + diversity / self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.initial_population_size)\n        \n        while evaluations < self.budget:\n            population_size = self.adaptive_population_size(self.calculate_swarm_diversity())\n            for i in range(min(self.initial_population_size, population_size)):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(min(self.initial_population_size, population_size)):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04116 with standard deviation 0.04686.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16865998096814616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07801454253562246, 0.0553122962098519, 0.05198315820751109, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.09485730377370705, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14463712210405333, 0.020000000000000018, 0.1086159632455298, 0.12676342425437725, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.026701114134553783, 0.053838723921108, 0.03551333365980991, 0.06251255694319513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052702310810223474, 0.020847090132434687, 0.039316127913145094, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.0690653278680835, 0.09080654473535488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05780285201293789, 0.08247904677910156, 0.06867912522087483, 0.13804028487350517, 0.10059146989951873, 0.11603057182456822, 0.07410737848799231, 0.055126236516060634, 0.053936809511723194, 0.09976547839093342, 0.08771993984301896, 0.10056258027619447, 0.06097698395185991, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.04354085641787209, 0.03083544610086375, 0.03247085960834395, 0.02491452834504637, 0.1460367740450299, 0.14995508500329047, 0.14920580819420282, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004255476537909475, 0.0006042807216090074, 0.0025435677552880787, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006201338235310883, 0.0, 6.427131687591903e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036761437563427646, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.04564205767772611, 0.041347738990614835, 0.034701169303381074, 0.08619032856391196, 0.08768521211623048, 0.07539063132411894, 0.027829751322100305, 0.038900516868527135, 0.022320025379924835, 0.08599548987369887, 0.07323695824976861, 0.063094016091916, 0.0, 0.0, 0.0, 0.01306696150149278, 0.010331259699854045, 0.012399266354949146, 0.008777970646403177, 0.01064139933457231, 0.011142454355775877, 0.11448749052965057, 0.1304161139054778, 0.12222123200721113, 0.0, 0.0, 0.0]}}
{"id": "8bd031bf-8d61-46c0-aba1-dfa54d6afd76", "fitness": 0.037971531949716565, "name": "NeurodynamicChaoticSwarmOptimizer", "description": "Introduce a dynamic chaotic perturbation strategy with adaptive neurodynamic-based velocity updates to enhance the exploration-exploitation balance for superior convergence in black-box optimization.", "code": "import numpy as np\n\nclass NeurodynamicChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.chaotic_factor = np.random.rand(self.population_size)\n        self.c1_initial = 2.5\n        self.c2_initial = 0.5\n        self.inertia_weight = 0.729\n        self.chaotic_intensity = 0.5\n\n    def logistic_map(self, x, r=4.0):\n        return r * x * (1 - x)\n\n    def chaotic_perturbation(self, position):\n        return position + self.chaotic_intensity * np.random.uniform(-1, 1, size=self.dim)\n\n    def adaptive_neurodynamic_velocity(self, i, diversity):\n        c1 = self.c1_initial - diversity * (self.c1_initial - 1.5)\n        c2 = self.c2_initial + diversity * (2.5 - self.c2_initial)\n        inertia = self.inertia_weight * self.velocities[i]\n        cognitive = c1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n        social = c2 * np.random.rand() * (self.global_best_position - self.positions[i])\n        return inertia + cognitive + social\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n\n            for i in range(self.population_size):\n                self.chaotic_factor[i] = self.logistic_map(self.chaotic_factor[i])\n                self.velocities[i] = self.adaptive_neurodynamic_velocity(i, diversity)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_perturbation(self.positions[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 55, "feedback": "The algorithm NeurodynamicChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03797 with standard deviation 0.06352.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.08253869520449197, 0.07602287599886492, 0.12201842119071116, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08451491123907118, 0.7585557980550941, 0.06222925186450734, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027015723451027873, 0.08594148016760361, 0.08930698704416384, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12091944974955426, 0.1013233900819892, 0.1313507402454832, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08166856294279601, 0.0863116411064907, 0.07168658951189111, 0.12990506644848054, 0.13323277534341382, 0.1160417955509998, 0.06458743453121485, 0.07990382579724953, 0.05610455226583122, 0.1202268297318918, 0.08503307741421029, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16719506670147666, 0.07292120586292017, 0.11006751161510497, 0.06527120746322768, 0.04616535580723691, 0.056492493752391515, 0.1473024093114026, 0.13589170657517036, 0.15475448018179316, 0.04340386290355491, 0.034906080824888, 0.02657375009670604, 0.023605947429338858, 0.015177948844331102, 0.039370847441834944, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08261770245691347, 0.03726816284166101, 0.06115437259069578, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07745106570732974, 0.05115711809036294, 0.07454370285145362, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.054904138422838034, 0.06147825531143891, 0.06011310414904969, 0.12153004129913958, 0.0954750122799295, 0.10281775224528589, 0.06116850300458676, 0.03518359929680204, 0.053936809511723194, 0.08115433583305187, 0.06539405484546112, 0.09429408100724512, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02686143845494937, 0.03015340633010577, 0.029543385815179346, 0.024895242935785933, 0.022487143875263516, 0.024640285494433645, 0.1413516077977235, 0.1337546573086903, 0.13600495694343973, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.005931665736863656, 0.0, 0.0022700854861735786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.015781468267444754, 0.006103362701087356, 0.0006895197929691621, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0272549744938142, 0.039867496446087336, 0.02404650667220065, 0.0, 0.0, 0.0, 0.03225881605184999, 0.04690435395736858, 0.033605611237027766, 0.08072778292416571, 0.08294123825641764, 0.07037484042883169, 0.026013506532659214, 0.03212313855720794, 0.018449874749746464, 0.07591637312206301, 0.07573275143415015, 0.0680956205674711, 0.0, 0.0, 0.0, 0.010488044048592937, 0.011323725468116552, 0.011240425634319262, 0.008048085675460892, 0.010051284513262426, 0.00757999124869857, 0.12253521544002444, 0.1304161139054778, 0.11628557999787081, 0.0, 0.0, 0.0]}}
{"id": "6bdc4e64-6959-4044-bd56-48331dffff8e", "fitness": 0.04110524216979455, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce an adaptive mutation strategy based on diversity and implement Gaussian perturbations to enhance local search capabilities in the EnhancedAdaptiveChaoticSwarmOptimizer.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def gaussian_perturbation(self, position, scale):\n        return position + scale * np.random.normal(0, 1, self.dim)\n\n    def adaptive_mutation(self, position, diversity):\n        mutation_scale = 0.01 + 0.1 * (1 - diversity / self.dim)  # Adaptive mutation scale\n        return self.gaussian_perturbation(position, mutation_scale)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.adaptive_mutation(self.positions[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04111 with standard deviation 0.04658.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11826719857100043, 0.11095230946083634, 0.1657582925795167, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03614524717495948, 0.025479345071211745, 0.030375076141431756, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0781240775697577, 0.05518074106377013, 0.05201232613125595, 0.10350062388933223, 0.0309805960994447, 0.020000000000000018, 0.062266113622002184, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.030188364798826473, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1345104713818388, 0.12810920113122481, 0.18450660346907677, 0.028578230283719086, 0.028208148391169918, 0.03322637002473561, 0.08072694858327945, 0.0863116411064907, 0.0970314050017721, 0.16071680041640946, 0.1705631837311029, 0.13884473438111433, 0.0880045106036963, 0.07990382579724953, 0.08149721384769126, 0.13260321934402752, 0.11892694650091229, 0.1293179892690861, 0.020000000000000018, 0.10430123655279788, 0.12707320678969058, 0.1676708224227883, 0.09327367199927028, 0.09288560104929078, 0.09086331553110227, 0.09606616918397715, 0.09988234186944256, 0.15875852791331568, 0.1558132646653566, 0.15475448018179316, 0.054201912813693576, 0.04672003628689336, 0.049375717847532585, 0.05324112160930983, 0.03610116072710379, 0.0627803334506325, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052666350142593465, 0.02110145044925449, 0.039536816016956466, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08912728923939439, 0.06878230425634924, 0.09041305714899806, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06214281743736971, 0.07481833497133661, 0.06762476500953252, 0.1356858630944734, 0.11082136320001568, 0.10607507967357621, 0.06870983143617759, 0.057716533786381086, 0.05409086326189472, 0.10875681967778572, 0.09878955363328057, 0.10106811084984824, 0.06366067326635294, 0.010000000000000009, 0.010000000000000009, 0.03430159035008473, 0.030408191685095676, 0.045093344794158274, 0.029178584369689564, 0.03285355373621446, 0.02492347280477203, 0.14366311524220765, 0.13123409970527322, 0.14141398090951574, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004757059100936378, 0.0003052534849643518, 0.003143170782625493, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005796045421722074, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03716314448733382, 0.03776668007966477, 0.029614218952174087, 0.0, 0.0, 0.0, 0.04289391755979144, 0.045708372888765614, 0.03682278567790087, 0.08534355146735506, 0.08950151758909097, 0.0766993400765118, 0.027171377145472464, 0.03372491650117837, 0.02064142547528236, 0.08401298403765944, 0.07788606103115858, 0.06391415105078946, 0.0, 0.0, 0.0, 0.013033957266805452, 0.010293795720026866, 0.012646151361650038, 0.007909133200936225, 0.010655239580098175, 0.011358767857154062, 0.1189880124395799, 0.1304161139054778, 0.1119534933915457, 0.0, 0.0, 0.0]}}
{"id": "f5dcb73d-af84-4358-ba27-43a715fb8812", "fitness": 0.03796309845743165, "name": "ImprovedChaoticMultiEliteOptimizer", "description": "Introduce a synergy of chaotic inertia weight adaptation with a dynamic multi-elite pooling strategy to enhance global exploration and local exploitation balance for superior convergence in black-box optimization.", "code": "import numpy as np\n\nclass ImprovedChaoticMultiEliteOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.elite_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.elite_positions = np.zeros((self.elite_size, dim))\n        self.elite_scores = np.full(self.elite_size, np.inf)\n        \n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def update_elite_pool(self, scores):\n        combined_scores = np.hstack((self.elite_scores, scores))\n        combined_positions = np.vstack((self.elite_positions, self.positions))\n        elite_indices = np.argsort(combined_scores)[:self.elite_size]\n        self.elite_scores = combined_scores[elite_indices]\n        self.elite_positions = combined_positions[elite_indices]\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n            self.update_elite_pool(self.personal_best_scores)\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                best_elite_position = self.elite_positions[np.random.randint(self.elite_size)]\n                social = self.social_coefficient * chaotic_factor[i] * (best_elite_position - self.positions[i])\n\n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        best_index = np.argmin(self.elite_scores)\n        return self.elite_positions[best_index], self.elite_scores[best_index]", "configspace": "", "generation": 57, "feedback": "The algorithm ImprovedChaoticMultiEliteOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03796 with standard deviation 0.04280.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.10890997520237422, 0.08620644444887393, 0.13836054311395685, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.026522262410328734, 0.030722500959798782, 0.024630416228644147, 0.026972816369538632, 0.020000000000000018, 0.020000000000000018, 0.07126401365783575, 0.05171980679947086, 0.06259347185394826, 0.020000000000000018, 0.07147709951346859, 0.020000000000000018, 0.03731647316627673, 0.09510363210192874, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037033770603938754, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1298281766923699, 0.11120769330908387, 0.13974213964979687, 0.020087087651364133, 0.02462172639347837, 0.03287226306656943, 0.0907309893430045, 0.09630146557312014, 0.08846095942848764, 0.15198596181403845, 0.13402750139565012, 0.12309581006425152, 0.10356875258669618, 0.11258474871718083, 0.05610455226583122, 0.12340629547832005, 0.10772790975831503, 0.12626898744667503, 0.10896008701163307, 0.020000000000000018, 0.10598152094414137, 0.11930907912279065, 0.1025893863977494, 0.0895133107273659, 0.06527120746322768, 0.04616535580723691, 0.07577467618239098, 0.14415701594860086, 0.1383020827305831, 0.15475448018179316, 0.058502720288769905, 0.0429519321592845, 0.047478797391022454, 0.03885083795591493, 0.036953036585659516, 0.05324919456009236, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03978862203606359, 0.020685706715505625, 0.022347643486213986, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02988193080709267, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.07775381657741165, 0.06965615881547615, 0.07446297080554631, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06170198966858098, 0.061908890635143154, 0.05395939349942802, 0.12188513882830943, 0.1155145195301518, 0.10425387634334382, 0.061669906150856546, 0.06046413178961041, 0.05554773593075557, 0.10310830174404129, 0.0870949528418814, 0.09806501748793661, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.028769558849600863, 0.03377200611778319, 0.0276194279307026, 0.025548655468088155, 0.025274621544117415, 0.024880872913607965, 0.13141702328561844, 0.13689302043960472, 0.1406104970380626, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0011489255882082272, 0.0, 0.008473098966799708, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0037690970246549993, 0.0, 0.00012772028905727595, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03416962271061186, 0.03664200188013922, 0.03270321288372713, 0.0, 0.0, 0.0, 0.032183401147938606, 0.03753213255583987, 0.03508340347355121, 0.08635562832610588, 0.08350907370677885, 0.08767879714612337, 0.029571115982236607, 0.027290649018644197, 0.020704941801128918, 0.08190671639869318, 0.06917186729459024, 0.07718533286657658, 0.0, 0.0, 0.0, 0.011445896433132763, 0.009273778755086282, 0.00955795952287164, 0.007722089283786482, 0.010777293580666814, 0.00980745789540649, 0.1228010319469881, 0.13345479311720665, 0.11342690763991581, 0.0, 0.0, 0.0]}}
{"id": "bf1f0f9c-2eb8-49c3-90f2-3072f5efd89d", "fitness": 0.0378426742001964, "name": "QuantumEnhancedChaoticSwarmOptimizer", "description": "Integrate adaptive chaotic perturbations and multi-strategy exploration leveraging quantum-inspired updates for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass QuantumEnhancedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def quantum_inspired_update(self, position, personal_best, global_best):\n        phi = np.random.uniform(0, np.pi, size=self.dim)\n        step = np.random.choice([-1, 1], size=self.dim) * np.sin(phi)\n        return position + step * (personal_best + global_best - 2 * position)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = self.quantum_inspired_update(self.positions[i], self.personal_best_positions[i], self.global_best_position)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 58, "feedback": "The algorithm QuantumEnhancedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03784 with standard deviation 0.04408.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.09060162018282891, 0.0899215652084463, 0.12616170550725325, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.027263185033405635, 0.02356831614098953, 0.028740609691684793, 0.0274736542719356, 0.020000000000000018, 0.020489620523581498, 0.08276931937955512, 0.06302150869425271, 0.06494754100838218, 0.020000000000000018, 0.03501189823434203, 0.020000000000000018, 0.05672444941473376, 0.08594148016760361, 0.07885460651766352, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.12631375378564802, 0.12427824048709113, 0.1686206026717071, 0.02211371077364599, 0.03410281580059438, 0.029623923242564243, 0.11400362781337914, 0.08989940747227965, 0.08727300014542205, 0.14006957790542973, 0.13323277534341382, 0.16099106036818356, 0.06862420988388895, 0.07990382579724953, 0.09446294481077533, 0.13457346529913394, 0.12761403707257524, 0.1365926895750006, 0.020000000000000018, 0.026845395742881917, 0.11113878264854704, 0.19977038261876034, 0.09112216868070933, 0.11499264639241913, 0.06527120746322768, 0.05580449998969372, 0.06729408161611672, 0.1438990366235351, 0.14179443735376762, 0.15475448018179316, 0.038669801718039354, 0.04137899358341601, 0.032293241760361635, 0.05286765034009522, 0.03729111092408588, 0.052010896436195275, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05005577255131144, 0.0261721688418719, 0.02382780249454841, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09948990711231043, 0.06886728804870912, 0.08846694549473055, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057794233712779586, 0.06161559354510926, 0.0582367817792151, 0.12800541852114822, 0.10186993802745614, 0.10281775224528589, 0.061087195581899234, 0.05269687464313033, 0.05405033844090923, 0.08900727799211505, 0.08534568523613062, 0.09881694870017899, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03192505429970793, 0.029802595650119112, 0.030899762957656285, 0.029671241550495053, 0.025651441291988597, 0.024640285494433645, 0.13255410807119605, 0.1327610412575485, 0.14234613700374066, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.002711419718792407, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005678759695281643, 0.0004796761465319932, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.042460551015392034, 0.0326031558028943, 0.025185783373438353, 0.0, 0.0, 0.0, 0.03533439670023131, 0.03981679928702164, 0.031371834036884705, 0.08270507677753158, 0.0927794333815547, 0.0740494624472815, 0.03000561155304904, 0.025888720961374734, 0.020831190073111516, 0.07043346187805188, 0.07647426912546307, 0.05389106633480378, 0.0, 0.0, 0.0, 0.011372845236917617, 0.010837145223587807, 0.012521281647939198, 0.0075321170129757364, 0.010051284513262426, 0.011761884258338906, 0.11335000246397442, 0.1304161139054778, 0.11401513182724643, 0.0, 0.0, 0.0]}}
{"id": "ff4da326-e6b6-45fb-998e-9ed0b024580b", "fitness": 0.04089759682450445, "name": "AdvancedDynamicChaoticSwarmOptimizer", "description": "Introduce dynamically adjusted chaotic perturbations and adaptive exploration-exploitation mechanisms to improve convergence in complex search spaces.", "code": "import numpy as np\n\nclass AdvancedDynamicChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1  # Adjusted for better exploration\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.5 * (1 - diversity / self.dim)  # More aggressive Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.02 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 59, "feedback": "The algorithm AdvancedDynamicChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04090 with standard deviation 0.04645.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11745957328468815, 0.11040922731175096, 0.17012072331457273, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03291207424714515, 0.02327136567072674, 0.03204136693238657, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07797494104885827, 0.055381379619548476, 0.052000360065152296, 0.10397547974108168, 0.02958859994368357, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.02384665442243683, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037202665944635616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13916910940912464, 0.13168124326473618, 0.183247417330482, 0.0254511620779454, 0.029336012346050544, 0.03336519853409581, 0.08072694858327945, 0.0863116411064907, 0.09144379771278499, 0.14914111512448003, 0.17153715314934315, 0.1324345901601217, 0.08957100005668683, 0.07990382579724953, 0.08081654996395427, 0.1383790592780647, 0.11688047359401987, 0.13883438469077503, 0.020000000000000018, 0.10941720761639606, 0.12356814437619623, 0.16539952253666568, 0.09021113911263268, 0.10736259159082506, 0.09527839720538944, 0.08331671860364454, 0.10007266157172756, 0.1586492688249166, 0.13589170657517036, 0.15475448018179316, 0.05932356581075382, 0.05681972910288724, 0.027307644955494093, 0.05328811275730172, 0.03509568887462278, 0.062083984097240696, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05256208479268676, 0.02102600004421107, 0.03934055905507572, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018497208004439325, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0896873472861851, 0.0683298611866684, 0.0919704314471399, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05525327034944272, 0.07846924941457534, 0.06657473161300487, 0.12933426075695298, 0.10889244428162148, 0.11300267990984336, 0.07323679527915805, 0.05107764422662253, 0.053936809511723194, 0.09616510085723218, 0.09392404645597952, 0.11235639414596887, 0.05485114646037348, 0.010000000000000009, 0.010000000000000009, 0.034975568888160335, 0.03079255694156602, 0.04257492433125065, 0.03128852623709577, 0.032107552470124756, 0.025021789083461532, 0.1474705998537721, 0.1423412921286462, 0.14045623437056864, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003951668387927931, 0.0007847651075139073, 0.002209651803564139, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006175406041205811, 0.0, 3.2524087666852e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03640775378533789, 0.03796499578803203, 0.030136751990212596, 0.0, 0.0, 0.0, 0.03743522429455526, 0.03959495805351754, 0.03928933267111889, 0.08661398304616286, 0.08850160641079075, 0.07517220693927418, 0.0271553411570018, 0.03940584164566485, 0.021252400351617573, 0.08457099656682376, 0.07578976112621749, 0.06164307111530887, 0.0, 0.0, 0.0, 0.012880383891819891, 0.010329248841959626, 0.01229629450130576, 0.008002231132610116, 0.010651168295786273, 0.011155432453979541, 0.11382702655638499, 0.13093035608278203, 0.11074945361895805, 0.0, 0.0, 0.0]}}
{"id": "fa1256e5-5a6a-4ecb-a282-2746f4b0e4df", "fitness": 0.04115777074326354, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce an adaptive inertia weight strategy to further balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                \n                # Updated line with adaptive inertia weight strategy\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i] * (1 - diversity / self.dim) \n                \n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04116 with standard deviation 0.04686.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16865998096814616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07801454253562246, 0.0553122962098519, 0.05198315820751109, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.09485730377370705, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14463712210405333, 0.020000000000000018, 0.1086159632455298, 0.12676342425437725, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.026701114134553783, 0.053838723921108, 0.03551333365980991, 0.06251255694319513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052702310810223474, 0.020847090132434687, 0.039316127913145094, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.0690653278680835, 0.09080654473535488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05780285201293789, 0.08247904677910156, 0.06867912522087483, 0.13804028487350517, 0.10059146989951873, 0.11603057182456822, 0.07410737848799231, 0.055126236516060634, 0.053936809511723194, 0.09976547839093342, 0.08771993984301896, 0.10056258027619447, 0.06097698395185991, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.04354085641787209, 0.03083544610086375, 0.03247085960834395, 0.02491452834504637, 0.1460367740450299, 0.14995508500329047, 0.14920580819420282, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004255476537909475, 0.0006042807216090074, 0.0025435677552880787, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006201338235310883, 0.0, 6.427131687591903e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036761437563427646, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.04564205767772611, 0.041347738990614835, 0.034701169303381074, 0.08619032856391196, 0.08768521211623048, 0.07539063132411894, 0.027829751322100305, 0.038900516868527135, 0.022320025379924835, 0.08599548987369887, 0.07323695824976861, 0.063094016091916, 0.0, 0.0, 0.0, 0.01306696150149278, 0.010331259699854045, 0.012399266354949146, 0.008777970646403177, 0.01064139933457231, 0.011142454355775877, 0.11448749052965057, 0.1304161139054778, 0.12222123200721113, 0.0, 0.0, 0.0]}}
{"id": "ebbd77ef-26a0-4c8e-ba3b-b8a19b4d99a1", "fitness": 0.04111091408396798, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhance convergence by refining chaotic mutation with a sinusoidal perturbation factor.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        # Modified line: Integrate sinusoidal perturbation factor\n        return position + mutation_scale * chaotic_value * np.sin(factor * np.pi) * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04111 with standard deviation 0.04665.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799960979470425, 0.11040400259272731, 0.16838507880289488, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03484211708462437, 0.025551276431639014, 0.03106988453311743, 0.020000000000000018, 0.020000000000000018, 0.02015010206911161, 0.07803448619397668, 0.055279938928011196, 0.05196971946694107, 0.10363606129594527, 0.02960587003048276, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03711371431036936, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13701725648012741, 0.1295741390127766, 0.18396291374558527, 0.028269917776563847, 0.029522587468544526, 0.030965573872180685, 0.08072694858327945, 0.0863116411064907, 0.09356002823449983, 0.1543336673631175, 0.1670042739182912, 0.13243477076822474, 0.08449547721149608, 0.07990382579724953, 0.08081639127333617, 0.1525122113813172, 0.11070451083040966, 0.14217006638750662, 0.020000000000000018, 0.10877258177511351, 0.12650479315913032, 0.16613638750807636, 0.09090634150458665, 0.09161814988425265, 0.09266229071255994, 0.08866969558258087, 0.09991993398717836, 0.1438526290318487, 0.13783176448793055, 0.15475448018179316, 0.0494017735043869, 0.05779331440521018, 0.03448625949002182, 0.05385087043552128, 0.03555937415194721, 0.0625497001397286, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05268385525107233, 0.020829640499561375, 0.03931531264882526, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014822056781269577, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08948501989340896, 0.0692770723297097, 0.09083114973806583, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05783673947914536, 0.07976846161114348, 0.06866950848292419, 0.13647723219224606, 0.10059365266464904, 0.11658196052400749, 0.07338360253368781, 0.055454557169720475, 0.053936809511723194, 0.09687312176556306, 0.09786744990578089, 0.1017600092608858, 0.06095210960054831, 0.010000000000000009, 0.010000000000000009, 0.034564375856926954, 0.030632235823786935, 0.043624986001819965, 0.030771094329967608, 0.03256141722062522, 0.0249151928847563, 0.14845958637951995, 0.15162758627728123, 0.16266544831829066, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004300654122541214, 0.0006360376824453562, 0.002563197908114434, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00622451752425901, 0.0, 4.732701403553641e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03677473324100644, 0.03797528604057154, 0.030028208425368685, 0.0, 0.0, 0.0, 0.04538478299320858, 0.04196145178679811, 0.03545247542335361, 0.0860553026248373, 0.08740368812685662, 0.07553168823863754, 0.027799125871880603, 0.03887452092599697, 0.022363955018984805, 0.08512813431878508, 0.0773563907404955, 0.06444524919058647, 0.0, 0.0, 0.0, 0.013071055894397388, 0.01032784518908969, 0.012413497224854186, 0.008743842135265911, 0.010638967856177461, 0.011149859984947552, 0.11262361297569523, 0.1304161139054778, 0.11061421995530352, 0.0, 0.0, 0.0]}}
{"id": "f6f80eda-4cf0-4e47-89ef-61be1a634b34", "fitness": -Infinity, "name": "EnhancedAdaptiveChaoticParticleSwarm", "description": "Enhance convergence by introducing dynamic chaotic sequences and adaptive mutation scales to improve exploration capabilities and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.5\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def sinusoidal_map(self, x):\n        return 0.5 + 0.5 * np.sin(np.pi * x)\n\n    def adaptive_mutation(self, position, factor):\n        mutation_scale = 0.01 + 0.04 * factor\n        chaotic_value = self.sinusoidal_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.sinusoidal_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.adaptive_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 62, "feedback": "An exception occurred: AttributeError(\"'EnhancedAdaptiveChaoticParticleSwarm' object has no attribute 'levy_flight'\").", "error": "AttributeError(\"'EnhancedAdaptiveChaoticParticleSwarm' object has no attribute 'levy_flight'\")", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {}}
{"id": "b5b5c48a-4018-49a8-981c-45192cafbde0", "fitness": -0.02020561405055792, "name": "EnhancedAdaptiveOppositionChaoticSwarmOptimizer", "description": "Synergize adaptive control of chaotic exploration with strategic adaptive opposition-based learning to enhance global search efficiency and solution quality in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  \n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                \n                if np.random.rand() < 0.2:  # Probability for opposition-based learning\n                    opposite_position = self.opposition_based_learning(self.positions[i])\n                    opposite_score = func(opposite_position)\n                    evaluations += 1\n                    if opposite_score < score:\n                        self.positions[i] = opposite_position\n                        score = opposite_score\n\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedAdaptiveOppositionChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02021 with standard deviation 0.11349.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11720348978093909, 0.10995121545473496, 0.1621470722590126, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02772271869351839, 0.025943321415473175, 0.03260078577502634, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07425984131146568, 0.0538041343850878, 0.0504452931130841, 0.10144087760644416, 0.020000000000000018, 0.020000000000000018, 0.057001259713709285, 0.08594148016760361, 0.10899958824994538, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03625213702654295, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1318629897271264, 0.12873890125724496, 0.18295700591307762, 0.028500676587500773, 0.029544970649087676, 0.0327743475712432, 0.08072694858327945, 0.0863116411064907, 0.07261929985545434, 0.15031767586019384, 0.16992881728753928, 0.1338875454501689, 0.0840971231351173, 0.07990382579724953, 0.07954866226102864, 0.1386710330205807, 0.1405124550799376, 0.15091475034725077, 0.020000000000000018, 0.09881358738518986, 0.12138241346437284, 0.16434062527256965, 0.09104908795537991, 0.0922831074123096, 0.06527120746322768, 0.08724465013171734, 0.09745346657901943, 0.14858999627944047, 0.13589170657517036, 0.15475448018179316, 0.04409707692088416, 0.05689433852004955, 0.04707920085532902, 0.05407040127515372, 0.035981335038157924, 0.06207616929383564, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.043197633675604696, 0.017325739244074434, 0.03472219247619024, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020996275483092575, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08789440328838527, 0.07099143967259125, 0.08772812876831182, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057307872551400574, 0.07564755037924475, 0.06920866926300218, 0.12981747906315955, 0.10670505125261187, 0.11171537954058064, 0.0728541716260489, 0.052451432208417526, 0.055617343105522576, 0.0969914232087633, 0.0985965966852066, 0.10813226275313115, 0.04852999394360613, 0.010000000000000009, 0.010000000000000009, 0.034066519318525335, 0.029043163533977734, 0.045985108444129175, 0.025548234586433738, 0.03255253777564848, 0.024640285494433645, 0.13197782854903084, 0.1321050511499089, 0.13457569026318383, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.20403445683246124, -0.16915625175288507, -0.17684089149642146, -0.17999999999999994, -0.17999999999999994, -0.17999999999999994, -0.18999999999999995, -0.16999999999999993, -0.20999999999999996, -0.18999999999999995, -0.16999999999999993, -0.17999999999999994, -0.20225669312280892, -0.20999999999999996, -0.21999999999999997, -0.17999999999999994, -0.16999999999999993, -0.16999999999999993, -0.18999999999999995, -0.16999999999999993, -0.1200000000000001, -0.20999999999999996, -0.17999999999999994, -0.16999999999999993, -0.20999999999999996, -0.16999999999999993, -0.1100000000000001, -0.19999999999999996, -0.17999999999999994, -0.16999999999999993, -0.20999999999999996, -0.21999999999999997, -0.17999999999999994, -0.20999999999999996, -0.17999999999999994, -0.1399999999999999, -0.26, -0.15999999999999992, -0.20999999999999996, -0.17452391153324887, -0.17290907803428368, -0.11359056453927963, -0.20999999999999996, -0.15999999999999992, -0.17999999999999994, -0.11991191004825286, -0.11545482503419757, -0.13324741422733033, -0.1153095342790631, -0.06819749136861342, -0.07079501690859069, -0.15841222681180067, -0.12696309993074606, -0.09711240915167063, -0.11803001817334535, -0.0664991710115177, -0.12834419309466294, -0.21999999999999997, -0.16999999999999993, -0.21999999999999997, -0.19443563643215866, -0.16774963566098577, -0.16526852294295602, -0.18971152036615724, -0.20680439276014617, -0.1669453852519951, -0.07287514937793471, 0.13065826358431565, -0.03942169071129209, -0.24, -0.16999999999999993, -0.19999999999999996]}}
{"id": "ba7105e7-ea45-4793-9efc-be61a777cf14", "fitness": 0.04095066157564555, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Integrate dynamic learning coefficients and chaotic perturbations with enhanced levy flight probability adjustment for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.25 + 0.3 * (1 - diversity / self.dim)  # Adjusted Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04095 with standard deviation 0.04633.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11801642961299796, 0.11043295399013597, 0.16804455253864004, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.038198199612328954, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.02075915594082034, 0.07809638270509023, 0.05532968058023613, 0.051977797617139054, 0.10377292628748325, 0.02966178450531398, 0.020000000000000018, 0.06422823446531656, 0.08594148016760361, 0.11179796376536022, 0.031508432312731705, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13789808766291634, 0.12810499167045553, 0.18388875101542024, 0.027232272429460358, 0.029432425048911415, 0.0321870294405574, 0.08072694858327945, 0.0863116411064907, 0.08983212435593302, 0.16060368928287472, 0.1688676934332065, 0.13243468046359386, 0.09347277172176038, 0.07990382579724953, 0.08081647062016684, 0.1296348043279414, 0.13437159945538835, 0.13889771049191624, 0.020000000000000018, 0.11076961557899023, 0.12581747432092039, 0.16662252184422288, 0.09178535641404073, 0.09357870228862086, 0.08631667044743774, 0.09046523081438496, 0.09883073629525763, 0.1438526290318487, 0.13943631953918934, 0.15475448018179316, 0.05051630689727549, 0.057417985508269265, 0.04003420293663307, 0.054516787525798804, 0.035735730643236874, 0.06251255694319513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05258701391697751, 0.020845838194361144, 0.039397209148032464, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08931800903662535, 0.06946930981272681, 0.08989434157959242, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055102845586556315, 0.07591712090274416, 0.06961238147374649, 0.13228534967787764, 0.1019707990095472, 0.11126151178961974, 0.07679838192168575, 0.056025786607575845, 0.053936809511723194, 0.09540909386818852, 0.08336438299310667, 0.09635731333206254, 0.056352300384592824, 0.010000000000000009, 0.010000000000000009, 0.032610860960487376, 0.030438758614043215, 0.044470895673074606, 0.027730360658428044, 0.032295824814041474, 0.024933959956834006, 0.1471497020947713, 0.13646763123062844, 0.14900898525871253, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004550327450210889, 0.0005276907324806013, 0.0032103303535915284, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006228168782388743, 0.0, 3.098751147267986e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03673506796927295, 0.03790799617102636, 0.03002510039895956, 0.0, 0.0, 0.0, 0.04238970756247473, 0.042982443249531155, 0.03516377275670601, 0.08619032856391196, 0.08588614595893473, 0.07590520505944853, 0.02542987553015774, 0.038900516868527135, 0.020363641717720538, 0.08599548987369887, 0.07558940771365097, 0.06236868001284235, 0.0, 0.0, 0.0, 0.013291391637485939, 0.010256870197116963, 0.012433133713692701, 0.008531929492729518, 0.010680629917133366, 0.011197769400822621, 0.12614772382458694, 0.1338350887918749, 0.11156679140755743, 0.0, 0.0, 0.0]}}
{"id": "b0c43928-f904-42fd-a77a-8cd85f2c5b6c", "fitness": 0.040948149380010866, "name": "RefinedAdaptiveChaoticSwarmOptimizer", "description": "Introduce a diversity-preserving mechanism and nonlinear dynamic inertia adjustment to enhance exploration and exploitation balance for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass RefinedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.diversity_threshold = 0.1\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        factor = 1 / (1 + np.exp(-10 * (diversity - self.diversity_threshold)))\n        return self.inertia_weight_min + factor * (self.inertia_weight_max - self.inertia_weight_min)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.adaptive_velocity_scaling(diversity)\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 65, "feedback": "The algorithm RefinedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04095 with standard deviation 0.04630.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11786877972893761, 0.11070257437102327, 0.168173929322455, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03605869242214599, 0.025812476369009074, 0.03119982939749788, 0.020000000000000018, 0.020000000000000018, 0.02040058446720361, 0.07795192714509258, 0.05538211060449927, 0.052039533660332093, 0.10375094539363572, 0.02974647688021481, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04335192871384652, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13739150570766, 0.1296852686076937, 0.1839523830981491, 0.02591329768530315, 0.030989010189003907, 0.03264807944014425, 0.08072694858327945, 0.0863116411064907, 0.10285730488087497, 0.14956225374626886, 0.15907444976684593, 0.13187952209499954, 0.0743721393102752, 0.07990382579724953, 0.07953150004393938, 0.12895099422312317, 0.12302544827429218, 0.14191710501225485, 0.020000000000000018, 0.10830259945182408, 0.12616785013963128, 0.1656987854596932, 0.09018417981840143, 0.11118122594281432, 0.09453861436435362, 0.08983735638251655, 0.10033813577349504, 0.14399432215847918, 0.14842254590365567, 0.15475448018179316, 0.05531401227888155, 0.04513840824908699, 0.02657375009670604, 0.05366526146951589, 0.035337357688328574, 0.062466057957973664, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052526619092564175, 0.020861419665786807, 0.03912775296913029, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02074844355847627, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08932205783623959, 0.06820520823926657, 0.09031061520359263, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05845904594171969, 0.08141302965229746, 0.06904749519572873, 0.14040260494462853, 0.1106856777493096, 0.11245968012019403, 0.06834688573417191, 0.05734908496011737, 0.05439753281034809, 0.10126668876103562, 0.08652364587380523, 0.1040729525174956, 0.05838389007043132, 0.010000000000000009, 0.010000000000000009, 0.035289272115113346, 0.030690028101203914, 0.0423533189181009, 0.03110750818197705, 0.032581761662285214, 0.024933183857030028, 0.14632484142708346, 0.14206380002365104, 0.13590008962570277, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.00459496888721711, 0.0008501178826385569, 0.003174578051256316, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006125678369918619, 0.0, 0.0002694193094384678, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.037073986557915495, 0.03833629480430856, 0.03013454404709437, 0.0, 0.0, 0.0, 0.04707920427291423, 0.042884100669193126, 0.03581778047235351, 0.0871374065434245, 0.08669077872630626, 0.07749999817425257, 0.028894389025438172, 0.03896074422572238, 0.019078539645970283, 0.07936608256237887, 0.07807756316353509, 0.06505323627060156, 0.0, 0.0, 0.0, 0.013105605646156149, 0.010322907416147276, 0.012273727709705362, 0.008757012066677006, 0.010714347430243354, 0.011085158728124322, 0.11142704065117992, 0.13185062001204018, 0.11876457914651584, 0.0, 0.0, 0.0]}}
{"id": "2017a4f0-786d-48e3-8952-1de79690c456", "fitness": 0.04087115818418141, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce dynamic mutation scale adjustment based on swarm diversity to improve convergence precision.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity): # Changed line\n        mutation_scale = 0.05 * (1 - diversity / self.dim) # Dynamic mutation scale adjustment\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity) # Updated call\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04087 with standard deviation 0.04602.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11861996084233084, 0.11040328277187428, 0.1670185436776742, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.025812619704741357, 0.026049567316146605, 0.030407704774082722, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07804982951536343, 0.055239457725063, 0.05196959425000647, 0.1034837743101309, 0.029608556685089438, 0.020000000000000018, 0.06422823446531656, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037108685342026604, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13553296750306476, 0.1280857729450966, 0.18461440913850835, 0.029172432271523996, 0.029550986024244996, 0.03152178221522428, 0.08072694858327945, 0.0863116411064907, 0.09283345095875406, 0.15878928742811926, 0.165435234931133, 0.134098325959645, 0.08950138333900948, 0.07990382579724953, 0.08081638234859378, 0.13285141793924327, 0.11987968959184603, 0.14095952326404726, 0.020000000000000018, 0.10709319218490865, 0.12687057744905195, 0.1670649826179652, 0.09114974367415674, 0.0931810800530638, 0.08799421067055335, 0.09323921151044634, 0.09990704134055806, 0.1438526290318487, 0.1372463511026677, 0.15475448018179316, 0.05026026488768309, 0.05787130492430437, 0.05440570912819864, 0.05417177136205342, 0.03575388425988446, 0.06302479981598952, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05266667014976745, 0.02084045197835993, 0.039299867135756616, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08939368887302224, 0.0699720294806867, 0.09098279765897144, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058612959095592276, 0.07577762995804915, 0.0737176627746865, 0.13556491618732391, 0.10106631360255536, 0.11610538079741217, 0.0717396824857357, 0.05525060313273955, 0.053936809511723194, 0.10214694269849545, 0.08588058441398672, 0.10643711287796731, 0.06106304298892351, 0.010000000000000009, 0.010000000000000009, 0.03409002161261554, 0.030574832859981416, 0.04380631373741939, 0.03090533284685848, 0.032819672658192856, 0.024921167276555245, 0.1406734117895726, 0.13123409970527322, 0.1381120941455941, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004444468536937918, 0.0005567818637409738, 0.002706812430529948, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006263155364427453, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03690899110576984, 0.03797793525869353, 0.029971308711804645, 0.0, 0.0, 0.0, 0.04543377191182829, 0.04421956135705085, 0.03362825407541903, 0.085855328058142, 0.08672415648901888, 0.07546084515019358, 0.027505339594723455, 0.03835920310886376, 0.021950052912857343, 0.08951138516135548, 0.07519090622980551, 0.06404470102059723, 0.0, 0.0, 0.0, 0.013123904802156527, 0.010331210605094565, 0.012447057906380898, 0.008701679396930784, 0.010633090572839898, 0.011169253660007095, 0.11342018450096347, 0.1304161139054778, 0.10782293007625565, 0.0, 0.0, 0.0]}}
{"id": "e20c06ce-448c-4f48-9c4f-ae8f640dd4b8", "fitness": 0.04084481530345792, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce a diversity-guided adaptive memory mechanism and chaotic local search to increase convergence speed and robustness in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))  # New memory concept\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def adaptive_memory_update(self, diversity):\n        # Adjust memory influence based on diversity\n        memory_influence = 0.1 + 0.5 * (1 - diversity / self.dim)\n        return memory_influence\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n            memory_influence = self.adaptive_memory_update(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                memory_effect = memory_influence * (self.memory[i] - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social + memory_effect\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n                \n                # Occasionally update memory to guide towards promising regions\n                if np.random.rand() < 0.05:\n                    self.memory[i] = self.positions[i]\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04084 with standard deviation 0.04725.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.18710309110025802, 0.1106262310029048, 0.15830276147067224, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03944756930850535, 0.02880961507403923, 0.03719704859338213, 0.027489511810362743, 0.031165330821803394, 0.02423304257915082, 0.0696281633418735, 0.056903187390911936, 0.05135886593754291, 0.02673535431309204, 0.02412891063591549, 0.020000000000000018, 0.058822579900601135, 0.08815900684305689, 0.10227952111194494, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16226221325320467, 0.14950185529459148, 0.15765024551046292, 0.04227558898283268, 0.022421616114094767, 0.041004937777299855, 0.08935355025966019, 0.0863116411064907, 0.07481246297481614, 0.15308834969966056, 0.15564860296214622, 0.1237383440940718, 0.0890132340180968, 0.07990382579724953, 0.08597355532624418, 0.14001062589346214, 0.1129673984339139, 0.13500594641819708, 0.12355574544747772, 0.020000000000000018, 0.11568650111264855, 0.17240891315242435, 0.09272692155046913, 0.0947667647785454, 0.07396695463762115, 0.12737584653745215, 0.10417953064297025, 0.14592786342367825, 0.14685333879989804, 0.17764874726216306, 0.049010630630651364, 0.04344500828834863, 0.0278022516382902, 0.03167573568848592, 0.051511722915908775, 0.06118201486091579, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05963076691868363, 0.020696312458300836, 0.020332097139553307, 0.010000000000000009, 0.010395271547679386, 0.010000000000000009, 0.015449328014747743, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09129315848810027, 0.08506709628353404, 0.10406191066017056, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.055190002331764854, 0.0673835804971995, 0.05395939349942802, 0.13177010302320202, 0.10467065809101883, 0.1051292225927124, 0.07911077025847901, 0.04543608175057545, 0.05865722941684348, 0.09545281036743436, 0.10239366395638116, 0.11475448180812564, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03704693528868164, 0.03410709599960815, 0.03092649156249261, 0.027272714349936944, 0.03734022787364355, 0.024879412680223978, 0.13141309820135194, 0.1434113462810973, 0.14090369940356584, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004485289359222988, 0.0015841344730770368, 0.010925915735611968, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005481075643147593, 0.0032086681872063316, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045674827006811025, 0.04782280645661441, 0.036755324009027146, 0.0, 0.0, 0.0, 0.03348736665278307, 0.039158268224311676, 0.0407621198327911, 0.08778207663481519, 0.0834591169702874, 0.08827827934628507, 0.026259698609716553, 0.028843379818551673, 0.023329474560395802, 0.0811326908169897, 0.07891687938099845, 0.06778876214437479, 0.0, 0.0, 0.0, 0.013116406994590935, 0.0117729299776268, 0.011473938817064822, 0.009340023856664992, 0.010051284513262426, 0.011276357232985701, 0.11685071602696862, 0.1349471841272586, 0.11732187287246998, 0.0, 0.0, 0.0]}}
{"id": "e7849b2b-8fe2-4991-b593-e939c85a86a5", "fitness": 0.041034397410983164, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "The EnhancedAdaptiveChaoticSwarmOptimizer is refined by incorporating diversity-based adaptive mutation scales and an elite preservation strategy to enhance convergence and robustness in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.elite_fraction = 0.1  # Fraction of the best solutions preserved\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity):\n        mutation_scale = 0.01 + 0.09 * (1 - diversity / self.dim)  # Adaptive mutation scale\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            sorted_indices = np.argsort(self.personal_best_scores)\n            num_elites = max(1, int(self.elite_fraction * self.population_size))\n            elites = sorted_indices[:num_elites]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                if i not in elites:\n                    levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                    if np.random.rand() < levy_prob:\n                        levy_step = 0.01 * self.levy_flight(self.dim)\n                        self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04103 with standard deviation 0.04628.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11843208525093796, 0.11040447216399574, 0.1659169739015215, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03588880105414749, 0.026061443650301608, 0.03048563401889892, 0.020000000000000018, 0.020000000000000018, 0.020006322544465993, 0.07800554522389402, 0.05516895642510877, 0.05195884913663873, 0.1034892421779603, 0.02957343572550941, 0.020000000000000018, 0.061766757066671674, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03711358598077952, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13564963371616412, 0.1286421489385018, 0.18455968398826528, 0.0289792860062269, 0.029552253930964167, 0.030399005490411746, 0.08072694858327945, 0.0863116411064907, 0.09960477133279477, 0.15714649548064974, 0.1660337731246213, 0.1359049060702746, 0.08978290651705745, 0.08012472341305266, 0.0808163910801446, 0.13387284158210078, 0.1189350054016296, 0.13449967651516137, 0.020000000000000018, 0.10712376896321418, 0.1270622254107029, 0.1667495141714752, 0.09111153759301216, 0.0930005918173461, 0.08460196269818576, 0.09250409886967814, 0.09991647085733402, 0.1438526290318487, 0.14072414676268308, 0.15475448018179316, 0.05236515995690949, 0.05787431819372191, 0.05001477107625474, 0.054709477026896436, 0.035823561446511, 0.06275703952638101, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052646437818366976, 0.0207359715631259, 0.03929644814706279, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011798236382222216, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08938389830209592, 0.06957733862080107, 0.0904216457654815, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05819122549506972, 0.07838705778459454, 0.06975848741111623, 0.129979836038716, 0.10865805272100237, 0.1154250409683949, 0.07432353242346923, 0.05595930793187964, 0.055935004014277645, 0.10358395272923981, 0.09217870553906338, 0.10021017833124557, 0.05907467107334741, 0.010000000000000009, 0.010000000000000009, 0.03382164364016016, 0.030540321212814248, 0.04380718533263217, 0.030402154499627132, 0.0328883152006848, 0.02498274848416837, 0.13647955020135982, 0.13500030133432928, 0.15367658139032514, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0045393568330984735, 0.0005177903392727945, 0.0029583504805827943, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006379761818694485, 0.0, 7.803920464544145e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036898488772174054, 0.037975859403656886, 0.029483794497242477, 0.0, 0.0, 0.0, 0.03899625205901902, 0.044418658460201765, 0.03623369260359377, 0.08606880532819061, 0.08747697608234362, 0.07668924791509424, 0.026339203144498557, 0.03837269306806845, 0.02414017202395513, 0.08438087926451743, 0.07083844945257922, 0.061889130395346825, 0.0, 0.0, 0.0, 0.013056551010933615, 0.010307467615546906, 0.012561015820258037, 0.008521623802303813, 0.010639659249868316, 0.01108421292095263, 0.13062436889270668, 0.13103512675493878, 0.11366724835738085, 0.0, 0.0, 0.0]}}
{"id": "28d232d9-d823-48c7-a815-20524b1676b2", "fitness": 0.04115777074326354, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhance convergence by integrating dynamic feedback from swarm diversity into velocity updates and incorporating LÃ©vy flight with dynamically adjusting probability for improved exploration-exploitation trade-off.  ", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        scale_factor = (self.inertia_weight_min + diversity) / (1 + diversity)\n        return scale_factor * self.velocities\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity)[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04116 with standard deviation 0.04686.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16865998096814616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07801454253562246, 0.0553122962098519, 0.05198315820751109, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.09485730377370705, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14463712210405333, 0.020000000000000018, 0.1086159632455298, 0.12676342425437725, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.026701114134553783, 0.053838723921108, 0.03551333365980991, 0.06251255694319513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052702310810223474, 0.020847090132434687, 0.039316127913145094, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.0690653278680835, 0.09080654473535488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05780285201293789, 0.08247904677910156, 0.06867912522087483, 0.13804028487350517, 0.10059146989951873, 0.11603057182456822, 0.07410737848799231, 0.055126236516060634, 0.053936809511723194, 0.09976547839093342, 0.08771993984301896, 0.10056258027619447, 0.06097698395185991, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.04354085641787209, 0.03083544610086375, 0.03247085960834395, 0.02491452834504637, 0.1460367740450299, 0.14995508500329047, 0.14920580819420282, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004255476537909475, 0.0006042807216090074, 0.0025435677552880787, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006201338235310883, 0.0, 6.427131687591903e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036761437563427646, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.04564205767772611, 0.041347738990614835, 0.034701169303381074, 0.08619032856391196, 0.08768521211623048, 0.07539063132411894, 0.027829751322100305, 0.038900516868527135, 0.022320025379924835, 0.08599548987369887, 0.07323695824976861, 0.063094016091916, 0.0, 0.0, 0.0, 0.01306696150149278, 0.010331259699854045, 0.012399266354949146, 0.008777970646403177, 0.01064139933457231, 0.011142454355775877, 0.11448749052965057, 0.1304161139054778, 0.12222123200721113, 0.0, 0.0, 0.0]}}
{"id": "1777d52d-9f40-4810-bda4-6f8b3ad1a115", "fitness": 0.04095443452914525, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Fine-tune chaotic mutation scaling to achieve a more precise balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.03  # Adjusted mutation scale for improved performance\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04095 with standard deviation 0.04624.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11819761182439559, 0.11040555834372323, 0.16804801635602873, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03554769152495452, 0.025157814958541302, 0.03088524260440262, 0.020000000000000018, 0.020000000000000018, 0.02015718872768746, 0.07803420739014011, 0.05528472457228628, 0.05197629456800967, 0.10368399618196344, 0.029596869874513043, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03714040535635377, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1368446886662591, 0.1290018832308245, 0.18423976002747777, 0.027935077578257528, 0.029470289294426633, 0.030180754369816043, 0.08072694858327945, 0.0863116411064907, 0.09424093230930419, 0.15623688146453474, 0.16859537293675475, 0.13243471658577743, 0.08774871584170396, 0.07990382579724953, 0.08081643888138712, 0.12745180483728402, 0.12429145460013236, 0.13835700225566394, 0.020000000000000018, 0.10798979546309995, 0.12734300333973214, 0.16635855264042543, 0.09116224648740545, 0.09205526342278603, 0.09079143920664834, 0.09072765427933915, 0.0999632775685112, 0.1438526290318487, 0.1456327325237191, 0.15475448018179316, 0.04912292595896195, 0.05759855487247645, 0.03850372129370272, 0.053987165351732536, 0.03561601047934393, 0.06275889779455557, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05267618955428599, 0.020835566409213913, 0.03930868578966851, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08946918028826378, 0.06942766827041469, 0.09058254107998776, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05866533614869385, 0.0778100079869628, 0.0720997742449544, 0.13673680547827094, 0.10110700496034541, 0.11581884272243159, 0.07206671114912955, 0.05534030804988277, 0.053936809511723194, 0.10361351761294035, 0.0860875102252896, 0.11034046501574724, 0.06119805845365145, 0.010000000000000009, 0.010000000000000009, 0.034330676866063836, 0.030636064639673166, 0.04365072581070917, 0.030809011388950203, 0.0326182667021615, 0.024922923078251058, 0.13618279796332045, 0.14153971167129764, 0.1393852739390704, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0043751473576730815, 0.0005988191540829968, 0.002649832025843013, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006239245515455405, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03685005530502006, 0.03797713745825537, 0.029994819526919958, 0.0, 0.0, 0.0, 0.04780782054084598, 0.042466214222327325, 0.034487126968604565, 0.0859570296167651, 0.08709642702761611, 0.07546337065081976, 0.02765339746507589, 0.03863079279919546, 0.022289583346161934, 0.08443910425182866, 0.07628998199356685, 0.06409665087225025, 0.0, 0.0, 0.0, 0.013115315075178824, 0.010331349170822679, 0.012430521401306627, 0.008727097745482859, 0.010636359858371636, 0.011173873968905235, 0.11578401085535261, 0.1304161139054778, 0.11703001248631817, 0.0, 0.0, 0.0]}}
{"id": "5e5d94a3-da1c-419c-8044-2c27fbca2893", "fitness": 0.040826475811213334, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Improve convergence by dynamically adjusting the mutation scale based on swarm diversity to refine exploration and exploitation phases.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity):\n        mutation_scale = 0.05 * (1.0 + diversity)  # Adjust mutation based on diversity\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04083 with standard deviation 0.04658.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11453751963894343, 0.11042316064565283, 0.17341500384514685, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029575127140010093, 0.022841055569633784, 0.021953722704889156, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07786591587629998, 0.05568044454550947, 0.052052666524068814, 0.10471374871194994, 0.029517800888749002, 0.020000000000000018, 0.05624346366825561, 0.08594148016760361, 0.11179796376536022, 0.05147076706928089, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07407590161801625, 0.03740484280955092, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.147124941392747, 0.13662412598998597, 0.17760409541703837, 0.03481733544924881, 0.028781279378962688, 0.035050146150807815, 0.08733485992950818, 0.0863116411064907, 0.1016431828363793, 0.1449075445709994, 0.15779590823965006, 0.14149323884529752, 0.0964317902642976, 0.07990382579724953, 0.0808169118941311, 0.12780793363470555, 0.11642359710483108, 0.12591958376122347, 0.020000000000000018, 0.11856197375639999, 0.12151704369178451, 0.19499225143257348, 0.08840893799209237, 0.10530587190439833, 0.08600724803632387, 0.07347564084029701, 0.10041884309579541, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.0544639431522248, 0.05077369101434437, 0.03790234409915305, 0.05010180438875911, 0.03286813288759416, 0.06105535641222981, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05305698216618493, 0.02079092734193655, 0.039628522433403646, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011500870611598657, 0.01453472859353877, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09090469459726136, 0.06654862392286831, 0.09526400882241448, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059865146130688385, 0.06277707403628374, 0.06251518859184246, 0.12620754136541945, 0.10668945376253669, 0.11442895229948291, 0.07645182366192715, 0.05263491823051125, 0.053936809511723194, 0.09740479758532272, 0.0849557603924227, 0.10299335162640932, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03584745542606382, 0.031942204040880995, 0.040777337373019806, 0.028886388720648637, 0.03200218230822627, 0.02479676789294405, 0.15643243511423421, 0.14562966910950914, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.000475570072396736, 0.0015814357618332275, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00561937378512023, 0.0, 0.0015718856857569463, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038037873243385256, 0.0374227971920551, 0.030312445627242446, 0.0, 0.0, 0.0, 0.031751077943733996, 0.03753213255583987, 0.03571246687193563, 0.09039059728705912, 0.09533809542320137, 0.07781629239542909, 0.02749394652549464, 0.03272532045365695, 0.023401482812833718, 0.07731800204052908, 0.07176915566603659, 0.06369037461567306, 0.0, 0.0, 0.0, 0.011749414981250261, 0.010121214624811525, 0.011036135265815372, 0.010335974227759226, 0.010466005299458958, 0.010464265308026244, 0.1152242720217842, 0.13776567780799964, 0.11155319620278292, 0.0, 0.0, 0.0]}}
{"id": "27736c45-296f-4940-84c1-c9b51e1ac627", "fitness": 0.040826475811213334, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce an adaptive mutation scaling factor based on swarm diversity to improve exploitation in the EnhancedAdaptiveChaoticSwarmOptimizer.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity):  # Modified line\n        mutation_scale = 0.05 * (1 + diversity)  # Adaptive mutation scaling based on diversity\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity)  # Pass diversity\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04083 with standard deviation 0.04658.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11453751963894343, 0.11042316064565283, 0.17341500384514685, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029575127140010093, 0.022841055569633784, 0.021953722704889156, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07786591587629998, 0.05568044454550947, 0.052052666524068814, 0.10471374871194994, 0.029517800888749002, 0.020000000000000018, 0.05624346366825561, 0.08594148016760361, 0.11179796376536022, 0.05147076706928089, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07407590161801625, 0.03740484280955092, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.147124941392747, 0.13662412598998597, 0.17760409541703837, 0.03481733544924881, 0.028781279378962688, 0.035050146150807815, 0.08733485992950818, 0.0863116411064907, 0.1016431828363793, 0.1449075445709994, 0.15779590823965006, 0.14149323884529752, 0.0964317902642976, 0.07990382579724953, 0.0808169118941311, 0.12780793363470555, 0.11642359710483108, 0.12591958376122347, 0.020000000000000018, 0.11856197375639999, 0.12151704369178451, 0.19499225143257348, 0.08840893799209237, 0.10530587190439833, 0.08600724803632387, 0.07347564084029701, 0.10041884309579541, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.0544639431522248, 0.05077369101434437, 0.03790234409915305, 0.05010180438875911, 0.03286813288759416, 0.06105535641222981, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05305698216618493, 0.02079092734193655, 0.039628522433403646, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011500870611598657, 0.01453472859353877, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09090469459726136, 0.06654862392286831, 0.09526400882241448, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.059865146130688385, 0.06277707403628374, 0.06251518859184246, 0.12620754136541945, 0.10668945376253669, 0.11442895229948291, 0.07645182366192715, 0.05263491823051125, 0.053936809511723194, 0.09740479758532272, 0.0849557603924227, 0.10299335162640932, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03584745542606382, 0.031942204040880995, 0.040777337373019806, 0.028886388720648637, 0.03200218230822627, 0.02479676789294405, 0.15643243511423421, 0.14562966910950914, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.000475570072396736, 0.0015814357618332275, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00561937378512023, 0.0, 0.0015718856857569463, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038037873243385256, 0.0374227971920551, 0.030312445627242446, 0.0, 0.0, 0.0, 0.031751077943733996, 0.03753213255583987, 0.03571246687193563, 0.09039059728705912, 0.09533809542320137, 0.07781629239542909, 0.02749394652549464, 0.03272532045365695, 0.023401482812833718, 0.07731800204052908, 0.07176915566603659, 0.06369037461567306, 0.0, 0.0, 0.0, 0.011749414981250261, 0.010121214624811525, 0.011036135265815372, 0.010335974227759226, 0.010466005299458958, 0.010464265308026244, 0.1152242720217842, 0.13776567780799964, 0.11155319620278292, 0.0, 0.0, 0.0]}}
{"id": "573e0589-e15e-4e36-b0aa-be7b00cff1cc", "fitness": 0.04095443452914525, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Fine-tune the chaotic mutation scale for enhanced convergence precision.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.03  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04095 with standard deviation 0.04624.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11819761182439559, 0.11040555834372323, 0.16804801635602873, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03554769152495452, 0.025157814958541302, 0.03088524260440262, 0.020000000000000018, 0.020000000000000018, 0.02015718872768746, 0.07803420739014011, 0.05528472457228628, 0.05197629456800967, 0.10368399618196344, 0.029596869874513043, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03714040535635377, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1368446886662591, 0.1290018832308245, 0.18423976002747777, 0.027935077578257528, 0.029470289294426633, 0.030180754369816043, 0.08072694858327945, 0.0863116411064907, 0.09424093230930419, 0.15623688146453474, 0.16859537293675475, 0.13243471658577743, 0.08774871584170396, 0.07990382579724953, 0.08081643888138712, 0.12745180483728402, 0.12429145460013236, 0.13835700225566394, 0.020000000000000018, 0.10798979546309995, 0.12734300333973214, 0.16635855264042543, 0.09116224648740545, 0.09205526342278603, 0.09079143920664834, 0.09072765427933915, 0.0999632775685112, 0.1438526290318487, 0.1456327325237191, 0.15475448018179316, 0.04912292595896195, 0.05759855487247645, 0.03850372129370272, 0.053987165351732536, 0.03561601047934393, 0.06275889779455557, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05267618955428599, 0.020835566409213913, 0.03930868578966851, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08946918028826378, 0.06942766827041469, 0.09058254107998776, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05866533614869385, 0.0778100079869628, 0.0720997742449544, 0.13673680547827094, 0.10110700496034541, 0.11581884272243159, 0.07206671114912955, 0.05534030804988277, 0.053936809511723194, 0.10361351761294035, 0.0860875102252896, 0.11034046501574724, 0.06119805845365145, 0.010000000000000009, 0.010000000000000009, 0.034330676866063836, 0.030636064639673166, 0.04365072581070917, 0.030809011388950203, 0.0326182667021615, 0.024922923078251058, 0.13618279796332045, 0.14153971167129764, 0.1393852739390704, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0043751473576730815, 0.0005988191540829968, 0.002649832025843013, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006239245515455405, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03685005530502006, 0.03797713745825537, 0.029994819526919958, 0.0, 0.0, 0.0, 0.04780782054084598, 0.042466214222327325, 0.034487126968604565, 0.0859570296167651, 0.08709642702761611, 0.07546337065081976, 0.02765339746507589, 0.03863079279919546, 0.022289583346161934, 0.08443910425182866, 0.07628998199356685, 0.06409665087225025, 0.0, 0.0, 0.0, 0.013115315075178824, 0.010331349170822679, 0.012430521401306627, 0.008727097745482859, 0.010636359858371636, 0.011173873968905235, 0.11578401085535261, 0.1304161139054778, 0.11703001248631817, 0.0, 0.0, 0.0]}}
{"id": "21448034-5a18-4c30-9eec-948457bff5da", "fitness": 0.04078917245674286, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduced a refined dynamic inertia weight scaling for improved diversity adaptation in chaotic swarm optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + np.sqrt(diversity)) / (1 + diversity)  # Changed line for dynamic inertia scaling\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04079 with standard deviation 0.04609.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11817388084613833, 0.11865698031317917, 0.1637183739867134, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04692341198514127, 0.022121470667225696, 0.026872550912384163, 0.02618783324496321, 0.020000000000000018, 0.020000000000000018, 0.07104350871932308, 0.046373850778161585, 0.05109991685662818, 0.04096410082405755, 0.030085353522333547, 0.020000000000000018, 0.0530954239411946, 0.13946729621604337, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14211302837806183, 0.12972506205888346, 0.17871877049183604, 0.029872545822216767, 0.03392794354627393, 0.03884621026843804, 0.08072694858327945, 0.10444118761868115, 0.08317986958356582, 0.15183074108771877, 0.16254592358901543, 0.1415411305876617, 0.09115673573167726, 0.07990382579724953, 0.07817479095289981, 0.14450213906774845, 0.10602650254016155, 0.12477679271879605, 0.020000000000000018, 0.10748221973867489, 0.12390492387588292, 0.1547492546520013, 0.0905455168200805, 0.10654596665747595, 0.07572583441007963, 0.09212346817002637, 0.058843180540948614, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.0674230934543888, 0.05635833306587701, 0.043180182777472265, 0.05170377947737992, 0.040792017273488024, 0.060112594276225284, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.039778813666099255, 0.016559225812099676, 0.025869067387724876, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010212104962465274, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08939406824850682, 0.07965340386265407, 0.08043506083953844, 0.010000000000000009, 0.010000000000000009, 0.0103690680861529, 0.07014013775828942, 0.06816051625957098, 0.05395939349942802, 0.13137435335544378, 0.09991575027891941, 0.10523700963600735, 0.07441454974128003, 0.044030696060758046, 0.05876954703616033, 0.09954671042189422, 0.09534637152314795, 0.10845436005323572, 0.08850598180841274, 0.010000000000000009, 0.010000000000000009, 0.043266898832931, 0.04326209405755832, 0.03965344373140345, 0.027442368967480535, 0.032080681248886966, 0.02509714870745894, 0.13165741461806335, 0.13123409970527322, 0.14955868226303926, 0.01146211148983678, 0.010000000000000009, 0.010000000000000009, 0.012214798786396086, 0.0002804718507642967, 0.014211191547771729, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0013812599664599912, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03898313059269798, 0.041214521641081525, 0.035126273627190896, 0.0, 0.0, 0.0, 0.033133598767384975, 0.038213806063789324, 0.044429133481417304, 0.0872561305359072, 0.09162282496818175, 0.08331536235617154, 0.03089404785701777, 0.03684381213278487, 0.027749061299693345, 0.08396799597275806, 0.08969025018813792, 0.07268760189102763, 0.0, 0.0, 0.0, 0.012278367566840864, 0.009966668872662066, 0.01190179256228463, 0.008528815909468412, 0.011111238203712293, 0.01005258958306987, 0.13204369950890138, 0.1304161139054778, 0.1235243111158576, 0.0, 0.0, 0.0]}}
{"id": "73c8ddcc-bb69-4b60-a03f-e589c8ee8289", "fitness": 0.04077614669667776, "name": "QuantumAdaptiveChaoticSwarmOptimizer", "description": "Implement an adaptive perturbation approach using quantum-inspired superposition states and chaotic dynamics to enhance exploration-exploitation trade-off and improve convergence rates in black-box optimization tasks.", "code": "import numpy as np\n\nclass QuantumAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def quantum_superposition(self, size):\n        # Create a quantum-inspired superposition state\n        phase = np.random.uniform(0, 2 * np.pi, size)\n        return np.sin(phase) * np.random.uniform(-1, 1, size)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05 \n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * self.quantum_superposition(self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.quantum_superposition(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 75, "feedback": "The algorithm QuantumAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04078 with standard deviation 0.04610.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11864949894144361, 0.1104047521185535, 0.16611911761072096, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02716033546216834, 0.02605440727381736, 0.030609467822862113, 0.020000000000000018, 0.020000000000000018, 0.020636511105984967, 0.07802506194163883, 0.05515317999602365, 0.051973141164269765, 0.10379638764335397, 0.029540301111234846, 0.020000000000000018, 0.06009096199073449, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037126727719898, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1367185886712199, 0.12788898588490183, 0.18444156065434736, 0.028610098792556493, 0.029523560751969158, 0.03234070901865982, 0.08072694858327945, 0.0863116411064907, 0.09032337376093491, 0.1538589889961577, 0.16734965252978673, 0.1422037591218529, 0.08164623320891595, 0.08196950777169709, 0.0808164622468539, 0.13268808143319688, 0.12287923011671242, 0.12937912144269825, 0.020000000000000018, 0.10485994866401283, 0.12661368234245318, 0.17321936714614228, 0.09204640176323409, 0.09292733955985621, 0.08432481861893859, 0.09322940187907558, 0.09986441005519109, 0.1516221252893315, 0.13589170657517036, 0.15475448018179316, 0.053473766523830624, 0.05771547296661128, 0.03563820098298476, 0.05416127566842166, 0.03547688821215533, 0.06314708179166706, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05259040409420701, 0.020752640296544667, 0.039316376813903986, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08952187789114607, 0.07012666944683177, 0.09037911904817075, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05763566498342787, 0.07330080158142427, 0.07245776543459814, 0.12900250899225907, 0.09896375765696319, 0.11072550274011972, 0.07495041611383013, 0.05596994829621149, 0.05495160988180037, 0.10490061240893822, 0.09072624594441558, 0.11157969131091461, 0.059783627797340255, 0.010000000000000009, 0.010000000000000009, 0.03439279260199701, 0.03077301739299887, 0.04355376514770515, 0.03076076975925024, 0.03277066369537218, 0.024938182120110453, 0.13597678559885762, 0.146268737947146, 0.1338495106644365, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004692368536690639, 0.0006814543453771416, 0.0028597556923735112, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0062218642345353015, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03726180806050228, 0.037975738984848184, 0.029778119516558288, 0.0, 0.0, 0.0, 0.042050321973427174, 0.046342299624367866, 0.034111630670123794, 0.08636932719168744, 0.08613173319703638, 0.07317434974299175, 0.02889218218491507, 0.035250643147897165, 0.02360705433702548, 0.07908092469782302, 0.07729035573170095, 0.060249614228611414, 0.0, 0.0, 0.0, 0.013128379741362273, 0.010346625680134114, 0.012424837330882621, 0.008524227391664807, 0.010615009659427299, 0.011157913819701548, 0.12174802222556391, 0.1306177782211685, 0.11278797177581867, 0.0, 0.0, 0.0]}}
{"id": "1bffa3a6-2066-4813-bef7-917415ea80cd", "fitness": 0.04109875814777918, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhance the algorithm by introducing a dynamic adjustment to the Levy flight step size based on function evaluations to improve exploration during the initial phase and exploitation during the later phase.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim) * (1 - evaluations / self.budget)  # Dynamic step size adjustment\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04110 with standard deviation 0.04681.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16866089645873106, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07801113318366593, 0.0553122962098519, 0.05198315750971527, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.09375199051108074, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14463712210405333, 0.020000000000000018, 0.1086159632455298, 0.12680090319796422, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.02657375009670604, 0.05390442148508057, 0.03554123581231439, 0.062473527521783034, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05269729849329108, 0.020842416661342344, 0.03931240805904135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.06913303242542557, 0.09080516006191686, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.057922576944878346, 0.07789767706379791, 0.06867912522087483, 0.13925185384186678, 0.10062360198602771, 0.11603437235235503, 0.07278755543656712, 0.05509665021388144, 0.053936809511723194, 0.10006993892970695, 0.08799611336745228, 0.10049388216361232, 0.06071132953932845, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.04354087188166933, 0.030758293970443717, 0.03247085960834395, 0.024918543409808813, 0.1460367740450299, 0.14995508500329047, 0.14920580819420282, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004256069053818368, 0.0005926572194965285, 0.002555839018089201, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006195129194465965, 0.0, 6.311497927302678e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036803158201683894, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.046175744964108256, 0.041347738990614835, 0.03469556809809049, 0.08636279316185214, 0.08768521211623048, 0.07542479520558132, 0.027867985244718008, 0.038900516868527135, 0.022320025379924835, 0.07917449176625735, 0.07323695824976861, 0.06337768456211501, 0.0, 0.0, 0.0, 0.013064811877017357, 0.010331259699854045, 0.01240356207173443, 0.008751083529771497, 0.01064139933457231, 0.011133098189620827, 0.11477064215221655, 0.1304161139054778, 0.12043484356551859, 0.0, 0.0, 0.0]}}
{"id": "acc00334-e548-408b-a883-df43e7472d8b", "fitness": 0.03834608023948493, "name": "RefinedAdaptiveChaoticSwarmOptimizer", "description": "Introduce adaptive inertia weight decay and collaborative chaotic search to further enhance convergence and exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass RefinedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.2\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.5\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.03\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def collaborative_search(self):\n        step_size = 0.01\n        for i in range(self.population_size):\n            if np.random.rand() < 0.2:\n                rand_partner = np.random.randint(self.population_size)\n                self.positions[i] += step_size * (self.personal_best_positions[rand_partner] - self.positions[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_inertia_decay(self, diversity, evaluations):\n        decay_factor = evaluations / self.budget\n        return self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * decay_factor * (1 - diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.adaptive_inertia_decay(diversity, evaluations)\n                inertia = self.inertia_weight * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            self.collaborative_search()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 77, "feedback": "The algorithm RefinedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03835 with standard deviation 0.04488.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.13253154814378976, 0.1056026443920457, 0.16617172118500068, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03453375061766817, 0.02134499922035915, 0.022669563274789972, 0.022925421702844062, 0.02617716749218102, 0.0246761133577732, 0.08354189807513313, 0.06973414996899951, 0.05375387523294961, 0.02487251576293692, 0.020000000000000018, 0.022965638529827803, 0.04743241473728599, 0.08594148016760361, 0.09734379171137375, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14541393764014343, 0.14193242759506064, 0.17537460407751126, 0.029650252093077145, 0.024474827577197655, 0.024044042416668132, 0.08283061304114614, 0.0863116411064907, 0.08314787775751609, 0.14220112589088363, 0.14060036981520374, 0.14381024044937674, 0.08207805189439144, 0.07990382579724953, 0.07725233999487102, 0.12021261382714377, 0.1094528873123014, 0.12513827139790157, 0.020000000000000018, 0.020000000000000018, 0.10760073329214959, 0.20740386541801825, 0.08690913361667751, 0.11228251799493028, 0.06527120746322768, 0.06211432766426128, 0.056492493752391515, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.039784967500048896, 0.03566165485756523, 0.029601545908135574, 0.05464507458239054, 0.03937670160774187, 0.05845359937795025, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06339252344720658, 0.02764398163934534, 0.054955202414453064, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.012948931886276105, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08870896716202126, 0.06961310183262137, 0.08833842580136997, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06147825531143891, 0.05395939349942802, 0.1220249712685263, 0.10391310404583365, 0.10336513493558086, 0.05984238030907152, 0.04800632622382239, 0.053936809511723194, 0.0933187795794913, 0.09673479144230468, 0.10860771163019034, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0324948573228202, 0.029047782449354687, 0.045958346353767165, 0.024895242935785933, 0.026416157816411046, 0.025313196306759767, 0.13141309820135194, 0.1325868351420264, 0.1437776982753186, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0, 0.0010938251837380175, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.021539704767089884, 0.0, 0.0010171188440404322, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.039600678741835704, 0.03728277707217709, 0.024909275518503637, 0.0, 0.0, 0.0, 0.033717239779930686, 0.03984962562633543, 0.03626488233493841, 0.08302955876501317, 0.07965841969894782, 0.07037484042883169, 0.020213094208609728, 0.026141144940839633, 0.02127103781061679, 0.08530494648952625, 0.07584876367828386, 0.06288192523806213, 0.0, 0.0, 0.0, 0.010355644336983993, 0.009375957483200636, 0.012685809623624311, 0.007518868240948495, 0.010051284513262426, 0.010190594421945587, 0.1159518932874678, 0.1304161139054778, 0.12277106479318445, 0.0, 0.0, 0.0]}}
{"id": "f324f9ab-5922-45b5-ac9f-776faad4be71", "fitness": 0.03976902669336905, "name": "RefinedAdaptiveChaoticSwarmOptimizer", "description": "Integrate adaptive chaotic perturbations and dynamic Levy flight adjustments, tuned by swarm diversity, to enhance global and local search capabilities in black-box optimization.", "code": "import numpy as np\n\nclass RefinedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.5\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.1  # Adjusted mutation scale for better exploration\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.5 * (1 - diversity / self.dim)  # Enhanced dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.02 * self.levy_flight(self.dim)  # Adjusted step size for enhanced exploration\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 78, "feedback": "The algorithm RefinedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03977 with standard deviation 0.04638.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.14542359628958712, 0.11716448200555074, 0.16531927202154062, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.038124670464433685, 0.02333328947821467, 0.025126457596684304, 0.02873864863899156, 0.020000000000000018, 0.020000000000000018, 0.07744226809238686, 0.05112190757145185, 0.051804985238302126, 0.02998054355947799, 0.020000000000000018, 0.020000000000000018, 0.053773032126996134, 0.11576709658399698, 0.09659954141819438, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.16948581442252275, 0.13707059896619112, 0.17693883897349283, 0.027074870825063213, 0.025059029111140663, 0.031053658703554254, 0.08072694858327945, 0.0863116411064907, 0.09888650242647035, 0.15211122992905335, 0.14885932139885882, 0.14199674485704117, 0.09198681735548331, 0.08014206629980836, 0.08288211897971498, 0.14212831540878057, 0.12055012072172733, 0.13084817461657783, 0.020000000000000018, 0.020000000000000018, 0.1395632991060345, 0.16515918418758924, 0.10466759492470545, 0.10741307950729095, 0.08052446255281032, 0.10110992078672809, 0.0957828935130195, 0.1438526290318487, 0.14320235193274256, 0.15475448018179316, 0.04730639918803081, 0.04588480589789157, 0.03134652188195208, 0.05624496118779243, 0.03402827932702468, 0.06013729090478703, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05535001676146312, 0.021818803906596962, 0.041192433566207165, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020382829525862345, 0.015402285223122036, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08922852132850712, 0.06373002071802114, 0.0883122420360073, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0658048952216369, 0.07216761903764501, 0.0621153418077689, 0.12321940191021652, 0.10484973987640478, 0.10877829695473129, 0.07246294939339348, 0.04547338980351423, 0.053936809511723194, 0.08844543417110007, 0.08857284628972129, 0.09815523927968317, 0.011348687072512575, 0.010000000000000009, 0.010000000000000009, 0.03342833293313008, 0.03542747827149062, 0.03844292737390942, 0.029341941985555287, 0.03133952637956228, 0.02533141581946452, 0.14454984758786726, 0.13495098685521145, 0.14345734310792158, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004223943573109956, 0.0004530191155721619, 0.0018945456221092227, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005817098216496341, 0.005862069590886754, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03389562974045335, 0.03525507982987219, 0.03126001854261906, 0.0, 0.0, 0.0, 0.032048481462608414, 0.04050381455440388, 0.03277786686915629, 0.08782838623208022, 0.08793512301779227, 0.07477028849418443, 0.024638461691599223, 0.02890469061972145, 0.020558804639254635, 0.08014022597488146, 0.08248265930197207, 0.05978919692185658, 0.0, 0.0, 0.0, 0.012171054132684711, 0.009675168760296726, 0.012805350982465713, 0.0078771597723023, 0.010440099351693988, 0.011169445204760153, 0.11900428879700131, 0.1304161139054778, 0.11368331925734876, 0.0, 0.0, 0.0]}}
{"id": "d33f110b-ccca-475b-8df8-55ec7819f6c7", "fitness": 0.04075799103575117, "name": "EnhancedAdaptiveChaoticSwarmOptimizerV2", "description": "Introduce a non-linear dynamic inertia weight and adaptive scaling of chaotic perturbations to enhance convergence speed and accuracy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05 * (1 + np.cos(factor * np.pi))  # Adaptive mutation scale\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def non_linear_inertia_weight(self, chaotic_factor):\n        return self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * np.sin(chaotic_factor * np.pi)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.non_linear_inertia_weight(chaotic_factor[i])\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04076 with standard deviation 0.04587.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11812518152056783, 0.11040398448363464, 0.16876309162546133, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03458559171524511, 0.025773707152156877, 0.03078082403900051, 0.020000000000000018, 0.020000000000000018, 0.020159398893872416, 0.07802533340190165, 0.05530268404813976, 0.051992519519898917, 0.1035606291224418, 0.02963284385307363, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03711369358136185, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13853341195218927, 0.12923948260533036, 0.18407330843196978, 0.028796777916139105, 0.02952624905485779, 0.031112747074610647, 0.08072694858327945, 0.0863116411064907, 0.09586047845110512, 0.15064094755100543, 0.16651114060693473, 0.13750149500454256, 0.08214206475816388, 0.07990382579724953, 0.08081639127186024, 0.1298548204131963, 0.11376798788015408, 0.12466967465485168, 0.020000000000000018, 0.10737154041580921, 0.12567380102917236, 0.16644939795792402, 0.09076072851342554, 0.09217586950631929, 0.09371700264367644, 0.0915716154271684, 0.0999160440430229, 0.14484329578778377, 0.13589170657517036, 0.15475448018179316, 0.050962072843665274, 0.05780448928591864, 0.039432908422931234, 0.05370393712663679, 0.035664550300683495, 0.06272214293203893, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052721869153906864, 0.020765260401124697, 0.039320202483895006, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08942014223213335, 0.06977811708587578, 0.09077626198926869, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0560861228645575, 0.07603209872594274, 0.07266335752070674, 0.1408768438756618, 0.09988332464107597, 0.11593920264160085, 0.07166694291756148, 0.05383089470725433, 0.053936809511723194, 0.10181388046799211, 0.08511833609633701, 0.1071081931059723, 0.062211821178572935, 0.010000000000000009, 0.010000000000000009, 0.03478088370832477, 0.03085545675795265, 0.04388137720935048, 0.03067236508555582, 0.032716994786578524, 0.0249171847201326, 0.13430592089153692, 0.13379489013861667, 0.14335832821133165, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004244686423577337, 0.0008006890807095157, 0.0024421440416817486, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006223210045941285, 0.0, 0.00012525462409940236, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03682905199956399, 0.037976753982615574, 0.030074616319440417, 0.0, 0.0, 0.0, 0.049658233981964894, 0.04281704750772786, 0.033516064629265596, 0.08571075763504876, 0.08693679680679833, 0.07782268007781867, 0.028328187086477663, 0.039033888326394095, 0.021861456640540067, 0.08342590324723487, 0.0788105800398684, 0.060145709720491713, 0.0, 0.0, 0.0, 0.013089555231275196, 0.010328376898122271, 0.012385824812656931, 0.00869158328382591, 0.010633609930897014, 0.011129428877751146, 0.11319058745524246, 0.1377796531707003, 0.1100241374973614, 0.0, 0.0, 0.0]}}
{"id": "8a123af7-4fd6-40eb-9338-36cd5951245d", "fitness": 0.040897786362783, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introducing a perturbation decay factor to the chaotic mutation for refined exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05 * (1 - factor)  # Introducing a perturbation decay factor based on chaotic factor\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04090 with standard deviation 0.04612.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11828796123469809, 0.11040399007041168, 0.16793732201761513, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03534520880872638, 0.0257255425433931, 0.030686860423498108, 0.020000000000000018, 0.020000000000000018, 0.020141010416151017, 0.07804574759853522, 0.05527135699237562, 0.051978201167959925, 0.10357244950883371, 0.02961396302996422, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03711370017632121, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1370432628959748, 0.12861359341609047, 0.1843100961418963, 0.02868337826434908, 0.02952513501668219, 0.031259628487500524, 0.08072694858327945, 0.0863116411064907, 0.09227413822910446, 0.15601537956024458, 0.16664211947645924, 0.13670073998745846, 0.08812403546792591, 0.07990382579724953, 0.08081639127232942, 0.13398560241584678, 0.11286107397458012, 0.1463332232327439, 0.020000000000000018, 0.10727229733169619, 0.12715106588797875, 0.16658085162770808, 0.09120343215561033, 0.09246183807746033, 0.0907251951634871, 0.09223132801551415, 0.09991721431518186, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.049487309160219595, 0.05780112408696669, 0.04243207052160902, 0.05397976603092158, 0.0356924980429858, 0.06288812979447489, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05267711179754575, 0.020797573763707833, 0.03930976096118921, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014146823553227383, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08941277404865178, 0.06976354048018829, 0.09122349342802083, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05818538193496092, 0.07642642149426881, 0.07333818864434893, 0.13796070864583754, 0.10100387161035074, 0.11714445865155698, 0.07159433097890999, 0.055197428665293535, 0.053936809511723194, 0.10038023244962413, 0.0878945221232087, 0.1051254023999415, 0.06165800805556321, 0.010000000000000009, 0.010000000000000009, 0.03437136258736184, 0.03069498544443927, 0.04380061201436081, 0.030746529954288948, 0.032740721795118666, 0.024925517721145707, 0.14892817592783425, 0.13595488652095145, 0.136017139422262, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004405217561388675, 0.0006692759984083807, 0.002643835440071407, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006255126703443303, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03689209949204797, 0.03797784254825198, 0.030001143416678255, 0.0, 0.0, 0.0, 0.044887969536949734, 0.04163758289467401, 0.032737323401185736, 0.08573145405857785, 0.08665829637170774, 0.07545817549619216, 0.027663507632767925, 0.03863394577931922, 0.02230643842309077, 0.081635564827516, 0.07302131787750499, 0.0663774110730252, 0.0, 0.0, 0.0, 0.013134441860278234, 0.010329727900559527, 0.012435383570227998, 0.008684341077361823, 0.01063209149006028, 0.011178253586089926, 0.11338860872301015, 0.1304161139054778, 0.11136407364127265, 0.0, 0.0, 0.0]}}
{"id": "709b86a9-0d02-4679-8dd8-91a8fc136265", "fitness": -0.032378576914546514, "name": "HybridChaoticDifferentialEvolution", "description": "Introduce a hybrid mutation strategy combining chaotic sequences with self-adaptive differential evolution to enhance solution diversity and convergence rate in black-box optimization.", "code": "import numpy as np\n\nclass HybridChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def differential_mutation(self, target_idx, f):\n        indices = [i for i in range(self.population_size) if i != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.positions[a] + f * (self.positions[b] - self.positions[c])\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.01\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                f = 0.5 + chaotic_factor[i] * 0.5  # Chaotic adaptation of differential weight\n                mutant = self.differential_mutation(i, f)\n                trial = self.chaotic_mutation(mutant, chaotic_factor[i])\n\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.positions[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 81, "feedback": "The algorithm HybridChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.03238 with standard deviation 0.11283.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.08370793683903377, 0.09408719711293623, 0.12111305630268887, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07190691478940436, 0.05493724667993061, 0.04956030618232932, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.040531031208096646, 0.08594148016760361, 0.057929235093625686, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09994410407015442, 0.1067179601503182, 0.132889018507245, 0.020000000000000018, 0.020000000000000018, 0.02368340645778455, 0.0815284925977926, 0.0863116411064907, 0.08265825826829598, 0.13125232404720732, 0.13323277534341382, 0.1213081546448399, 0.07314880797608625, 0.07990382579724953, 0.06353099852263044, 0.11205586464406281, 0.10848952857031802, 0.12191976134240401, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11120256989280308, 0.07673594067624634, 0.0895133107273659, 0.06527120746322768, 0.06428599142714975, 0.056492493752391515, 0.1482648465897397, 0.13589170657517036, 0.15475448018179316, 0.038669801718039354, 0.03705775927144972, 0.02657375009670604, 0.03312017394570621, 0.017125755952921984, 0.04273584385560725, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01200725156736826, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01305238105976203, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06717132965113548, 0.07282120500741929, 0.08289708361970671, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.058472214607235506, 0.06147825531143891, 0.05395939349942802, 0.11869262382913237, 0.10432273666087877, 0.10281775224528589, 0.05756835603815702, 0.03518359929680204, 0.053936809511723194, 0.07896945735270666, 0.06539405484546112, 0.08807105303750307, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02492142306634204, 0.029043163533977734, 0.026018756973356538, 0.024895242935785933, 0.022487143875263516, 0.025630987319559706, 0.13171404855204438, 0.13123409970527322, 0.14199644381683596, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.16623237579901473, -0.16257858485121934, -0.17613892825085742, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1604233631252825, -0.15483893424474116, -0.15738442576530454, -0.10283004658917316, -0.10373783269231307, -0.11186674823219911, -0.17558476495472242, -0.17007122388392437, -0.17532109287087727, -0.12156757854714062, -0.12982477324864217, -0.14866500222299983, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18832264645009378, -0.1899672453686947, -0.18867049822916426, -0.191147705244745, -0.18780676904453797, -0.1910832455163669, -0.06337252751318179, -0.043207726894507026, -0.06387039947019146, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "7f6fdfec-01be-4f86-9872-ea6a27f7b5c1", "fitness": 0.03870952315916719, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Integrate dynamic parameter tuning and enhanced chaos mechanisms to improve convergence speed and robustness in diverse black-box optimization problems.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.3\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.5\n        self.cognitive_coefficient_max = 2.5\n        self.social_coefficient_min = 1.5\n        self.social_coefficient_max = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.03  # Further reduced mutation scale for more precise perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.15 + 0.35 * (1 - diversity / self.dim)  # Refined dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.005 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03871 with standard deviation 0.04469.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.12303990594698222, 0.10450997676639373, 0.15420762167534052, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02077287868739519, 0.02828356593974435, 0.02098193361134093, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08111674008236402, 0.06803131970874376, 0.05791608845274199, 0.02902560946214583, 0.031818307703579185, 0.020000000000000018, 0.055811686352276735, 0.08679418867012467, 0.08703535043745092, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13336358205210774, 0.10134931017395932, 0.162366852869111, 0.0506956682973555, 0.020000000000000018, 0.020000000000000018, 0.08206621511884094, 0.08713244696701239, 0.07589839575300372, 0.14657622388527602, 0.13323277534341382, 0.14069188739155636, 0.08119067638590227, 0.07990382579724953, 0.07653267030585742, 0.12420934213243162, 0.12622529633450086, 0.1587623683679107, 0.020000000000000018, 0.020000000000000018, 0.13043694539141404, 0.16347934527621566, 0.08216661937568437, 0.10286898042145143, 0.0670192641475359, 0.05762895342201768, 0.05760476334959719, 0.1461290150491641, 0.13589170657517036, 0.15475448018179316, 0.05308913947372251, 0.03392426887360889, 0.027899259581548708, 0.05021106814304199, 0.036907305501856724, 0.04730993990161336, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06057070269797693, 0.026774210722058878, 0.03964255476515033, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011445888284407735, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08927387104562767, 0.07246820661869269, 0.10105629104706115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05480271182006957, 0.0673361231992814, 0.060088678374092264, 0.12419510321138294, 0.10421063851277179, 0.10942261574969725, 0.06931083178783937, 0.0400296307790029, 0.05644449669336127, 0.10295990807131306, 0.08838965426870604, 0.10266549549442205, 0.11459996844395282, 0.010000000000000009, 0.010000000000000009, 0.030123595677721937, 0.038202741985565614, 0.03139454617018911, 0.0267440950216411, 0.024435696463711354, 0.024716806786450607, 0.1410763969724671, 0.15713695193234767, 0.14417405883933587, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004136337226472775, 7.255218406887476e-05, 0.0006778204912047947, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006657402127108414, 0.0064375104468195055, 0.0008131106543729505, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.032610384873006826, 0.03915647965373925, 0.031506885765184456, 0.0, 0.0, 0.0, 0.03516077353678926, 0.03753213255583987, 0.033273801992628305, 0.08660772550665319, 0.09247837914651513, 0.07499923034865019, 0.027737383642588598, 0.026726576793556944, 0.02453975122130425, 0.07915017451065798, 0.0755943696735083, 0.060050443575471624, 0.0, 0.0, 0.0, 0.011027211800195058, 0.009902840752605169, 0.012832351637470207, 0.007594740795706545, 0.010432776200557048, 0.011018155048578282, 0.11667059709855332, 0.1304161139054778, 0.1248867524409788, 0.0, 0.0, 0.0]}}
{"id": "d903f2e2-2fea-4c3e-b5ff-d9bc848bc951", "fitness": -Infinity, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce a dynamic population size scaling based on convergence to efficiently allocate resources in the EnhancedAdaptiveChaoticSwarmOptimizer.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n            \n            # Dynamic population scaling\n            self.population_size = max(5, int(self.population_size * (1 + diversity/self.dim)))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 83, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {}}
{"id": "e8076613-f3bc-40ef-85e0-907d5ead16e0", "fitness": 0.040058939772827956, "name": "EnhancedAdaptiveChaoticSwarmOptimizerV2", "description": "Enhance exploration and exploitation by integrating adaptive levy flights and chaotic logistic maps with a dynamic mutation scale based on swarm diversity for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.5\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.5\n        self.cognitive_coefficient_max = 2.5\n        self.social_coefficient_min = 1.5\n        self.social_coefficient_max = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity):\n        mutation_scale = 0.02 + 0.06 * (1 - diversity)  # Dynamic mutation scale\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return np.tanh(self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.2 + 0.3 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.015 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04006 with standard deviation 0.04502.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11439630363265618, 0.1377339811550905, 0.1547245510108607, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029701216802767494, 0.03419121477680365, 0.02585370223161121, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07933202734899936, 0.05603349464159435, 0.05245908828712231, 0.02685476203482784, 0.0321837070367782, 0.020000000000000018, 0.05613333987873903, 0.09070617272415404, 0.09434170239593076, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1409873419847798, 0.10227847367519116, 0.1612149023380567, 0.025243575730314327, 0.029755470760083447, 0.029925226453065834, 0.08803356103858706, 0.11498738100388972, 0.09306648506442128, 0.14033295838184978, 0.15643183529419769, 0.1310916059948306, 0.07688690194873404, 0.08273903544263594, 0.08242796041583655, 0.13899377036018956, 0.11703281588828018, 0.1452250486117438, 0.020000000000000018, 0.020000000000000018, 0.12737652028124313, 0.12670757538085653, 0.10698644805051771, 0.11859961498367821, 0.06955477985912606, 0.1057990842748362, 0.06646869512150122, 0.1438526290318487, 0.1424091133132882, 0.15475448018179316, 0.049626692499763814, 0.04730240816500808, 0.031589424286722734, 0.04778049735297274, 0.03879673408745743, 0.04653519893218727, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05664876755841197, 0.024298636509591187, 0.01915579182513283, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.024384300918656843, 0.011473642636001924, 0.015296465924058644, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08446727490018846, 0.07547587709883496, 0.08704273674379703, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05668599518797479, 0.07413033680329195, 0.0553739999487578, 0.12441081730476067, 0.10654218565721474, 0.10841066276725675, 0.07143725894825581, 0.04394269262790795, 0.058752448661192, 0.09954778829929167, 0.10329286789603231, 0.10859214816883023, 0.1054217424418934, 0.010000000000000009, 0.010000000000000009, 0.044851265419020736, 0.05007002920969139, 0.04384340112475438, 0.03141547563225944, 0.025111620005309754, 0.02560908714536536, 0.13244446719570446, 0.13351207711643653, 0.14019676647220902, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.007331035870851932, 0.002600882749497324, 0.017038001423601346, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0005715138646508189, 0.001340870067554345, 0.0007274660191004534, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04337364889974393, 0.05104314530189413, 0.037543934764334375, 0.0, 0.0, 0.0, 0.045466673305108674, 0.03889284480017907, 0.03262965350875291, 0.08697599319631677, 0.09537506718333044, 0.08248032199782573, 0.03899440623237571, 0.0353467650539967, 0.02237781208638079, 0.08863677634803224, 0.08800836386331601, 0.0720919664528119, 0.0, 0.0, 0.0, 0.01188680067765191, 0.009623305760463996, 0.013005774897973055, 0.009092191133794336, 0.011386375798035253, 0.01049384473858428, 0.12162976422507743, 0.1304161139054778, 0.11907153850861463, 0.0, 0.0, 0.0]}}
{"id": "3cfef8c5-c0a7-443c-8a40-63f4ac33a095", "fitness": 0.04032767995917359, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Integrate stochastic ranking to balance exploration-exploitation dynamically to enhance convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def stochastic_ranking(self, scores):\n        order = np.argsort(scores)\n        ranked_positions = self.positions[order]\n        return ranked_positions\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            self.positions = self.stochastic_ranking(self.personal_best_scores)  # Implementing stochastic ranking\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04033 with standard deviation 0.04666.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.10663716717180316, 0.10980702476716842, 0.16592665269230022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.035450786730125805, 0.024761158703800024, 0.03137855711201554, 0.020000000000000018, 0.020000000000000018, 0.020130273133914467, 0.07737879951761784, 0.05830228797799164, 0.06021179857376524, 0.09213779763644381, 0.020000000000000018, 0.020000000000000018, 0.06544938567374547, 0.08594148016760361, 0.10944000100887563, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03559836709080344, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1435859160275429, 0.13395528761774855, 0.20206535327819597, 0.02748509697254331, 0.02869611100345848, 0.03176056888328416, 0.08072694858327945, 0.0863116411064907, 0.08171690625371353, 0.14994640158750516, 0.16689270656443744, 0.14556388552802613, 0.07839808838870088, 0.07990382579724953, 0.08018283168800455, 0.159010541358916, 0.13369791364502737, 0.14712870567830238, 0.020000000000000018, 0.02807267744989772, 0.1308730173839998, 0.17106349767395845, 0.09631727107881416, 0.09140217838020703, 0.074547617071687, 0.08567275565725996, 0.09761100031172787, 0.14659208297367665, 0.1373987191390692, 0.15475448018179316, 0.05226266613942554, 0.05593856663871977, 0.037495999209184006, 0.05771508978547257, 0.03640669958187914, 0.06371625687146287, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04172026911539517, 0.019028616126687048, 0.03333775650011672, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.020836909171743412, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0117553472136257, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09217265221347115, 0.06362380660904876, 0.09365485590148315, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.07415944183957424, 0.0700586756125644, 0.13044528293242608, 0.09947704322074091, 0.10698626364724684, 0.07757483295342749, 0.05665515157993595, 0.053936809511723194, 0.10015738318095213, 0.08751448474798007, 0.10425069735389902, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03605542461458544, 0.03779668105072587, 0.04133393256417994, 0.024895242935785933, 0.03347978021459386, 0.024640285494433645, 0.14615264013973417, 0.14784771677491504, 0.14898548596869443, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004900245710319995, 0.0007131634025354661, 0.0027726559689637, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.008565817622321337, 0.0, 0.0008396822844950469, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036124458357849276, 0.03681912652453734, 0.03102444845064245, 0.0, 0.0, 0.0, 0.042286216712183355, 0.04162829828728942, 0.03934679388966833, 0.08590688929650725, 0.08733077596351757, 0.07551751422845643, 0.0276776515772863, 0.038716666018372425, 0.0218174084149666, 0.08533117397113799, 0.07246771464450585, 0.06343884840191516, 0.0, 0.0, 0.0, 0.012621177046088006, 0.010249888395899243, 0.01239382604570649, 0.009112960506016177, 0.010666333763641678, 0.011564042247744877, 0.11156787334095863, 0.13104052587993853, 0.11178242841967345, 0.0, 0.0, 0.0]}}
{"id": "d204a506-947c-40f4-b092-7f3e6d2b6e25", "fitness": 0.040116682210788734, "name": "QuantumEnhancedAdaptiveSwarmOptimizer", "description": "Introduce quantum-inspired perturbations and adaptive swarm scaling to enhance convergence speed and solution accuracy in black-box optimization.", "code": "import numpy as np\n\nclass QuantumEnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def quantum_mutation(self, position):\n        mutation_scale = 0.1  # Quantum-inspired mutation scale\n        quantum_value = np.random.uniform(-1, 1, size=self.dim)\n        return position + mutation_scale * quantum_value\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1.5 + diversity)  # Adjusted scaling for quicker convergence\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * np.random.rand()\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * np.random.rand() * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.2  # Fixed Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.quantum_mutation(self.positions[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 86, "feedback": "The algorithm QuantumEnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04012 with standard deviation 0.04620.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.12746499912112852, 0.09647794640254947, 0.15758925772418086, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.05709414138150404, 0.03231164086096916, 0.026116052127952427, 0.03919436719812053, 0.03211962911262778, 0.021071538695435654, 0.07619362910042926, 0.05284711782842555, 0.05062912857307955, 0.08810308991739302, 0.020000000000000018, 0.020000000000000018, 0.05427760745524357, 0.09251453615787963, 0.08045093195180952, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15781406133264897, 0.1287696007665281, 0.15674210189945992, 0.036587543990285076, 0.031975253990072505, 0.022298834820578595, 0.08667859890266638, 0.09443855518183142, 0.0936973627397214, 0.14945129160489856, 0.1592838614321156, 0.15441522069034075, 0.08385606406361379, 0.07990382579724953, 0.07358359997684483, 0.14246094238212892, 0.1378564731603863, 0.1488952848257129, 0.020000000000000018, 0.020000000000000018, 0.09970805179149822, 0.16647754449161356, 0.10328398909045833, 0.10022638390493421, 0.08365044309977687, 0.1052577507110215, 0.09998630784321505, 0.15848382798514704, 0.16111766403191463, 0.15475448018179316, 0.04776306893901283, 0.03860799963294359, 0.027499102710355716, 0.05687254840413414, 0.041403144817711124, 0.07077035039444057, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03460953006035139, 0.01763877467964481, 0.02335139687739085, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011482666910028194, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09266504083197025, 0.06753059726181976, 0.08042545548893942, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05879562701147023, 0.06819470641897352, 0.05395939349942802, 0.12726296021029815, 0.1057178090800005, 0.11346011162218272, 0.08598511839394674, 0.04144943035790771, 0.05655738982263858, 0.09681039777533584, 0.09743285373145893, 0.10102043830956076, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03143944331582604, 0.03844380515919876, 0.042956339623480444, 0.039672868422483965, 0.031865450456953104, 0.024993687076073856, 0.14122894144810716, 0.1371081107867167, 0.13849787173717398, 0.012115204831565585, 0.010000000000000009, 0.010000000000000009, 0.013388475528046784, 0.0, 0.004305097426489546, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0019868238884959144, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04507228295320043, 0.04432263327466268, 0.03264913142239423, 0.0, 0.0, 0.0, 0.031224565932135295, 0.03770922979443825, 0.03983180619663884, 0.08689611243261497, 0.08861444511474503, 0.08169477003143821, 0.024404175612128376, 0.034855100095474434, 0.024023254856519682, 0.08262463419608668, 0.07502917555742483, 0.07113668987705946, 0.0, 0.0, 0.0, 0.011086090687037142, 0.011235648957484301, 0.011541470386708608, 0.009094479207304662, 0.010384479019394766, 0.01103790690505757, 0.11734614058426229, 0.1304161139054778, 0.12159445329093699, 0.0, 0.0, 0.0]}}
{"id": "dc4f028e-87d4-4693-b022-790d31fe26f6", "fitness": 0.040881097965736, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Incorporate variable mutation scale in chaotic mutations for enhanced adaptability in diverse optimization landscapes.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05 + 0.05 * np.random.rand()  # Incorporate variability in mutation scale\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04088 with standard deviation 0.04615.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11885773927196386, 0.11041086821629387, 0.16905579874487942, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.029479034936912285, 0.02609023923840903, 0.034588514786382696, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07800761985387306, 0.055312171169663915, 0.05196591829814001, 0.10395592301196144, 0.02940803220402355, 0.020000000000000018, 0.06009096199073449, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.037168161001563615, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13451642686619858, 0.12990457733276484, 0.18797865425721683, 0.028909861108883828, 0.029786604976165254, 0.03715296948406632, 0.08072694858327945, 0.0863116411064907, 0.08672905438351308, 0.1512377590323699, 0.17290237627546157, 0.14151797055492554, 0.08394151285702778, 0.07990382579724953, 0.09771040012651211, 0.1383399720750994, 0.11828503811930813, 0.13852765560618796, 0.020000000000000018, 0.10710756815137923, 0.12865100853900513, 0.16489339658893043, 0.09425779342709151, 0.09340895942680927, 0.08406100834923191, 0.08797246709787432, 0.09981200788849032, 0.1438526290318487, 0.14260471211501569, 0.15475448018179316, 0.04933844438691326, 0.056263405193379135, 0.05075187099392853, 0.05458810832462557, 0.035840605147488436, 0.06310838081527859, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05261152345822662, 0.020895953442866544, 0.039508938706121044, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08914997281647219, 0.06995125027220306, 0.0892177239652654, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05774038067976828, 0.07225879589661621, 0.0713988136914524, 0.13119281484841938, 0.10799703239644443, 0.1130251956368602, 0.07354272353222813, 0.05098920608019386, 0.055274536984725176, 0.09810809434968082, 0.08681732065945558, 0.10107156210477841, 0.06441656234031745, 0.010000000000000009, 0.010000000000000009, 0.03502357727272776, 0.030629240368487465, 0.044812004112487314, 0.027095990219142885, 0.033099365452699536, 0.024779880346195715, 0.13802191079211212, 0.13123409970527322, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004678153289927822, 0.00086558741861964, 0.0025698001996878883, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006220368146185429, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036662305593757494, 0.03828662176030373, 0.029730722604640603, 0.0, 0.0, 0.0, 0.041182601976952116, 0.04997631268625202, 0.03525267696184231, 0.08640975865949496, 0.08618824477682496, 0.07408916381442066, 0.026753566503401882, 0.0356485408783227, 0.019376291331639983, 0.08099561027826596, 0.07927939779062088, 0.05846025937943855, 0.0, 0.0, 0.0, 0.013332998759109649, 0.010311943684955804, 0.01248559834251639, 0.008450779653305651, 0.010685576423639431, 0.011083784124334639, 0.12250449918433803, 0.13109141362038423, 0.11468259862789765, 0.0, 0.0, 0.0]}}
{"id": "5c219677-6d1b-4d21-b7c8-c59f292460e2", "fitness": 0.04115777074326354, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhance the exploration-exploitation trade-off by incorporating adaptive chaotic dynamics and Levy flights with diversity-based parameter tuning for robust black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04116 with standard deviation 0.04686.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16865998096814616, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07801454253562246, 0.0553122962098519, 0.05198315820751109, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.09485730377370705, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14463712210405333, 0.020000000000000018, 0.1086159632455298, 0.12676342425437725, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.026701114134553783, 0.053838723921108, 0.03551333365980991, 0.06251255694319513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052702310810223474, 0.020847090132434687, 0.039316127913145094, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.0690653278680835, 0.09080654473535488, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05780285201293789, 0.08247904677910156, 0.06867912522087483, 0.13804028487350517, 0.10059146989951873, 0.11603057182456822, 0.07410737848799231, 0.055126236516060634, 0.053936809511723194, 0.09976547839093342, 0.08771993984301896, 0.10056258027619447, 0.06097698395185991, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.04354085641787209, 0.03083544610086375, 0.03247085960834395, 0.02491452834504637, 0.1460367740450299, 0.14995508500329047, 0.14920580819420282, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004255476537909475, 0.0006042807216090074, 0.0025435677552880787, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006201338235310883, 0.0, 6.427131687591903e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036761437563427646, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.04564205767772611, 0.041347738990614835, 0.034701169303381074, 0.08619032856391196, 0.08768521211623048, 0.07539063132411894, 0.027829751322100305, 0.038900516868527135, 0.022320025379924835, 0.08599548987369887, 0.07323695824976861, 0.063094016091916, 0.0, 0.0, 0.0, 0.01306696150149278, 0.010331259699854045, 0.012399266354949146, 0.008777970646403177, 0.01064139933457231, 0.011142454355775877, 0.11448749052965057, 0.1304161139054778, 0.12222123200721113, 0.0, 0.0, 0.0]}}
{"id": "966c2dec-3657-4209-9a22-69b50e85b782", "fitness": 0.040715680725676544, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce a small adaptive mutation factor based on the swarm's diversity to further fine-tune the balance between exploration and exploitation.  ", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity):  # Modified line\n        mutation_scale = 0.05 + 0.01 * diversity  # Adaptive mutation scale based on diversity\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04072 with standard deviation 0.04603.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11733050001960776, 0.1104099270359632, 0.17020322222068618, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0328213223604682, 0.025275671513657616, 0.03209126270826557, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0779810928159893, 0.05538538659800096, 0.05199683554251633, 0.10401737562734259, 0.029580181476419276, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.025263567382488694, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03720766275794207, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.13948793854449404, 0.13141073533847847, 0.18315230274049132, 0.02507938719862035, 0.02930982795234416, 0.03345839011092355, 0.08072694858327945, 0.0863116411064907, 0.09795943800702334, 0.1490003218780106, 0.17166827888199743, 0.13243458000537023, 0.07699933948754056, 0.07990382579724953, 0.08081655888614758, 0.1409176253610943, 0.11163739351853152, 0.12730279285977786, 0.020000000000000018, 0.10928679999464663, 0.12322557558632041, 0.1660058700775855, 0.09057412046148527, 0.10737088314373733, 0.09506243702733996, 0.08381465767651464, 0.10008138325481408, 0.1467739592014743, 0.14389843024675786, 0.15475448018179316, 0.058123616080140716, 0.056625498601438284, 0.027357673511751557, 0.053148158610220264, 0.035018073241123826, 0.06147500076534618, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05277356901934516, 0.020860196812134912, 0.03934849009654939, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.018497208004439325, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08979874238480046, 0.06721321066057684, 0.09176499487430378, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05916449328086415, 0.07872584225078272, 0.06391723122634607, 0.12881576582119447, 0.09676749300194787, 0.12020198638152235, 0.07442289223852316, 0.04872380190103742, 0.053936809511723194, 0.09169752026275024, 0.094611481384556, 0.10626658120408239, 0.06088067170024203, 0.010000000000000009, 0.010000000000000009, 0.035266825386354284, 0.030890134996217622, 0.04298822645836742, 0.03061171543595198, 0.03179380980166058, 0.024898242863926168, 0.13530084777517815, 0.14413103933760918, 0.13698762191359104, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003467597760911434, 0.0007530763033670729, 0.001851686313996348, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005901485977478305, 0.0, 0.00037567153430928535, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03615206164036011, 0.03793738605343766, 0.030244048420737246, 0.0, 0.0, 0.0, 0.042986075916144895, 0.038235642479936494, 0.03836896368667331, 0.0891012438718285, 0.08819914179777599, 0.07817239152794708, 0.027024942204825764, 0.0408906332066824, 0.023264033526215644, 0.07924370096470057, 0.07610173416658872, 0.06483718295868135, 0.0, 0.0, 0.0, 0.012830036570517844, 0.010321155059040188, 0.012184484793630435, 0.009085530459957303, 0.010658270969255867, 0.01102818099377445, 0.11925695238191092, 0.1304161139054778, 0.1035039018893883, 0.0, 0.0, 0.0]}}
{"id": "a01e5751-27f9-4c95-8271-3567993668da", "fitness": 0.040375894376361826, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce adaptive mutation scaling to enhance diversity control for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05 * (1 - self.calculate_swarm_diversity())  # Adaptive mutation scale\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04038 with standard deviation 0.04531.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.10394910676306035, 0.11039140670132341, 0.16205828367152808, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04347416297402373, 0.02711230361910255, 0.028181389118640543, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.07806304151127363, 0.05495729137719707, 0.051906115712734735, 0.07246950908470384, 0.0332392935610214, 0.020000000000000018, 0.06367571956325202, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03690204527084151, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1326274676127147, 0.12637754363813025, 0.18560985811560815, 0.026525497788799424, 0.029977368257417814, 0.039809357478000074, 0.08072694858327945, 0.0863116411064907, 0.0854966174108921, 0.16261993062969593, 0.15618792408018667, 0.1373771527147486, 0.08357641504662827, 0.07990382579724953, 0.08081601760284773, 0.12745621198692902, 0.12246123923503094, 0.12383978530931172, 0.020000000000000018, 0.09425043244692421, 0.12838953918261065, 0.16979183196093928, 0.08298935179118094, 0.09718649367014887, 0.06683583853514619, 0.10410977224126383, 0.09955457606088658, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.05244628254274408, 0.056481560854686585, 0.03523563496034687, 0.05674026909037111, 0.037753114636159935, 0.0670426974576922, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.052320193238284296, 0.020759505722698357, 0.03914527208587271, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02214573162476574, 0.010000000000000009, 0.010755604849713052, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08821981621242814, 0.07449066252437209, 0.08739201831179, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05907956994854946, 0.0669819440680891, 0.0548852390348914, 0.13205517125031707, 0.09922120458562045, 0.10301119065055064, 0.06492468279442665, 0.03988623285631698, 0.0564720601623353, 0.10660429309466235, 0.10418324105778565, 0.10455247624083042, 0.06071922583763101, 0.010000000000000009, 0.010000000000000009, 0.03182067918100129, 0.03121779569292993, 0.045884804155654435, 0.02975053516716697, 0.034696790841242664, 0.024975398421389183, 0.13530394214271657, 0.13508741530930513, 0.15002622473728833, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.006636661445717951, 0.000136719673201946, 0.004658619808980302, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.007599255258682103, 0.0043959574215202135, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03987198551376392, 0.037517084713935556, 0.028253882845481915, 0.0, 0.0, 0.0, 0.04383409001753147, 0.04609740598990231, 0.040672290032455316, 0.0853911773397984, 0.08933066342750762, 0.07759112181448868, 0.028294775143785644, 0.034908394814366694, 0.02326539840198083, 0.0813316528887692, 0.0778759320553154, 0.06306919078647166, 0.0, 0.0, 0.0, 0.013809720416614213, 0.010213570184314125, 0.012861349173793113, 0.007972193602646227, 0.01031630621062718, 0.01154581901778029, 0.11843861896739438, 0.1304161139054778, 0.11319218614568216, 0.0, 0.0, 0.0]}}
{"id": "080412f5-2e7f-4111-b343-34b06763aa2b", "fitness": 0.03575378499668411, "name": "RefinedAdaptiveChaoticSwarmOptimizer", "description": "Introduce adaptive mutation scaling and dynamic population size adjustments to enhance exploration and convergence dynamics in chaotic swarm optimization.", "code": "import numpy as np\n\nclass RefinedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.3\n        self.inertia_weight_max = 0.8\n        self.cognitive_coefficient_min = 1.2\n        self.cognitive_coefficient_max = 2.4\n        self.social_coefficient_min = 1.2\n        self.social_coefficient_max = 2.4\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.initial_population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def adaptive_mutation(self, position, factor, diversity):\n        mutation_scale = 0.02 + 0.08 * (1 - diversity / self.dim)  # Adaptive mutation scale\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def adjust_population_size(self, evaluations):\n        max_population_size = 40\n        min_population_size = 10\n        phase = evaluations / self.budget\n        return int(min_population_size + (max_population_size - min_population_size) * (1 - phase))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.initial_population_size)\n        \n        while evaluations < self.budget:\n            self.population_size = self.adjust_population_size(evaluations)\n            if self.positions.shape[0] != self.population_size:\n                self.positions = np.resize(self.positions, (self.population_size, self.dim))\n                self.velocities = np.resize(self.velocities, (self.population_size, self.dim))\n                self.personal_best_positions = np.resize(self.personal_best_positions, (self.population_size, self.dim))\n                self.personal_best_scores = np.resize(self.personal_best_scores, self.population_size)\n                chaotic_factor = np.resize(chaotic_factor, self.population_size)\n\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.adaptive_mutation(self.positions[i], chaotic_factor[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 91, "feedback": "The algorithm RefinedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03575 with standard deviation 0.04186.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.09864567171449812, 0.08725803528568998, 0.1400972251824787, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.022668133948602898, 0.020000000000000018, 0.025304165855824845, 0.020000000000000018, 0.020000000000000018, 0.024123610486116998, 0.05613683461931995, 0.0430393742577837, 0.051382685071464484, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03467400648357255, 0.08594148016760361, 0.08848083783040639, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1221122300491223, 0.11416871819300012, 0.141645307069445, 0.026670882824640807, 0.023479172790872527, 0.020000000000000018, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.13390462231635236, 0.1478587065796474, 0.11985406243921692, 0.0769433800265995, 0.07990382579724953, 0.07049709465795384, 0.1240045540416077, 0.09756014825334647, 0.12198685780234408, 0.020000000000000018, 0.020000000000000018, 0.09170261131180468, 0.1464709172424884, 0.12077765897433734, 0.10840529978291669, 0.06527120746322768, 0.06045053661471522, 0.05786424624887454, 0.17571805355238634, 0.1363681267022312, 0.15475448018179316, 0.045779075821808735, 0.03753956744817688, 0.029016735027844298, 0.04455893656582033, 0.027334715754814276, 0.0511124268966221, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.030289193883037746, 0.01517540422264152, 0.02391581069275628, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0800397103633338, 0.060531602565965015, 0.08434331759322977, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.06175814995315032, 0.059954727026639176, 0.1261784687109323, 0.10027118231883203, 0.10679926787858207, 0.059319313495161174, 0.039198228590997086, 0.05611768179050569, 0.09283232614680859, 0.07831350723543085, 0.10663559288897062, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.027622771023116832, 0.029043163533977734, 0.02967837144479657, 0.025300010619214275, 0.025166753780798357, 0.024732745543804113, 0.13141309820135194, 0.13123409970527322, 0.13721563972527162, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0030373097927572923, 0.0, 0.0015016129138599732, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.000913719407207747, 0.0023227328869035446, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03114631780444821, 0.03526120260720189, 0.027831882674844932, 0.0, 0.0, 0.0, 0.037554192132576714, 0.03753213255583987, 0.03013329652498753, 0.08711563599377681, 0.08499743802963822, 0.07260303872420837, 0.024985063627236626, 0.03169964228554234, 0.018727608190938883, 0.07863849938574019, 0.07548200180033204, 0.06043947413999462, 0.0, 0.0, 0.0, 0.011321009428222895, 0.009401732639753857, 0.011957697667934197, 0.007548436094943489, 0.010051284513262426, 0.009917728198743703, 0.1112398058338967, 0.1304161139054778, 0.1127002980026286, 0.0, 0.0, 0.0]}}
{"id": "0e7f468e-bb26-4185-9ebb-0c70ba0722f6", "fitness": 0.03923873395021639, "name": "EnhancedAdaptiveChaoticSwarmOptimizerV2", "description": "Introduce dynamic inertia weight using entropy-based swarm diversity and adaptive chaotic Levy flights to enhance global exploration and convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_entropy_based_diversity(self):\n        normalized_positions = (self.positions - self.lower_bound) / (self.upper_bound - self.lower_bound)\n        entropy = -np.sum(normalized_positions * np.log(normalized_positions + 1e-12), axis=1)\n        return np.mean(entropy)\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def dynamic_inertia_weight(self, diversity):\n        return self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * (1 - diversity)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_entropy_based_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.dynamic_inertia_weight(diversity)\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03924 with standard deviation 0.04502.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.12410225773442218, 0.08430948627392154, 0.15023396945838186, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.0301811640289944, 0.028510105184385237, 0.027294987139846683, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08426033338342764, 0.10797112084308791, 0.05898168094399836, 0.0290426949320981, 0.03507134464899142, 0.020000000000000018, 0.04331158244364419, 0.09895177553977408, 0.08409803117420633, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.14233812362638498, 0.10353174086604244, 0.17391626658767256, 0.05596580118122485, 0.025207177292022487, 0.025109020875787036, 0.09998963353002721, 0.0863116411064907, 0.07915599896346637, 0.14680394042180245, 0.1403682314986634, 0.13334415797870125, 0.07888032123667332, 0.07990382579724953, 0.07762953332595535, 0.12145150299339635, 0.10993920207099694, 0.16132530646111065, 0.020000000000000018, 0.020000000000000018, 0.10939855708308388, 0.16370288684416268, 0.1049364161584524, 0.12780780993342833, 0.07331971640393709, 0.08336008102246606, 0.08225425221912441, 0.15503158431428377, 0.13589170657517036, 0.15475448018179316, 0.04680134943999836, 0.035705291421977314, 0.028753438542349463, 0.05370708930418222, 0.03628597396523692, 0.045001988814061034, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0610001102113108, 0.027479516806195647, 0.03766529236877769, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0878115615792181, 0.07150558731906376, 0.07869267801118984, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06213624455646538, 0.06676354641448379, 0.05395939349942802, 0.12380499405274559, 0.10823988644052829, 0.10281775224528589, 0.06509942373568067, 0.04039654239737145, 0.05408742693067525, 0.09996573502151318, 0.09386181179615605, 0.10420535103607576, 0.1183625208036031, 0.010000000000000009, 0.010000000000000009, 0.03188813852752792, 0.031024817141524608, 0.031233391928878085, 0.026633948054156198, 0.03037519280812906, 0.02493432922044425, 0.13775297923507945, 0.1447183544665781, 0.13659332264751667, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004484513695922732, 0.0, 0.0027975104876264423, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.003971264433208721, 0.005101307206241912, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.032173967087551936, 0.0375463009370125, 0.03192418624743054, 0.0, 0.0, 0.0, 0.03416428959598916, 0.03753213255583987, 0.03673057913427458, 0.08503214309571494, 0.0900865138647946, 0.07483369298022413, 0.0263159537733495, 0.02768809944983952, 0.021120801994369054, 0.08482943670087906, 0.0814602213978235, 0.06553722251698635, 0.0, 0.0, 0.0, 0.012439379279136964, 0.009900790345083288, 0.012936007259893967, 0.007446122754348639, 0.010614679442639718, 0.010888580368887402, 0.11383281691684488, 0.1330249564986622, 0.1139386322040058, 0.0, 0.0, 0.0]}}
{"id": "6e8069a0-dd3e-49df-8831-3c3bc12807da", "fitness": 0.04086953356482962, "name": "ImprovedChaoticSwarmOptimizer", "description": "Introduce a self-adaptive chaotic mutation scale and enhanced swarm diversity control to improve exploration-exploitation dynamics and convergence rate in black-box optimization.", "code": "import numpy as np\n\nclass ImprovedChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor, diversity):\n        mutation_scale = 0.05 + 0.2 * (1.0 - diversity / self.dim)  # Dynamic mutation scale\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i], diversity)\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 93, "feedback": "The algorithm ImprovedChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04087 with standard deviation 0.04616.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11848501090370267, 0.1104038032159832, 0.16829315432159986, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.035843375605111305, 0.02587041859762107, 0.030848872266051153, 0.020000000000000018, 0.020000000000000018, 0.020152119793138135, 0.07795698709361587, 0.05529634290524643, 0.05199739917769319, 0.10356684281383366, 0.029628220343909217, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03713818831939508, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1361902162833044, 0.1309282192527561, 0.18426870695310926, 0.028718175205808105, 0.029532706439933665, 0.029611545750207524, 0.08072694858327945, 0.0863116411064907, 0.09538474081105164, 0.1499540829290109, 0.166206939081186, 0.1324347210842367, 0.07537634142050531, 0.07990382579724953, 0.08081643492878954, 0.12805916661104522, 0.13658682748925544, 0.13241438225197755, 0.020000000000000018, 0.10985604703252394, 0.12731738523893843, 0.1667743324101656, 0.08941297605473608, 0.09213356018416585, 0.09470013694886992, 0.0864603346115953, 0.09995935817185198, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.049426705860812215, 0.057823394350638435, 0.04012770218552475, 0.05366943844234617, 0.03545394071933938, 0.0621006645909713, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05281514022734368, 0.020935855040127738, 0.03932575725235887, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08961363221127261, 0.06906900668638283, 0.09108263351514823, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05621748915163183, 0.07571839591093332, 0.06479754978112018, 0.13496174514858505, 0.09763174691722187, 0.1181264628492662, 0.07277062400392964, 0.05470093509717289, 0.053936809511723194, 0.10193334656052766, 0.09273668835269955, 0.10836426571310787, 0.05945760157863933, 0.010000000000000009, 0.010000000000000009, 0.034766956124188564, 0.03125326632879177, 0.043348956962887875, 0.03125091898832044, 0.03238664221285503, 0.024855353005241998, 0.1426589930929134, 0.1451742563555718, 0.13929559824474513, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.003811368020294914, 0.0004374606788182245, 0.002121505182140604, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006037230372855085, 0.0, 0.00048518030540889434, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03641668653654828, 0.03795833145719807, 0.030175050173129603, 0.0, 0.0, 0.0, 0.04436820563328647, 0.03938120391130151, 0.04074111359311583, 0.08834139773787852, 0.0884986262740558, 0.07836867792509239, 0.027695976668971722, 0.039842560982238706, 0.023146701887684085, 0.08011015109323527, 0.07107170812179575, 0.06337740860831031, 0.0, 0.0, 0.0, 0.012792872485724471, 0.010327477704518584, 0.012270348526085106, 0.008986067340207127, 0.010654286561671111, 0.01148157045157061, 0.11957565598106479, 0.1304161139054778, 0.11828848295863081, 0.0, 0.0, 0.0]}}
{"id": "00aab878-a669-4922-a064-7a317c7b751b", "fitness": 0.040897786362783, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Introduce a dynamic mutation scale in the chaotic mutation to further enhance fine-tuning without compromising exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05 * (1 - factor)  # Dynamic mutation scale based on chaotic factor\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04090 with standard deviation 0.04612.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11828796123469809, 0.11040399007041168, 0.16793732201761513, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03534520880872638, 0.0257255425433931, 0.030686860423498108, 0.020000000000000018, 0.020000000000000018, 0.020141010416151017, 0.07804574759853522, 0.05527135699237562, 0.051978201167959925, 0.10357244950883371, 0.02961396302996422, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03711370017632121, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1370432628959748, 0.12861359341609047, 0.1843100961418963, 0.02868337826434908, 0.02952513501668219, 0.031259628487500524, 0.08072694858327945, 0.0863116411064907, 0.09227413822910446, 0.15601537956024458, 0.16664211947645924, 0.13670073998745846, 0.08812403546792591, 0.07990382579724953, 0.08081639127232942, 0.13398560241584678, 0.11286107397458012, 0.1463332232327439, 0.020000000000000018, 0.10727229733169619, 0.12715106588797875, 0.16658085162770808, 0.09120343215561033, 0.09246183807746033, 0.0907251951634871, 0.09223132801551415, 0.09991721431518186, 0.1438526290318487, 0.13589170657517036, 0.15475448018179316, 0.049487309160219595, 0.05780112408696669, 0.04243207052160902, 0.05397976603092158, 0.0356924980429858, 0.06288812979447489, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05267711179754575, 0.020797573763707833, 0.03930976096118921, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.014146823553227383, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08941277404865178, 0.06976354048018829, 0.09122349342802083, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05818538193496092, 0.07642642149426881, 0.07333818864434893, 0.13796070864583754, 0.10100387161035074, 0.11714445865155698, 0.07159433097890999, 0.055197428665293535, 0.053936809511723194, 0.10038023244962413, 0.0878945221232087, 0.1051254023999415, 0.06165800805556321, 0.010000000000000009, 0.010000000000000009, 0.03437136258736184, 0.03069498544443927, 0.04380061201436081, 0.030746529954288948, 0.032740721795118666, 0.024925517721145707, 0.14892817592783425, 0.13595488652095145, 0.136017139422262, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004405217561388675, 0.0006692759984083807, 0.002643835440071407, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006255126703443303, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03689209949204797, 0.03797784254825198, 0.030001143416678255, 0.0, 0.0, 0.0, 0.044887969536949734, 0.04163758289467401, 0.032737323401185736, 0.08573145405857785, 0.08665829637170774, 0.07545817549619216, 0.027663507632767925, 0.03863394577931922, 0.02230643842309077, 0.081635564827516, 0.07302131787750499, 0.0663774110730252, 0.0, 0.0, 0.0, 0.013134441860278234, 0.010329727900559527, 0.012435383570227998, 0.008684341077361823, 0.01063209149006028, 0.011178253586089926, 0.11338860872301015, 0.1304161139054778, 0.11136407364127265, 0.0, 0.0, 0.0]}}
{"id": "a08139b2-831e-437f-bfff-389dc38d48d7", "fitness": -0.026595197992691805, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhance exploration by increasing the initial population size for better diversity in early iterations.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased initial population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05  # Reduced mutation scale for finer perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02660 with standard deviation 0.11582.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.13655389840137844, 0.12879915429738897, 0.14583947822180432, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04253059198942777, 0.04663386988373819, 0.0437715299849083, 0.020000000000000018, 0.02279714585881709, 0.021055067622215096, 0.05435668772033775, 0.05457255348007717, 0.05329140652673514, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.059080360525352926, 0.08777846717930371, 0.08212131783592558, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04775526602674118, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02435491987312588, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1345556896607567, 0.13581114623909452, 0.1485761269988538, 0.030221968775129837, 0.02163406901678766, 0.028688266966747977, 0.08072694858327945, 0.0863116411064907, 0.07015575039186472, 0.15483082739957443, 0.14724909797843677, 0.12481630226504814, 0.07359039023342162, 0.08581629373512945, 0.062164281636260865, 0.14584210677683973, 0.11272587309226001, 0.1323658983823015, 0.11216557976024433, 0.020000000000000018, 0.10505458338216256, 0.10819636878037442, 0.10979076860811943, 0.10592004355969076, 0.0677162831653646, 0.06544194592905772, 0.06613769912489587, 0.1438526290318487, 0.14243283588818745, 0.15475448018179316, 0.05158449799566678, 0.036088809579099435, 0.03776649763968143, 0.04065914096807688, 0.049836073213664234, 0.0644829491710549, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.023472840894831926, 0.019294097827908807, 0.031189740339489735, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.015917045487575887, 0.013208751109881955, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09101983624744037, 0.09048381427085905, 0.0779141298348156, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05668930609104483, 0.06698513825263874, 0.054566909141540054, 0.13014925854298043, 0.1039644935764289, 0.10630494688036363, 0.07133451768509302, 0.0432417288561977, 0.053936809511723194, 0.09624954194256974, 0.09311844866837626, 0.09728264921417773, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05840167789683659, 0.034838109767791114, 0.03379298525545593, 0.028921325172819756, 0.02681557946080826, 0.024643585301046378, 0.13336422493380595, 0.13412080682136107, 0.13672935580627155, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.18928230890396147, -0.1997394493313387, -0.19662261890283128, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19551830665039582, -0.19863050280221506, -0.19976692699011633, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.14487851432162802, -0.15222118517383798, -0.14092727355215762, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.159500582534565, -0.15463961044304209, -0.1577285075090451, -0.09053606241282108, -0.08593777403858427, -0.09353937321763706, -0.16644935645585512, -0.16005134145173638, -0.16803145956196586, -0.10954136966532069, -0.09915167406467096, -0.10686816429347834, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18417337019523505, -0.18824475047998201, -0.18613450167088086, -0.18999990326918126, -0.18773888914580827, -0.1897095334399086, -0.05951002563853103, -0.043207726894507026, -0.06348893884686624, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
{"id": "94645983-67ac-4621-9be1-107d7bcc88c9", "fitness": 0.041041521719116014, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Integrate adaptive chaos-influenced inertia and Levy-enhanced perturbations to improve convergence precision in dynamic black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i] * 0.9  # modified\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.5 * (1 - diversity / self.dim)  # modified\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.02 * self.levy_flight(self.dim)  # modified\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04104 with standard deviation 0.04676.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.11799138879092386, 0.11040660718970907, 0.16865542639487785, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.034620814528785515, 0.024663011746407282, 0.031206155216450315, 0.020000000000000018, 0.020000000000000018, 0.020149493760229786, 0.07802306830596861, 0.0553122962098519, 0.05198316190310481, 0.10377292628748325, 0.029594606753484243, 0.020000000000000018, 0.063458867511336, 0.08594148016760361, 0.11179796376536022, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03715820379988399, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.1375053938323012, 0.12979582746132767, 0.18399181680048082, 0.027234721077029622, 0.029432425048911415, 0.03125654450257198, 0.08072694858327945, 0.0863116411064907, 0.08824737776838176, 0.1533592323305859, 0.16977729636685912, 0.13243468046359386, 0.08443266165599939, 0.07990382579724953, 0.08081647062016684, 0.15776119163480362, 0.13437159945538835, 0.14463712210405333, 0.020000000000000018, 0.1086159632455298, 0.12656417119393326, 0.1660459979402712, 0.09090393350512382, 0.09142959214924729, 0.09275473890193098, 0.0885968645541001, 0.09999468185139937, 0.1438526290318487, 0.137514643182446, 0.15475448018179316, 0.05172587782445437, 0.057417985508269265, 0.030235207885905058, 0.0536707276619246, 0.03536196012028814, 0.06270618376442172, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05259246402508866, 0.02096161317214651, 0.039334815084875796, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.021633740728489115, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.01165504165856135, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.08953252538063117, 0.069262498018275, 0.09147803025844392, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05459995317003097, 0.07995375210840772, 0.06867912522087483, 0.13067325257078477, 0.1004139358060887, 0.11428512504582589, 0.07351278912705883, 0.0552599696640772, 0.053936809511723194, 0.10150970356911126, 0.08665824661692256, 0.10298154619948918, 0.05506717079863077, 0.010000000000000009, 0.010000000000000009, 0.03452613212204314, 0.03068101448454097, 0.04319700191261322, 0.03115092400095054, 0.03247085960834395, 0.024968682946119536, 0.1463337260639177, 0.14995508500329047, 0.1494512080288305, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.004253171193038252, 0.0006865084563031365, 0.0024813285623821457, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.006234009488979231, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.036639895013124146, 0.0379749533053676, 0.030036399032335348, 0.0, 0.0, 0.0, 0.04021075449406486, 0.04305203996818252, 0.0356594901235735, 0.08584376134861016, 0.08768521211623048, 0.07467746278194742, 0.027345849361252617, 0.038900516868527135, 0.022320025379924835, 0.08568439016632479, 0.07323695824976861, 0.06133214440339574, 0.0, 0.0, 0.0, 0.012941194687792534, 0.010331259699854045, 0.012377250481907631, 0.007991680595014206, 0.01064139933457231, 0.01119427540615503, 0.12267922006467602, 0.13447476349078102, 0.11248814790496386, 0.0, 0.0, 0.0]}}
{"id": "159ab272-4214-4bb8-87ac-d5daf81b8ff1", "fitness": 0.02549173939364177, "name": "EnhancedAdaptiveChaoticSwarmOptimizer", "description": "Enhance swarm behavior by dynamically adjusting population size and incorporating a more precise chaotic mutation strategy for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, int(np.sqrt(dim) * 3))  # Dynamically adjust population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 4.0\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.025  # More precise perturbations\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)  # Dynamic Levy flight probability\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02549 with standard deviation 0.05471.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.10867388967287606, 0.12899498395421316, 0.19810953012882526, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.02328512693916107, 0.029603164589421693, 0.021760946361264466, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.08207050017367012, 0.06340209104718841, 0.16030915556088043, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.049284148636842384, 0.08686226535568409, 0.08457498175554445, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.09636404848187452, 0.14369434231990885, 0.14709643739617217, 0.022243257709262942, 0.020000000000000018, 0.020000000000000018, 0.08387344275282427, 0.10163665713482539, 0.07261262372075838, 0.15286898054480869, 0.14074072076213406, 0.14099781118398758, 0.1093821306508671, 0.08229802146424026, 0.07955596679514154, 0.12474824540267249, 0.12122254921903786, 0.13994002647455805, 0.020000000000000018, 0.020000000000000018, 0.1462400215595291, 0.09257344398453338, 0.09135921627087118, 0.08091545196639094, 0.0842953837142153, 0.05331609766378842, 0.08373008722395725, 0.16467275726526798, 0.1334719882711224, 0.15277999975923873, 0.04913367149872239, 0.03389627143379981, 0.02657515876140404, 0.058671242387860145, 0.02289341062355743, 0.0552390890239165, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06838450189344869, 0.03179712799073886, 0.040622911599896394, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.06942968732517141, 0.06721153762818077, 0.08064624815070787, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.056912938251002076, 0.07971858656305497, 0.07181612827172446, 0.13491951791989465, 0.10517295706829255, 0.10485988570910021, 0.06149105005885058, 0.03813724228107729, 0.0571573252740637, 0.0858584885037953, 0.08764163500291133, 0.10169861097257171, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.02511230767777961, 0.030440085687999052, 0.03032791589458539, 0.028713986940216207, 0.020894773772724418, 0.04200183545872316, 0.13530997557397617, 0.1411989044655857, 0.14607044931351454, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.03282007218699112, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.03360046259343075, -0.03363298218022215, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, 0.006606429170472827, -8.56510919984288e-05, -0.014530165740755718, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, 0.004122898143786857, 0.004587789624408867, -0.006572790264264716, 0.052633491519481934, 0.055160867117120316, 0.04720304081798987, -0.006799624343432287, -0.0063067382100407965, -0.019722429787131457, 0.0370252040175969, 0.03417861706273728, 0.030325941088112707, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036, -0.029102468103652468, -0.030085337610611385, -0.029004525412518856, -0.032512338831584886, -0.030535631983365397, -0.030084496566439967, 0.07904280065494929, 0.09569134574548088, 0.08551704612451816, -0.040000000000000036, -0.040000000000000036, -0.040000000000000036]}}
{"id": "3f98486a-ea54-469a-9bd2-b12554fada15", "fitness": 0.03997914523103536, "name": "HybridAdaptiveChaoticSwarmOptimizer", "description": "Introduce hybrid parallel swarming with adaptive chaos infusion to elevate search diversity and intensify convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_max = 0.9\n        self.cognitive_coefficient_min = 1.0\n        self.cognitive_coefficient_max = 2.0\n        self.social_coefficient_min = 1.0\n        self.social_coefficient_max = 2.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 3.57\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.05\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + diversity) / (1 + diversity)\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def parallel_swarm_interaction(self):\n        random_indices = np.random.choice(self.population_size, self.population_size // 2, replace=False)\n        for i in random_indices:\n            partner = np.random.choice(self.population_size)\n            if self.personal_best_scores[i] > self.personal_best_scores[partner]:\n                self.positions[i] = self.personal_best_positions[partner]\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                levy_prob = 0.1 + 0.4 * (1 - diversity / self.dim)\n                if np.random.rand() < levy_prob:\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n            self.parallel_swarm_interaction()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 98, "feedback": "The algorithm HybridAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03998 with standard deviation 0.04553.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.12543252821507622, 0.11767675532669386, 0.16548299221770724, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.04176692286111494, 0.021750524476884192, 0.025895840200552134, 0.033584142014057905, 0.020000000000000018, 0.020000000000000018, 0.07598358217038392, 0.05358249235449508, 0.052469895971017255, 0.03267470599299793, 0.030415710294404374, 0.020000000000000018, 0.0647655060116441, 0.08594148016760361, 0.08991316144714656, 0.0566958484580653, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.15164104797488842, 0.12916635523248632, 0.17083499845865147, 0.024280531975205744, 0.03878943002874391, 0.03071918396320228, 0.08072694858327945, 0.10257367488613167, 0.08010371141952799, 0.14520414594723297, 0.15917808082559304, 0.15232015813720468, 0.07328679069344146, 0.07990382579724953, 0.08200543911237124, 0.13155049895467807, 0.13047580069654885, 0.12957984234151954, 0.020000000000000018, 0.06697860742113937, 0.13059609719264786, 0.1659843196977332, 0.07833548636704901, 0.11412768030522502, 0.0883121795854026, 0.0762199014079673, 0.08674698246288604, 0.1466619957877794, 0.13589170657517036, 0.15475448018179316, 0.04873678978280138, 0.03843058357206286, 0.03494523833207319, 0.05503512748179018, 0.03313484664257149, 0.06400969458283368, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.04414406468559884, 0.01856030646007356, 0.03880107951170697, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09207583307532408, 0.06909390222956635, 0.07853870115368677, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.0547405278750287, 0.07090747604732583, 0.06818566315474583, 0.14477410352030662, 0.10694577465638133, 0.10638448516106525, 0.0755518182886099, 0.054965114147095595, 0.05504840404099698, 0.09623351218419995, 0.08806661792941595, 0.1100785572042372, 0.06560917297418101, 0.010000000000000009, 0.010000000000000009, 0.03537502635745837, 0.034624283184863436, 0.0502946875221052, 0.0256769311088747, 0.03305642833389688, 0.02482185727850339, 0.1394998725507932, 0.1423030544648316, 0.1337832524086161, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.007783749927842476, 0.0, 0.0020880741668358738, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001995798537399174, 0.0003828985467544399, 0.0003721613603068219, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03578062404882443, 0.03886095714787696, 0.029017560296889955, 0.0, 0.0, 0.0, 0.03170188230769644, 0.03753213255583987, 0.039254284941838025, 0.08586696627322399, 0.08279875021161698, 0.0786036299767835, 0.02443473409043817, 0.03348489275016664, 0.02145325540363685, 0.08584656114555356, 0.07919518264945469, 0.06593674311063069, 0.0, 0.0, 0.0, 0.012252747257103902, 0.010630331413786442, 0.0124722939713664, 0.008225426287212345, 0.011059258025788998, 0.010787032482141634, 0.1112398058338967, 0.1304161139054778, 0.11260674318103481, 0.0, 0.0, 0.0]}}
{"id": "c94eb13a-9b00-47bd-a5d1-dfe0cf107e9e", "fitness": -0.02722850813326965, "name": "RefinedAdaptiveChaoticSwarmOptimizer", "description": "Integrate adaptive multi-stage exploration with chaotic perturbations and dynamic diversity-based strategy switching to enhance convergence in black-box optimization.", "code": "import numpy as np\n\nclass RefinedAdaptiveChaoticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.inertia_weight_min = 0.2  # Lowered for better convergence\n        self.inertia_weight_max = 0.8\n        self.cognitive_coefficient_min = 1.2\n        self.cognitive_coefficient_max = 2.5\n        self.social_coefficient_min = 1.5\n        self.social_coefficient_max = 2.5\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, dim))  # Reduced initial velocity range\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n\n    def logistic_map(self, x):\n        r = 3.9  # Slightly reduced to maintain stability\n        return r * x * (1 - x)\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        return u / np.abs(v) ** (1 / beta)\n\n    def chaotic_mutation(self, position, factor):\n        mutation_scale = 0.03  # Further reduced for stability\n        chaotic_value = self.logistic_map(factor)\n        return position + mutation_scale * chaotic_value * np.random.uniform(-1, 1, size=self.dim)\n\n    def calculate_swarm_diversity(self):\n        return np.mean(np.linalg.norm(self.positions - np.mean(self.positions, axis=0), axis=1))\n\n    def adaptive_velocity_scaling(self, diversity):\n        return (self.inertia_weight_min + (diversity / self.dim)) / (1 + diversity)  # Adjusted scaling\n\n    def update_learning_coefficients(self, diversity):\n        adaptive_factor = diversity / self.dim\n        self.cognitive_coefficient = self.cognitive_coefficient_min + adaptive_factor * (self.cognitive_coefficient_max - self.cognitive_coefficient_min)\n        self.social_coefficient = self.social_coefficient_max - adaptive_factor * (self.social_coefficient_max - self.social_coefficient_min)\n\n    def diversity_based_strategy_switch(self, diversity):\n        if diversity < 0.5:  # Threshold for switching strategies\n            return True\n        return False\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_factor = np.random.rand(self.population_size)\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i]\n\n            diversity = self.calculate_swarm_diversity()\n            self.update_learning_coefficients(diversity)\n\n            for i in range(self.population_size):\n                chaotic_factor[i] = self.logistic_map(chaotic_factor[i])\n                self.inertia_weight = self.inertia_weight_min + (self.inertia_weight_max - self.inertia_weight_min) * chaotic_factor[i]\n                inertia = self.adaptive_velocity_scaling(diversity) * self.velocities[i]\n                cognitive = self.cognitive_coefficient * chaotic_factor[i] * (self.personal_best_positions[i] - self.positions[i])\n                social = self.social_coefficient * chaotic_factor[i] * (self.global_best_position - self.positions[i])\n                \n                if self.diversity_based_strategy_switch(diversity):\n                    levy_step = 0.01 * self.levy_flight(self.dim)\n                    self.positions[i] += levy_step\n\n                self.velocities[i] = inertia + cognitive + social\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = self.chaotic_mutation(self.positions[i], chaotic_factor[i])\n                self.positions[i] = np.clip(self.positions[i], self.lower_bound, self.upper_bound)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 99, "feedback": "The algorithm RefinedAdaptiveChaoticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of -0.02723 with standard deviation 0.11524.", "error": "", "parent_ids": ["9b1107e8-ee21-496c-8b02-d616d4b47bb7"], "operator": null, "metadata": {"aucs": [0.12451504454784323, 0.15003971885340017, 0.12301458980379598, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.023694293999145466, 0.041738548873100245, 0.024700806978717904, 0.022492569407323804, 0.020000000000000018, 0.026093744902479066, 0.055229179431313224, 0.05556921304940399, 0.05183542943749875, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.03898388398568442, 0.09071834910138021, 0.07616172836226054, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.020000000000000018, 0.11229802698157809, 0.1216141062913274, 0.16240068934673335, 0.027862644764749422, 0.026541696532764503, 0.02647446350006233, 0.08850323188426301, 0.09574105279074951, 0.08249574878390886, 0.14783004902008046, 0.14517752627714176, 0.12689186716735945, 0.07420898384583385, 0.08678143991791432, 0.06697750595975382, 0.13483314824527337, 0.11169494904607602, 0.16103561982320225, 0.03003663809538326, 0.020000000000000018, 0.05614698891209624, 0.11785934550042687, 0.10843395367514208, 0.10875048842172164, 0.0750076599987366, 0.07819144369841557, 0.05691726796399821, 0.1438526290318487, 0.14778651352229577, 0.15475448018179316, 0.052807613224848615, 0.036326480236037906, 0.03211057953961327, 0.04429414622044647, 0.041122324656665654, 0.06748642517611458, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.03447273039912535, 0.02293015729857617, 0.0392989374581717, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.013602001659857699, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.011975143790669551, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.09542004023185668, 0.09934301740870521, 0.07949236180110963, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, 0.05471102905448921, 0.07269613504103523, 0.054322810467117066, 0.12680724352784767, 0.10294405410448049, 0.10724569660191707, 0.06913798704020013, 0.043205058009406994, 0.05412192652654402, 0.08962638120241817, 0.08527464629875114, 0.11488047259069889, 0.019622461097844823, 0.010000000000000009, 0.010000000000000009, 0.038293293632880365, 0.045283794122789045, 0.035474940197623206, 0.028215938408858277, 0.030921959694031664, 0.02700864038175732, 0.13247321517124688, 0.13209559084518108, 0.1362397668968629, 0.010000000000000009, 0.010000000000000009, 0.010000000000000009, -0.19765692497067344, -0.1980534461630734, -0.19792285385267583, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19901372918313776, -0.19995887442518034, -0.19914558403742166, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.1439092481771469, -0.15020400627421027, -0.1466437485475094, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.15192690767689876, -0.14175604720054813, -0.15583564650569248, -0.08835368762496576, -0.09394471411798055, -0.1021819627704117, -0.1628641998860887, -0.1616156255053709, -0.16743847038673554, -0.09179234422747573, -0.10460039195820348, -0.10314198935228669, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996, -0.18583030644103626, -0.18494209996900035, -0.1855150289783405, -0.18990064910178583, -0.18724773656949112, -0.18938654110836972, -0.058129511413584245, -0.04098299500545788, -0.06463474528525248, -0.19999999999999996, -0.19999999999999996, -0.19999999999999996]}}
