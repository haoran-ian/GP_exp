{"id": "1c7da0cf-d6eb-46f0-be7d-f25961834d58", "fitness": 0.024097161483298254, "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization and Differential Evolution to efficiently explore and exploit the search space for black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.020786864025374552, 0.009076238418586402, 0.022704654988335626, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.008720582864200965, 0.004737512308129355, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.061550580354802764, 0.061105674360706685, 0.04869187635235461, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.043180461463812714, 0.0514877092853403, 0.041236072599862506, 0.09415597103652373, 0.10421115350100907, 0.08999896175570032, 0.04065081926485026, 0.0338847603072705, 0.030838689843374234, 0.09495673071298616, 0.08912323519873355, 0.096468107516827, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019874180218813153, 0.018085850358571576, 0.01652204838992033, 0.014920606313934548, 0.01503128110650409, 0.015306244696970173, 0.14091734616630225, 0.13554948993953375, 0.12426540170901401, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7c03e030-fc83-4bbb-8ee8-d3eceb8e9d5b", "fitness": 0.02377164868659004, "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization and Differential Evolution with a dynamic inertia weight for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.9  # Updated line: Changed the inertia weight to a slightly higher value\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["1c7da0cf-d6eb-46f0-be7d-f25961834d58"], "operator": null, "metadata": {"aucs": [0.010002139509937447, 0.006472744925941298, 0.023192289765655127, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.005033232103786256, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05393530790090606, 0.05837189852575164, 0.047478797720194144, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04323951282743965, 0.04980159979872101, 0.03730110218130667, 0.10158253131309414, 0.10534286052360509, 0.09194871151131045, 0.036793915335685545, 0.041532172104204346, 0.034665967140845244, 0.09318502079414503, 0.08892851579422478, 0.09213789682124929, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018599577453248806, 0.01716937301558552, 0.01709062588343957, 0.015704466988626598, 0.0165912899562638, 0.013920258822087028, 0.1322277144445989, 0.1273694054373441, 0.14063542900919945, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ec3752f3-20dc-4d98-89e0-c2bdba32fe89", "fitness": 0.023991476811943264, "name": "HybridPSODE", "description": "Enhance particle convergence by increasing the crossover probability in the Differential Evolution step.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.95  # Increase crossover probability\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["1c7da0cf-d6eb-46f0-be7d-f25961834d58"], "operator": null, "metadata": {"aucs": [0.021324245178340973, 0.009076238418586402, 0.022669242172520532, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.005973179799958039, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05126791988882673, 0.061105674360706685, 0.04869187635235461, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04405717715250812, 0.0514877092853403, 0.039613291292204034, 0.0949213105740292, 0.10421115350100907, 0.09151897579750046, 0.04065081926485026, 0.03380106602738875, 0.030057429537675873, 0.09459597981199941, 0.08912323519873355, 0.096468107516827, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019874180218813153, 0.015682389387360884, 0.01668735284893641, 0.01457966558726298, 0.0171038770220302, 0.015789550356718918, 0.14091734616630225, 0.13554948993953375, 0.1292834999755107, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "dc2940dd-bd1f-4bd2-89f0-06844b5c09ee", "fitness": 0.02412231164459774, "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization and Differential Evolution, enhanced by dynamic inertia weight adjustment to efficiently explore and exploit the search space for black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["1c7da0cf-d6eb-46f0-be7d-f25961834d58"], "operator": null, "metadata": {"aucs": [0.011774781722260763, 0.008439477184777444, 0.025992304726085158, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.008888625342180156, 0.004503638866060644, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056707067136319456, 0.0623020127306223, 0.0472921311793747, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04421096662912638, 0.05122019487430152, 0.04509164083021511, 0.09934355318556498, 0.10542863016157, 0.08770607882824355, 0.037963331561626124, 0.03976722443126035, 0.033811225563918135, 0.09710292635617412, 0.09154058212051075, 0.08754187845944572, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019249384810779535, 0.017991339747389756, 0.017138933953182778, 0.016160973272506096, 0.01553775227878218, 0.01575100352158687, 0.13477728400127398, 0.12405910513349605, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "18d44862-9a00-428f-beb8-30d1f4f511ed", "fitness": 0.023983018499485934, "name": "HybridPSODE", "description": "A refined hybrid metaheuristic combining PSO and DE, with enhanced global exploration through adjusted crossover probability.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.95  # Line changed: Adjusted crossover probability\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["dc2940dd-bd1f-4bd2-89f0-06844b5c09ee"], "operator": null, "metadata": {"aucs": [0.011156595823958004, 0.008380118214755594, 0.025806896445831562, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006422959333494793, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.050187515566511465, 0.06416242988297927, 0.0472921311793747, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04834350439074886, 0.05122019487430152, 0.05057964647049118, 0.09934355318556498, 0.10542863016157, 0.08770607882824355, 0.037963331561626124, 0.04079312761283682, 0.03462884630875873, 0.09710292635617412, 0.08951491986838389, 0.08761382215383018, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019155237472298747, 0.017117560545516275, 0.0166402493838389, 0.016181388923943385, 0.016751672238702442, 0.016653677620708907, 0.12537335690296691, 0.12139674476621709, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1f022404-ad22-4309-9e59-ca2cafa3e9c3", "fitness": 0.023906129477279252, "name": "HybridPSODE", "description": "An enhanced version of HybridPSODE with improved dynamic inertia weight for better exploration in early iterations.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / (self.budget * 0.8)) * 0.5  # Improved dynamic inertia weight\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["dc2940dd-bd1f-4bd2-89f0-06844b5c09ee"], "operator": null, "metadata": {"aucs": [0.012556736513787081, 0.010991703031900224, 0.025233065220426343, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.008784114397062948, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.058521922601248666, 0.06345964590157727, 0.047402335563408005, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047092839023770594, 0.05261878134832365, 0.04208084264098222, 0.0969239336154154, 0.10588382345402736, 0.0910170592263636, 0.040265252309342414, 0.03823504022853896, 0.037777084658333404, 0.09273500558138381, 0.08445558929677233, 0.09566225627034519, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019365713828860653, 0.019099984255984026, 0.016782118445918925, 0.016311821081072098, 0.015608722970416267, 0.01571981536798961, 0.12462423694147373, 0.12613731235428227, 0.12459021840901308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "bb8ecbd3-b72f-4077-a7c1-d17998b98d96", "fitness": 0.02395422105665375, "name": "HybridPSODE", "description": "A minor adjustment to the hybrid PSO-DE algorithm which modifies the inertia weight formula for potentially enhanced convergence in black-box optimization problems.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations**0.5 / self.budget**0.5) * 0.5  # Modified inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["dc2940dd-bd1f-4bd2-89f0-06844b5c09ee"], "operator": null, "metadata": {"aucs": [0.021512024861335632, 0.00834107281014862, 0.025199777343201335, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.008651937194650183, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05870211253211277, 0.06266935910585181, 0.04891993949049778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04617812987464254, 0.051827106598794304, 0.04232175276678385, 0.09569516986142812, 0.10445100659523299, 0.08905115696488275, 0.04141719008829725, 0.03941232836316566, 0.032830297381715834, 0.09693037379832403, 0.09018698332211905, 0.09630800741237378, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019919605217892156, 0.01953364660566459, 0.016790680636443067, 0.01470255707671142, 0.01574849893584862, 0.01607453580529361, 0.11805474099614521, 0.12969787279125844, 0.12227170382216845, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "48128691-d3e9-40f4-bfcb-b7c48c54ec6d", "fitness": 0.023725453709863113, "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization and Differential Evolution, enhanced by a slightly higher dynamic inertia weight adjustment to explore and exploit the search space for black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.92 - (evaluations / self.budget) * 0.5  # Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["dc2940dd-bd1f-4bd2-89f0-06844b5c09ee"], "operator": null, "metadata": {"aucs": [0.011498528949864473, 0.008292810763778857, 0.023990237863598995, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.008658863700075514, 0.004764538892677028, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06002407120645692, 0.062338874598942606, 0.04735066293673429, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0455354410123342, 0.051335086016268905, 0.04303219368798705, 0.09723700893131904, 0.10348021568839771, 0.08735906968030371, 0.04415439689615719, 0.03574691325632939, 0.03846601065218702, 0.09153399786838567, 0.0892135517850815, 0.093356172135456, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019156727806978968, 0.017886805493488867, 0.017256694835466657, 0.01614650634230419, 0.015366212601021778, 0.013891751342665626, 0.12748973521386897, 0.12408804644528393, 0.12262501876759968, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "00124723-0fbf-4e2e-8f61-b6f9a7b2bd90", "fitness": 0.02415059430266408, "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization and Differential Evolution, enhanced by dynamic inertia weight adjustment and adaptive differential weight to efficiently explore and exploit the search space for black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)  # Adaptive differential weight\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["dc2940dd-bd1f-4bd2-89f0-06844b5c09ee"], "operator": null, "metadata": {"aucs": [0.014243831165356657, 0.00814900426590559, 0.025830300615574342, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006912761219556418, 0.0045043600321351684, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056659923142658775, 0.062422929418844975, 0.04731159211409419, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04421096662912638, 0.05122019487430152, 0.05057964647049118, 0.09936521559523948, 0.10542863016157, 0.08776388131074409, 0.039113598006301764, 0.03943892303808372, 0.036584917963017216, 0.09713577689924247, 0.08951491986838389, 0.08749093737197611, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019262697055798528, 0.017866098286338672, 0.01704553306016854, 0.016160973272506096, 0.015788632658534363, 0.01600387978189799, 0.13433337333151685, 0.11898690238004617, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b3a48943-5ff0-4ce0-860f-7425a5d34538", "fitness": 0.023599739665798664, "name": "HybridPSODE", "description": "Modify the PSO component to introduce a nonlinear inertia weight adjustment for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (0.9 - 0.4) * ((evaluations / self.budget) ** 2)  # Nonlinear inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)  # Adaptive differential weight\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["00124723-0fbf-4e2e-8f61-b6f9a7b2bd90"], "operator": null, "metadata": {"aucs": [0.0122306224628147, 0.009613720390500013, 0.02440930398627117, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004752368518428529, 0.004467728115717384, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05679694531419355, 0.05942136927806685, 0.047464393540054384, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04603171364618719, 0.051558649143554014, 0.04026875753253867, 0.09785600507373604, 0.10617420341395134, 0.09420338841607445, 0.04009979843934364, 0.036265303844261076, 0.03841494140211976, 0.09196712940074947, 0.09064101915262668, 0.08859901773265921, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018969975470668032, 0.01667490454297582, 0.01810877993864235, 0.01600489690132101, 0.015292086332651, 0.014915758549507996, 0.12143258063621432, 0.1276665328368074, 0.12192284018573862, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "479a1e87-1c09-4151-9a9c-39c4529c2f40", "fitness": 0.02415059430266408, "name": "HybridPSODE", "description": "HybridPSODE with adaptive particle count based on the budget to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = max(30, budget // 100)  # Adaptive particle count based on budget\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)  # Adaptive differential weight\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["00124723-0fbf-4e2e-8f61-b6f9a7b2bd90"], "operator": null, "metadata": {"aucs": [0.014243831165356657, 0.00814900426590559, 0.025830300615574342, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006912761219556418, 0.0045043600321351684, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056659923142658775, 0.062422929418844975, 0.04731159211409419, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04421096662912638, 0.05122019487430152, 0.05057964647049118, 0.09936521559523948, 0.10542863016157, 0.08776388131074409, 0.039113598006301764, 0.03943892303808372, 0.036584917963017216, 0.09713577689924247, 0.08951491986838389, 0.08749093737197611, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019262697055798528, 0.017866098286338672, 0.01704553306016854, 0.016160973272506096, 0.015788632658534363, 0.01600387978189799, 0.13433337333151685, 0.11898690238004617, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "158f800f-e3a2-47f5-8086-e0638cd19d79", "fitness": 0.024121119087480564, "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization and Differential Evolution, with a refined strategy based on adaptive particle and differential parameter tuning for enhanced performance in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)  # Adaptive differential weight\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n                # Refined Strategy: Increase crossover probability near budget exhaustion\n                self.crossover_prob = 0.9 + 0.1 * (evaluations / self.budget)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 11, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["00124723-0fbf-4e2e-8f61-b6f9a7b2bd90"], "operator": null, "metadata": {"aucs": [0.010507193699629602, 0.00814900426590559, 0.02591785174146477, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.005673141187361175, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057302658327252565, 0.06254995469126667, 0.0472921311793747, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04421096662912638, 0.05122019487430152, 0.05057964647049118, 0.09936521559523948, 0.10542863016157, 0.08776388131074409, 0.03803127383828375, 0.03922729838048611, 0.036584917963017216, 0.09710292635617412, 0.08951491986838389, 0.08808653652779119, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.021173729159360888, 0.017866098286338672, 0.016599421003678616, 0.016245279308052196, 0.015088001817070928, 0.01645298862954181, 0.13433337333151685, 0.12059312380581766, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f00da930-e99a-42c9-a355-6cdc03717191", "fitness": 0.024256203680611006, "name": "HybridPSODE", "description": "An improved hybrid metaheuristic combining Particle Swarm Optimization and Differential Evolution with a refined crossover probability for better exploration and exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 15\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.85  # Changed from 0.9 to 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Dynamic inertia weight adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)  # Adaptive differential weight\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["00124723-0fbf-4e2e-8f61-b6f9a7b2bd90"], "operator": null, "metadata": {"aucs": [0.011843830314804848, 0.015845961328952107, 0.02522923293841972, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.00935306598186647, 0.014558052596215232, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05623741464428278, 0.0623020127306223, 0.04731715856518515, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04421096662912638, 0.05122019487430152, 0.05057964647049118, 0.0997111318262609, 0.10790829366542931, 0.08562431618808397, 0.037963331561626124, 0.04090835775614876, 0.035692911110561276, 0.09710292635617412, 0.09154058212051075, 0.08839466141928942, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019430273228775108, 0.018002576888574984, 0.0166021187930272, 0.016160973272506096, 0.015114462179404153, 0.016233298716319844, 0.1210221956055938, 0.12082432743903626, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "014f1639-3506-4cf5-a942-2fe84ecf8f15", "fitness": 0.024417803310086077, "name": "HybridPSODE", "description": "Enhanced selection mechanism by tuning the number of differential mutation vectors to optimize exploration-exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["f00da930-e99a-42c9-a355-6cdc03717191"], "operator": null, "metadata": {"aucs": [0.01618411969028466, 0.012775522333395961, 0.025011988596728152, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02043399954789127, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06321082016703039, 0.06448491807046597, 0.05181169459488877, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04909987323311227, 0.047369469454544566, 0.040183829822438066, 0.09804263518309264, 0.10449988751733075, 0.0856124535715248, 0.04379126937206579, 0.03570597351209015, 0.032435534236421204, 0.09328175497399527, 0.09075579269360623, 0.0943649852207753, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019194069358058008, 0.01809347508110193, 0.015892931120375486, 0.015507472405452694, 0.014369685976821756, 0.016785629684786252, 0.13304355712844085, 0.1222782798901193, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c4340ad8-2e9c-4ec1-bf44-b6d854fbd065", "fitness": 0.02448746266380286, "name": "HybridPSODE", "description": "Slightly increase the crossover probability to enhance exploration in the differential evolution phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9  # Slightly increased from 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 14, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["014f1639-3506-4cf5-a942-2fe84ecf8f15"], "operator": null, "metadata": {"aucs": [0.01618411969028466, 0.009092160451874776, 0.024596597763705264, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019277511467356456, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06383670230698024, 0.06574742548172607, 0.050221335101748754, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.048369393459040566, 0.047369469454544566, 0.03878513128550831, 0.09862424847793916, 0.10449988751733075, 0.09239786480425893, 0.043827347514585724, 0.03903566574466055, 0.03534749309893592, 0.09319536827037822, 0.09028751397346968, 0.0943649852207753, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01915487794923798, 0.01761415962579882, 0.015922000977491746, 0.015480638436594751, 0.014107752684070496, 0.016398917816049186, 0.1337125869126421, 0.12178594041745783, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "50668931-1fb4-4e45-8963-c20f855baa30", "fitness": 0.02393452260224182, "name": "HybridPSODE", "description": "Refine inertia weight decay to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9  # Slightly increased from 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.95 - (evaluations / self.budget) * 0.6  # Refined inertia weight decay\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 15, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c4340ad8-2e9c-4ec1-bf44-b6d854fbd065"], "operator": null, "metadata": {"aucs": [0.015823653416297434, 0.009058520486660115, 0.025668637371803693, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01977683118634177, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06386186190148502, 0.06490588012424658, 0.05018816270394599, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.050434862687689264, 0.04750162551559134, 0.03908827365801315, 0.09717229396247196, 0.10184670541524421, 0.08953304885590263, 0.043573432545428226, 0.027557234630387062, 0.03609577488391835, 0.09250780883062737, 0.09108858392871111, 0.09592053134983891, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01895569364614924, 0.017677069821778413, 0.0158624858836246, 0.01549572197768001, 0.014197731025117788, 0.01714730298888778, 0.125870215618332, 0.11854169542846238, 0.12662963969068863, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "542bb1aa-cd36-4230-a762-7535dce43a3c", "fitness": 0.02397674865723952, "name": "HybridPSODE", "description": "Adjusted the velocity update to have a more dynamic influence on exploration and exploitation trade-off in the PSO phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9  # Slightly increased from 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i])) * (1 + 0.1 * (evaluations / self.budget))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c4340ad8-2e9c-4ec1-bf44-b6d854fbd065"], "operator": null, "metadata": {"aucs": [0.014545655194565077, 0.008313100710248267, 0.025551016068747656, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.024446695368720683, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06069206486549106, 0.06527302396049217, 0.04981308451613897, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04776122123242421, 0.044183649731491914, 0.04068212111337166, 0.10084733151167469, 0.09860964396276106, 0.09128464207105247, 0.03509224197265748, 0.03748144619427507, 0.0383842525700836, 0.0912554681100709, 0.09034196669478844, 0.09845229590020022, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016682721887636642, 0.01793477719523906, 0.015625482592110718, 0.015096582895324784, 0.01456446141150447, 0.01662519780474203, 0.12430517192938384, 0.1271514103150253, 0.12402482771493695, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cb9f829f-d1be-44ce-a7dc-e199e3c67274", "fitness": 0.024358006113499715, "name": "HybridPSODE", "description": "Slightly increase the personal attraction coefficient to enhance local search capability in the PSO phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.6  # Slightly increased from 1.5 to enhance local search\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c4340ad8-2e9c-4ec1-bf44-b6d854fbd065"], "operator": null, "metadata": {"aucs": [0.016655051683789, 0.008361478783883602, 0.02468186356926816, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.021135458843952626, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06158418226829909, 0.06536525464189957, 0.050254284181925346, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047884577392762084, 0.047369469454544566, 0.04219798107083994, 0.09874018750863134, 0.10449988751733075, 0.08878139829265463, 0.04180540416070633, 0.0390660212953442, 0.03543794337314876, 0.09342295630193553, 0.09060738191125062, 0.09476463450753625, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01915487794923798, 0.017919512026331685, 0.015922000977491746, 0.01541378358593215, 0.014106406614235012, 0.016398917816049186, 0.12294356305658094, 0.12544174549705933, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b502ebf1-db47-45cd-b400-b37014f16dc2", "fitness": 0.02428205926426494, "name": "HybridPSODE", "description": "Introduce a dynamic adjustment to the crossover probability to adaptively enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9  # Slightly increased from 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    # Dynamic crossover probability based on evaluations\n                    self.crossover_prob = 0.9 - (evaluations / self.budget) * 0.1\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c4340ad8-2e9c-4ec1-bf44-b6d854fbd065"], "operator": null, "metadata": {"aucs": [0.01618411969028466, 0.009473323839883419, 0.025011988596728152, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018864496812568188, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06425740455041151, 0.06448491807046597, 0.05181169459488877, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.048369393459040566, 0.047369469454544566, 0.03878513128550831, 0.09804263518309264, 0.10449988751733075, 0.08833675805573349, 0.04379126937206579, 0.035728105116163644, 0.0322779288690781, 0.09319536827037822, 0.09190165919507576, 0.0947290945267868, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01915487794923798, 0.017888243253617042, 0.016243827175246306, 0.015495511818240937, 0.014354786139633036, 0.016398917816049186, 0.12671988398408918, 0.12107735654157381, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a1d38bab-4884-4e02-ac10-17a7fb98e364", "fitness": 0.024358006113499715, "name": "HybridPSODE", "description": "Enhance convergence by adjusting the c1 parameter to improve personal influence in the PSO update phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.6  # Changed from 1.5 to 1.6\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9  # Slightly increased from 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c4340ad8-2e9c-4ec1-bf44-b6d854fbd065"], "operator": null, "metadata": {"aucs": [0.016655051683789, 0.008361478783883602, 0.02468186356926816, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.021135458843952626, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06158418226829909, 0.06536525464189957, 0.050254284181925346, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.047884577392762084, 0.047369469454544566, 0.04219798107083994, 0.09874018750863134, 0.10449988751733075, 0.08878139829265463, 0.04180540416070633, 0.0390660212953442, 0.03543794337314876, 0.09342295630193553, 0.09060738191125062, 0.09476463450753625, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01915487794923798, 0.017919512026331685, 0.015922000977491746, 0.01541378358593215, 0.014106406614235012, 0.016398917816049186, 0.12294356305658094, 0.12544174549705933, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "92310d3b-85ab-46c4-bea5-35e90ca900f5", "fitness": 0.024200424249588855, "name": "HybridPSODE", "description": "Slightly increase the number of differential evolutions to improve diversity in exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 21  # Changed from 20 to 21\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c4340ad8-2e9c-4ec1-bf44-b6d854fbd065"], "operator": null, "metadata": {"aucs": [0.013365575083369996, 0.004347826086956497, 0.020570449541988278, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006854928092121515, 0.014988704354558346, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05736986963846025, 0.06305414411555188, 0.05200039961545255, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05630298073267792, 0.047369469454544566, 0.04892493694485589, 0.09667576711816883, 0.1020738885979996, 0.09004813167197145, 0.04062987293992959, 0.03989138609022569, 0.03388021484823511, 0.09593535429544653, 0.0894760779472954, 0.09287929839456677, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01915487794923798, 0.01805736241810918, 0.01598987984551803, 0.015348008527644286, 0.01440831541781118, 0.016504078623210572, 0.1256626292771521, 0.12115372854493478, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b1e93f2d-6d35-479b-9bea-87527d704ca1", "fitness": 0.02453995780899447, "name": "HybridPSODE", "description": "Increase inertia weight decay rate to enhance convergence speed in the PSO phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.9  # Slightly increased from 0.85\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 21, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c4340ad8-2e9c-4ec1-bf44-b6d854fbd065"], "operator": null, "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.02586855751647188, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06144041391058408, 0.06779600974573874, 0.048447868312482045, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04362140929961278, 0.047327610903144746, 0.04582073148398025, 0.09774544678401131, 0.10320740085509028, 0.0913829702187815, 0.04513824587028059, 0.0356751247257211, 0.03894905307330854, 0.09448578774117089, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.017515737577190715, 0.01609837901692379, 0.015452479384129969, 0.014855531127048738, 0.016185857771162326, 0.12712099429603174, 0.12801445930130062, 0.13318077469428158, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cb123024-5299-4909-adb3-b7ee1b2af1f2", "fitness": 0.02446626999657181, "name": "HybridPSODE", "description": "Fine-tune the exploration-exploitation balance by reducing the crossover probability to improve diversity.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.85  # Reduced from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 22, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1e93f2d-6d35-479b-9bea-87527d704ca1"], "operator": null, "metadata": {"aucs": [0.020859112890846965, 0.011103655574233873, 0.025910833261853394, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020595627711245124, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.062358475080514175, 0.06779600974573874, 0.04681035993437177, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04362140929961278, 0.04765143599627897, 0.04582073148398025, 0.09912889853277174, 0.1020845452709962, 0.09204924853619245, 0.04347741115596193, 0.03856048632881015, 0.039605719603267864, 0.09192767079771691, 0.08959161494917678, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020576196342072306, 0.018111457471414405, 0.016057266956976513, 0.01535273341194765, 0.013994484532916296, 0.01668001070357228, 0.12652839298875296, 0.11979319712502756, 0.14030196780645454, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "741dcd25-e792-4846-9e7e-b30813ce2406", "fitness": 0.024661676342607082, "name": "HybridPSODE", "description": "Slightly increase the crossover probability to improve exploration in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["b1e93f2d-6d35-479b-9bea-87527d704ca1"], "operator": null, "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.025431543549394586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.060398481331448206, 0.06779600974573874, 0.04890621340173029, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04362140929961278, 0.047327610903144746, 0.04582073148398025, 0.099243793631133, 0.10227362077051727, 0.09836487333314692, 0.04513824587028059, 0.03568903545275759, 0.03894905307330854, 0.09563448579490053, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.018035335859084123, 0.016054969206747982, 0.015452479384129969, 0.015989693681241368, 0.016185857771162326, 0.12958363470658285, 0.12513106982984312, 0.13306642994867024, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "112a207d-53b6-4fc6-80eb-c56d30000f5c", "fitness": 0.024522861697953344, "name": "HybridPSODE", "description": "Further increase the crossover probability to enhance exploration in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.92  # Further increased from 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 24, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.025431543549394586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05490097054712917, 0.06779600974573874, 0.04733773683673226, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04478271594773742, 0.047327610903144746, 0.04582073148398025, 0.09864276356660306, 0.10227362077051727, 0.09836487333314692, 0.044927529221703955, 0.03568903545275759, 0.03894905307330854, 0.09563448579490053, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.017893414109628303, 0.016218770925480075, 0.015052157756305862, 0.015999495963338828, 0.016185857771162326, 0.12655970233665204, 0.12513106982984312, 0.13318077469428158, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f6799a67-1ccd-4f17-86e5-37bd7dead783", "fitness": 0.024510230265864703, "name": "HybridPSODE", "description": "Fine-tune the inertia weight decay rate for improved convergence in PSO.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.7  # Adjusted decay rate from 0.8 to 0.7\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 25, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.01907418043681397, 0.011182194622716635, 0.02442261814003066, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022297652919977207, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0625549175268375, 0.06549995920220586, 0.05115843146799626, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04661335413726686, 0.04849627081233887, 0.04275633914043353, 0.1019535072812674, 0.09936368242365246, 0.09436807847411544, 0.04145247544034136, 0.037319577610204435, 0.03725594385497499, 0.0952604483618753, 0.09216786133828758, 0.09455602911065719, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019343612932388732, 0.017303952352959118, 0.016059151050668907, 0.015659120725327713, 0.0161406944802317, 0.01633742875379618, 0.12330154420043493, 0.13388670488187926, 0.12764649963649277, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ba067ddb-c96f-4f2c-a96c-f14a76fd62a6", "fitness": -Infinity, "name": "HybridPSODE", "description": "Slightly increase the crossover probability to improve exploration in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 24, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": "\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.3% of the code, which means if the code has 100 lines, you can only change 1.2987012987012987 lines, and the rest of the lines should remain unchanged. This input code has 77 lines, so you can only change 1 lines, the rest 76 lines should remain unchanged. This changing rate 1.3% is the mandatory requirement, you cannot change more or less than this rate.\n    ", "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.025431543549394586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.060398481331448206, 0.06779600974573874, 0.04890621340173029, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04362140929961278, 0.047327610903144746, 0.04582073148398025, 0.099243793631133, 0.10227362077051727, 0.09836487333314692, 0.04513824587028059, 0.03568903545275759, 0.03894905307330854, 0.09563448579490053, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.018035335859084123, 0.016054969206747982, 0.015452479384129969, 0.015989693681241368, 0.016185857771162326, 0.12958363470658285, 0.12513106982984312, 0.13306642994867024, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ddd9f793-a6e9-4f8f-bc1a-46c6f0e7c91e", "fitness": 0.024510230265864703, "name": "HybridPSODE", "description": "Decrease the inertia weight decay rate slightly to improve convergence speed.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.7  # Adjusted decay rate from 0.8 to 0.7\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 27, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.01907418043681397, 0.011182194622716635, 0.02442261814003066, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022297652919977207, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0625549175268375, 0.06549995920220586, 0.05115843146799626, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04661335413726686, 0.04849627081233887, 0.04275633914043353, 0.1019535072812674, 0.09936368242365246, 0.09436807847411544, 0.04145247544034136, 0.037319577610204435, 0.03725594385497499, 0.0952604483618753, 0.09216786133828758, 0.09455602911065719, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019343612932388732, 0.017303952352959118, 0.016059151050668907, 0.015659120725327713, 0.0161406944802317, 0.01633742875379618, 0.12330154420043493, 0.13388670488187926, 0.12764649963649277, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0bbe7afb-c6d0-4109-8d01-86cb0964bd31", "fitness": 0.02401228305043181, "name": "HybridPSODE", "description": "Increase the number of particles for better exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 35  # Increased from 30 to 35\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 28, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.011990587381490947, 0.010583198903458269, 0.01377415524461889, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004601290287357229, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05807620695582305, 0.07729863032757012, 0.05259160780054317, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04548085062016172, 0.047267710566129884, 0.047165834440823895, 0.10305762648923644, 0.10422988481097195, 0.0916805207046042, 0.03639336995056175, 0.03979665204899485, 0.024389209553035474, 0.09096664166401469, 0.09367589076069471, 0.09468306887124034, 0.004347826086956497, 0.009154553516384834, 0.004347826086956497, 0.0185487982755973, 0.020891569176671787, 0.019986629334247552, 0.014844169481045943, 0.017620482752478184, 0.016852482292614046, 0.1259821126145395, 0.12747769570775846, 0.12286642735929199, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e86f9804-5f98-4e5b-8029-42c8e8bb5546", "fitness": 0.024189355541882965, "name": "HybridPSODE", "description": "Enhanced exploration and exploitation using an adaptive strategy with a slightly larger differential weight range and an increased number of differentials.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 22  # Changed from 20 to 22\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.6 + (0.9 - 0.6) * (1 - evaluations / self.budget)  # Changed from 0.5 to 0.6\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.016858592227409708, 0.006136942469954776, 0.025059922920956268, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018605131189898483, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06664103903473617, 0.06363852098062583, 0.05108411067086216, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04483785572476162, 0.047327610903144746, 0.044599057219101956, 0.09546359324726883, 0.10408930985598364, 0.08985513038879755, 0.04480529751199025, 0.0354713842262111, 0.04098553134150629, 0.08970488099183371, 0.0877408823123047, 0.09205915794877517, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022293986892533035, 0.017814142617164408, 0.016737048735096294, 0.01489573352457041, 0.020732453888500757, 0.01594998581972018, 0.1245079124796965, 0.12085814361489278, 0.13157589245119028, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "224d8846-699d-4ee0-90e6-bb30ebbe9500", "fitness": 0.023636174615994415, "name": "HybridPSODE", "description": "Slight increase in the number of particles to improve the exploration phase of the PSO.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 31  # Increased from 30 to 31\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 30, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.012200054660747583, 0.018928338259424637, 0.012973806827079715, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0045012763876267625, 0.004347826086956497, 0.004399919735584845, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05487317768583011, 0.06499030860504318, 0.052156136256373165, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04788746141926137, 0.04675456192048355, 0.04602084570914988, 0.09195646187528939, 0.09538944103482894, 0.08932384846745112, 0.03186451358895481, 0.032090182650616916, 0.034305949282834924, 0.09225668405767373, 0.09298783545488887, 0.09386441007753987, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01924246895589954, 0.017670590338544012, 0.01776994679623367, 0.015216639007861299, 0.017546089955515765, 0.018275544772176966, 0.13332775565079946, 0.13078512392764463, 0.12528867725110981, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "8ac54969-1224-43e6-90eb-77f2f54f693a", "fitness": 0.02400647428696027, "name": "HybridPSODE", "description": "Increase the exploration by adjusting the inertia weight decay rate in the PSO phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.6  # Changed decay rate from 0.8 to 0.6\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 31, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.017527745718979193, 0.009988182384948474, 0.024556507661529614, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.023976806804258066, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06333606304339012, 0.06494542334290998, 0.050393866057964365, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04727283564399487, 0.048073162002477354, 0.04002532727662356, 0.09459206374536755, 0.10160057035162162, 0.09308976657962154, 0.042757660663350294, 0.03821728734405838, 0.03461015754857555, 0.0892922791360401, 0.08564829513866123, 0.09469789601626177, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019252095776052136, 0.018089576765265347, 0.015974483959048658, 0.015563892082122277, 0.01608914519932514, 0.016364605124899678, 0.12594678506297896, 0.12387033329594954, 0.12140898710877823, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6edb3ac8-f1bb-4741-a961-551a6bb5ffce", "fitness": 0.023636174615994415, "name": "HybridPSODE", "description": "Slightly increase the number of particles to enhance exploration capabilities.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 31  # Increased from 30 to 31\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 32, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.012200054660747583, 0.018928338259424637, 0.012973806827079715, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0045012763876267625, 0.004347826086956497, 0.004399919735584845, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05487317768583011, 0.06499030860504318, 0.052156136256373165, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04788746141926137, 0.04675456192048355, 0.04602084570914988, 0.09195646187528939, 0.09538944103482894, 0.08932384846745112, 0.03186451358895481, 0.032090182650616916, 0.034305949282834924, 0.09225668405767373, 0.09298783545488887, 0.09386441007753987, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01924246895589954, 0.017670590338544012, 0.01776994679623367, 0.015216639007861299, 0.017546089955515765, 0.018275544772176966, 0.13332775565079946, 0.13078512392764463, 0.12528867725110981, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ebb6d09b-f344-4152-8487-7099bdfdc699", "fitness": 0.024522861697953344, "name": "HybridPSODE", "description": "Further increase the crossover probability to enhance exploration in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.92  # Further increased from 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 33, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.025431543549394586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05490097054712917, 0.06779600974573874, 0.04733773683673226, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04478271594773742, 0.047327610903144746, 0.04582073148398025, 0.09864276356660306, 0.10227362077051727, 0.09836487333314692, 0.044927529221703955, 0.03568903545275759, 0.03894905307330854, 0.09563448579490053, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.017893414109628303, 0.016218770925480075, 0.015052157756305862, 0.015999495963338828, 0.016185857771162326, 0.12655970233665204, 0.12513106982984312, 0.13318077469428158, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1bc73a4e-4610-45d0-bfc8-cedf582f58ad", "fitness": 0.023891632254548267, "name": "HybridPSODE", "description": "Slightly increase the number of differential vectors for enhanced exploration in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 21  # Changed from 20 to 21\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 34, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.011808589814604087, 0.006374344671340126, 0.021397107822786254, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.007980165054917832, 0.012492170678289227, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05696821585380729, 0.06860792022229256, 0.04758232331628798, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05319503085469357, 0.04967770696856755, 0.042548368641417866, 0.0975227308200467, 0.10178700533585772, 0.09201152856021899, 0.04481973728298838, 0.03550112746914458, 0.03458071635086457, 0.09275632357138652, 0.08772103263278574, 0.0940887274816925, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020683651152363924, 0.017002673374825306, 0.01604936756053399, 0.014788307859541105, 0.016686797462441172, 0.016566700089335806, 0.12390480921633162, 0.12461958539060514, 0.12351823507837789, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b2c72fa2-b266-4019-861a-3ce8049fcc59", "fitness": 0.023959288525491482, "name": "HybridPSODE", "description": "Introduce adaptive crossover probability in DE phase for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.2 * (global_best_value - np.min(personal_best_values)) / np.ptp(personal_best_values)  # Changed line\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.020966849200972693, 0.011543121033051773, 0.025936714415003004, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004994752228157373, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06085951367033582, 0.06779600974573874, 0.047167176692627044, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04487649209082112, 0.04752967701407795, 0.04582073148398025, 0.10113998120910295, 0.1020845452709962, 0.08991043709459767, 0.043403925865004855, 0.03435737306871889, 0.036148755182934034, 0.09395171386578505, 0.09133818803975802, 0.09446393347114668, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020576196342072306, 0.018111457471414405, 0.016486897776222253, 0.014898306548219331, 0.014227763856090259, 0.01665750564077173, 0.12761323343059883, 0.11738493922272386, 0.12351823507837789, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d97a464f-3129-468e-b78a-541f51cf3d9b", "fitness": 0.024522861697953344, "name": "HybridPSODE", "description": "Fine-tune crossover probability by increasing it slightly and modifying differential weight dynamically for better exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.92  # Slightly increased from 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.025431543549394586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05490097054712917, 0.06779600974573874, 0.04733773683673226, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04478271594773742, 0.047327610903144746, 0.04582073148398025, 0.09864276356660306, 0.10227362077051727, 0.09836487333314692, 0.044927529221703955, 0.03568903545275759, 0.03894905307330854, 0.09563448579490053, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.017893414109628303, 0.016218770925480075, 0.015052157756305862, 0.015999495963338828, 0.016185857771162326, 0.12655970233665204, 0.12513106982984312, 0.13318077469428158, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "46d88cc6-9fc4-4018-8509-6482409fe9b3", "fitness": 0.024661676342607082, "name": "HybridPSODE", "description": "Slightly increase the differential weight to enhance exploration in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.85  # Slightly increased from 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 37, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.025431543549394586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.060398481331448206, 0.06779600974573874, 0.04890621340173029, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04362140929961278, 0.047327610903144746, 0.04582073148398025, 0.099243793631133, 0.10227362077051727, 0.09836487333314692, 0.04513824587028059, 0.03568903545275759, 0.03894905307330854, 0.09563448579490053, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.018035335859084123, 0.016054969206747982, 0.015452479384129969, 0.015989693681241368, 0.016185857771162326, 0.12958363470658285, 0.12513106982984312, 0.13306642994867024, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ae70cc88-8bc9-4272-ad4f-4e4012eaaa87", "fitness": -Infinity, "name": "HybridPSODE", "description": "Slightly increase the crossover probability to improve exploration in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Adjusted decay rate from 0.5 to 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 24, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": "\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.3% of the code, which means if the code has 100 lines, you can only change 1.2987012987012987 lines, and the rest of the lines should remain unchanged. This input code has 77 lines, so you can only change 1 lines, the rest 76 lines should remain unchanged. This changing rate 1.3% is the mandatory requirement, you cannot change more or less than this rate.\n    ", "metadata": {"aucs": [0.02117466392137779, 0.011028519415930638, 0.025431543549394586, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022440225598232222, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.060398481331448206, 0.06779600974573874, 0.04890621340173029, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04362140929961278, 0.047327610903144746, 0.04582073148398025, 0.099243793631133, 0.10227362077051727, 0.09836487333314692, 0.04513824587028059, 0.03568903545275759, 0.03894905307330854, 0.09563448579490053, 0.09109541069434013, 0.09391813843438002, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02058481274880708, 0.018035335859084123, 0.016054969206747982, 0.015452479384129969, 0.015989693681241368, 0.016185857771162326, 0.12958363470658285, 0.12513106982984312, 0.13306642994867024, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7e19bb0c-6ed2-4099-ab05-6bbe3b0bb493", "fitness": 0.024119072877068555, "name": "HybridPSODE", "description": "Adjust the DE crossover probability to dynamically decrease as the convergence improves.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    self.crossover_prob = 0.91 * (evaluations / self.budget)  # Adjusted crossover probability\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 39, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.02437629980859024, 0.012075615390422123, 0.022752027356723548, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.052517869873729195, 0.06623194476323724, 0.051288674989963146, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04809067702636438, 0.047327610903144746, 0.04197927053137074, 0.0991403283207265, 0.10383887364412947, 0.09518542369636418, 0.04382304019212413, 0.03422476627158644, 0.03802795854894725, 0.09171934367821022, 0.08816735694663969, 0.09423378365491519, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020831737569107278, 0.017062932826269583, 0.01699234694677043, 0.01568543501121622, 0.015425276910743912, 0.017632257423246478, 0.12712099429603174, 0.1228410899775223, 0.1323281366777972, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a5520ba2-c688-4121-a3d2-255724e53826", "fitness": 0.024679073844058028, "name": "HybridPSODE", "description": "Refine the adaptive inertia weight to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Changed from 0.9 - (evaluations / self.budget) * 0.8 to 0.9 - (evaluations / self.budget) * 0.9 for refined balance\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9  \n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 40, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["741dcd25-e792-4846-9e7e-b30813ce2406"], "operator": null, "metadata": {"aucs": [0.0220978489846273, 0.012650359460701033, 0.025438777733843287, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02366637116488035, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0612846897492928, 0.06874151010461305, 0.04897936964187888, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05167468172105971, 0.04573797155535253, 0.04033352876523266, 0.09746308565495654, 0.10130250968757637, 0.09262291111047516, 0.0425447462469718, 0.040452833397334076, 0.03669819383230877, 0.09441253728549559, 0.09256095351446092, 0.09132082249559059, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020843534928532415, 0.01830472552192508, 0.01673232085956111, 0.015393969360262272, 0.01518991366687461, 0.016241106666381566, 0.13561134231003935, 0.12305427485311349, 0.13423407867275106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "76fe8096-b2a0-422a-9304-249a7b3a4ca7", "fitness": 0.024679073844058028, "name": "HybridPSODE", "description": "Enhance global exploration by slightly increasing the initial inertia weight for a better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.71  # Slightly increased from 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Changed from 0.9 - (evaluations / self.budget) * 0.8 to 0.9 - (evaluations / self.budget) * 0.9 for refined balance\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9  \n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a5520ba2-c688-4121-a3d2-255724e53826"], "operator": null, "metadata": {"aucs": [0.0220978489846273, 0.012650359460701033, 0.025438777733843287, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02366637116488035, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0612846897492928, 0.06874151010461305, 0.04897936964187888, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05167468172105971, 0.04573797155535253, 0.04033352876523266, 0.09746308565495654, 0.10130250968757637, 0.09262291111047516, 0.0425447462469718, 0.040452833397334076, 0.03669819383230877, 0.09441253728549559, 0.09256095351446092, 0.09132082249559059, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020843534928532415, 0.01830472552192508, 0.01673232085956111, 0.015393969360262272, 0.01518991366687461, 0.016241106666381566, 0.13561134231003935, 0.12305427485311349, 0.13423407867275106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "210cdfe1-52a9-44c3-a47e-3a62844a1234", "fitness": 0.024531396893242668, "name": "HybridPSODE", "description": "Alter the crossover probability dynamically for better adaptation between diversification and intensification.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Changed from 0.9 - (evaluations / self.budget) * 0.8 to 0.9 - (evaluations / self.budget) * 0.9 for refined balance\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9  \n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    self.crossover_prob = 0.8 + 0.1 * (evaluations / self.budget)  # Dynamically adjust crossover probability\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 42, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a5520ba2-c688-4121-a3d2-255724e53826"], "operator": null, "metadata": {"aucs": [0.022216593020307873, 0.01237242266303229, 0.026119237057250833, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.005206079657827933, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06196527856315759, 0.06873884945361275, 0.04879345525218515, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04424910653974179, 0.04573797155535253, 0.048976667772667515, 0.09365584241794533, 0.101098040793271, 0.0923799176725617, 0.04303732637666713, 0.042585756415190024, 0.04015454989746026, 0.09441253728549559, 0.0943184171403364, 0.09106032489704852, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020836435319268154, 0.018157854374634463, 0.01619879616740716, 0.015545609661865356, 0.0151148182886367, 0.016481893128557856, 0.13561134231003935, 0.12569702613311384, 0.13423407867275106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6fa122d6-dc72-4812-8298-ddfbc6c01a8a", "fitness": 0.02480485504081207, "name": "HybridPSODE", "description": "Introduce decaying personal learning coefficient to enhance convergence behavior.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 43, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["a5520ba2-c688-4121-a3d2-255724e53826"], "operator": null, "metadata": {"aucs": [0.021208312960434017, 0.01380273407539434, 0.023576109199808237, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.005887444594801616, 0.014916206839572066, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05875445572942939, 0.06886142516822968, 0.048950971600859594, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05180097887598367, 0.05081898132771312, 0.042723820321645456, 0.10159786811265503, 0.10689385396789197, 0.0903012625847941, 0.042995391896745394, 0.04058916010924052, 0.03947581571296854, 0.09470113419898962, 0.09340218466416772, 0.09461285298832067, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02054889458798448, 0.0184265282885282, 0.01649012743105549, 0.015174600077418665, 0.016324933522711693, 0.016533517499872308, 0.13561134231003935, 0.1197780538793336, 0.13423407867275106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f1d2d052-1d02-4643-a9e5-e99edc88185e", "fitness": 0.02482786883035342, "name": "HybridPSODE", "description": "Introduce adaptive crossover probability to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 44, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["6fa122d6-dc72-4812-8298-ddfbc6c01a8a"], "operator": null, "metadata": {"aucs": [0.021230314724721033, 0.014138065633586105, 0.024269245995902078, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01026005292856269, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06658536427733719, 0.06846976255098758, 0.04804868133861173, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05198718936117064, 0.05081898132771312, 0.042723820321645456, 0.09926676527691292, 0.10689385396789197, 0.0910031977984832, 0.0425447462469718, 0.040452833397334076, 0.039218818273350275, 0.09627389957724786, 0.09256095351446092, 0.09124153230344867, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01958032209354299, 0.018280732694352153, 0.016306992826400024, 0.01549948093890574, 0.016095438338528, 0.017452415082447548, 0.13561134231003935, 0.12525332618605423, 0.13423407867275106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "074dcaeb-0e78-4d06-8a27-bf0161bae69e", "fitness": 0.023830451116729403, "name": "HybridPSODE", "description": "Improve exploration by slightly increasing the number of particles to improve the diversity of the search.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 32  # Increased from 30 to 32\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 45, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f1d2d052-1d02-4643-a9e5-e99edc88185e"], "operator": null, "metadata": {"aucs": [0.014225225446404477, 0.0069308702852417525, 0.01636767171917186, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06422474231961439, 0.07349164975293243, 0.05136278846823561, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04691383776797231, 0.04305257624553338, 0.045315312456594814, 0.08131476400535564, 0.09816509836169884, 0.0890921085037858, 0.03450718492304394, 0.03839441743186223, 0.035647386414616955, 0.09801340786680701, 0.09501146333626753, 0.09824677330551346, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017938133137780587, 0.017959384890981256, 0.018114089283836288, 0.015269369790888776, 0.020668423405240666, 0.01676460215520237, 0.128125387223615, 0.1302963249716549, 0.12472731302162243, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e34ba891-f78a-4c4f-8558-8e6de9f0f676", "fitness": 0.024673600082417965, "name": "HybridPSODE", "description": "Fine-tune DE's differential weight adaptation for balance in exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.6 + (0.9 - 0.6) * (1 - evaluations / self.budget)  # Adjusted range\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 46, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["f1d2d052-1d02-4643-a9e5-e99edc88185e"], "operator": null, "metadata": {"aucs": [0.021227219392857655, 0.014253327524994197, 0.024158997000888638, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01114959010054084, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06696805012326223, 0.06702545446124342, 0.047787662793212116, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05198718936117064, 0.05081898132771312, 0.04357197009305591, 0.09429708033481854, 0.10689385396789197, 0.08862443159541944, 0.038508399126949144, 0.040452833397334076, 0.03943472111958146, 0.09465752609614964, 0.09256095351446092, 0.09413784394840552, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01958032209354299, 0.018305302296417025, 0.0163470517698725, 0.015740631714023845, 0.01606501644332603, 0.017453439314168984, 0.13561134231003935, 0.12334158821391661, 0.13423407867275106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6171ac36-d8ad-4d6a-8d41-d9c1d5f3a342", "fitness": 0.02420626826887159, "name": "HybridPSODE", "description": "Adjust inertia weight decay to improve convergence stability and performance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.7 # Adjusted to 0.7 for smoother decay\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 47, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f1d2d052-1d02-4643-a9e5-e99edc88185e"], "operator": null, "metadata": {"aucs": [0.01925919455286773, 0.013036960892973126, 0.02615517462881456, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004437764996776061, 0.0062354296370654705, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06177187837761455, 0.0673875149041977, 0.04988094324416881, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.053469188171363924, 0.04849627081233887, 0.045452179229217626, 0.10023653946173439, 0.09936368242365246, 0.09351334669509981, 0.039633372041193216, 0.038224309759217756, 0.03741329040414998, 0.09307195851085936, 0.09216732702815167, 0.09273513358259622, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019343612932388732, 0.01807907183865265, 0.01622379202326285, 0.01576022460049653, 0.016141470383945755, 0.01799642554423242, 0.12627775077232728, 0.1226838811171207, 0.12144710505314493, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b98c08c8-3b77-489c-ba55-0f8960eeff28", "fitness": 0.02450922581500412, "name": "HybridPSODE", "description": "Refine the exploration-exploitation strategy by dynamically adjusting the inertia weight.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.8  # Change here\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 48, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f1d2d052-1d02-4643-a9e5-e99edc88185e"], "operator": null, "metadata": {"aucs": [0.019486441679134714, 0.014316548766901582, 0.024783703877388708, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0066663444991260645, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06662631000884245, 0.06706560048778243, 0.04784935928661238, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.053965141622242196, 0.05106061263961614, 0.044910554086105114, 0.09998810020255688, 0.10597605753909767, 0.09554745163409151, 0.042537738467212205, 0.0356751247257211, 0.03757947440074472, 0.0931689405540872, 0.09109541069434013, 0.0943757746353735, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019460786907843808, 0.018426264297811024, 0.016316752811730062, 0.015640040329952587, 0.01624758112853031, 0.017605385899509662, 0.12668195697887707, 0.1225282394916356, 0.12777821320134386, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "561d2daf-a6ae-4e9f-b636-6020d7479971", "fitness": 0.02454509881725799, "name": "HybridPSODE", "description": "Adjust the c2 coefficient to be adaptive, improving the exploration-exploitation balance over time.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5  # Original value\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                self.c2 = 1.5 + (0.5 * (evaluations / self.budget))  # Adaptive social learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 49, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["f1d2d052-1d02-4643-a9e5-e99edc88185e"], "operator": null, "metadata": {"aucs": [0.023454053459091795, 0.012701897558683783, 0.024278966206771613, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.010190455414273658, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06178887272669409, 0.06807228137199761, 0.05232884405915217, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.044861430450686135, 0.04793484455699859, 0.038345153988146974, 0.09740191963316802, 0.10616598461578075, 0.10129533283642345, 0.038460329646362035, 0.03743290000277144, 0.03349373375344944, 0.09832274010964392, 0.09046964816515701, 0.09633104177888763, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0177658647604928, 0.017305346705738134, 0.01711940285922353, 0.014807534742674933, 0.01582222149740975, 0.015810529229151382, 0.12922289567006795, 0.13583593955858497, 0.12892260165900582, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "fee7a76c-f7a6-442b-bcda-196a8bd7c15a", "fitness": 0.01890997403043695, "name": "HybridPSODE", "description": "Introduce adaptive velocity cap to prevent particle explosion and improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                velocities[i] = np.clip(velocities[i], -0.1, 0.1)  # Adaptive velocity cap\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 50, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["f1d2d052-1d02-4643-a9e5-e99edc88185e"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02184455611050018, 0.03918674681067458, 0.0251583872581036, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05312992765392521, 0.04127821174996493, 0.03791239554514236, 0.07710532718960683, 0.07872059787765251, 0.078739068383195, 0.019021320860621804, 0.02856420312340502, 0.018977617610867914, 0.061755697725644154, 0.06441077231951253, 0.05852624336076717, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01511831891895632, 0.013475303018766427, 0.013681665543733845, 0.012543884870824695, 0.012426342909360177, 0.011248143678280198, 0.12481402844836675, 0.12016757576802406, 0.1250161412816525, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c3c0d95a-581b-4c9e-abf4-0180037606b8", "fitness": 0.025006545334620392, "name": "HybridPSODE", "description": "Enhance local search by adjusting inertia weight's lower bound for better stability.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 51, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["f1d2d052-1d02-4643-a9e5-e99edc88185e"], "operator": null, "metadata": {"aucs": [0.023585148795082223, 0.00982023599747095, 0.01770980314768289, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01833340448180698, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.07021119371348694, 0.07083433290252228, 0.051592076893659744, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05051208999432988, 0.04979327004770606, 0.04340350560367345, 0.09918977988893374, 0.1007053420693782, 0.09133211547231501, 0.03756912677780355, 0.04286676785693977, 0.04201300160157451, 0.10026641246282608, 0.09593315104978395, 0.09980370960173601, 0.004347826086956497, 0.0063467272105532935, 0.004347826086956497, 0.022067172739657526, 0.01685311837016301, 0.016442865935936135, 0.015019812053068016, 0.01775595024158283, 0.0171812341275559, 0.12029046312016267, 0.13817709136834055, 0.12790583882780648, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "8c7c2acf-14f6-4f71-a437-4642ab682f6c", "fitness": 0.024230115348124207, "name": "HybridPSODE", "description": "Introduce a dynamic global learning coefficient to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                self.c2 = 1.5 + 0.5 * (evaluations / self.budget)  # Dynamic global learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 52, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.024942195207623974, 0.00881147913520619, 0.024778244944205996, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.015399967256342073, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06286582658115492, 0.07021139586271663, 0.05242827667574779, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05498351295148596, 0.04351374432207611, 0.04570685287304699, 0.09723937041101738, 0.10333777550864454, 0.0913845472101884, 0.03201422155256395, 0.04211372681495529, 0.03304578292609539, 0.09331255584205134, 0.09181168770127779, 0.09458429553797909, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.021968629286932106, 0.016870415745279144, 0.016348236709850306, 0.015051425882495972, 0.01650400380404371, 0.015085470253383249, 0.11831559460102259, 0.12285249206430415, 0.12778222957716612, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a7bef227-a37d-449f-83c1-5c9b10e45d7a", "fitness": 0.02482786883035342, "name": "HybridPSODE", "description": "Fine-tune exploration by dynamically adjusting the inertia weight's upper bound for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.9  # Adjusted upper bound\n                self.c1 = 1.5 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.021230314724721033, 0.014138065633586105, 0.024269245995902078, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01026005292856269, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06658536427733719, 0.06846976255098758, 0.04804868133861173, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05198718936117064, 0.05081898132771312, 0.042723820321645456, 0.09926676527691292, 0.10689385396789197, 0.0910031977984832, 0.0425447462469718, 0.040452833397334076, 0.039218818273350275, 0.09627389957724786, 0.09256095351446092, 0.09124153230344867, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01958032209354299, 0.018280732694352153, 0.016306992826400024, 0.01549948093890574, 0.016095438338528, 0.017452415082447548, 0.13561134231003935, 0.12525332618605423, 0.13423407867275106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "211242ce-7119-4c1b-a649-615fdf9de8c5", "fitness": 0.024050882169605898, "name": "HybridPSODE", "description": "Refine the inertia weight decay strategy for smoother velocity adjustments in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.7 - (0.2 * (evaluations / self.budget))  # Smoother decay\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.019623526125927437, 0.010549421951390414, 0.024145077268278414, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0060027380253659945, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06152566806005133, 0.06486245069362018, 0.046987113924774726, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04310642176304624, 0.0499202950449229, 0.04094828453958721, 0.09118488334126895, 0.1021839189684195, 0.08795690153052116, 0.04031404940068517, 0.04029283743644596, 0.03170652142566355, 0.09740904293136121, 0.09480851702948534, 0.0980957431989945, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02010673982222999, 0.018223784514714514, 0.016386775457462366, 0.015481213387001258, 0.015758057020807015, 0.017424716419498054, 0.12645200072958818, 0.1273755603726794, 0.13152690800174804, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "08856a3b-10dd-4ca8-b9c6-035e70ff28ae", "fitness": 0.024649134329808888, "name": "HybridPSODE", "description": "Introduce adaptive differentiation in PSO-DE hybrid by making the differential weight inversely proportional to generation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    # Changed differential weight strategy\n                    self.differential_weight = 1.0 - (evaluations / self.budget) * 0.5  # Inversely proportional adjustment\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 55, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.02221885984907479, 0.009778480862911554, 0.017719239314454738, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018300024255346936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06821689603436687, 0.07038239153731485, 0.04878545808194401, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.050295067686367045, 0.04979327004770606, 0.04340350560367345, 0.09918977988893374, 0.1007053420693782, 0.08985524999423633, 0.035654263635691796, 0.04252453507622189, 0.04201300160157451, 0.10003192120767213, 0.0936012632697728, 0.09815206826021305, 0.004347826086956497, 0.007086868709470284, 0.004347826086956497, 0.022142837927456194, 0.016753851344270987, 0.016445874469963484, 0.015010076431023367, 0.017695416545586373, 0.017163426134727433, 0.12138427324541634, 0.12539363833893413, 0.12808426858340727, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "7db3481d-5722-4fd4-930c-82d754c8eda1", "fitness": 0.024483242702689756, "name": "HybridPSODE", "description": "Introduce a small mutation in the DE's mutant vector to enhance exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2) + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 56, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.019078721207744676, 0.010752175391235408, 0.023430861716123186, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06287665441611567, 0.06233771696283452, 0.05426611053653729, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05413886352912001, 0.05446552539831062, 0.04233897908023587, 0.09794198534781784, 0.100835493282602, 0.09070513503259836, 0.03347594429924905, 0.04493087158257625, 0.04201300160157451, 0.10000592203783165, 0.09331630325031215, 0.09887639092592104, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02248892618762388, 0.016607500756406712, 0.018305991988792458, 0.015597791106602976, 0.016224092425796144, 0.01609161652034019, 0.12105034448324681, 0.12539363833893413, 0.12959474327413678, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "fa845e8c-2ee3-44a9-9ffe-28917edf3312", "fitness": 0.02378256659714438, "name": "HybridPSODE", "description": "Introduce inertia weight decay and adaptive differential weight for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.9  # Increased initial differential weight\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.4  # Adjusted inertia decay\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.9 * (1 - evaluations / self.budget) + 0.7  # Adaptive differential weight\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 57, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.01566811176118066, 0.014593035179892633, 0.023896418856565127, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.026137139449073032, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06220451589337328, 0.06397577779000585, 0.04986645515261656, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04341239908924843, 0.04756990861439525, 0.03929000489479162, 0.09625593569214752, 0.10163463378130211, 0.08918320096153476, 0.04213145210535718, 0.03135910694090893, 0.03500186043284503, 0.08908619753217506, 0.08393109443720903, 0.09416593935302231, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019052614460719375, 0.016965683348531435, 0.01580689808930824, 0.015386840163509552, 0.0157230581247918, 0.01735105725190489, 0.12245281959708076, 0.1232990039411842, 0.12563928427363502, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "904f9299-6c08-420a-b600-a159091c6757", "fitness": 0.024839632132603835, "name": "HybridPSODE", "description": "Introduce adaptive acceleration coefficients in the particle update to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 1.5 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient\n                self.c2 = 2.5 * (evaluations / self.budget)  # Adaptive acceleration coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 58, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.023794694499400304, 0.019959286612857063, 0.013729490397656141, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06103178817941657, 0.06876813818591876, 0.05216842710104064, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04807194542665061, 0.054227968117572134, 0.04651016812125752, 0.09012365496424335, 0.09827908032977939, 0.08600765598131799, 0.030610316019228034, 0.03675956642634204, 0.03039034139033525, 0.09122344956823025, 0.10134612980906432, 0.09939086256133844, 0.04799591804826453, 0.004347826086956497, 0.004347826086956497, 0.01848659064972391, 0.0193601066075052, 0.017881162240757087, 0.015007210229599832, 0.018686700004950096, 0.014402678355095011, 0.1281283631961787, 0.13943928306756137, 0.12536818963010565, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e6e0be6e-52bc-4986-8b34-fb4059048da0", "fitness": 0.025181561579675455, "name": "HybridPSODE", "description": "Adjust personal learning coefficient to improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["c3c0d95a-581b-4c9e-abf4-0180037606b8"], "operator": null, "metadata": {"aucs": [0.02420825645804192, 0.009340238012488511, 0.017934039880940778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018370001920100854, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06800747328024404, 0.07232274198264277, 0.05181495517062584, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04895459501095056, 0.04979327004770606, 0.04294314378676323, 0.09918977988893374, 0.10102485981538101, 0.0918223999943133, 0.03558290896594163, 0.04318299966940653, 0.04243228475373051, 0.10080558627923453, 0.09593315104978395, 0.10003361306908576, 0.004347826086956497, 0.008296900811176178, 0.004347826086956497, 0.023804757191238757, 0.01742879888112514, 0.01677055801072902, 0.014815620219989833, 0.016964615518570425, 0.016223755221576708, 0.12474823720524941, 0.13817709136834055, 0.13518927853319196, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "cd7ad18c-9621-4f0c-a93c-1b929bad0481", "fitness": 0.019382011694531007, "name": "HybridPSODE", "description": "Incorporate a velocity clamping mechanism to maintain stability and prevent particles from diverging.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n        self.velocity_clamp = 0.2  # Add a velocity clamping value\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)  # Apply velocity clamping\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.025081889708360006, 0.03923896683512018, 0.026288011201220818, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05634583867329401, 0.04323556710922882, 0.03864041606512625, 0.0799603415444764, 0.08364263955082574, 0.08010095610235424, 0.019000941858110854, 0.027547314779892584, 0.018743795049007472, 0.06616231646640669, 0.06292008491919954, 0.06375215507328114, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01518318702197785, 0.01347850305847309, 0.014049156259413276, 0.012655568008764218, 0.012496460894055872, 0.01139293648053008, 0.1260022556389786, 0.1266799250356545, 0.12420996249856864, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "685981aa-64f0-4f63-bc9f-dad02c198807", "fitness": 0.024791834819200276, "name": "HybridPSODE", "description": "Fine-tune the crossover probability to enhance exploration in DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.85 + 0.1 * (1 - evaluations / self.budget)  # Fine-tuned crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 61, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.02417591798203511, 0.011250836356603955, 0.01909887160027024, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019801468672600242, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06770998703436448, 0.07395289809742334, 0.05021471471082972, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0502193051835963, 0.04979327004770606, 0.04294314378676323, 0.09918977988893374, 0.10074100661492669, 0.08890887661157898, 0.03496021218646628, 0.04043972486132574, 0.042045102497405895, 0.10122283646323238, 0.09593315104978395, 0.10003361306908576, 0.004347826086956497, 0.008166935279618426, 0.004347826086956497, 0.020669874886814266, 0.016985531461805592, 0.01639562247221593, 0.01474095001286968, 0.016731329248554805, 0.016401661814563706, 0.12474823720524941, 0.12539363833893413, 0.12518708780773236, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e6d727f8-59ce-4cee-a3de-015d03943f5c", "fitness": 0.02509932524433828, "name": "HybridPSODE", "description": "Introduce adaptive dimensionality reduction in PSO to improve convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i] * (0.5 + 0.5 * evaluations / self.budget)  # Apply dimensionality reduction\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n\n                current_value = func(particles[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n\n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n\n                    trial_value = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n\n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 62, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.02720176913555783, 0.021827651241918655, 0.015527355841238988, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004348969178563644, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0594580307603374, 0.0743846227586411, 0.055464584201557865, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05828341077836008, 0.04500515468645616, 0.050565951937831755, 0.0918553348025124, 0.10506957041887177, 0.09044747591879654, 0.045912004613620105, 0.04064300323255343, 0.03283817020253321, 0.10340011142916428, 0.10030394807685117, 0.10486528275414642, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018405695423700186, 0.020725022037905716, 0.017911883746895785, 0.016511466485052306, 0.015406407372721476, 0.015159184958098204, 0.13430732224946418, 0.12458813568650629, 0.1254295498364134, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "ea9b5437-b077-48e0-b620-5e9744b1a0b4", "fitness": 0.025181561579675455, "name": "HybridPSODE", "description": "Refine the strategy by slightly increasing the inertia weight to enhance exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.75  # Increased from 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.02420825645804192, 0.009340238012488511, 0.017934039880940778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018370001920100854, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06800747328024404, 0.07232274198264277, 0.05181495517062584, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04895459501095056, 0.04979327004770606, 0.04294314378676323, 0.09918977988893374, 0.10102485981538101, 0.0918223999943133, 0.03558290896594163, 0.04318299966940653, 0.04243228475373051, 0.10080558627923453, 0.09593315104978395, 0.10003361306908576, 0.004347826086956497, 0.008296900811176178, 0.004347826086956497, 0.023804757191238757, 0.01742879888112514, 0.01677055801072902, 0.014815620219989833, 0.016964615518570425, 0.016223755221576708, 0.12474823720524941, 0.13817709136834055, 0.13518927853319196, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "06251014-c577-4302-88fd-3d26a8548577", "fitness": 0.025181561579675455, "name": "HybridPSODE", "description": "Enhance PSO component by adjusting constants for improved convergence speed.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5  # This line is changed: Original value was 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 64, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.02420825645804192, 0.009340238012488511, 0.017934039880940778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018370001920100854, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06800747328024404, 0.07232274198264277, 0.05181495517062584, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04895459501095056, 0.04979327004770606, 0.04294314378676323, 0.09918977988893374, 0.10102485981538101, 0.0918223999943133, 0.03558290896594163, 0.04318299966940653, 0.04243228475373051, 0.10080558627923453, 0.09593315104978395, 0.10003361306908576, 0.004347826086956497, 0.008296900811176178, 0.004347826086956497, 0.023804757191238757, 0.01742879888112514, 0.01677055801072902, 0.014815620219989833, 0.016964615518570425, 0.016223755221576708, 0.12474823720524941, 0.13817709136834055, 0.13518927853319196, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d048dc57-172f-42e2-a62c-14525d8e68b0", "fitness": 0.024566778338411234, "name": "HybridPSODE", "description": "Introduce dynamic adjustments to the inertia weight for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 + (0.5 - 0.4) * (1 - evaluations / self.budget)  # Modified inertia weight adjustment\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 65, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.023797814406525952, 0.011199079522495436, 0.018961341451456226, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020915530090889756, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0652335688456781, 0.06496214404202516, 0.04953141873492173, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.045205155532672237, 0.04207671848307393, 0.04434413208366195, 0.09436641380958455, 0.09861358288039612, 0.10278531084173204, 0.03818740201447879, 0.0392911993210201, 0.030952930061396766, 0.10514699218092705, 0.09190230592313509, 0.10158757110092842, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.021052567005780842, 0.019554074180745173, 0.016614807111063667, 0.014743681079136373, 0.015688273422325816, 0.017029510999402198, 0.12864326720820418, 0.12809106354655964, 0.12702583665930567, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "8739e9cc-f8c6-4283-85ce-d387e64849a3", "fitness": 0.024280877217781785, "name": "HybridPSODE", "description": "Enhance convergence by dynamically adjusting the global learning coefficient.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 2.0 * (evaluations / self.budget)  # Dynamically adjusted global learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 66, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.023381354452910674, 0.011866123227648462, 0.012721597268218976, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004557515885698971, 0.004454783548351937, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05645167001565221, 0.06500133644691375, 0.04969008350757376, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04828706873320576, 0.0429685717754712, 0.04037509920091964, 0.09337210662602402, 0.10194341510937732, 0.08640225024212644, 0.0348398079924368, 0.04450948908483543, 0.036183864859014925, 0.09767946677540584, 0.09918600991321136, 0.0961351605369889, 0.016772061022646056, 0.004347826086956497, 0.004347826086956497, 0.018296780851286387, 0.01728007335426518, 0.016620027132648207, 0.014405355891878635, 0.019865836826017946, 0.013869624605638564, 0.1213951551750343, 0.14551331753599006, 0.13158945643072384, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "44c64ba8-f504-4706-a51d-3e544dc6e790", "fitness": 0.023791517901226647, "name": "HybridPSODE", "description": "Introduces a slight decay to the global learning coefficient in PSO to enhance convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 2.0 * (1 - evaluations / self.budget)  # Introduced decay to global learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 67, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.020516775119976405, 0.0062318136072329056, 0.016716840426175716, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.005648709435365773, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05450879136658915, 0.06539222902174258, 0.05096972868705851, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04810060098195279, 0.04843175783058684, 0.047351120387479684, 0.09588428462707421, 0.103667980739516, 0.08933314364277467, 0.03483043737439495, 0.04270442422576426, 0.03944927706201884, 0.09741200707283793, 0.09347880534245467, 0.09789800153461647, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019381961205221954, 0.016541985078299848, 0.016371036820246987, 0.014090208579319086, 0.017078854167677404, 0.014246647188316697, 0.12042557346617178, 0.1214090106581801, 0.12361293541318641, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f5c743b6-6dc9-4f53-915f-b38aa539efd0", "fitness": 0.025181561579675455, "name": "HybridPSODE", "description": "Introduced adaptive differential weight decay to improve convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Adaptive differential weight decay\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.02420825645804192, 0.009340238012488511, 0.017934039880940778, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018370001920100854, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06800747328024404, 0.07232274198264277, 0.05181495517062584, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04895459501095056, 0.04979327004770606, 0.04294314378676323, 0.09918977988893374, 0.10102485981538101, 0.0918223999943133, 0.03558290896594163, 0.04318299966940653, 0.04243228475373051, 0.10080558627923453, 0.09593315104978395, 0.10003361306908576, 0.004347826086956497, 0.008296900811176178, 0.004347826086956497, 0.023804757191238757, 0.01742879888112514, 0.01677055801072902, 0.014815620219989833, 0.016964615518570425, 0.016223755221576708, 0.12474823720524941, 0.13817709136834055, 0.13518927853319196, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "bbe4dd45-a842-4758-9de3-3d1cbd77f87a", "fitness": 0.02418469494986225, "name": "HybridPSODE", "description": "Adaptively adjust the inertia weight for dynamic exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Adjusted upper bound from 0.5 to 0.9\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.018852457360033714, 0.010050883362148988, 0.023886920830836322, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.012309011833305683, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06261529723435777, 0.064239105153574, 0.0504544353469647, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05412293730985118, 0.047369469454544566, 0.03878946487838264, 0.09614023193401822, 0.10449988751733075, 0.08629384824339448, 0.04410274926744884, 0.03572660279653239, 0.029750563022094556, 0.09338218788722374, 0.09283334534836774, 0.09439539072716319, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01915487794923798, 0.017484121502277183, 0.016381074295804154, 0.01515650537691815, 0.015859662800642993, 0.016398917816049186, 0.12811177078839875, 0.11907610046382111, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "971e71ee-0ad4-4d2c-9e41-53d750c81206", "fitness": 0.024656992198822152, "name": "HybridPSODE", "description": "Improve convergence by adjusting velocity calculation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i])) * 0.99 # Adjusted velocity reduction\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 70, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.02412291618274065, 0.009627992967710552, 0.01785200958133437, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.016730393288024503, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06765620307527598, 0.072824321745946, 0.05320640136871968, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05026220210569632, 0.0512575230350627, 0.04303280228205131, 0.09351839963444852, 0.10019266774275815, 0.09041540292980166, 0.03551593680363807, 0.04188160383867545, 0.03637469924141512, 0.099606878963161, 0.09571816998893656, 0.09977019903998918, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020442064816144634, 0.01698545157731779, 0.0170018511320269, 0.014994683108971119, 0.017010880539350515, 0.016582839002189487, 0.12519450417108036, 0.13369885022162142, 0.12252124210502091, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "5947410d-39c9-4262-ae01-71183a1e0040", "fitness": 0.024873009041270083, "name": "HybridPSODE", "description": "Adjust the differential weight to improve convergence in the DE phase.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8  # Original value\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.85 + (0.95 - 0.85) * (1 - evaluations / self.budget)  # Fine-tuned differential weight\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 71, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.024443796714640587, 0.008993940991247507, 0.01762994150112096, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004787736293702993, 0.016686476129490035, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06285074604489072, 0.0715538459979741, 0.05176447210052415, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.058229212747872516, 0.04979327004770606, 0.04294314378676323, 0.09918977988893374, 0.1007053420693782, 0.0916885326234087, 0.03547886610587647, 0.0405270647448811, 0.04201300160157451, 0.10080558627923453, 0.09593315104978395, 0.09568322082148284, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020892079651304574, 0.016660005754725482, 0.01648491241722161, 0.015110536324141721, 0.016890961907054747, 0.015676450052484747, 0.13134934702204493, 0.1329003551689515, 0.12623435339390043, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "e9b65e70-48df-49f1-a428-a2c4458123d4", "fitness": 0.024791834819200276, "name": "HybridPSODE", "description": "Minor adjustment to adaptive crossover probability for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.85 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 72, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.02417591798203511, 0.011250836356603955, 0.01909887160027024, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019801468672600242, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06770998703436448, 0.07395289809742334, 0.05021471471082972, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0502193051835963, 0.04979327004770606, 0.04294314378676323, 0.09918977988893374, 0.10074100661492669, 0.08890887661157898, 0.03496021218646628, 0.04043972486132574, 0.042045102497405895, 0.10122283646323238, 0.09593315104978395, 0.10003361306908576, 0.004347826086956497, 0.008166935279618426, 0.004347826086956497, 0.020669874886814266, 0.016985531461805592, 0.01639562247221593, 0.01474095001286968, 0.016731329248554805, 0.016401661814563706, 0.12474823720524941, 0.12539363833893413, 0.12518708780773236, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6dc1bedb-4cc2-47b6-8379-5c9d61c624fd", "fitness": 0.02418469494986225, "name": "HybridPSODE", "description": "Introduced adaptive inertia weight to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (0.9 - 0.4) * (evaluations / self.budget)  # Adaptive inertia weight\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 73, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.018852457360033714, 0.010050883362148988, 0.023886920830836322, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.012309011833305683, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06261529723435777, 0.064239105153574, 0.0504544353469647, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05412293730985118, 0.047369469454544566, 0.03878946487838264, 0.09614023193401822, 0.10449988751733075, 0.08629384824339448, 0.04410274926744884, 0.03572660279653239, 0.029750563022094556, 0.09338218788722374, 0.09283334534836774, 0.09439539072716319, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01915487794923798, 0.017484121502277183, 0.016381074295804154, 0.01515650537691815, 0.015859662800642993, 0.016398917816049186, 0.12811177078839875, 0.11907610046382111, 0.14255586806327325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "92804300-d5b9-4a73-9ab6-b61610a71d44", "fitness": 0.02453524801531295, "name": "HybridPSODE", "description": "Introduce adaptive inertia weight decay to enhance convergence speed and solution precision.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.3  # Adjusted decay factor\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 74, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.024664669595760302, 0.008418983045739403, 0.0164418336595209, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004508402224055019, 0.017384964134020575, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06462358008866986, 0.0720650095103853, 0.0515326387759657, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05543262346822608, 0.046210844735281476, 0.043207557117369344, 0.09476940436820436, 0.10080825385233438, 0.09073392730799412, 0.034921673794196084, 0.038043668035577904, 0.03746388429938419, 0.10221096721404588, 0.09358764180958379, 0.09877641727614395, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.022043733712881486, 0.01697843370938157, 0.016516907850089413, 0.01502587992980653, 0.01615574397376185, 0.015463665306785557, 0.13269628851249204, 0.12128808254903745, 0.12760565550670855, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "c06a6ad8-ed14-4f73-b115-828988892893", "fitness": 0.023726376853721934, "name": "HybridPSODE", "description": "Slightly increase the number of particles to enhance exploration capabilities.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 31  # Increased from 30 to 31\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 75, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.012746500427758156, 0.012212709606639893, 0.012054000997974823, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.058203622250710296, 0.07076623272755844, 0.055457413527633004, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.046878373152726915, 0.0459501704116656, 0.048131892804143095, 0.0943353209249389, 0.09877302737404203, 0.0865498717291866, 0.034677734077021016, 0.03581955896670341, 0.03470843796575751, 0.09352067984984658, 0.09718902433825105, 0.09350278350686181, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.018398912181481375, 0.017536783847581505, 0.017894134909352655, 0.014567516592156382, 0.018030246542810713, 0.01711829567412526, 0.1313940515318256, 0.12125315775699275, 0.12497650587919129, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "babd4578-42a6-4346-beda-27d91e920f3b", "fitness": 0.025272348602354933, "name": "HybridPSODE", "description": "Adjust the global learning coefficient to improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)  # Increasing global learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 76, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["e6e0be6e-52bc-4986-8b34-fb4059048da0"], "operator": null, "metadata": {"aucs": [0.027144593341155265, 0.013631774060919866, 0.015929400193785748, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006666192466094678, 0.0077044544183473285, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06819138304835826, 0.07327226451221935, 0.05389075191731829, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04916635862010521, 0.0462480562334574, 0.06109884923040387, 0.10041869905448997, 0.1031653281947511, 0.08853079365425898, 0.045452002545901427, 0.037195895655743993, 0.038618912122974525, 0.10171006287789153, 0.10353472099538963, 0.09826324285080212, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01865844006029982, 0.021171729803994732, 0.017679223236035324, 0.016031312059105685, 0.02219018495142322, 0.014904316761855885, 0.13155314971679366, 0.12446412739096624, 0.12616635765558282, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "d08a5012-2a10-45ea-8a9d-17e06db93a41", "fitness": 0.025272348602354933, "name": "HybridPSODE", "description": "Introduce an adaptive particle count that decreases over time to enhance exploration in later stages.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.5 - (evaluations / self.budget) * 0.5\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 77, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["babd4578-42a6-4346-beda-27d91e920f3b"], "operator": null, "metadata": {"aucs": [0.027144593341155265, 0.013631774060919866, 0.015929400193785748, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006666192466094678, 0.0077044544183473285, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06819138304835826, 0.07327226451221935, 0.05389075191731829, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04916635862010521, 0.0462480562334574, 0.06109884923040387, 0.10041869905448997, 0.1031653281947511, 0.08853079365425898, 0.045452002545901427, 0.037195895655743993, 0.038618912122974525, 0.10171006287789153, 0.10353472099538963, 0.09826324285080212, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01865844006029982, 0.021171729803994732, 0.017679223236035324, 0.016031312059105685, 0.02219018495142322, 0.014904316761855885, 0.13155314971679366, 0.12446412739096624, 0.12616635765558282, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "2bcf0462-38a9-48c6-b212-a729e190b221", "fitness": 0.025482288683517672, "name": "HybridPSODE", "description": "Adjust the inertia weight decay rate of the particles to enhance convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)  # Increasing global learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 78, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["babd4578-42a6-4346-beda-27d91e920f3b"], "operator": null, "metadata": {"aucs": [0.027546922378153038, 0.01586628084248276, 0.013329230263636194, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.00879947563089356, 0.007488823540556133, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06752186213222144, 0.07140927698172062, 0.0515474465391309, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057161968285503795, 0.045921073875434426, 0.054401627973191924, 0.09076977787326401, 0.10826420309435514, 0.09100330879547747, 0.04113744817946485, 0.036271316106945006, 0.03587370783207644, 0.09903687387326288, 0.10634454714881036, 0.10489093318728082, 0.02804407845529977, 0.004347826086956497, 0.004347826086956497, 0.018237919055048457, 0.01970070637954635, 0.01802800177432684, 0.015892326631323672, 0.018853188298122325, 0.015207368963069512, 0.1282826315908966, 0.1294381406686782, 0.12584562321092607, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "efb5f722-3608-4305-92df-fe8e0a5eaaea", "fitness": 0.024780543546934625, "name": "HybridPSODE", "description": "Slightly increase the number of particles to enhance exploration and convergence capabilities.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 31  # Increased from 30 to 31\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 79, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.02350445816928326, 0.021037772165513613, 0.011237734377765318, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.010510361694353487, 0.010053429745338516, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.059351512331652256, 0.06311372902613188, 0.053070169117967025, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0455896321561261, 0.045417868791100324, 0.05134996595165797, 0.09677700484384888, 0.09942853445195099, 0.09808469363414818, 0.03784524919817078, 0.030491566321120045, 0.03828700337413815, 0.10156289449835132, 0.09740100994577627, 0.10589578263711286, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02590898605099512, 0.017732810813008704, 0.01857889981989802, 0.016858683429740506, 0.018735063218369152, 0.01463269299490133, 0.12019512001601085, 0.13587175390920014, 0.12871823095653256, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "0a15d478-18f6-4952-b136-7c97a290ce62", "fitness": 0.025478835917438263, "name": "HybridPSODE", "description": "Fine-tune the inertia weight lower bound for enhanced convergence stability.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.3 - (evaluations / self.budget) * 0.3  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)  # Increasing global learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 80, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.028985940260954246, 0.00745540460513805, 0.012188525606906642, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0064436374579252, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06386238375923825, 0.07326404932952513, 0.05432281650841442, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0600468641969214, 0.050432801444751596, 0.04979041414030416, 0.09623773249460688, 0.09942852858873985, 0.08857889144490927, 0.037775073020396954, 0.0426627545167495, 0.03383234475278263, 0.09987627195043358, 0.10337252983023715, 0.09899040340099197, 0.0409667492975202, 0.007732404311787122, 0.004347826086956497, 0.02083658074910477, 0.02132963342384664, 0.01785856303368405, 0.01541440521578219, 0.018621843965978102, 0.01506603891409164, 0.13173296525302325, 0.12419088553225632, 0.13057005339638106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f388befe-f0e8-4852-82d4-397dc2278441", "fitness": 0.024947988438374702, "name": "HybridPSODE", "description": "Enhanced global learning coefficient by slightly increasing the upper bound to improve convergence.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.6 + 2.0 * (evaluations / self.budget)  # Increased upper bound of global learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 81, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.02860941310288989, 0.01083245518788245, 0.010214577646934564, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004711775150053055, 0.012899650415453046, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057186819824574964, 0.06930615483194169, 0.055425538191059553, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056041683148292165, 0.048049492887460854, 0.0621962854147482, 0.09493502111663943, 0.10117486257615271, 0.09236697624649637, 0.04744021113734398, 0.03789448276534457, 0.03930432626000835, 0.09785299933532143, 0.09902278937534903, 0.09909956397918551, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.020292285356860895, 0.02012257583687249, 0.017783480886608416, 0.014838814960814517, 0.015283194899779695, 0.0152073183962258, 0.12898567275446382, 0.1293323865025855, 0.12288783763650624, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "afd7643f-da44-4732-b4b1-3f259f536450", "fitness": 0.02541954838853737, "name": "HybridPSODE", "description": "Refine the DE's differential weight calculation to leverage adaptive hybridization for improved global exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)  # Increasing global learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.6 + (0.9 - 0.6) * (1 - evaluations / self.budget)  # Modified adaptive differential weight calculation\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 82, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.02755999456146707, 0.015739965459513283, 0.013829508893427489, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.008865663552736658, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06701247373834163, 0.07077571465553933, 0.0514605805435886, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057161968285503795, 0.04687624672121349, 0.05698135527261605, 0.09627765342452843, 0.1056533841723446, 0.09229162089494425, 0.03838280389840043, 0.03599869018543922, 0.0318198846541049, 0.10000265016672705, 0.10466884705394153, 0.10489093318728082, 0.02760664231484178, 0.004347826086956497, 0.004347826086956497, 0.018439461750517916, 0.01974341859543771, 0.017750910417779764, 0.015725418271239078, 0.018845622498769643, 0.015212843698783285, 0.1282826315908966, 0.1294381406686782, 0.12595593310695863, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "dd228a55-0a53-4ada-a608-b7eb770fc96e", "fitness": 0.025482221444109845, "name": "HybridPSODE", "description": "Incorporate a feedback mechanism to dynamically adjust the crossover probability for improved exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)  # Increasing global learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - min(0.9, evaluations / self.budget))  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 83, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.027546922378153038, 0.01586628084248276, 0.013329230263636194, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.00879947563089356, 0.007488823540556133, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06752186213222144, 0.07140927698172062, 0.0515474465391309, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057161968285503795, 0.045921073875434426, 0.054401627973191924, 0.09076977787326401, 0.10826420309435514, 0.09100330879547747, 0.04113744817946485, 0.036271316106945006, 0.03587370783207644, 0.09903687387326288, 0.10634454714881036, 0.10489093318728082, 0.02804407845529977, 0.004347826086956497, 0.004347826086956497, 0.018237919055048457, 0.01970070637954635, 0.01802800177432684, 0.015892326631323672, 0.018848347060758885, 0.015207368963069512, 0.1282826315908966, 0.1294381406686782, 0.12584562321092607, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a6924f8d-33db-4669-abba-2bf8fe47de84", "fitness": 0.024456735522170887, "name": "HybridPSODE", "description": "Enhance the PSO global learning coefficient to improve convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                self.c2 = 0.5 + 2.5 * (evaluations / self.budget)  # Increased global learning coefficient\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 84, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.02966864478506759, 0.0060174544859397106, 0.01604321793554797, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004726912258615434, 0.01090178713397194, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.055120156492510675, 0.06638773978962564, 0.05547102199457443, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05844249830735704, 0.0481473216277607, 0.05234840923857609, 0.09015836991007009, 0.09948769869790275, 0.08562123678280442, 0.03519308990820147, 0.04176085518756245, 0.03920094080722347, 0.09912921733392777, 0.10190392516711244, 0.09765037758758877, 0.014683026229973417, 0.004347826086956497, 0.004347826086956497, 0.018513970419878345, 0.01843660426465865, 0.018303060164400753, 0.015045449631636232, 0.015284088726699951, 0.015497025479616289, 0.12434035174986369, 0.1217193483725485, 0.12307246147291429, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6870cc8a-ee29-4b8e-9c8b-cef067fcac1a", "fitness": 0.025098380645855414, "name": "HybridPSODE", "description": "Improved exploration by making the inertia weight decay rate adaptive and slightly increasing it towards the end of the budget.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.3  # Changed upper bound slightly\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)  # Increasing global learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)  # Adaptive crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 85, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.027185948652007963, 0.01354169343930467, 0.013496526196674075, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006559649342762652, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06768446500580827, 0.0744432211634215, 0.05440427475507259, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05549708513619245, 0.04572354319347449, 0.058658026418864195, 0.09523384857022477, 0.10585896787159566, 0.09270024044426328, 0.040514674770994796, 0.032015359804708154, 0.029533480010031088, 0.10389742666976998, 0.10241989739980684, 0.09946106374237684, 0.011362866824671025, 0.004347826086956497, 0.004347826086956497, 0.018234450026167526, 0.02029617680477691, 0.017632657373087612, 0.01611543104261648, 0.018648404762567128, 0.014750152403401495, 0.13370209841868763, 0.12856177454988582, 0.1219934799692447, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "290c0116-8421-4fac-97cf-451322e18696", "fitness": 0.02486273099807543, "name": "HybridPSODE", "description": "Introduce adaptive dynamic adjustment of crossover probability during Differential Evolution update for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20  # Changed from 15 to 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5  # Original value\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91  # Slightly increased from 0.9\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4  # Adjusted lower bound\n                self.c1 = 2.0 * (1 - evaluations / self.budget)  # Decaying personal learning coefficient (changed)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)  # Increasing global learning coefficient (changed)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.9 + 0.05 * np.sin((evaluations / self.budget) * np.pi)  # Adaptive sinusoidal crossover probability\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 86, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.028165648652014652, 0.013763736617418587, 0.013650543816641325, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004667891844449379, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06664981975373041, 0.07366351375453739, 0.05329075290379759, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.058816175281884986, 0.04480439676190928, 0.04717947442455128, 0.09558687259269971, 0.10462792981177749, 0.09100330879547747, 0.03527682570759105, 0.035532235046147886, 0.030647668058158883, 0.10030648088742256, 0.10466884705394153, 0.10489093318728082, 0.005839843219340168, 0.004347826086956497, 0.004347826086956497, 0.021280047610629516, 0.02185976440429982, 0.017437618243926423, 0.01581278311034784, 0.019216664873031863, 0.01463314614786937, 0.12743613228613992, 0.1294381406686782, 0.12301291460660613, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "03d7b27b-d746-4400-9eda-c7acbe59cc7b", "fitness": 0.025482288683517672, "name": "HybridPSODE", "description": "Further optimize the adaptive parameters to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                # Modify inertia weight decay rate slighty for further improvement\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 87, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.027546922378153038, 0.01586628084248276, 0.013329230263636194, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.00879947563089356, 0.007488823540556133, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06752186213222144, 0.07140927698172062, 0.0515474465391309, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.057161968285503795, 0.045921073875434426, 0.054401627973191924, 0.09076977787326401, 0.10826420309435514, 0.09100330879547747, 0.04113744817946485, 0.036271316106945006, 0.03587370783207644, 0.09903687387326288, 0.10634454714881036, 0.10489093318728082, 0.02804407845529977, 0.004347826086956497, 0.004347826086956497, 0.018237919055048457, 0.01970070637954635, 0.01802800177432684, 0.015892326631323672, 0.018853188298122325, 0.015207368963069512, 0.1282826315908966, 0.1294381406686782, 0.12584562321092607, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "1630302c-9a3e-4302-9898-2959919d9b2a", "fitness": 0.024480900490152006, "name": "HybridPSODE", "description": "Increase the number of particles to improve exploration capability and diversity.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 35  # Increased from 30 to 35\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget)\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + (0.9 - 0.5) * (1 - evaluations / self.budget)\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 88, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.029894619657137023, 0.012372384107216527, 0.014787223925305737, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006942021905685936, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06508825269275065, 0.07359738913801617, 0.04952780480065244, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04474818841093664, 0.04034876036380486, 0.04612192055409259, 0.10130143646667988, 0.09661760645533479, 0.08802461251255278, 0.030583872358703412, 0.04014299140001254, 0.03350582229016852, 0.10343227664618815, 0.09930636737846776, 0.10372463026664258, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.019183445816986056, 0.020896254752276744, 0.0176174752074727, 0.019209623691435196, 0.018980522377458175, 0.013768074954253473, 0.1364987273374746, 0.12361125803658979, 0.12148692396056282, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "acf66f83-bf13-4a0e-860f-a61ea65cb66e", "fitness": 0.02548906736531351, "name": "HybridPSODE", "description": "Enhance convergence by adapting the differential weight and personal learning coefficient based on iteration progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 89, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["2bcf0462-38a9-48c6-b212-a729e190b221"], "operator": null, "metadata": {"aucs": [0.026659882427842674, 0.01655146539015495, 0.014713274271514032, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006702020187054347, 0.013627563804596843, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06328793417378975, 0.07045787918483348, 0.05301219094424103, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05632340710842876, 0.04254514568770018, 0.05561658765608446, 0.09067939048635298, 0.10464502898704586, 0.09046056058488172, 0.04075580276101254, 0.03507679790019724, 0.03647608776749378, 0.09903687387326288, 0.10466884705394153, 0.10019580418676277, 0.03783087620822101, 0.013073762407905254, 0.004347826086956497, 0.018405540716077806, 0.0196824489809303, 0.017917138037992775, 0.015717780764746614, 0.019038795688425814, 0.014945405400737743, 0.12845116696986614, 0.1262361109393142, 0.12416041018594692, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "3c8f7baf-e28b-45d6-94d0-17f8bae1cf8c", "fitness": 0.02548906736531351, "name": "HybridPSODE", "description": "Improve convergence by introducing a dynamic mutation step proportional to the budget utilization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 90, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.026659882427842674, 0.01655146539015495, 0.014713274271514032, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.006702020187054347, 0.013627563804596843, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06328793417378975, 0.07045787918483348, 0.05301219094424103, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05632340710842876, 0.04254514568770018, 0.05561658765608446, 0.09067939048635298, 0.10464502898704586, 0.09046056058488172, 0.04075580276101254, 0.03507679790019724, 0.03647608776749378, 0.09903687387326288, 0.10466884705394153, 0.10019580418676277, 0.03783087620822101, 0.013073762407905254, 0.004347826086956497, 0.018405540716077806, 0.0196824489809303, 0.017917138037992775, 0.015717780764746614, 0.019038795688425814, 0.014945405400737743, 0.12845116696986614, 0.1262361109393142, 0.12416041018594692, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "6e92d6a1-fe92-4a04-ab98-881eb014d06b", "fitness": 0.025121285602531785, "name": "HybridPSODE", "description": "Enhance exploration by dynamically adjusting the number of differential evolutions based on iteration progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                self.num_diffs = int(20 * (1 - evaluations / self.budget)) + 1  # Modified\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 91, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.026115964723745444, 0.01599232419419605, 0.011019103634902105, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004748543665242799, 0.005418569272029106, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06673008591086527, 0.0739063480528519, 0.05577407148964153, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05624546236419503, 0.046402723531948964, 0.0476284393552866, 0.09431155235836397, 0.10557458075834436, 0.09181716580859212, 0.039635665904566464, 0.03958254647508863, 0.03249497173267746, 0.10137125115656165, 0.10648202610121638, 0.10018055097041179, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.02280978813265755, 0.026046448848943582, 0.016835965719630308, 0.016100262688445555, 0.023148552023983582, 0.016076147010853914, 0.12495873882144504, 0.12753858930106698, 0.12682960163540524, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "f5354cc7-60f4-41c0-8149-58a6288611b8", "fitness": 0.025076832874828363, "name": "HybridPSODE", "description": "Fine-tune balance between exploration and exploitation by dynamically adjusting inertia and crossover probabilities based on objective function improvement.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    improvement_factor = (global_best_value - np.min(personal_best_values)) / global_best_value if global_best_value != 0 else 0\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * improvement_factor  # Changed\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 92, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.028066840586516206, 0.015072450222924805, 0.013900202197418277, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004527392546268216, 0.005358040797134533, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06409600184260134, 0.07048760595590975, 0.052881322854122614, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056094900852647234, 0.043285505348237496, 0.04728031395088028, 0.09661157415960187, 0.10525353046779673, 0.09172517810953928, 0.03783260400430788, 0.034719467236384416, 0.030196318256771604, 0.09677847604581957, 0.10466884705394153, 0.10053777208414028, 0.03783087620822101, 0.008274859692992242, 0.004347826086956497, 0.019445201199469908, 0.021309030292578357, 0.018464507381168893, 0.01580210461408671, 0.018432327983521013, 0.01509154741247154, 0.12089193120928043, 0.12820056094942223, 0.12415380590624947, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a51dd80f-ccde-4b7a-95fa-7073816b5477", "fitness": 0.024418765094274278, "name": "HybridPSODE", "description": "Improve performance by adjusting the inertia weight for faster convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.7 - (evaluations / self.budget) * 0.5  # Modified\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 93, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.02174443566903861, 0.008254000689114083, 0.020327695765817833, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004749169460411262, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06229291322257324, 0.07288410890357211, 0.05690683380727879, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.04642051471662878, 0.04311518498312217, 0.049382520097556504, 0.09803437735534082, 0.10507849614853049, 0.08708004619574206, 0.03306823158985139, 0.0360982680949371, 0.03979642738825617, 0.09668675257747661, 0.09675053999628624, 0.0922472014210367, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.017388293977397273, 0.019653048994756284, 0.020470776177586192, 0.016827340800257717, 0.01706325510229567, 0.015110386726841285, 0.14005040239669397, 0.12806749187131306, 0.12129802483194974, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "31ecd25e-f567-490e-8486-22d48fc0ab9a", "fitness": 0.025019855593497682, "name": "HybridPSODE", "description": "Enhance convergence by adjusting the inertia weight reduction rate based on the budget utilization.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.3  # Changed line\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 94, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.025761913422372662, 0.01524781063835623, 0.013942561176418011, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0046581992804994865, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06201317502194614, 0.07290903841047625, 0.055024164939959874, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05543262346822608, 0.04572354319347449, 0.05486727669084901, 0.09597806111138663, 0.10624663527311562, 0.09075579605275397, 0.0386925306687963, 0.03438214634923553, 0.02937759452820965, 0.10378450565992747, 0.10273087621916832, 0.1010264199629729, 0.004347826086956497, 0.01072943399974502, 0.004347826086956497, 0.018674365793260428, 0.021984510779107125, 0.01761208237329326, 0.016085146799098005, 0.019147028994478288, 0.014795476054460077, 0.13370209841868763, 0.12721461831129832, 0.1259734474011308, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "b3d22619-c2bc-4458-8804-914a706cf73d", "fitness": 0.025362217483528418, "name": "HybridPSODE", "description": "Introduced adaptive mutation scaling based on convergence progress to further fine-tune diversity and convergence speed.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + (self.differential_weight * (1 - evaluations / self.budget)) * (x1 - x2), self.lower_bound, self.upper_bound)  # Changed\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 95, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.02819462318892607, 0.013033272698555809, 0.01333601487672853, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06596285104306587, 0.07717117593216671, 0.05478051460851541, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056094900852647234, 0.04486093565120508, 0.05190279345852189, 0.0944125026123176, 0.10660043520265883, 0.09269010954524792, 0.036569835158084096, 0.0387220760591227, 0.03364666755232515, 0.09903687387326288, 0.10466884705394153, 0.10006937737530341, 0.04353914970232475, 0.004347826086956497, 0.004347826086956497, 0.01840740687595044, 0.019646634082362224, 0.019087216643179472, 0.015846751141047166, 0.018493272787580506, 0.014882027028938705, 0.12342562154817882, 0.1262361109393142, 0.12345731349648725, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "9ffb51e1-caf1-4a7c-926d-ce7b0f1bde5b", "fitness": 0.024960959992672584, "name": "HybridPSODE", "description": "Minor parameter adjustment in crossover probability to enhance the diversity of solutions.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.9 + 0.09 * (1 - evaluations / self.budget)  # Modified\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 96, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.026642168194282, 0.013832072409549756, 0.016259338521198985, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.00450176953045367, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06441114896576894, 0.07258465962487992, 0.05308198414981635, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05609513280872125, 0.04479322582548573, 0.046539876566187854, 0.09561935120275977, 0.10443242741177328, 0.09119529131993609, 0.041657359772069524, 0.035132728709498795, 0.030916856642593138, 0.1004604665508596, 0.10466884705394153, 0.09878143481067003, 0.023962075702268493, 0.004347826086956497, 0.004347826086956497, 0.02008908425368061, 0.021192162349903843, 0.017568288182898573, 0.01590410225113137, 0.01887578197989881, 0.014758385576826405, 0.12830285505551442, 0.1262361109393142, 0.12173761137141381, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "a4f5d36a-2705-412f-9ccc-d636e5da6cde", "fitness": 0.025104748740815325, "name": "HybridPSODE", "description": "Improve exploration by modifying the crossover probability in the Differential Evolution update.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.7 + 0.2 * (1 - evaluations / self.budget)  # Change here\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 97, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.02878427875934575, 0.015014031500372615, 0.014215418525803214, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004483436022550746, 0.005708851608850596, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.0633776382341602, 0.07033481948318232, 0.05266770146537836, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.056094900852647234, 0.043285505348237496, 0.04728031395088028, 0.09629918846783136, 0.10434965118582662, 0.09111404545363755, 0.03734353108036914, 0.03477892922099768, 0.029534726511696197, 0.09725092407802771, 0.10466884705394153, 0.10053777208414028, 0.03606185964165021, 0.0051240158639078714, 0.004347826086956497, 0.01920317315902431, 0.01980738232612078, 0.01877550445116538, 0.01595932154031232, 0.018432327983521013, 0.01511104356627968, 0.11951419677023967, 0.1324388861871486, 0.13172881739624043, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "57c5d78e-ef2e-4983-9db2-51e825cd10e4", "fitness": 0.0252631796588855, "name": "HybridPSODE", "description": "Improve exploration by adjusting the personal learning coefficient based on particle performance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.4 - (evaluations / self.budget) * 0.4\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget) * (personal_best_values[i] / np.max(personal_best_values))  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 98, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.027711788118654157, 0.01576470411327746, 0.013331838642255733, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004613754599692044, 0.00690521989443782, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.06358493994412173, 0.0758682298260116, 0.051524719634661875, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05646709905287495, 0.04659408700554557, 0.05567999185812067, 0.0953003554602525, 0.10638771394611513, 0.09131056545297134, 0.037576537075049155, 0.03606349860383207, 0.03641889192266423, 0.09903687387326288, 0.10466884705394153, 0.09944172653468009, 0.030555919233481776, 0.008647216534679258, 0.004347826086956497, 0.018403875170740602, 0.019670845751443067, 0.017917666888972672, 0.01584276540976126, 0.018936234621483194, 0.014933609287843708, 0.11888581553228172, 0.12673138917310278, 0.12591134565832707, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
{"id": "20d0a2c7-d6c8-4038-bd29-ea59dcc19f26", "fitness": 0.024153477891539668, "name": "HybridPSODE", "description": "Improve exploration by adjusting inertia weight dynamically based on the proportion of budget used, promoting better global search early on.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.num_particles = 30\n        self.num_diffs = 20\n        self.inertia_weight = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.differential_weight = 0.8\n        self.crossover_prob = 0.91\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = particles.copy()\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n\n        evaluations = self.num_particles\n\n        while evaluations < self.budget:\n            # PSO Update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.inertia_weight = 0.9 - (evaluations / self.budget) * 0.5  # Modified\n                self.c1 = 2.0 * (1 - evaluations / self.budget) + np.log(1 + evaluations/self.budget)  # Modified\n                self.c2 = 0.5 + 2.0 * (evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] + \n                                 self.c1 * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(particles[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_values[i] = current_value\n                    personal_best_positions[i] = particles[i]\n                    \n                    if current_value < global_best_value:\n                        global_best_value = current_value\n                        global_best_position = particles[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # DE Update\n            if evaluations < self.budget:\n                for i in range(self.num_diffs):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    x0, x1, x2 = personal_best_positions[idxs]\n                    self.differential_weight = 0.5 + 0.4 * (1 - evaluations / self.budget)  # Modified\n                    self.crossover_prob = 0.8 + 0.1 * (1 - evaluations / self.budget)\n                    mutant_vector = np.clip(x0 + self.differential_weight * (x1 - x2), self.lower_bound, self.upper_bound)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant_vector, personal_best_positions[i])\n                    \n                    trial_value = func(trial_vector)\n                    evaluations += 1\n                    \n                    if trial_value < personal_best_values[i]:\n                        personal_best_values[i] = trial_value\n                        personal_best_positions[i] = trial_vector\n                        \n                        if trial_value < global_best_value:\n                            global_best_value = trial_value\n                            global_best_position = trial_vector\n\n                    if evaluations >= self.budget:\n                        break\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 99, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["acf66f83-bf13-4a0e-860f-a61ea65cb66e"], "operator": null, "metadata": {"aucs": [0.019719817541067997, 0.00922608784231782, 0.017126746642316393, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004802043508391973, 0.008382107252566717, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05498942490490344, 0.07261211978735571, 0.05583067495367944, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.05212121395845226, 0.05244683454053689, 0.04453810123086266, 0.09298589108067357, 0.10307657830321648, 0.09002148776664154, 0.036407532378446184, 0.031853182828392446, 0.027527335803282926, 0.09778390233506418, 0.0937940733623126, 0.09487834921830907, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497, 0.01564716740766625, 0.018957519957929714, 0.0178073940700908, 0.016292458416663935, 0.021287833859605865, 0.015871631424893673, 0.1280547939678356, 0.12985209575242207, 0.12819948635582845, 0.004347826086956497, 0.004347826086956497, 0.004347826086956497]}}
