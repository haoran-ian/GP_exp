{"id": "2780ad82-a029-412a-b08f-ff7c0bf26c83", "fitness": 0.07945553742703423, "name": "HybridPSO_ADM", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Mutation integrates swarm intelligence with adaptive mutation strategies for diverse exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.positions = np.random.rand(self.population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(2)\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    self.w * self.velocities[i] + \n                    self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                    self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07946 with standard deviation 0.05722.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.014672766880426735, 0.014781433464161386, 0.015372616279626161, 0.06658424406397423, 0.08736492261253914, 0.06124081556169281, 0.13631575205239244, 0.17371239412000372, 0.14505489180849152]}}
{"id": "b2294b2e-58a8-4013-ab03-b550ac9852e6", "fitness": 0.07877302939122265, "name": "EnhancedHybridPSO", "description": "Enhanced Hybrid PSO with Dynamic Inertia and Adaptive Mutation introduces momentum variability and adaptive learning to improve convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.positions = np.random.rand(self.population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w_max = 0.9  # max inertia weight\n        self.w_min = 0.4  # min inertia weight\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.mutation_rate = 0.2\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n\n        evaluations = 0\n        while evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            for i in range(self.population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(2)\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    w * self.velocities[i] +\n                    self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) +\n                    self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07877 with standard deviation 0.04732.", "error": "", "parent_ids": ["2780ad82-a029-412a-b08f-ff7c0bf26c83"], "operator": null, "metadata": {"aucs": [0.01948821181647553, 0.027278225513254428, 0.03211153471115358, 0.06711478327500642, 0.0689084357033437, 0.07233031199669782, 0.13402007777449942, 0.14110865325970368, 0.14659703047086925]}}
{"id": "d15ababd-f402-478e-839b-9d683ca54d9a", "fitness": 0.07593774734371002, "name": "EnhancedHybridPSO_AVM", "description": "Enhanced Hybrid PSO with Adaptive Velocity and Mutation dynamically adjusts velocities and mutation strategies based on convergence dynamics for improved solution accuracy and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_AVM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.positions = np.random.rand(self.population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w = 0.7  # increased inertia weight for more exploration\n        self.c1 = 1.2  # reduced cognitive coefficient\n        self.c2 = 1.7  # increased social coefficient for better convergence\n        self.initial_mutation_rate = 0.2\n        self.final_mutation_rate = 0.05\n        self.mutation_rate = self.initial_mutation_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(2)\n            for i in range(self.population_size):\n                # Adaptive inertia weight to focus on exploration initially and exploitation later\n                self.w = 0.9 - (0.5 * (evaluations / self.budget))\n                self.velocities[i] = (\n                    self.w * self.velocities[i] + \n                    self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                    self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            # Adaptive mutation rate, decreasing over time to stabilize convergence\n            self.mutation_rate = (self.initial_mutation_rate - self.final_mutation_rate) * ((self.budget - evaluations) / self.budget) + self.final_mutation_rate\n\n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedHybridPSO_AVM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07594 with standard deviation 0.05466.", "error": "", "parent_ids": ["2780ad82-a029-412a-b08f-ff7c0bf26c83"], "operator": null, "metadata": {"aucs": [0.013176552494024829, 0.015718650904148257, 0.016599647387243954, 0.07016604184354625, 0.06336141384180805, 0.061660235709320776, 0.14825224005668736, 0.14942533056465523, 0.1450796132919555]}}
{"id": "5179b8ab-a2fb-456b-8c57-acebf0d1111d", "fitness": 0.0731366952826652, "name": "EnhancedHybridPSO_ADM", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation incorporates dynamic population sizing and learning rates, improving convergence by balancing exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.max_population_size = self.initial_population_size * 2\n        self.velocities = np.random.rand(self.initial_population_size, dim) * 0.1\n        self.positions = np.random.rand(self.initial_population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.initial_population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w_max, self.w_min = 0.9, 0.4  # inertia weights\n        self.c1_start, self.c1_end = 2.5, 0.5  # cognitive coefficients\n        self.c2_start, self.c2_end = 0.5, 2.5  # social coefficients\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            population_size = int(self.initial_population_size + (self.max_population_size - self.initial_population_size) * (evaluations / self.budget))\n            if len(self.positions) < population_size:\n                new_positions = lb + (ub - lb) * np.random.rand(population_size - len(self.positions), self.dim)\n                new_velocities = np.random.rand(population_size - len(self.velocities), self.dim) * 0.1\n                self.positions = np.vstack((self.positions, new_positions))\n                self.velocities = np.vstack((self.velocities, new_velocities))\n                self.personal_best_positions = np.vstack((self.personal_best_positions, new_positions))\n                self.personal_best_values = np.append(self.personal_best_values, np.full(population_size - len(self.personal_best_values), np.inf))\n            \n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n            c1 = self.c1_start - (self.c1_start - self.c1_end) * (evaluations / self.budget)\n            c2 = self.c2_start + (self.c2_end - self.c2_start) * (evaluations / self.budget)\n            \n            for i in range(population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(2)\n            for i in range(population_size):\n                self.velocities[i] = (\n                    w * self.velocities[i] + \n                    c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                    c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedHybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07314 with standard deviation 0.05133.", "error": "", "parent_ids": ["2780ad82-a029-412a-b08f-ff7c0bf26c83"], "operator": null, "metadata": {"aucs": [0.02074866570334566, 0.016529873994788558, 0.01902233002407716, 0.061308160286151714, 0.05510518260060315, 0.059865583737771844, 0.1423613986132619, 0.14418880133729717, 0.13910026124668962]}}
{"id": "67f2171d-d99e-4e2f-b106-516ca9036fe1", "fitness": 0.07717094249894349, "name": "HybridPSO_ADM", "description": "Enhanced Hybrid PSO with Dynamic Inertia Weight and Adaptive Mutation Rate improves exploration and exploitation by adapting inertia and mutation based on progress.", "code": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.positions = np.random.rand(self.population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w = 0.9  # Dynamic inertia starts higher\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.mutation_rate = 0.2  # Start with higher mutation rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(2)\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    self.w * self.velocities[i] + \n                    self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                    self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            # Decrease inertia weight dynamically\n            self.w = 0.9 - (0.4 * evaluations / self.budget)\n            \n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n                        \n            # Update mutation rate dynamically\n            self.mutation_rate = 0.2 * (1 - evaluations / self.budget)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07717 with standard deviation 0.05224.", "error": "", "parent_ids": ["2780ad82-a029-412a-b08f-ff7c0bf26c83"], "operator": null, "metadata": {"aucs": [0.013467465222831265, 0.015628567389129544, 0.028365047658317377, 0.07299255623710277, 0.06384963139183686, 0.06484121107021779, 0.13685070395965826, 0.14534905750170268, 0.1531942420596949]}}
{"id": "9136ea6d-25ce-41d2-8844-ddb02c511ba7", "fitness": 0.08165065347061638, "name": "HybridPSO_ADM", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation by dynamically adjusting inertia weight for better convergence.", "code": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.positions = np.random.rand(self.population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(2)\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    self.w * self.velocities[i] + \n                    self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                    self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            self.w = 0.9 - 0.8 * (evaluations / self.budget)  # Dynamically update inertia weight\n\n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08165 with standard deviation 0.05214.", "error": "", "parent_ids": ["2780ad82-a029-412a-b08f-ff7c0bf26c83"], "operator": null, "metadata": {"aucs": [0.033392623852541936, 0.02127516508447047, 0.015158527193177895, 0.0677248921974346, 0.08850226576305686, 0.06348595196070062, 0.15711659092073316, 0.145132522919862, 0.1430673413435699]}}
{"id": "2a623cd4-aa6a-4f26-b765-15b03a37a998", "fitness": -Infinity, "name": "ImprovedHybridPSO_ADM", "description": "Enhanced Hybrid PSO with Adaptive Differential Mutation and Dynamic Niching for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.positions = np.random.rand(self.population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_rate = 0.1\n        self.niche_radius = 0.1 * np.linalg.norm(np.array([func.bounds.ub - func.bounds.lb]), axis=1) / np.sqrt(dim)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            r1, r2 = np.random.rand(2)\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    self.w * self.velocities[i] + \n                    self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                    self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            self.w = 0.9 - 0.8 * (evaluations / self.budget)\n\n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n\n            # Dynamic niching strategy\n            for i in range(self.population_size):\n                for j in range(i + 1, self.population_size):\n                    if np.linalg.norm(self.positions[i] - self.positions[j]) < self.niche_radius:\n                        if self.personal_best_values[i] < self.personal_best_values[j]:\n                            self.personal_best_positions[j] = self.personal_best_positions[i]\n                            self.personal_best_values[j] = self.personal_best_values[i]\n                        else:\n                            self.personal_best_positions[i] = self.personal_best_positions[j]\n                            self.personal_best_values[i] = self.personal_best_values[j]\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 6, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["9136ea6d-25ce-41d2-8844-ddb02c511ba7"], "operator": null, "metadata": {}}
{"id": "da82b06b-127f-44ad-904b-a143f5f938d8", "fitness": 0.08453320465893972, "name": "HybridPSO_ADM_LS", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Mutation and Local Search (HybridPSO_ADM_LS) incorporating a local search strategy to exploit promising regions for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_ADM_LS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(np.clip(5 * np.log10(dim), 10, 50))\n        self.velocities = np.random.rand(self.population_size, dim) * 0.1\n        self.positions = np.random.rand(self.population_size, dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.positions = lb + (ub - lb) * self.positions\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            # Evaluate current population\n            for i in range(self.population_size):\n                value = func(self.positions[i])\n                evaluations += 1\n\n                if value < self.personal_best_values[i]:\n                    self.personal_best_values[i] = value\n                    self.personal_best_positions[i] = self.positions[i]\n\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = self.positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2)\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    self.w * self.velocities[i] + \n                    self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + \n                    self.c2 * r2 * (self.global_best_position - self.positions[i])\n                )\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], lb, ub)\n\n            # Dynamically update inertia weight\n            self.w = 0.9 - 0.8 * (evaluations / self.budget)\n\n            # Apply differential mutation\n            if np.random.rand() < self.mutation_rate:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                target, donor1, donor2 = self.positions[idxs]\n                mutant = target + 0.8 * (donor1 - donor2)\n                mutant = np.clip(mutant, lb, ub)\n                \n                if evaluations < self.budget:\n                    mutant_value = func(mutant)\n                    evaluations += 1\n                    if mutant_value < self.personal_best_values[idxs[0]]:\n                        self.personal_best_values[idxs[0]] = mutant_value\n                        self.personal_best_positions[idxs[0]] = mutant\n\n            # Local search around the global best\n            if evaluations < self.budget:\n                local_radius = 0.1 * (ub - lb)\n                local_search_position = self.global_best_position + np.random.uniform(-local_radius, local_radius, self.dim)\n                local_search_position = np.clip(local_search_position, lb, ub)\n                local_search_value = func(local_search_position)\n                evaluations += 1\n                if local_search_value < self.global_best_value:\n                    self.global_best_value = local_search_value\n                    self.global_best_position = local_search_position\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSO_ADM_LS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08453 with standard deviation 0.05388.", "error": "", "parent_ids": ["9136ea6d-25ce-41d2-8844-ddb02c511ba7"], "operator": null, "metadata": {"aucs": [0.02080010789382236, 0.021082008716304945, 0.04759965366303931, 0.07064445961679278, 0.062095822062949724, 0.06832633565462443, 0.15224355665925415, 0.16329951057484748, 0.15470738708882237]}}
