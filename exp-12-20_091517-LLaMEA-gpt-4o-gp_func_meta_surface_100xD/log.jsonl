{"id": "dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261", "fitness": 0.06247576578293536, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Crossover and Mutation Rates for Efficient Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.06247086677341107, 0.0624721703034653, 0.062484260532063574, 0.06247086672105573, 0.062472170250891135, 0.06248426047974298, 0.0624708665657403, 0.06247217009572259, 0.062484260324325525]}}
{"id": "76331061-01ea-4188-9ad5-4784238a8e82", "fitness": 0.062475728122361254, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a diversity-enhancing mechanism using random perturbation to maintain exploration in Adaptive Differential Evolution.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                \n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n            \n            # Diversity enhancement through random perturbation\n            if evaluations < self.budget:  # Ensuring we stay within budget\n                rand_idx = np.random.randint(0, self.population_size)\n                self.pop[rand_idx] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                self.pop[rand_idx] = np.clip(self.pop[rand_idx], self.bounds[0], self.bounds[1])\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247083362073114, 0.06247217128475069, 0.062484179721688404, 0.06247083356834704, 0.062472171232394125, 0.062484179669394346, 0.06247083341296378, 0.06247217107700498, 0.06248417951397678]}}
{"id": "cd8d15e9-6e1d-4302-afe7-2b97ea4ae908", "fitness": 0.062475688407923786, "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with Stepwise Dynamic Parameter Adjustment for Enhanced Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        dynamic_adjustment_steps = 5  # New parameter\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR every few steps\n            if evaluations % dynamic_adjustment_steps == 0:\n                self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05), 0.1, 0.9)\n                self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470910274703195, 0.06247221465642461, 0.06248394055273132, 0.062470910222308995, 0.062472214604068044, 0.06248394050035233, 0.06247091006701966, 0.062472214448712426, 0.062483940344993494]}}
{"id": "89cf3a43-a79c-4e38-82a9-98eba8c1c576", "fitness": 0.06247573136348772, "name": "AdaptiveDifferentialEvolution", "description": "Improved dynamic adjustment of mutation factor for better convergence in Adaptive Differential Evolution.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05), 0.1, 0.9)  # Slightly adjusted mutation factor range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470809182748166, 0.06247218478150873, 0.06248420038626579, 0.062470809130392824, 0.062472184729163716, 0.06248420033394253, 0.06247080897506441, 0.06247218457377479, 0.062484200178528515]}}
{"id": "494f7aa6-26dc-4490-8880-03d22e0bf7ff", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Crossover, Mutation Rates, and Enhanced Random Selection for Efficient Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False, p=[1/self.population_size]*self.population_size)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 4, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {}}
{"id": "a4894fe4-83c8-4842-9f22-b605506103cf", "fitness": 0.062475688407923786, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Improved Dynamic Parameter Adjustments for Better Convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05), 0.4, 0.9)  # Modified to improve convergence\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.5, 1.0)  # Modified for better adaptability\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470910274703195, 0.06247221465642461, 0.06248394055273132, 0.062470910222308995, 0.062472214604068044, 0.06248394050035233, 0.06247091006701966, 0.062472214448712426, 0.062483940344993494]}}
{"id": "9debddd1-3353-4593-b7a9-a612ded3c7df", "fitness": 0.06247571850071395, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Novel Population Diversity Strategy and Adaptive Learning for Superior Black-Box Optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.learning_rate = 0.1  # Rate to adjust F and CR\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors with diversity check\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                selected = np.random.choice(candidates, 3, replace=False)\n                a, b, c = selected if np.std(self.pop[selected], axis=0).mean() > 0.1 else np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive adjustment of F and CR based on population improvement\n            mean_fitness = np.mean(self.fitness)\n            F_improvement = self.learning_rate * (np.min(self.fitness) - mean_fitness)\n            CR_improvement = self.learning_rate * (mean_fitness - np.min(self.fitness))\n            self.F = np.clip(self.F + F_improvement, 0.1, 0.9)\n            self.CR = np.clip(self.CR + CR_improvement, 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247088471617279, 0.06247203817875113, 0.06248423286738014, 0.06247088466381745, 0.062472038126368146, 0.06248423281483051, 0.06247088450848903, 0.06247203797097911, 0.06248423265963721]}}
{"id": "51b7e233-01bb-440e-9d82-d3aa7558a162", "fitness": 0.062475636095235126, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Target-to-Best Mutation for Improved Convergence in Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                best = np.argmin(self.fitness)\n\n                # Enhanced Mutation: Target-to-Best\n                mutant = np.clip(self.pop[i] + self.F * (self.pop[best] - self.pop[i]) + self.F * (self.pop[b] - self.pop[c]), \n                                 self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247046276051815, 0.06247224685887154, 0.062484198926402335, 0.06247046270818701, 0.0624722468064105, 0.06248419887404977, 0.06247046255281219, 0.0624722466511739, 0.06248419871869071]}}
{"id": "3bb45a09-b9ae-44c9-9753-884d350bd384", "fitness": 0.06247571704957184, "name": "AdaptiveDifferentialEvolution", "description": "Introduced a learning rate to adaptively update the mutation factor F, enhancing exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        learning_rate = 0.05  # Introduced learning rate for F adjustment\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + learning_rate * np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247089150184504, 0.062472188254344974, 0.06248407165258241, 0.062470891449571186, 0.06247218820198819, 0.06248407160012759, 0.06247089129418826, 0.06247218804662813, 0.06248407144487078]}}
{"id": "ea795c19-2286-4aa2-94c5-1b797f621764", "fitness": 0.06247570624180294, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Self-Adaptive Population Size Control for Improved Black-Box Optimization Efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(max(4, 10 * dim), budget // 2)\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.initial_population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        \n        while evaluations < self.budget:\n            population_size = len(self.pop)\n            for i in range(population_size):\n                # Select three distinct vectors\n                candidates = list(range(population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n            # Self-adaptive population size control\n            if evaluations < self.budget / 2:\n                new_size = int(0.9 * population_size)\n            else:\n                new_size = int(1.1 * population_size)\n            new_size = max(4, min(new_size, self.budget - evaluations))\n            \n            # Adjust population size\n            if new_size < population_size:\n                sort_idx = np.argsort(self.fitness)\n                self.pop = self.pop[sort_idx[:new_size]]\n                self.fitness = self.fitness[sort_idx[:new_size]]\n            elif new_size > population_size:\n                additional_pop = np.random.rand(new_size - population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n                additional_fitness = np.array([func(ind) for ind in additional_pop])\n                evaluations += len(additional_pop)\n                self.pop = np.vstack((self.pop, additional_pop))\n                self.fitness = np.concatenate((self.fitness, additional_fitness))\n        \n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.0624708686473866, 0.062472148743553446, 0.06248410159452966, 0.06247086859503115, 0.062472148691223195, 0.06248410154217343, 0.062470868439703064, 0.06247214853583416, 0.062484101386791724]}}
{"id": "a2f8bb73-b5f5-47d2-91f9-55ecdd007617", "fitness": 0.062475746851686345, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Adaptive Population Resizing and Success-Based Parameter Tuning.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.success_count = 0\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.success_count += 1\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adjust population size dynamically\n            if evaluations < self.budget:\n                self.population_size = max(4, int(self.initial_population_size * (1 - evaluations / self.budget)))\n                self.pop = self.pop[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n            # Success-based parameter tuning\n            if self.success_count > 0:\n                self.F = np.clip(self.F + np.random.uniform(0, 0.2), 0.1, 0.9)\n                self.CR = np.clip(self.CR + np.random.uniform(0, 0.1), 0.1, 1.0)\n                self.success_count = 0\n            else:\n                self.F = np.clip(self.F + np.random.uniform(-0.2, 0.0), 0.1, 0.9)\n                self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.0), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247078623025826, 0.06247220538846221, 0.062484249196515074, 0.06247078617780932, 0.062472205336105424, 0.06248424914399986, 0.06247078602248113, 0.06247220518074226, 0.06248424898880356]}}
{"id": "b7ea79a0-15ad-4ef6-953f-d5f8ef4668ef", "fitness": 0.062475688407923786, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Learning-Based Parameter Adjustment for Improved Black-Box Optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.successful_mutations = []\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.successful_mutations.append((self.F, self.CR))\n\n                if evaluations >= self.budget:\n                    break\n\n            # Learning-Based Dynamic Adjustment of F and CR\n            if self.successful_mutations:\n                self.F = np.clip(np.mean([f for f, cr in self.successful_mutations]) + np.random.uniform(-0.05, 0.05), 0.1, 0.9)\n                self.CR = np.clip(np.mean([cr for f, cr in self.successful_mutations]) + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n                self.successful_mutations.clear()\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470910274703195, 0.06247221465642461, 0.06248394055273132, 0.062470910222308995, 0.062472214604068044, 0.06248394050035233, 0.06247091006701966, 0.062472214448712426, 0.062483940344993494]}}
{"id": "282483d3-3a1d-4a65-b208-87de3b8a18f0", "fitness": 0.06247561612718942, "name": "AdaptiveDifferentialEvolution", "description": "Introducing a non-uniform mutation factor `F` to increase diversity and potentially escape local optima.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                F_i = np.random.uniform(0.4, 0.9)  # Non-uniform mutation factor\n                mutant = np.clip(self.pop[a] + F_i * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247048514348186, 0.062472213335077575, 0.062484150163147234, 0.06247048509098463, 0.06247221328279373, 0.06248415011059372, 0.06247048493579399, 0.062472213127404586, 0.062484149955427504]}}
{"id": "a98a27ad-1ca8-4454-894b-699b91ec8ad1", "fitness": 0.06247569446975296, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution with Self-Adaptive Mechanisms for Mutation and Crossover Rates to Improve Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F_base = 0.5  # Base mutation factor\n        self.CR_base = 0.9  # Base crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        F_adapt = self.F_base\n        CR_adapt = self.CR_base\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with self-adaptation\n                F = np.clip(F_adapt + np.random.normal(0, 0.1), 0.1, 0.9)\n                mutant = np.clip(self.pop[a] + F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover with self-adaptation\n                CR = np.clip(CR_adapt + np.random.normal(0, 0.1), 0.1, 1.0)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    # Successful adaptation\n                    F_adapt = F\n                    CR_adapt = CR\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247086245830058, 0.06247209539884391, 0.06248412581223173, 0.062470862405770156, 0.06247209534648712, 0.06248412575990914, 0.06247086225061582, 0.062472095191097976, 0.06248412560452021]}}
{"id": "3c93d282-bcf2-4aa3-b3b4-f681482e83fd", "fitness": 0.06247575707689888, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population and Learning Mechanism for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.learning_rate = 0.1  # Added learning rate for adaptive strategy\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.F += self.learning_rate * (trial_fitness - self.fitness[i])  # Learn from success\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n            if evaluations % (self.population_size // 2) == 0:  # Population change mechanism\n                best_idx = np.argmin(self.fitness)\n                new_ind = np.random.rand(self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n                new_fitness = func(new_ind)\n                evaluations += 1\n                if new_fitness < self.fitness[best_idx]:\n                    self.pop[best_idx] = new_ind\n                    self.fitness[best_idx] = new_fitness\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247083783422713, 0.06247217380803749, 0.06248425984854955, 0.06247083778191198, 0.06247217375546821, 0.06248425979622918, 0.06247083762652861, 0.062472173600299774, 0.062484259640838036]}}
{"id": "c0ac72cb-111a-4e96-a70e-120fb7c42357", "fitness": 0.062475784678674984, "name": "EnhancedDifferentialEvolution", "description": "Integrating Adaptive Differential Evolution with Levy Flight for Enhanced Exploration and Convergence in Black-Box Optimization", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247094244894025, 0.06247224475837332, 0.06248416708896187, 0.06247094239638584, 0.06247224470600932, 0.06248416703646131, 0.06247094224106575, 0.06247224455067524, 0.06248416688120195]}}
{"id": "cdec047a-f68b-4450-bb51-46eb85907a78", "fitness": 0.06247580576199174, "name": "EnhancedDifferentialEvolution", "description": "Slightly increasing the mutation factor dynamics to improve exploration and convergence balance in the Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["c0ac72cb-111a-4e96-a70e-120fb7c42357"], "operator": null, "metadata": {"aucs": [0.062470942930580975, 0.06247222771124061, 0.062484246904223495, 0.06247094287822097, 0.06247222765888205, 0.06248424685184906, 0.06247094272290066, 0.06247222750354231, 0.06248424669648556]}}
{"id": "610d38e8-1afe-4217-a235-49f5b6ebbf75", "fitness": 0.062475534618921316, "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with refined random selection to improve diversity and enhance convergence.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors with better diversity\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False, p=np.full(len(candidates), 1/len(candidates)))\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["cdec047a-f68b-4450-bb51-46eb85907a78"], "operator": null, "metadata": {"aucs": [0.06247016280759232, 0.06247217444398023, 0.06248426686520403, 0.06247016275531858, 0.06247217439162367, 0.062484266812853684, 0.06247016259994376, 0.06247217423628093, 0.062484266657494625]}}
{"id": "c3069041-364e-4399-8e62-29c9a08a589c", "fitness": 0.06247577658780606, "name": "EnhancedDifferentialEvolution", "description": "Integrate dynamic scaling of mutation factor and crossover rate based on fitness variance to enhance adaptability in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            fitness_variance = np.var(self.fitness)\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR based on fitness variance\n            scale_factor = fitness_variance / (fitness_variance + 1)\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12) * scale_factor, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1) * scale_factor, 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["cdec047a-f68b-4450-bb51-46eb85907a78"], "operator": null, "metadata": {"aucs": [0.062470930316329665, 0.062472193296829404, 0.062484206410447496, 0.06247093026381523, 0.06247219324449904, 0.06248420635806884, 0.062470930108494915, 0.06247219308911511, 0.062484206202654824]}}
{"id": "4b565aee-70b8-49cf-b3ed-dd0d9698b265", "fitness": 0.062475428806078, "name": "ImprovedDifferentialEvolution", "description": "Improved Differential Evolution with Adaptive Levy Flight to enhance dynamic exploration and exploitation balance.", "code": "import numpy as np\n\nclass ImprovedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def adaptive_levy_flight(self, lam=1.5):\n        # Adapt lambda based on budget consumption to balance exploration and exploitation\n        lam = 1.5 - 0.5 * (self.budget_consumed / self.budget)\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        self.budget_consumed = evaluations\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Adaptive Levy Flight\n                lev = self.adaptive_levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.budget_consumed += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm ImprovedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["cdec047a-f68b-4450-bb51-46eb85907a78"], "operator": null, "metadata": {"aucs": [0.062469788637366186, 0.06247222063051894, 0.06248427741047735, 0.062469788584941455, 0.06247222057816204, 0.062484277358066165, 0.06246978842968931, 0.06247222042277323, 0.06248427720270733]}}
