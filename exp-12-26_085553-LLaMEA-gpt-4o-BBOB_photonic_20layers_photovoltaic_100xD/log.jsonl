{"id": "1d3144b4-49e8-4a96-a059-02c150563fdb", "fitness": 0.07082143215201088, "name": "HybridDE_SA", "description": "The algorithm combines differential evolution and simulated annealing to adaptively explore and exploit the search space.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + 0.8 * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < 0.9\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):  # Inner loop iterations for SA\n            candidate = current_best + np.random.normal(0, 0.1, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            if candidate_fitness < current_best_fitness or \\\n               np.exp((current_best_fitness - candidate_fitness) / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95  # Cooling schedule for SA\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07082 with standard deviation 0.05290.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.012875142936775719, 0.015194330659675681, 0.014897621361003255, 0.053433464842395084, 0.05860429461325023, 0.05790337500276832, 0.13959642489781832, 0.14238073366746118, 0.14250750138695012]}}
{"id": "0c9f2199-e193-4a9f-aecf-6bb7ab5ab32e", "fitness": 0.07199563962111173, "name": "EnhancedHybridDE_SA", "description": "Integrate a dynamic adaptation of mutation and crossover rates with enhanced local search using adaptive simulated annealing to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07200 with standard deviation 0.05284.", "error": "", "parent_ids": ["1d3144b4-49e8-4a96-a059-02c150563fdb"], "operator": null, "metadata": {"aucs": [0.013444081668787522, 0.01966746953108578, 0.01296531109963761, 0.056560491135491664, 0.060959933066577654, 0.057044040881931046, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "bb54d396-549a-4aa5-8cff-44d17102b05a", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Introduce adaptive population resizing and gradient-based mutation to dynamically balance diversity and convergence speed in evolutionary search.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.min_pop_size = 4 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        mutant += np.random.normal(0, 0.01, self.dim)  # Gradient-based mutation tweak\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def resize_population(self):\n        # Resize population based on performance\n        if np.std(self.fitness) < 1e-5:\n            new_size = max(self.min_pop_size, int(0.8 * self.pop_size))\n        else:\n            new_size = min(20 * self.dim, int(1.2 * self.pop_size))\n        if new_size != self.pop_size:\n            self.population = self.population[:new_size]\n            self.fitness = self.fitness[:new_size]\n            self.pop_size = new_size\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.95\n\n            self.resize_population()\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 2, "feedback": "An exception occurred: IndexError('index 200 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 200 is out of bounds for axis 0 with size 200')", "parent_ids": ["0c9f2199-e193-4a9f-aecf-6bb7ab5ab32e"], "operator": null, "metadata": {}}
{"id": "3b8fdf87-c809-46e6-9546-3925c47d27fe", "fitness": 0.09435307338676523, "name": "EnhancedHybridDE_SA", "description": "Fine-tune the cooling schedule of the adaptive simulated annealing by adjusting the temperature decay rate and enhancing the initial population diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09435 with standard deviation 0.06414.", "error": "", "parent_ids": ["0c9f2199-e193-4a9f-aecf-6bb7ab5ab32e"], "operator": null, "metadata": {"aucs": [0.2129392852265264, 0.019517470991671226, 0.0129415043237745, 0.05737588729495746, 0.06082802518837371, 0.058256058249089415, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "952de44a-c4b8-4311-8252-4eea32c8979e", "fitness": 0.07712780533035836, "name": "ChaosPerturbedHybridDE_SA", "description": "Improve the exploration-exploitation balance by integrating a chaos theory-based perturbation mechanism and dynamically adjusting mutation and crossover based on population diversity.", "code": "import numpy as np\n\nclass ChaosPerturbedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.chaos_param = 0.75\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def chaos_perturbation(self):\n        self.chaos_param *= 3.57 * (1 - self.chaos_param)\n        return self.chaos_param\n\n    def diversity_control(self):\n        diversity = np.std(self.population, axis=0).mean()\n        scale_factor = 0.5 + (1.5 * (1 - diversity))\n        crossover_prob = 0.8 + (0.2 * diversity)\n        return scale_factor, crossover_prob\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor, crossover_prob = self.diversity_control()\n                mutant = self.mutate(i, scale_factor)\n                chaotic_factor = self.chaos_perturbation()\n                trial = self.crossover(self.population[i], mutant * chaotic_factor, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 4, "feedback": "The algorithm ChaosPerturbedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07713 with standard deviation 0.05097.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.019053224899072796, 0.030307689631484558, 0.01765148082375778, 0.060153619610664566, 0.053832459322288306, 0.081121577067642, 0.14626498820177636, 0.1410864898900802, 0.14467871852645864]}}
{"id": "e5e568b0-3d41-428e-9c25-2803693a4c85", "fitness": 0.07211661708704652, "name": "EnhancedHybridDE_SA_LF", "description": "Improve search efficiency by dynamically adjusting population and integrating Levy Flights for enhanced exploration.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_LF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def levy_flight(self, current_best):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return current_best + 0.01 * step * (current_best - self.lb)\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            if evaluations / self.budget > 0.5:\n                best_solution = self.levy_flight(best_solution)\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedHybridDE_SA_LF got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07212 with standard deviation 0.05299.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013162954720501885, 0.018485569161684645, 0.012663274725878582, 0.05502874318299367, 0.06082802518837371, 0.06149674792096771, 0.14432737514899596, 0.14025270046742777, 0.14280416326659473]}}
{"id": "9eb23b7d-a514-4d80-8ddb-0751b5d85b54", "fitness": 0.07302557394620718, "name": "EnhancedHybridDE_SA", "description": "Introduce dynamic population resizing and adaptive parameter tuning to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.dynamic_scale = True  # New dynamic scaling flag\n        self.min_pop_size = 4 * self.dim  # Minimum population size\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0) if self.dynamic_scale else 0.7  # Adjusted\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n            # New dynamic population resizing\n            if evaluations % 100 == 0 and self.pop_size > self.min_pop_size:\n                self.pop_size -= 2 * self.dim\n\n        return best_solution, best_fitness", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07303 with standard deviation 0.05435.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.01315144900905929, 0.018018388133289376, 0.012432870490230452, 0.05755596117176087, 0.05527696153407691, 0.0648341454066027, 0.14432737514899574, 0.14628982797548462, 0.1453431866463647]}}
{"id": "9611d8ad-39a3-4d4c-9dfc-42446b39c595", "fitness": 0.07205136995624445, "name": "RefinedHybridDE_SA", "description": "Integrate a dynamic adaptation of population size and mutation strategies based on convergence trends to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.max_pop_size = 20 * self.dim\n        self.min_pop_size = 5 * self.dim\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub, pop_size):\n        self.population = np.random.uniform(lb, ub, (pop_size, self.dim))\n        self.fitness = np.full(pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(len(self.population)))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def adapt_population_size(self):\n        if self.fitness.std() < 1e-3:\n            new_size = max(self.min_pop_size, int(len(self.population) * 0.9))\n        else:\n            new_size = min(self.max_pop_size, int(len(self.population) * 1.1))\n        if new_size != len(self.population):\n            selected_indices = np.argsort(self.fitness)[:new_size]\n            self.population = self.population[selected_indices]\n            self.fitness = self.fitness[selected_indices]\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub, self.initial_pop_size)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n\n            self.evaluate_population(func)\n            evaluations += len(self.population)\n\n            for i in range(len(self.population)):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            self.adapt_population_size()\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 7, "feedback": "The algorithm RefinedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07205 with standard deviation 0.05251.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013419259028851882, 0.024056597875143138, 0.012760158023609747, 0.05737588729495746, 0.05527493992805399, 0.058256058249089415, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "ff0fc343-c6bb-4d24-9c00-b9e9bab99c71", "fitness": 0.07217970503582909, "name": "EnhancedHybridDE_SA_Swarm", "description": "Improve solution quality by incorporating adaptive parameter control and swarm intelligence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Swarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.global_best = None\n        self.global_best_fitness = np.inf\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def update_global_best(self):\n        current_best_idx = np.argmin(self.fitness)\n        current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n        if current_best_fitness < self.global_best_fitness:\n            self.global_best, self.global_best_fitness = current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + np.random.rand() * 0.5  # Adaptive mutation rate\n                crossover_prob = 0.8 + np.random.rand() * 0.2  # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            self.update_global_best()\n\n            if self.global_best_fitness < np.inf:\n                self.global_best, self.global_best_fitness = self.adaptive_simulated_annealing(self.global_best, self.global_best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return self.global_best, self.global_best_fitness", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedHybridDE_SA_Swarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07218 with standard deviation 0.05281.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.01337897006810107, 0.019517470991671226, 0.0129415043237745, 0.05737588729495746, 0.06082802518837371, 0.058256058249089415, 0.14432737514899596, 0.14018789079090366, 0.14280416326659473]}}
{"id": "a5e84fc5-9ee1-4304-812d-6d2bd288e6ca", "fitness": 0.07345939828497514, "name": "EnhancedHybridDE_SA", "description": "Integrate a multi-strategy mutation mechanism and adaptive crossover probabilities to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        strategies = [\n            lambda a, b, c: self.population[a] + scale_factor * (self.population[b] - self.population[c]),\n            lambda a, b, c: self.population[a] + scale_factor * (self.population[b] - self.population[c]) + scale_factor * (self.population[a] - self.population[c])\n        ]\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        chosen_strategy = np.random.choice(strategies)\n        mutant = chosen_strategy(a, b, c)\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = 0.5 + 0.5 * ((self.budget - evaluations) / self.budget) # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07346 with standard deviation 0.05663.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.011756165276757158, 0.014757142171291648, 0.013452511704860837, 0.06264601733118813, 0.05571332272164842, 0.057860375456386226, 0.1378755068543337, 0.14018789079090366, 0.16688565225740648]}}
{"id": "7b909eae-91c3-464c-89a9-c2a0b69510d0", "fitness": 0.0746004188190109, "name": "EnhancedHybridDE_SA_LocalSearch", "description": "Introduce a self-adaptive parameter strategy and integrate a local search phase, enhancing convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_LocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def local_search(self, candidate, candidate_fitness):\n        for _ in range(3):\n            perturbation = np.random.normal(0, 0.05, self.dim)\n            new_candidate = candidate + perturbation\n            new_candidate = np.clip(new_candidate, self.lb, self.ub)\n            new_fitness = self.func(new_candidate)\n            if new_fitness < candidate_fitness:\n                candidate, candidate_fitness = new_candidate, new_fitness\n        return candidate, candidate_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            if np.random.rand() < 0.3:  # 30% chance to perform local search\n                best_solution, best_fitness = self.local_search(best_solution, best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedHybridDE_SA_LocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07460 with standard deviation 0.05438.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013338258954438742, 0.01987402551897366, 0.013343563465675334, 0.05932403430010458, 0.06637084557805772, 0.05977965319188128, 0.14468158117649565, 0.1402525233918086, 0.15443928379366256]}}
{"id": "3440bc42-5eec-4901-82e0-7b6a2215e0b2", "fitness": 0.07192761086658842, "name": "EnhancedHybridDE_SA", "description": "Improve population diversity by introducing Gaussian noise in the initialization phase.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim)) + np.random.normal(0, 0.01, (self.pop_size, self.dim))  # Introduce Gaussian noise\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92  # Adjusted temperature decay rate\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07193 with standard deviation 0.05234.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.012382673754019247, 0.015436932844969387, 0.020790958899411405, 0.0635651222051713, 0.0504076151858166, 0.05981625092686338, 0.1401123398416496, 0.13806824395767836, 0.14676836018371642]}}
{"id": "dc6e28ad-5efe-4ad9-bb77-5655310e20a4", "fitness": 0.07306739107156174, "name": "EnhancedHybridDE_SA", "description": "Leverage a multi-phase adaptive strategy combining DE with adaptively scheduled simulated annealing and dynamic population size adjustment.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.adaptive_cooling_rate = 0.95\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(len(self.population)))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        pop_size = self.initial_pop_size\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += pop_size\n\n            for i in range(pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)  # Dynamic mutation rate\n                crossover_prob = np.random.uniform(0.8, 1.0)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= self.adaptive_cooling_rate  # Adaptive temperature decay\n\n            pop_size = int(pop_size * 0.95)  # Gradual reduction of population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07307 with standard deviation 0.05266.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.013800111776125279, 0.019995613632783682, 0.01366852117724826, 0.056221086396101794, 0.06539755856574558, 0.060208973494449425, 0.14532260054410473, 0.14018789079090366, 0.1428041632665933]}}
{"id": "e9b90592-186d-4110-9cf4-9b08bffc7302", "fitness": 0.07343619093006329, "name": "EnhancedHybridDE_SA_Adaptive", "description": "Introduce a self-adaptive strategy that dynamically adjusts mutation and crossover rates based on population diversity, while incorporating an elite preservation mechanism to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def calculate_diversity(self):\n        pairwise_distances = np.sum((self.population[np.newaxis, :, :] - self.population[:, np.newaxis, :])**2, axis=2)\n        max_distance = np.max(pairwise_distances)\n        avg_distance = np.mean(pairwise_distances)\n        return avg_distance / max_distance if max_distance > 0 else 0\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        elite_solution = None\n        elite_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            diversity = self.calculate_diversity()\n            scale_factor = 0.5 + 0.5 * diversity\n            crossover_prob = 0.7 + 0.3 * (1 - diversity)\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            if current_best_fitness < elite_fitness:\n                elite_solution, elite_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n            self.temperature *= 0.92\n\n            if evaluations >= self.budget:\n                break\n\n        return elite_solution, elite_fitness", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedHybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07344 with standard deviation 0.05378.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.01305775815374155, 0.015089105705803685, 0.016162445928842528, 0.06507704251646251, 0.053832459322288306, 0.06435465995183676, 0.13966265467455974, 0.14800487441205956, 0.14568471770497493]}}
{"id": "0d8edcf7-0a94-4115-a7f4-14bd9f4fe937", "fitness": -Infinity, "name": "EnhancedHybridDE_LF_SA", "description": "Integrate Lvy Flights to enhance exploration and refine temperature decay dynamically for balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_LF_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.temperature_decay = 0.92\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def levy_flight(self, current_best):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return current_best + step\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0) \n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            if evaluations < 0.5 * self.budget: \n                best_solution = self.levy_flight(best_solution)\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= self.temperature_decay\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 14, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {}}
{"id": "5f57360d-6507-4b9d-9fab-d0f9cb370bf1", "fitness": 0.09695464924359509, "name": "EnhancedHybridDE_SA", "description": "Introduce a non-linear temperature decay rate and dynamic population size adaption for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09695 with standard deviation 0.06270.", "error": "", "parent_ids": ["3b8fdf87-c809-46e6-9546-3925c47d27fe"], "operator": null, "metadata": {"aucs": [0.20991799010379453, 0.020543577347015618, 0.015423729238919104, 0.06892843601285292, 0.05903711103410647, 0.06445534717403234, 0.1443273751489912, 0.14628982797548862, 0.14366844915715504]}}
{"id": "39423513-ac6d-4657-b756-9f889a9fea04", "fitness": 0.07753280012293612, "name": "EnhancedHybridDE_SA", "description": "Introduce adaptive crossover rate modification and refined temperature decay for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                # Changed line: Adaptive crossover rate based on evaluations\n                crossover_prob = 0.8 + 0.2 * (1 - evaluations / self.budget)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            # Changed line: Adjusted temperature decay formula for smoother transitions\n            self.temperature *= 0.94 + 0.06 * np.tanh(0.05 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07753 with standard deviation 0.05331.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013046981559853954, 0.015748899058196653, 0.014953752253907826, 0.07622285204089063, 0.0659559193838255, 0.07824286122557633, 0.1380879966588755, 0.15047115401068623, 0.1450647849146124]}}
{"id": "b380f12d-73d4-4835-b2a4-bb03b71f317f", "fitness": 0.0743947704439667, "name": "EnhancedHybridDE_SA", "description": "Introduce a dynamic mutation strategy and enhance adaptive simulated annealing acceptance criteria to improve convergence stability.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            acceptance_prob = np.exp(delta_fitness / (self.temperature / (1 + np.abs(delta_fitness))))  # Enhanced acceptance\n            if delta_fitness > 0 or acceptance_prob > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.4, 0.9)  # Dynamic mutation strategy\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07439 with standard deviation 0.05195.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013697996124563017, 0.02086500522381951, 0.017893037212304064, 0.06612330990848048, 0.06192986846705417, 0.060360492363060736, 0.13859381433252171, 0.14167507801670964, 0.14841433234718693]}}
{"id": "7b13a900-f175-46df-a9ba-3b3a25f0e0df", "fitness": 0.07691406522784039, "name": "EnhancedHybridDE_SA", "description": "Apply dynamic crossover rate and adaptive mutation strategy for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.6, 1.2)  # Adjusted for adaptability\n                crossover_prob = 0.8 + 0.2 * np.sin(0.1 * evaluations / self.budget * np.pi)  # Dynamic crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07691 with standard deviation 0.05468.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013859559776290942, 0.014732422558393354, 0.012443913929109152, 0.0709635647997594, 0.06573424173949183, 0.07456172214494972, 0.1430141223707846, 0.14018789079090366, 0.15672914894088086]}}
{"id": "6cc90f17-8173-4347-857d-6f91ba298c8c", "fitness": 0.07503447808002899, "name": "EnhancedHybridDE_SA", "description": "Introduce dynamic mutation rate adaption based on population diversity for improved exploration in EnhancedHybridDE_SA.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            # Dynamic mutation rate based on population diversity\n            diversity = np.std(self.population, axis=0).mean()\n            self.mutation_rate = 0.5 + 0.5 * (1 - diversity / (self.ub - self.lb).mean())\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07503 with standard deviation 0.05314.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.01263644963169952, 0.020543577347015618, 0.015423729238919104, 0.06892843601285292, 0.05903711103410647, 0.06445534717403234, 0.1443273751489912, 0.14628982797548862, 0.14366844915715504]}}
{"id": "93b98fe4-4d4d-4aba-bf4e-1dca3be8bee0", "fitness": 0.0740389664089585, "name": "ImprovedAdaptiveHybridDE_SA", "description": "Combine adaptive learning rates with a stochastic constraint handling mechanism to enhance exploration and exploitation in a dynamic environment.", "code": "import numpy as np\n\nclass ImprovedAdaptiveHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def adaptive_parameters(self):\n        return 0.5 + 0.5 * np.tanh(0.1 * self.evaluations / self.budget)\n\n    def stochastic_constraint_handling(self, trial):\n        if np.random.rand() < self.constraint_prob:\n            trial = np.random.uniform(self.lb, self.ub, self.dim)\n        return trial\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        self.evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        self.constraint_prob = 0.1\n\n        while self.evaluations < self.budget:\n            self.evaluate_population(func)\n            self.evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = self.adaptive_parameters()\n                crossover_prob = self.adaptive_parameters()\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial = self.stochastic_constraint_handling(trial)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * self.evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n            self.constraint_prob = 0.1 + 0.1 * np.sin(0.1 * self.evaluations / self.budget)\n\n            if self.evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 20, "feedback": "The algorithm ImprovedAdaptiveHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07404 with standard deviation 0.05212.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.014428120973721814, 0.017944148510409152, 0.013957736715893176, 0.06373985046217223, 0.060221337980867484, 0.07091417051194504, 0.13444693169040856, 0.14819089944825603, 0.142507501386953]}}
{"id": "d709eaa6-64a9-49cd-9486-d6048800c66f", "fitness": 0.0750269248683102, "name": "EnhancedHybridDE_SA", "description": "Incorporate adaptive learning rates and elite preservation to enhance exploration and exploitation balance in the optimization process.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.init_pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.elite_fraction = 0.1\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.init_pop_size, self.dim))\n        self.fitness = np.full(self.init_pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.init_pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.init_pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        learning_rate = 0.5\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.init_pop_size\n\n            elite_size = int(self.elite_fraction * self.init_pop_size)\n            elite_indices = np.argsort(self.fitness)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            for i in range(self.init_pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n                # Incorporate elite information\n                if i in elite_indices:\n                    elite_member = elite_population[np.random.randint(elite_size)]\n                    trial = learning_rate * trial + (1 - learning_rate) * elite_member\n                    trial_fitness = func(trial)\n                    evaluations += 1\n                    self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.init_pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07503 with standard deviation 0.05027.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.019347272849151498, 0.019199418052548545, 0.017663596302969653, 0.06332404802333935, 0.07245265537950041, 0.06183872927705847, 0.13459219628546315, 0.14018789079090366, 0.14663651685385704]}}
{"id": "9f8d7b25-d05b-4935-ad74-d044daa50035", "fitness": 0.07684801374020975, "name": "EnhancedHybridDE_SA", "description": "Implement exponential decay in temperature and enhance crossover probability for faster convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.85, 1.0)  # Enhanced crossover probability (change 1)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= np.exp(-0.05 * evaluations / self.budget)  # Exponential temperature decay (change 2)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07685 with standard deviation 0.04839.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.02665236816200034, 0.03642393629881602, 0.01366061404658081, 0.055720613284405585, 0.058620616463661235, 0.07919960557690375, 0.13865897765166335, 0.14018789079090366, 0.142507501386953]}}
{"id": "14c526d6-51c7-4e12-b037-23d1a5dc14e8", "fitness": 0.07536030048676551, "name": "EnhancedHybridDE_SA", "description": "Introduce adaptive crossover and scale factor strategies based on population diversity to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                diversity = np.std(self.population, axis=0).mean()\n                scale_factor = np.random.uniform(0.5, 1.0) * (1 + 0.1 * diversity)  # Adaptive scale factor\n                crossover_prob = np.random.uniform(0.8, 1.0) * (1 - 0.1 * diversity)  # Adaptive crossover rate\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07536 with standard deviation 0.05345.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.014239860639234103, 0.015532082426283123, 0.018607163328035803, 0.0725309497063169, 0.05709418721391768, 0.06445534717403234, 0.13915958866321965, 0.14846536028099822, 0.1481581649488517]}}
{"id": "f612708f-2eec-4948-aeed-b859217dfd29", "fitness": 0.07298500495797539, "name": "EnhancedHybridDE_SA", "description": "Integrate an adaptive differential mutation strategy and flexible crossover probability for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = 0.5 + 0.5 * np.random.rand()  # Adaptive scale factor\n                crossover_prob = 0.7 + 0.3 * np.random.rand()  # Flexible crossover probability\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07299 with standard deviation 0.05261.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.013996266466596352, 0.015488233667482532, 0.01405145756399706, 0.06162566645356149, 0.06130480883691991, 0.06445534717403234, 0.13755376517300988, 0.14588199789922596, 0.142507501386953]}}
{"id": "df3caf94-bbcf-4ce6-8ffa-15230e845642", "fitness": 0.07145533957067075, "name": "EnhancedHybridDE_SA_Opposition", "description": "Introduce adaptive step size control and opposition-based learning for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Opposition:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def opposition_based_learning(self):\n        opp_population = self.lb + self.ub - self.population\n        opp_population = np.clip(opp_population, self.lb, self.ub)\n        opp_fitness = np.array([self.func(ind) for ind in opp_population])\n        return opp_population, opp_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        step_size = 0.1\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            # Opposite learning\n            opp_population, opp_fitness = self.opposition_based_learning()\n            combined_population = np.vstack((self.population, opp_population))\n            combined_fitness = np.hstack((self.fitness, opp_fitness))\n            best_indices = np.argpartition(combined_fitness, self.pop_size)[:self.pop_size]\n            self.population, self.fitness = combined_population[best_indices], combined_fitness[best_indices]\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor + step_size)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            step_size *= 0.95  # Adaptive step size control\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedHybridDE_SA_Opposition got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07146 with standard deviation 0.05135.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.015669097743745253, 0.015915263917513522, 0.014551615584374566, 0.06717688774705588, 0.052016133389111596, 0.06050892277977482, 0.13294786964103478, 0.14137638721771162, 0.14293587811571473]}}
{"id": "170ea8e4-0510-480f-bd57-4fc6c66ec604", "fitness": 0.07347314947553368, "name": "EnhancedHybridDE_SA", "description": "Enhance convergence by increasing mutation diversity with a variable scale factor range.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.4, 1.2)  # Adjusted scale factor range\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07347 with standard deviation 0.05133.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.015520993901239288, 0.022406024370998034, 0.014990851788458492, 0.06004550008317211, 0.059485991225352586, 0.06445534717403234, 0.139782757423892, 0.14051430510125762, 0.1440565742114006]}}
{"id": "5d4b1677-abdc-47f0-8f06-8ebbffe491b1", "fitness": -Infinity, "name": "EnhancedHybridDE_LevySA", "description": "Enhance the exploration-exploitation balance by integrating a Lvy flight mechanism in mutation and introducing adaptive crossover rates based on diversity.", "code": "import numpy as np\n\nclass EnhancedHybridDE_LevySA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def levy_flight(self, size, beta=1.5):\n        sigma_u = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                   (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma_u, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v)**(1 / beta)\n        return step\n\n    def mutate(self, target_idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        levy_step = self.levy_flight(self.dim)\n        mutant = self.population[a] + self.mutation_rate * (self.population[b] - self.population[c]) + levy_step\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, diversity_factor):\n        crossover_prob = self.crossover_rate * (1 + diversity_factor)\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            diversity = np.std(self.population, axis=0)\n            diversity_factor = np.mean(diversity) / (self.ub - self.lb)\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant, diversity_factor)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 27, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {}}
{"id": "bb279dc3-4e64-4095-91b1-fe3a142d5136", "fitness": 0.08345442868429813, "name": "EnhancedHybridDE_SA", "description": "Enhanced cooling and dynamic parameter adaptation for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.6, 1.2)  # Modified scale factor range\n                crossover_prob = np.random.uniform(0.85, 1.0)  # Modified crossover probability range\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08345 with standard deviation 0.05125.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.11244925814057549, 0.015532082426283123, 0.01312991200162339, 0.05399199750115169, 0.05738458933269208, 0.06445534717403234, 0.15145127940446834, 0.14018789079090366, 0.142507501386953]}}
{"id": "6ad1b09d-2f62-4679-94c1-7c49c3044ffa", "fitness": 0.06907903206147122, "name": "EnhancedHybridDE_StochasticTunneling", "description": "Enhance convergence by introducing a multi-phase optimization strategy combining DE with stochastic tunneling and adaptive parameter tuning.", "code": "import numpy as np\n\nclass EnhancedHybridDE_StochasticTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(5, int(10 * self.dim))\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1.0\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def stochastic_tunneling(self, candidate, candidate_fitness):\n        g = np.exp(-candidate_fitness / self.temperature)\n        return g, candidate, candidate_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            g, tunneling_solution, tunneling_fitness = self.stochastic_tunneling(best_solution, best_fitness)\n            if g > np.random.rand():\n                best_solution, best_fitness = tunneling_solution, tunneling_fitness\n\n            self.temperature *= 0.9 + 0.1 * np.sin(np.pi * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedHybridDE_StochasticTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06908 with standard deviation 0.05424.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.011990921779448493, 0.01665878958348166, 0.01233315241309585, 0.045261828364884904, 0.0530322971629108, 0.05464901592801408, 0.1443273751489974, 0.1406537449058124, 0.1428041632665954]}}
{"id": "7bd87502-1407-4cbc-aa41-6909ff56fb3c", "fitness": 0.08384240591953535, "name": "EnhancedHybridDE_SA_Refined", "description": "Integrate a self-adaptive mutation strategy and incorporate a cooperative approach among population members to enhance explorative capabilities and convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        indices = list(range(self.pop_size))\n        indices.remove(target_idx)\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def cooperative_mutation(self, target_idx):\n        partner_idx = np.random.choice([i for i in range(self.pop_size) if i != target_idx])\n        partner = self.population[partner_idx]\n        scale_factor = np.random.uniform(0.5, 1.0)\n        return self.mutate(target_idx, scale_factor) * 0.5 + partner * 0.5\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                if np.random.rand() < 0.5:\n                    mutant = self.mutate(i, np.random.uniform(0.5, 1.0))\n                else:\n                    mutant = self.cooperative_mutation(i)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedHybridDE_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08384 with standard deviation 0.04685.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.024021546471524102, 0.03563674920064952, 0.031608706328707936, 0.07344362961431095, 0.08458243055802905, 0.07316320665350307, 0.1486410214689643, 0.14097686159317613, 0.142507501386953]}}
{"id": "b11ebf59-df03-4e5a-9a16-9cfefed62ef4", "fitness": 0.07555597237488106, "name": "EnhancedHybridDE_SA", "description": "Enhance dynamic scaling of mutation and crossover rates to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.6, 1.2)  # Changed from 0.5 to 0.6 and 1.0 to 1.2\n                crossover_prob = np.random.uniform(0.9, 1.2)  # Changed from 0.8 to 0.9 and 1.0 to 1.2\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07556 with standard deviation 0.05320.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.015131219965601517, 0.015532082426283123, 0.015373896197558912, 0.0698513428036247, 0.05715956495040464, 0.0746274106863114, 0.13722129486760404, 0.1525994380895882, 0.142507501386953]}}
{"id": "75920e9e-83f7-4edb-8067-58479d85960a", "fitness": 0.07763271303790503, "name": "EnhancedHybridDE_SA", "description": "Integrate adaptive differential evolution with variable mutation and crossover strategies, while combining simulated annealing with entropy-based cooling for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        scale_factor = np.random.uniform(0.5, 1.0)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        crossover_prob = np.random.uniform(0.6, 1.0)\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            acceptance_prob = np.exp(delta_fitness / self.temperature)\n            if delta_fitness > 0 or acceptance_prob > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def entropy_based_cooling(self, evaluations):\n        return 0.9 + 0.1 * np.tanh(0.01 * np.log1p(evaluations))\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= self.entropy_based_cooling(evaluations)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07763 with standard deviation 0.05344.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.012836470649042364, 0.015544513340687405, 0.013933554600604525, 0.07398983677520721, 0.07199089319224916, 0.07652595311525356, 0.13761722502094753, 0.1504339612059301, 0.14582200944122337]}}
{"id": "a296f6f9-77ac-4d76-92e3-2d4195084b39", "fitness": 0.07503447808002899, "name": "RefinedHybridDE_SA", "description": "Combine differential evolution with adaptive simulated annealing and introduce self-adaptive control parameters for more efficient exploration and exploitation.", "code": "import numpy as np\n\nclass RefinedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def self_adaptive_parameters(self):\n        self.mutation_rate = np.random.uniform(0.5, 1.0)\n        self.crossover_rate = np.random.uniform(0.8, 1.0)\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                self.self_adaptive_parameters()\n                mutant = self.mutate(i, self.mutation_rate)\n                trial = self.crossover(self.population[i], mutant, self.crossover_rate)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 33, "feedback": "The algorithm RefinedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07503 with standard deviation 0.05314.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.01263644963169952, 0.020543577347015618, 0.015423729238919104, 0.06892843601285292, 0.05903711103410647, 0.06445534717403234, 0.1443273751489912, 0.14628982797548862, 0.14366844915715504]}}
{"id": "0e789b94-76b9-480b-84a0-02610dba2797", "fitness": 0.08060146164094878, "name": "EnhancedHybridDE_SA_Improved", "description": "Implement a multi-phase mutation strategy and adaptive learning rate to enhance convergence precision and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, phase):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        if phase == 1:\n            scale_factor = np.random.uniform(0.5, 1.0)\n        else:\n            scale_factor = np.random.uniform(0.7, 1.2)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, phase):\n        if phase == 1:\n            crossover_prob = np.random.uniform(0.8, 0.9)\n        else:\n            crossover_prob = np.random.uniform(0.9, 1.0)\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            phase = 1 if evaluations < self.budget * 0.5 else 2\n\n            for i in range(self.pop_size):\n                mutant = self.mutate(i, phase)\n                trial = self.crossover(self.population[i], mutant, phase)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Non-linear temperature decay rate\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedHybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08060 with standard deviation 0.05440.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.019511740518602383, 0.015534172039137317, 0.014142972820248567, 0.0743420269288253, 0.07598916039540726, 0.07844863802225654, 0.14262233780789257, 0.15574606952041947, 0.14907603671574954]}}
{"id": "e45b89dd-ebab-4735-92f2-713c0107dc33", "fitness": -Infinity, "name": "EnhancedHybridDE_SA", "description": "Incorporate an adaptive mutation scale and enhanced annealing acceptance criteria for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n        self.mutation_rate = 0.8\n        self.crossover_rate = 0.9\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature * (1 - self.budget/1000), self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            acceptance_prob = np.exp(delta_fitness / (self.temperature * (1 + np.abs(delta_fitness))))\n            if delta_fitness > 0 or acceptance_prob > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.3, 0.9)\n                crossover_prob = np.random.uniform(0.8, 1.0)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 35, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {}}
{"id": "c1ce9b2e-f2cd-4d79-9ba5-3599e4799e1e", "fitness": 0.09692702343808854, "name": "EnhancedHybridDE_SA_v2", "description": "Introducing adaptive mutation and crossover rates based on convergence speed and adaptive cooling schedule in Simulated Annealing for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * self.dim\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if np.isinf(self.fitness[i]):\n                self.fitness[i] = func(self.population[i])\n\n    def mutate(self, target_idx, scale_factor):\n        candidates = list(range(self.pop_size))\n        candidates.remove(target_idx)\n        a, b, c = np.random.choice(candidates, 3, replace=False)\n        mutant = self.population[a] + scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant, crossover_prob):\n        cross_points = np.random.rand(self.dim) < crossover_prob\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, trial_fitness):\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adaptive_simulated_annealing(self, current_best, current_best_fitness):\n        for _ in range(5):\n            candidate = current_best + np.random.normal(0, 0.1 * self.temperature, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            candidate_fitness = self.func(candidate)\n            delta_fitness = current_best_fitness - candidate_fitness\n            if delta_fitness > 0 or np.exp(delta_fitness / self.temperature) > np.random.rand():\n                current_best, current_best_fitness = candidate, candidate_fitness\n        return current_best, current_best_fitness\n\n    def __call__(self, func):\n        self.func = func\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self.initialize_population(self.lb, self.ub)\n\n        evaluations = 0\n        best_solution = None\n        best_fitness = np.inf\n\n        self.temperature = 1.0\n        convergence_speed = 1.0\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            evaluations += self.pop_size\n\n            for i in range(self.pop_size):\n                scale_factor = np.random.uniform(0.5, 1.0) * convergence_speed\n                crossover_prob = np.random.uniform(0.8, 1.0) * (1 - convergence_speed)\n                mutant = self.mutate(i, scale_factor)\n                trial = self.crossover(self.population[i], mutant, crossover_prob)\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.select(i, trial, trial_fitness)\n\n            current_best_idx = np.argmin(self.fitness)\n            current_best, current_best_fitness = self.population[current_best_idx], self.fitness[current_best_idx]\n\n            if current_best_fitness < best_fitness:\n                best_solution, best_fitness = current_best, current_best_fitness\n                convergence_speed = 0.5\n            else:\n                convergence_speed = min(1.0, convergence_speed + 0.1)\n\n            best_solution, best_fitness = self.adaptive_simulated_annealing(best_solution, best_fitness)\n\n            self.temperature *= 0.92 + 0.08 * np.tanh(0.1 * evaluations / self.budget)  # Adaptive cooling schedule\n            self.pop_size = max(5, int(10 * self.dim * (1 - evaluations / self.budget)))  # Dynamic population size\n\n            if evaluations >= self.budget:\n                break\n\n        return best_solution, best_fitness", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedHybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09693 with standard deviation 0.06295.", "error": "", "parent_ids": ["5f57360d-6507-4b9d-9fab-d0f9cb370bf1"], "operator": null, "metadata": {"aucs": [0.2123955347421096, 0.020044046569425933, 0.01488636941278132, 0.05908798387502445, 0.06015719917907136, 0.07582692997246132, 0.1437230208849828, 0.1437146249199871, 0.142507501386953]}}
