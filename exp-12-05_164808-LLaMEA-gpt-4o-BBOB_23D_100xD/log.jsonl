{"id": "ae46f693-9630-4000-a0e8-3da729ce7f02", "fitness": 0.031119058021491126, "name": "HybridPSODE", "description": "Hybrid Particle Swarm and Differential Evolution algorithm that explores the search space dynamically by combining swarm intelligence and differential mutation strategies for effective optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.04294977087579577, 0.04294977087579577, 0.04294977087579577, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05436453789936935, 0.05436453789936935, 0.05436453789936935, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.101874169008214, 0.101874169008214, 0.101874169008214, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052017609329708336, 0.052017609329708336, 0.052017609329708336, 0.11453705693922722, 0.11453705693922722, 0.11453705693922722, 0.06008775752797069, 0.06008775752797069, 0.06008775752797069, 0.09699710590340616, 0.09699710590340616, 0.09699710590340616, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05848861645723036, 0.05848861645723036, 0.05848861645723036, 0.02526796080055227, 0.02526796080055227, 0.02526796080055227, 0.13418585125257354, 0.13418585125257354, 0.13418585125257354, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "33f5756b-cb5d-4da6-83dd-fcc2c2123a21", "fitness": 0.031119058021491126, "name": "HybridPSODE", "description": "Introduced adaptive parameters for PSO and DE to enhance search space exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.04294977087579577, 0.04294977087579577, 0.04294977087579577, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05436453789936935, 0.05436453789936935, 0.05436453789936935, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.101874169008214, 0.101874169008214, 0.101874169008214, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.052017609329708336, 0.052017609329708336, 0.052017609329708336, 0.11453705693922722, 0.11453705693922722, 0.11453705693922722, 0.06008775752797069, 0.06008775752797069, 0.06008775752797069, 0.09699710590340616, 0.09699710590340616, 0.09699710590340616, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05848861645723036, 0.05848861645723036, 0.05848861645723036, 0.02526796080055227, 0.02526796080055227, 0.02526796080055227, 0.13418585125257354, 0.13418585125257354, 0.13418585125257354, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "59ddc567-ff84-4e53-a3b3-dac5040b56f3", "fitness": 0.028566818014711188, "name": "HybridPSODE", "description": "HybridPSODE with adaptive inertia weight for better convergence by dynamically adjusting the exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            self.w = 0.9 - 0.8 * (eval_count / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.047875578321527446, 0.047875578321527446, 0.047875578321527446, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0369059130563425, 0.0369059130563425, 0.0369059130563425, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08163625999276003, 0.08163625999276003, 0.08163625999276003, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04855298899853888, 0.04855298899853888, 0.04855298899853888, 0.11232464706416168, 0.11232464706416168, 0.11232464706416168, 0.05068956591766205, 0.05068956591766205, 0.05068956591766205, 0.09307538182010733, 0.09307538182010733, 0.09307538182010733, 0.00916811783643745, 0.00916811783643745, 0.00916811783643745, 0.04160707902452687, 0.04160707902452687, 0.04160707902452687, 0.016406044600660863, 0.016406044600660863, 0.016406044600660863, 0.1417098818072997, 0.1417098818072997, 0.1417098818072997, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "3b89cc43-b319-43ac-9584-7572b95bc4f8", "fitness": 0.029541896486493507, "name": "HybridPSODE", "description": "Improved Hybrid PSO-DE with adaptive parameters and enhanced mutation strategy for robust optimization.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 2.0  # Increased cognitive parameter for PSO\n        self.c2 = 2.0  # Increased social parameter for PSO\n        self.w = 0.7   # Increased inertia weight for PSO\n        self.F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = (1 - self.F) * personal_best[i] + self.F * (personal_best[a] - personal_best[b] + personal_best[c]) \n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.0488497454361827, 0.046452862813404994, 0.03942015918606345, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04025282940848085, 0.039324495310400276, 0.01795741739019696, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0012337740482244453, 0.0025234985977223845, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.08445255005099661, 0.08474947132757382, 0.09556046002898333, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048266320387806205, 0.052821560402941725, 0.05390428908040357, 0.10357324006739732, 0.11276562436952597, 0.11031641797904423, 0.055671511871496326, 0.05232959190139119, 0.060985932698840783, 0.09545624403324382, 0.09670280911094209, 0.09824963367193285, 0.00043478260869567187, 0.0017476044892812403, 0.014368220567236634, 0.0503355374042993, 0.05011236484091752, 0.04896730625320744, 0.024413797152808003, 0.019783615914471975, 0.01900477830553604, 0.14154399693303776, 0.1489005532935832, 0.14949659356952183, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "0e58a8e4-176a-4108-bba1-38c2a3d6d89b", "fitness": 0.03531398617545086, "name": "HybridPSODE", "description": "A modified Hybrid Particle Swarm and Differential Evolution algorithm where the inertia weight is dynamically adjusted using a decaying factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget)  # Dynamic inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                mutant_vector = personal_best[a] + self.F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_ids": ["ae46f693-9630-4000-a0e8-3da729ce7f02"], "operator": null, "metadata": {"aucs": [0.0658382452338967, 0.0658382452338967, 0.0658382452338967, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04224227105723355, 0.04224227105723355, 0.04224227105723355, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.004163182410576782, 0.004163182410576782, 0.004163182410576782, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10917190813199495, 0.10917190813199495, 0.10917190813199495, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.048220078296240976, 0.048220078296240976, 0.048220078296240976, 0.10884356978110132, 0.10884356978110132, 0.10884356978110132, 0.05660386472071699, 0.05660386472071699, 0.05660386472071699, 0.10266081000034122, 0.10266081000034122, 0.10266081000034122, 0.06820881792833422, 0.06820881792833422, 0.06820881792833422, 0.06735005864923238, 0.06735005864923238, 0.06735005864923238, 0.02518410047239006, 0.02518410047239006, 0.02518410047239006, 0.1438313702244135, 0.1438313702244135, 0.1438313702244135, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "2d913048-7cd2-460c-9a50-a615bbca6535", "fitness": 0.037959650017031214, "name": "HybridPSODE", "description": "Enhanced Hybrid Particle Swarm and Differential Evolution with adaptive mutation factor to improve local search.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget)  # Dynamic inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["0e58a8e4-176a-4108-bba1-38c2a3d6d89b"], "operator": null, "metadata": {"aucs": [0.09233811399637704, 0.09233811399637704, 0.09233811399637704, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05846665878500967, 0.05846665878500967, 0.05846665878500967, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.02216812842629523, 0.02216812842629523, 0.02216812842629523, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.1269624248585779, 0.1269624248585779, 0.1269624248585779, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05131473635739714, 0.05131473635739714, 0.05131473635739714, 0.12218781284167379, 0.12218781284167379, 0.12218781284167379, 0.06053834867169683, 0.06053834867169683, 0.06053834867169683, 0.10351487015096861, 0.10351487015096861, 0.10351487015096861, 0.052235121754443004, 0.052235121754443004, 0.052235121754443004, 0.06330907136880781, 0.06330907136880781, 0.06330907136880781, 0.01839534147487032, 0.01839534147487032, 0.01839534147487032, 0.1343835804182838, 0.1343835804182838, 0.1343835804182838, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "141df425-29cc-4632-97e1-563c44a23375", "fitness": 0.06104646010450819, "name": "HybridPSODE", "description": "Enhanced Hybrid Particle Swarm and Differential Evolution with adaptive inertia weight and crossover rate to improve exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = self.CR - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.13.", "error": "", "parent_ids": ["2d913048-7cd2-460c-9a50-a615bbca6535"], "operator": null, "metadata": {"aucs": [0.06824246345767537, 0.06824246345767537, 0.06824246345767537, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6591801220489166, 0.6591801220489166, 0.6591801220489166, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.000796698831783349, 0.000796698831783349, 0.000796698831783349, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09359564898496109, 0.09359564898496109, 0.09359564898496109, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05360947628310242, 0.05360947628310242, 0.05360947628310242, 0.12199308764423555, 0.12199308764423555, 0.12199308764423555, 0.06573504545609743, 0.06573504545609743, 0.06573504545609743, 0.10059565159180928, 0.10059565159180928, 0.10059565159180928, 0.0349785369335982, 0.0349785369335982, 0.0349785369335982, 0.10661419341589073, 0.10661419341589073, 0.10661419341589073, 0.021020923021979443, 0.021020923021979443, 0.021020923021979443, 0.13353580353379912, 0.13353580353379912, 0.13353580353379912, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "57ffa1b2-c510-4b22-8104-af3288b6f63b", "fitness": 0.036077436931164594, "name": "HybridPSODE", "description": "Enhanced Hybrid PSO-DE with self-adaptive selection of parameters and dynamic population resizing to improve convergence efficiency.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.3 + 0.4 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.2 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = self.CR - 0.3 * (eval_count / self.budget)  # Adaptive crossover rate\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_ids": ["141df425-29cc-4632-97e1-563c44a23375"], "operator": null, "metadata": {"aucs": [0.07761744377659796, 0.07761744377659796, 0.07761744377659796, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.051171118202798405, 0.051171118202798405, 0.051171118202798405, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.009069437344225606, 0.009069437344225606, 0.009069437344225606, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09758199565456815, 0.09758199565456815, 0.09758199565456815, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.04842257828104857, 0.04842257828104857, 0.04842257828104857, 0.12870794785364648, 0.12870794785364648, 0.12870794785364648, 0.06403078050906374, 0.06403078050906374, 0.06403078050906374, 0.10109725611477305, 0.10109725611477305, 0.10109725611477305, 0.011052191552314627, 0.011052191552314627, 0.011052191552314627, 0.10699423803706931, 0.10699423803706931, 0.10699423803706931, 0.0242772888806686, 0.0242772888806686, 0.0242772888806686, 0.1406188188368277, 0.1406188188368277, 0.1406188188368277, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "b4088a78-8433-4b7c-a755-02a030910d6d", "fitness": 0.06170819870053955, "name": "HybridPSODE", "description": "HybridPSODE with adaptive self-adjusting crossover rate for enhanced convergence.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = self.CR - 0.35 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.13.", "error": "", "parent_ids": ["141df425-29cc-4632-97e1-563c44a23375"], "operator": null, "metadata": {"aucs": [0.07136041873855548, 0.07136041873855548, 0.07136041873855548, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.6717165523258646, 0.6717165523258646, 0.6717165523258646, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.0036235831122093387, 0.0036235831122093387, 0.0036235831122093387, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.10245061956362222, 0.10245061956362222, 0.10245061956362222, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.050522710009886396, 0.050522710009886396, 0.050522710009886396, 0.1223460571955175, 0.1223460571955175, 0.1223460571955175, 0.058340574578247706, 0.058340574578247706, 0.058340574578247706, 0.09937606056584314, 0.09937606056584314, 0.09937606056584314, 0.04579456946281368, 0.04579456946281368, 0.04579456946281368, 0.09241793416596922, 0.09241793416596922, 0.09241793416596922, 0.0221105112824167, 0.0221105112824167, 0.0221105112824167, 0.13571978650765515, 0.13571978650765515, 0.13571978650765515, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "4de72ea6-94f5-4842-b59e-89fe6d65c74e", "fitness": 0.06293270826823462, "name": "HybridPSODE", "description": "HybridPSODE with improved adaptive mutation and crossover strategies for better exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = (self.w * velocities[i] +\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.15.", "error": "", "parent_ids": ["b4088a78-8433-4b7c-a755-02a030910d6d"], "operator": null, "metadata": {"aucs": [0.06418892356451367, 0.06418892356451367, 0.06418892356451367, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.7504852744471278, 0.7504852744471278, 0.7504852744471278, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003613788926093542, 0.003613788926093542, 0.003613788926093542, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.09338579546619197, 0.09338579546619197, 0.09338579546619197, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05114420816974652, 0.05114420816974652, 0.05114420816974652, 0.12713651074936283, 0.12713651074936283, 0.12713651074936283, 0.05741906241517147, 0.05741906241517147, 0.05741906241517147, 0.10086119397702709, 0.10086119397702709, 0.10086119397702709, 0.0016084365664312816, 0.0016084365664312816, 0.0016084365664312816, 0.08979387336609446, 0.08979387336609446, 0.08979387336609446, 0.017845997038102746, 0.017845997038102746, 0.017845997038102746, 0.14768454244741946, 0.14768454244741946, 0.14768454244741946, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
{"id": "106c2f72-5d86-4b87-a984-573fdeeb7106", "fitness": 0.030787623084661986, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with dynamic particle velocity adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n        self.w = 0.5   # Inertia weight for PSO\n        self.F = 0.8   # Differential mutation factor for DE\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize particles and their velocities\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = particles.copy()\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        \n        eval_count = self.population_size\n        while eval_count < self.budget:\n            # PSO Update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.w = 0.5 * (1 - eval_count / self.budget) + 0.3 * np.random.rand()  # Adaptive inertia weight adjustment\n                velocities[i] = ((self.w + 0.2 * np.random.rand()) * velocities[i] +  # Dynamic velocity adjustment\n                                 self.c1 * r1 * (personal_best[i] - particles[i]) +\n                                 self.c2 * r2 * (global_best - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n                \n                fitness = func(particles[i])\n                eval_count += 1\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = particles[i], fitness\n                    if fitness < func(global_best):\n                        global_best = particles[i]\n            \n            if eval_count >= self.budget:\n                break\n\n            # DE Update (only if budget allows further evaluations)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                adaptive_F = 0.6 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = personal_best[a] + adaptive_F * (personal_best[b] - personal_best[c])\n                adaptive_CR = 0.95 - 0.4 * (eval_count / self.budget)  # Adaptive crossover rate adjustment\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_CR else particles[i, j]\n                                         for j in range(self.dim)])\n                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best[i], personal_best_fitness[i] = trial_vector, trial_fitness\n                    if trial_fitness < func(global_best):\n                        global_best = trial_vector\n\n        return global_best", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["4de72ea6-94f5-4842-b59e-89fe6d65c74e"], "operator": null, "metadata": {"aucs": [0.06013812310974198, 0.06013812310974198, 0.06013812310974198, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.03973733743419361, 0.03973733743419361, 0.03973733743419361, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.003641815300666984, 0.003641815300666984, 0.003641815300666984, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.07781886433494456, 0.07781886433494456, 0.07781886433494456, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.05584640083977066, 0.05584640083977066, 0.05584640083977066, 0.1136369335398435, 0.1136369335398435, 0.1136369335398435, 0.05909623636537931, 0.05909623636537931, 0.05909623636537931, 0.09633736626226097, 0.09633736626226097, 0.09633736626226097, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187, 0.06417830013519266, 0.06417830013519266, 0.06417830013519266, 0.02228027461686921, 0.02228027461686921, 0.02228027461686921, 0.1405391281799806, 0.1405391281799806, 0.1405391281799806, 0.00043478260869567187, 0.00043478260869567187, 0.00043478260869567187]}}
