{"id": "0ea2e0c7-8fd1-4438-b49b-e0d9106c6e7e", "fitness": 0.39184819334261706, "name": "AMPSO", "description": "Adaptive Memory-based Particle Swarm Optimization (AMPSO) that dynamically adjusts particles' memory and utilizes a global adaptive learning strategy.", "code": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim, population_size=30, w=0.5, c1=2.0, c2=2.0):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w = w  # inertia weight\n        self.c1 = c1  # cognitive (personal) coefficient\n        self.c2 = c2  # social (global) coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 0, "feedback": "The algorithm AMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39185 with standard deviation 0.40103.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.06055746336165002, 0.9561407462758804, 0.1588463703903209]}}
{"id": "95a1edb2-052a-4deb-a928-a16e5240f49d", "fitness": 0.10457155737122892, "name": "AMPSO", "description": "Enhanced Adaptive Memory-based Particle Swarm Optimization (AMPSO) with dynamic inertia weight adjustment for improved convergence.", "code": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim, population_size=30, w=0.9, c1=2.0, c2=2.0):  # Adjusted initial inertia weight\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w = w  # inertia weight\n        self.c1 = c1  # cognitive (personal) coefficient\n        self.c2 = c2  # social (global) coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 1, "feedback": "The algorithm AMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10457 with standard deviation 0.02041.", "error": "", "parent_ids": ["0ea2e0c7-8fd1-4438-b49b-e0d9106c6e7e"], "operator": null, "metadata": {"aucs": [0.10263083740378409, 0.08059637766871552, 0.13048745704118714]}}
{"id": "de6d1a3b-99d5-4f28-b675-b0c1b490e232", "fitness": 0.09126075893004877, "name": "AMPSO", "description": "Enhanced AMPSO by incorporating adaptive inertia weight for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AMPSO:\n    def __init__(self, budget, dim, population_size=30, w=0.5, c1=2.0, c2=2.0):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w = w  # inertia weight\n        self.c1 = c1  # cognitive (personal) coefficient\n        self.c2 = c2  # social (global) coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adaptive inertia weight\n                velocities[i] = self.w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 2, "feedback": "The algorithm AMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09126 with standard deviation 0.00947.", "error": "", "parent_ids": ["0ea2e0c7-8fd1-4438-b49b-e0d9106c6e7e"], "operator": null, "metadata": {"aucs": [0.10304039584724378, 0.0798440501446761, 0.09089783079822644]}}
{"id": "7a84ee7c-e39b-45ad-ae03-4291a3213c04", "fitness": 0.14830867657417332, "name": "EMPSO", "description": "Enhanced Memory-based Particle Swarm Optimization (EMPSO) with adaptive inertia and velocity clamping for improved convergence stability.", "code": "import numpy as np\n\nclass EMPSO:\n    def __init__(self, budget, dim, population_size=30, w_min=0.2, w_max=0.9, c1=2.0, c2=2.0):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w_min = w_min  # minimum inertia weight\n        self.w_max = w_max  # maximum inertia weight\n        self.c1 = c1  # cognitive (personal) coefficient\n        self.c2 = c2  # social (global) coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Calculate inertia weight\n            w = self.w_max - (self.w_max - self.w_min) * (evaluations / self.budget)\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = w * velocities[i] + cognitive_component + social_component\n\n                # Velocity clamping\n                velocities[i] = np.clip(velocities[i], lower_bounds - upper_bounds, upper_bounds - lower_bounds)\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 3, "feedback": "The algorithm EMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14831 with standard deviation 0.05455.", "error": "", "parent_ids": ["0ea2e0c7-8fd1-4438-b49b-e0d9106c6e7e"], "operator": null, "metadata": {"aucs": [0.22430526932562522, 0.09883499454657452, 0.1217857658503202]}}
{"id": "e7793459-f4ca-490b-aae1-feae6c14036b", "fitness": 0.36935267454050424, "name": "EAMPSO", "description": "Enhanced Adaptive Memory-based Particle Swarm Optimization (EAMPSO) that integrates a dynamic inertia weight adjustment and a local search phase for improved convergence.", "code": "import numpy as np\n\nclass EAMPSO:\n    def __init__(self, budget, dim, population_size=30, w=0.9, c1=2.0, c2=2.0, inertia_decay=0.99, local_search_radius=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w = w  # initial inertia weight\n        self.c1 = c1  # cognitive (personal) coefficient\n        self.c2 = c2  # social (global) coefficient\n        self.inertia_decay = inertia_decay  # decay factor for inertia weight\n        self.local_search_radius = local_search_radius  # radius for local search\n        self.global_best_position = None\n        self.global_best_value = np.inf\n\n    def local_search(self, position, func, lower_bounds, upper_bounds):\n        # Perform a simple random local search around a position\n        perturbation = np.random.uniform(-self.local_search_radius, self.local_search_radius, self.dim)\n        candidate_position = np.clip(position + perturbation, lower_bounds, upper_bounds)\n        candidate_value = func(candidate_position)\n        return candidate_position, candidate_value\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n                    \n                    # Local search around the new global best\n                    candidate_position, candidate_value = self.local_search(self.global_best_position, func, lower_bounds, upper_bounds)\n                    evaluations += 1\n                    if candidate_value < self.global_best_value:\n                        self.global_best_value = candidate_value\n                        self.global_best_position = candidate_position.copy()\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = self.w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n            # Decay inertia weight\n            self.w *= self.inertia_decay\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 4, "feedback": "The algorithm EAMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36935 with standard deviation 0.39110.", "error": "", "parent_ids": ["0ea2e0c7-8fd1-4438-b49b-e0d9106c6e7e"], "operator": null, "metadata": {"aucs": [0.922249125431142, 0.08000903410852311, 0.1057998640818476]}}
{"id": "e10cbc9f-e9e5-4c6e-b916-ea8c709e39dc", "fitness": 0.41482421957469523, "name": "E_AMPSO", "description": "Enhanced Adaptive Memory-based Particle Swarm Optimization (E-AMPSO) introducing dynamic inertia and diversity preservation for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass E_AMPSO:\n    def __init__(self, budget, dim, population_size=30, w_max=0.9, w_min=0.4, c1=2.0, c2=2.0, epsilon=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w_max = w_max  # maximum inertia weight\n        self.w_min = w_min  # minimum inertia weight\n        self.c1 = c1  # cognitive (personal) coefficient\n        self.c2 = c2  # social (global) coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.epsilon = epsilon  # diversity threshold\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Calculate inertia weight dynamically\n            w = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n            # Maintain diversity by reinitializing stagnant particles\n            if np.std(personal_best_values) < self.epsilon:\n                stagnant_indices = np.where(personal_best_values > np.percentile(personal_best_values, 75))[0]\n                for idx in stagnant_indices:\n                    particles[idx] = np.random.uniform(lower_bounds, upper_bounds, self.dim)\n                    personal_best_positions[idx] = particles[idx].copy()\n                    personal_best_values[idx] = np.inf\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 5, "feedback": "The algorithm E_AMPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41482 with standard deviation 0.37763.", "error": "", "parent_ids": ["0ea2e0c7-8fd1-4438-b49b-e0d9106c6e7e"], "operator": null, "metadata": {"aucs": [0.12327699519616997, 0.9480979381955228, 0.17309772533239287]}}
{"id": "9a5e3633-889f-4f4f-857a-011529243f3f", "fitness": 0.6103696691728594, "name": "AMPSO_NIAM", "description": "Adaptive Memory-based Particle Swarm Optimization with Nonlinear Inertia and Adaptive Mutation (AMPSO-NIAM) to enhance convergence speed and maintain diversity.", "code": "import numpy as np\n\nclass AMPSO_NIAM:\n    def __init__(self, budget, dim, population_size=30, w_max=0.9, w_min=0.4, c1=2.05, c2=2.05, epsilon=0.1, mutation_chance=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w_max = w_max  # maximum inertia weight\n        self.w_min = w_min  # minimum inertia weight\n        self.c1 = c1  # cognitive coefficient\n        self.c2 = c2  # social coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.epsilon = epsilon  # diversity threshold\n        self.mutation_chance = mutation_chance  # chance of mutation\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Calculate inertia weight using nonlinear function\n            w = self.w_min + (self.w_max - self.w_min) * (1 - (evaluations / self.budget)**2)\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n                # Apply mutation to maintain diversity\n                if np.random.rand() < self.mutation_chance:\n                    mutation_vector = np.random.normal(0, 1, self.dim) * (upper_bounds - lower_bounds) * 0.1\n                    particles[i] = np.clip(particles[i] + mutation_vector, lower_bounds, upper_bounds)\n\n            # Maintain diversity by reinitializing stagnant particles\n            if np.std(personal_best_values) < self.epsilon:\n                stagnant_indices = np.where(personal_best_values > np.percentile(personal_best_values, 75))[0]\n                for idx in stagnant_indices:\n                    particles[idx] = np.random.uniform(lower_bounds, upper_bounds, self.dim)\n                    personal_best_positions[idx] = particles[idx].copy()\n                    personal_best_values[idx] = np.inf\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 6, "feedback": "The algorithm AMPSO_NIAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61037 with standard deviation 0.35572.", "error": "", "parent_ids": ["e10cbc9f-e9e5-4c6e-b916-ea8c709e39dc"], "operator": null, "metadata": {"aucs": [0.13523095279062813, 0.991075241683172, 0.7048028130447781]}}
{"id": "2f4e00a0-51a9-409e-b0f8-5b2302b5360d", "fitness": 0.4365123804899776, "name": "AMPSO_NIAM", "description": "Improved Adaptive Memory-based Particle Swarm Optimization with Enhanced Mutation Strategy to Boost Performance.", "code": "import numpy as np\n\nclass AMPSO_NIAM:\n    def __init__(self, budget, dim, population_size=30, w_max=0.9, w_min=0.4, c1=2.05, c2=2.05, epsilon=0.1, mutation_chance=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w_max = w_max  # maximum inertia weight\n        self.w_min = w_min  # minimum inertia weight\n        self.c1 = c1  # cognitive coefficient\n        self.c2 = c2  # social coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.epsilon = epsilon  # diversity threshold\n        self.mutation_chance = mutation_chance  # chance of mutation\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Calculate inertia weight using nonlinear function\n            w = self.w_min + (self.w_max - self.w_min) * (1 - (evaluations / self.budget)**2)\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n                # Apply mutation to maintain diversity\n                if np.random.rand() < self.mutation_chance:\n                    mutation_vector = np.random.normal(0, 0.5, self.dim) * (upper_bounds - lower_bounds) * 0.1  # Increased mutation effect\n                    particles[i] = np.clip(particles[i] + mutation_vector, lower_bounds, upper_bounds)\n\n            # Maintain diversity by reinitializing stagnant particles\n            if np.std(personal_best_values) < self.epsilon:\n                stagnant_indices = np.where(personal_best_values > np.percentile(personal_best_values, 75))[0]\n                for idx in stagnant_indices:\n                    particles[idx] = np.random.uniform(lower_bounds, upper_bounds, self.dim)\n                    personal_best_positions[idx] = particles[idx].copy()\n                    personal_best_values[idx] = np.inf\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 7, "feedback": "The algorithm AMPSO_NIAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43651 with standard deviation 0.39285.", "error": "", "parent_ids": ["9a5e3633-889f-4f4f-857a-011529243f3f"], "operator": null, "metadata": {"aucs": [0.1301767665682092, 0.9910749820892742, 0.18828539281244916]}}
{"id": "97108c8f-9d1a-4844-bd2d-d87b63116782", "fitness": 0.4477260830283345, "name": "AMPSO_NIAM", "description": "Improved AMPSO-NIAM using adaptive mutation intensity based on particle diversity to enhance exploration.", "code": "import numpy as np\n\nclass AMPSO_NIAM:\n    def __init__(self, budget, dim, population_size=30, w_max=0.9, w_min=0.4, c1=2.05, c2=2.05, epsilon=0.1, mutation_chance=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w_max = w_max  # maximum inertia weight\n        self.w_min = w_min  # minimum inertia weight\n        self.c1 = c1  # cognitive coefficient\n        self.c2 = c2  # social coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.epsilon = epsilon  # diversity threshold\n        self.mutation_chance = mutation_chance  # chance of mutation\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particles[i])\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particles[i].copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particles[i].copy()\n\n            # Calculate inertia weight using nonlinear function\n            w = self.w_min + (self.w_max - self.w_min) * (1 - (evaluations / self.budget)**2)\n\n            # Update particles' velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - particles[i])\n                velocities[i] = w * velocities[i] + cognitive_component + social_component\n\n                # Update particle position\n                particles[i] += velocities[i]\n\n                # Ensure particles are within bounds\n                particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n                # Apply mutation to maintain diversity\n                if np.random.rand() < self.mutation_chance:\n                    mutation_intensity = np.std(personal_best_values)  # New line\n                    mutation_vector = np.random.normal(0, mutation_intensity, self.dim) * (upper_bounds - lower_bounds) * 0.1\n                    particles[i] = np.clip(particles[i] + mutation_vector, lower_bounds, upper_bounds)\n\n            # Maintain diversity by reinitializing stagnant particles\n            if np.std(personal_best_values) < self.epsilon:\n                stagnant_indices = np.where(personal_best_values > np.percentile(personal_best_values, 75))[0]\n                for idx in stagnant_indices:\n                    particles[idx] = np.random.uniform(lower_bounds, upper_bounds, self.dim)\n                    personal_best_positions[idx] = particles[idx].copy()\n                    personal_best_values[idx] = np.inf\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 8, "feedback": "The algorithm AMPSO_NIAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44773 with standard deviation 0.38421.", "error": "", "parent_ids": ["9a5e3633-889f-4f4f-857a-011529243f3f"], "operator": null, "metadata": {"aucs": [0.1738743599860103, 0.9910743999914066, 0.17822948910758662]}}
{"id": "29254c72-69c5-47c1-9fcd-10dd6022b063", "fitness": 0.38266502599393065, "name": "EAMPSO_DGAM", "description": "Enhanced Adaptive Memory-based Particle Swarm Optimization with Dynamic Grouping and Adaptive Mutation (EAMPSO-DGAM) to improve convergence and solution quality by adaptive subgrouping and mutation.", "code": "import numpy as np\n\nclass EAMPSO_DGAM:\n    def __init__(self, budget, dim, population_size=30, w_max=0.9, w_min=0.4, c1=2.05, c2=2.05, epsilon=0.1, mutation_chance=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.w_max = w_max  # maximum inertia weight\n        self.w_min = w_min  # minimum inertia weight\n        self.c1 = c1  # cognitive coefficient\n        self.c2 = c2  # social coefficient\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.epsilon = epsilon  # diversity threshold\n        self.mutation_chance = mutation_chance  # chance of mutation\n\n    def __call__(self, func):\n        lower_bounds = np.array(func.bounds.lb)\n        upper_bounds = np.array(func.bounds.ub)\n\n        # Initialize particles\n        particles = np.random.uniform(lower_bounds, upper_bounds, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, np.inf)\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Dynamic grouping based on current performance\n            group_size = max(1, self.population_size // (1 + evaluations // (self.budget // 10)))\n            groups = [particles[i:i + group_size] for i in range(0, self.population_size, group_size)]\n\n            for i, particle in enumerate(particles):\n                if evaluations >= self.budget:\n                    break\n\n                # Evaluate current position\n                value = func(particle)\n                evaluations += 1\n\n                # Update personal best\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = particle.copy()\n\n                # Update global best\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = particle.copy()\n\n            # Calculate inertia weight using nonlinear function\n            w = self.w_min + (self.w_max - self.w_min) * (1 - (evaluations / self.budget)**2)\n\n            # Update particles' velocities and positions with group influence\n            for group in groups:\n                group_best_position = group[np.argmin([func(p) for p in group])]\n                for particle in group:\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    cognitive_component = self.c1 * r1 * (personal_best_positions[i] - particle)\n                    social_component = self.c2 * r2 * (group_best_position - particle)\n                    velocities[i] = w * velocities[i] + cognitive_component + social_component\n\n                    # Update particle position\n                    particles[i] += velocities[i]\n\n                    # Ensure particles are within bounds\n                    particles[i] = np.clip(particles[i], lower_bounds, upper_bounds)\n\n                    # Apply adaptive mutation to maintain diversity\n                    if np.random.rand() < self.mutation_chance:\n                        mutation_vector = np.random.normal(0, 1, self.dim) * (upper_bounds - lower_bounds) * (0.1 + 0.9 * (evaluations / self.budget))\n                        particles[i] = np.clip(particles[i] + mutation_vector, lower_bounds, upper_bounds)\n\n            # Maintain diversity by reinitializing stagnant particles based on group performance\n            if np.std(personal_best_values) < self.epsilon:\n                stagnant_indices = np.where(personal_best_values > np.percentile(personal_best_values, 75))[0]\n                for idx in stagnant_indices:\n                    particles[idx] = np.random.uniform(lower_bounds, upper_bounds, self.dim)\n                    personal_best_positions[idx] = particles[idx].copy()\n                    personal_best_values[idx] = np.inf\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 9, "feedback": "The algorithm EAMPSO_DGAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38267 with standard deviation 0.42576.", "error": "", "parent_ids": ["9a5e3633-889f-4f4f-857a-011529243f3f"], "operator": null, "metadata": {"aucs": [0.08986769219012969, 0.9846987268991614, 0.07342865889250083]}}
