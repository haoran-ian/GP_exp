{"id": "c0e5f95a-8594-4793-bd60-325b599e86c1", "fitness": 0.4138441897248371, "name": "AdaptiveSwarmOptimization", "description": "Inspired by an adaptive swarm intelligence model, this algorithm balances exploration and exploitation by dynamically adjusting particles' learning strategies based on performance feedback.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Adaptive inertia weight adjustment\n                self.inertia_weight = max(0.4, self.inertia_weight * (1 - eval_count / self.budget))\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41384 with standard deviation 0.38291.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.9475728211343721, 0.22624932702683775, 0.0677104210133016]}}
{"id": "1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070", "fitness": 0.41388012059781615, "name": "AdaptiveSwarmOptimization", "description": "Improved by introducing a dynamic cognitive coefficient to further balance exploration and exploitation based on iteration progress.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * (1 - eval_count / self.budget) + 1.0 * (eval_count / self.budget)  # Adjusted cognitive coefficient\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Adaptive inertia weight adjustment\n                self.inertia_weight = max(0.4, self.inertia_weight * (1 - eval_count / self.budget))\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41388 with standard deviation 0.38289.", "error": "", "parent_ids": ["c0e5f95a-8594-4793-bd60-325b599e86c1"], "operator": null, "metadata": {"aucs": [0.9475728211343721, 0.2262958150948834, 0.06777172556419264]}}
{"id": "e6973905-7797-43dc-8841-6a9f4af6a9cc", "fitness": 0.3629110574907233, "name": "AdaptiveSwarmOptimizationImproved", "description": "Adaptive Swarm Optimization with nonlinear inertia and cognitive coefficient decay for balanced exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimizationImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear cognitive coefficient decay\n                cognitive_coeff = 2.5 * (1 - (eval_count / self.budget)**2) + 0.5 * ((eval_count / self.budget)**2)\n                cognitive_velocity = cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = 1.5 * r2 * (self.gbest_position - self.positions[i])\n                \n                # Nonlinear inertia weight adjustment\n                inertia_weight = 0.9 - (0.5 * ((eval_count / self.budget)**2))\n                \n                self.velocities[i] = (inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveSwarmOptimizationImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36291 with standard deviation 0.29548.", "error": "", "parent_ids": ["1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070"], "operator": null, "metadata": {"aucs": [0.10096051936318695, 0.7758429004400724, 0.21192975266891045]}}
{"id": "b1d52ece-78fa-4e03-a7ae-03a11113466b", "fitness": 0.37864976899141506, "name": "EnhancedSwarmOptimization", "description": "Enhanced exploration and exploitation by introducing a mutation mechanism to diversify search and improve convergence.  ", "code": "import numpy as np\n\nclass EnhancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_rate = 0.1\n        self.mutation_strength = 0.1\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * (1 - eval_count / self.budget) + 1.0 * (eval_count / self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.inertia_weight = max(0.4, self.inertia_weight * (1 - eval_count / self.budget))\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n\n                if np.random.random() < self.mutation_rate:\n                    mutation = np.random.normal(0, self.mutation_strength, self.dim)\n                    self.velocities[i] += mutation\n\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37865 with standard deviation 0.38419.", "error": "", "parent_ids": ["1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070"], "operator": null, "metadata": {"aucs": [0.14602310619069092, 0.9201910926620606, 0.06973510812149364]}}
{"id": "ab526fbc-2279-440d-a0dc-faa6dd0f2285", "fitness": 0.6666283469964501, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced AdaptiveSwarmOptimization by integrating a nonlinear dynamic cognitive coefficient and inertia weight adjustment based on exponential decay for better convergence control.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Exponential decay for inertia weight\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66663 with standard deviation 0.36426.", "error": "", "parent_ids": ["1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070"], "operator": null, "metadata": {"aucs": [0.15153547990888627, 0.9304027757515596, 0.9179467853289047]}}
{"id": "61844cfa-301c-4a3d-80fd-d32b83bf42b5", "fitness": 0.3293950723974965, "name": "ImprovedDynamicSwarmOptimization", "description": "Improved Dynamic Swarm Optimization by integrating adaptive inertia, cognitive, and social coefficients based on diversity and evaluation progress for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedDynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.initial_cognitive_coeff = 2.0\n        self.final_cognitive_coeff = 0.5\n        self.initial_social_coeff = 0.5\n        self.final_social_coeff = 2.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n\n                # Adaptive inertia weight based on diversity\n                diversity = np.std(self.positions, axis=0).mean()\n                inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - eval_count/self.budget)\n                \n                # Adaptive cognitive coefficient\n                cognitive_coeff = self.final_cognitive_coeff + (self.initial_cognitive_coeff - self.final_cognitive_coeff) * diversity / (diversity + 1e-9)\n                \n                # Adaptive social coefficient\n                social_coeff = self.final_social_coeff + (self.initial_social_coeff - self.final_social_coeff) * (1 - diversity / (diversity + 1e-9))\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.velocities[i] = (inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 5, "feedback": "The algorithm ImprovedDynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32940 with standard deviation 0.34142.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.1011575914045666, 0.8120060818258101, 0.0750215439621128]}}
{"id": "12582f59-096c-4eb2-84ad-e6213bab4cf2", "fitness": 0.48745426339753495, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced AdaptiveSwarmOptimization by dynamically adjusting the social coefficient based on the remaining budget to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                \n                # Dynamically adjust the social coefficient\n                self.social_coeff = 1.5 * (eval_count / self.budget)\n                \n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48745 with standard deviation 0.23365.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.5195179302706224, 0.7562331612521657, 0.18661169866981675]}}
{"id": "ce6d4be4-0c64-45b5-826d-285876cf28eb", "fitness": 0.10551048779624927, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Refined Enhanced AdaptiveSwarmOptimization by adjusting social coefficient dynamically using a sinusoidal function for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n\n                # Sinusoidal adjustment for social coefficient\n                self.social_coeff = 1.5 + 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Exponential decay for inertia weight\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10551 with standard deviation 0.03347.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.15253120774624984, 0.07728779442873224, 0.08671246121376575]}}
{"id": "53ea9962-f58b-442f-b736-14e420872d64", "fitness": 0.05583596223459575, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced Adaptive Swarm Optimization by incorporating a self-adjusting hybrid velocity component based on local convergence rate for improved adaptability in diverse search spaces.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.hybrid_coeff = 0.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            local_convergence_rate = np.zeros(self.population_size)\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    local_convergence_rate[i] = abs(self.pbest_scores[i] - score)\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                hybrid_velocity = self.hybrid_coeff * r3 * local_convergence_rate[i] * (bounds.ub - bounds.lb)\n\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity + hybrid_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05584 with standard deviation 0.00971.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.06954742936991631, 0.048263733140010645, 0.04969672419386029]}}
{"id": "c2ff0935-d2f2-4287-9a11-36ec37ac4785", "fitness": 0.15441492248721697, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Modified EnhancedAdaptiveSwarmOptimization by introducing nonlinear dynamic social coefficient and diversity-based inertia adjustment to improve convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                # Nonlinear dynamic social coefficient\n                self.social_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Diversity-based inertia adjustment\n                position_diversity = np.std(self.positions, axis=0).mean()\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget) * (1 + position_diversity)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15441 with standard deviation 0.01223.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.15196425271258152, 0.14080955114161786, 0.1704709636074515]}}
