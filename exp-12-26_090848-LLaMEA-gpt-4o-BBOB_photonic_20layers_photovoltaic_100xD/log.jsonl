{"id": "d9b03ea1-e26f-48f3-aa80-7b0259ecaf37", "fitness": 0.07851926654644717, "name": "HybridDE_CMA", "description": "The algorithm combines differential evolution and covariance matrix adaptation to maintain diversity and adapt search trajectories towards optimal solutions efficiently.", "code": "import numpy as np\n\nclass HybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T)\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07852 with standard deviation 0.04951.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.018913622474481584, 0.023653760099824228, 0.04801572565636125, 0.059752385085465654, 0.05370783322119166, 0.06627269540702407, 0.14343857907370494, 0.14463577076454348, 0.14828302713542763]}}
{"id": "eaed1e1e-b29e-40bb-ac59-8fe18123e2d2", "fitness": 0.07560886769487374, "name": "HybridDE_CMA_Enhanced", "description": "The algorithm hybridizes differential evolution with covariance matrix adaptation and dynamic parameter adjustment for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_CMA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        # Adaptive parameters\n        de_scale_min, de_scale_max = 0.2, 0.8\n        crossover_min, crossover_max = 0.6, 1.0\n\n        while evaluations < self.budget:\n            # Adjust parameters dynamically based on progress\n            de_scale = de_scale_min + (de_scale_max - de_scale_min) * (1 - evaluations / self.budget)\n            crossover_rate = crossover_min + (crossover_max - crossover_min) * (1 - evaluations / self.budget)\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T) + np.eye(self.dim) * 1e-8  # Adding small value for numerical stability\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDE_CMA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07561 with standard deviation 0.05208.", "error": "", "parent_ids": ["d9b03ea1-e26f-48f3-aa80-7b0259ecaf37"], "operator": null, "metadata": {"aucs": [0.01394130026692797, 0.013136700890499231, 0.02941252447704068, 0.06791941253834788, 0.06291815673935419, 0.06080983580018118, 0.1396175555842084, 0.14957316158180922, 0.14315116137549488]}}
{"id": "861a76f6-67f3-45fe-82db-7bb00bd310d0", "fitness": 0.07281471439888056, "name": "HybridDE_CMA", "description": "Enhanced HybridDE_CMA with adaptive DE parameters and elitist strategy for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        best_solution = np.copy(population[np.argmin(fitness)])\n\n        while evaluations < self.budget:\n            # Adaptive scaling factor\n            de_scale = 0.5 + 0.3 * (1 - evaluations / self.budget)\n            \n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(best_solution):\n                        best_solution = np.copy(trial)\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T)\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n                    if sample_fitness < func(best_solution):\n                        best_solution = np.copy(sample)\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return best_solution, func(best_solution)", "configspace": "", "generation": 2, "feedback": "The algorithm HybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07281 with standard deviation 0.05051.", "error": "", "parent_ids": ["d9b03ea1-e26f-48f3-aa80-7b0259ecaf37"], "operator": null, "metadata": {"aucs": [0.017219006455376995, 0.016946538494387875, 0.027933158858439056, 0.05765165121166349, 0.057692343556274284, 0.05488565011335256, 0.13856998115679298, 0.14147726158242735, 0.1429568381612104]}}
{"id": "3124b0d9-2538-434d-9ba1-ec2e5fe1794a", "fitness": 0.07800613351543605, "name": "EnhancedHybridDE_CMA", "description": "Introduce adaptive scaling in Differential Evolution and adaptive covariance in CMA-ES to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Adaptive Differential Evolution Step\n            fitness_std = np.std(fitness)\n            scale_factor = 0.5 + 0.5 * fitness_std / max(fitness)\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + scale_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES with adaptive covariance\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T) + 1e-5 * np.eye(self.dim)  # Avoid singular matrix\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07801 with standard deviation 0.05209.", "error": "", "parent_ids": ["d9b03ea1-e26f-48f3-aa80-7b0259ecaf37"], "operator": null, "metadata": {"aucs": [0.018607750825454406, 0.025021411409390515, 0.019819437702710108, 0.08076733711922213, 0.047108112177560946, 0.07409199036569247, 0.1459698655146885, 0.1411519922503116, 0.14951730427389376]}}
{"id": "315fced1-167c-4436-a3e4-a5fc302f9eb0", "fitness": 0.07907108167194649, "name": "HybridDE_CMA", "description": "Enhance exploration and exploitation balance by introducing adaptive scaling for Differential Evolution and adaptive sigma for CMA-ES based on convergence progress.", "code": "import numpy as np\n\nclass HybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T)\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 4, "feedback": "The algorithm HybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07907 with standard deviation 0.04916.", "error": "", "parent_ids": ["d9b03ea1-e26f-48f3-aa80-7b0259ecaf37"], "operator": null, "metadata": {"aucs": [0.01913591605557785, 0.023675245036633763, 0.047163847378898116, 0.05351838589975766, 0.06852684342195992, 0.06446073169214361, 0.1475126926693513, 0.14747562900632438, 0.14017044388687172]}}
{"id": "5d47b1af-d659-427c-b03d-0a9e771cc364", "fitness": 0.07850068560194916, "name": "EnhancedHybridDE_CMA", "description": "Integrate adaptive learning rate for DE and covariance matrix adaptation for CMA-ES to enhance convergence efficiency dynamically.", "code": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = max(2, population_size // 2)\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Differential Evolution Step with Adaptive Learning Rate\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T) + np.eye(self.dim) * 1e-8  # Prevent singular covariance\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07850 with standard deviation 0.04949.", "error": "", "parent_ids": ["315fced1-167c-4436-a3e4-a5fc302f9eb0"], "operator": null, "metadata": {"aucs": [0.019827712241269224, 0.02370641940921492, 0.046956367582400294, 0.05264710355426505, 0.06231873379241093, 0.06450652095138443, 0.14778504740349363, 0.14398874745830326, 0.14476951802480065]}}
{"id": "b9900331-bb66-46d6-af7a-57ae2b2127df", "fitness": 0.07619098078423217, "name": "HybridDE_CMA_Improved", "description": "Introduce dynamic population adaptation by tuning both DE and CMA-ES components based on diversity metrics to improve convergence and robustness.", "code": "import numpy as np\n\nclass HybridDE_CMA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        def calculate_diversity(population):\n            return np.mean(np.std(population, axis=0))\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            diversity = calculate_diversity(population)\n            de_scale = 0.1 + 0.4 * adap_state * (1 - diversity)  # Adaptive DE scaling with diversity\n            cma_sigma = 0.3 + 0.2 * adap_state * diversity  # Adaptive CMA sigma with diversity\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T)\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 6, "feedback": "The algorithm HybridDE_CMA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07619 with standard deviation 0.05174.", "error": "", "parent_ids": ["315fced1-167c-4436-a3e4-a5fc302f9eb0"], "operator": null, "metadata": {"aucs": [0.013800914748155702, 0.016553890617137745, 0.02539589061245695, 0.0780563020885301, 0.05797484831257105, 0.06421818094690213, 0.13728400715045885, 0.1507895832160714, 0.1416452093658056]}}
{"id": "a1121806-aa22-46a8-b6fb-9e16570b15ac", "fitness": 0.0732715954729784, "name": "HybridDE_CMA", "description": "Improve balance by introducing adaptive crossover rate in DE and refining CMA-ES selection.", "code": "import numpy as np\n\nclass HybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.7 + 0.2 * adap_state  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T)\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 7, "feedback": "The algorithm HybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07327 with standard deviation 0.05038.", "error": "", "parent_ids": ["315fced1-167c-4436-a3e4-a5fc302f9eb0"], "operator": null, "metadata": {"aucs": [0.017586286419390085, 0.02317115767977629, 0.021287869852603114, 0.05346015533427795, 0.06682060083261654, 0.05453193299407, 0.1366194363128138, 0.140515284606347, 0.14545163522491078]}}
{"id": "75e47984-6ecd-45da-9ef1-874ec9d6ccb2", "fitness": 0.07907108165917548, "name": "RefinedHybridDE_CMA", "description": "Introduce adaptive mutation in DE and Covariance Matrix Adaptation with restart mechanism to improve convergence speed and robustness.", "code": "import numpy as np\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = max(2, population_size // 2)\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Differential Evolution Step with adaptive mutation\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T)\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            # Restart mechanism if convergence stalls\n            if np.std(fitness) < 1e-8:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 8, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07907 with standard deviation 0.04916.", "error": "", "parent_ids": ["315fced1-167c-4436-a3e4-a5fc302f9eb0"], "operator": null, "metadata": {"aucs": [0.01913591597918196, 0.023675245033988768, 0.04716384734544754, 0.05351838589975766, 0.06852684342121251, 0.06446073169044342, 0.1475126926693513, 0.14747562900632438, 0.14017044388687172]}}
{"id": "cfb977b3-ece3-4a6e-b306-eec7a561ac8d", "fitness": 0.0732715954729784, "name": "HybridDE_CMA", "description": "Improve exploration by enhancing the crossover process in Differential Evolution using dynamic crossover rates based on convergence progress.", "code": "import numpy as np\n\nclass HybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n            crossover_rate = 0.7 + 0.2 * adap_state  # Adaptive crossover rate\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T)\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 9, "feedback": "The algorithm HybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07327 with standard deviation 0.05038.", "error": "", "parent_ids": ["315fced1-167c-4436-a3e4-a5fc302f9eb0"], "operator": null, "metadata": {"aucs": [0.017586286419390085, 0.02317115767977629, 0.021287869852603114, 0.05346015533427795, 0.06682060083261654, 0.05453193299407, 0.1366194363128138, 0.140515284606347, 0.14545163522491078]}}
{"id": "b4fcaf9c-56be-4bac-8b5b-665118b9aec8", "fitness": 0.07850068560194916, "name": "EnhancedHybridDE_CMA", "description": "Improve convergence by integrating adaptive topology for Differential Evolution and covariance adaptation in CMA-ES to dynamically control exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Differential Evolution Step with Adaptive Topology\n            for i in range(population_size):\n                neighbors = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[neighbors]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Select best individuals for CMA-ES with Covariance Adaptation\n            best_indices = np.argsort(fitness)[:cma_population_size]\n            cma_population = population[best_indices]\n            cma_mean = np.mean(cma_population, axis=0)\n            cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)  # Add small noise for numerical stability\n            cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n            for sample in cma_samples:\n                sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                sample_fitness = func(sample)\n                evaluations += 1\n\n                if sample_fitness < np.max(fitness):\n                    worst_index = np.argmax(fitness)\n                    population[worst_index] = sample\n                    fitness[worst_index] = sample_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07850 with standard deviation 0.04949.", "error": "", "parent_ids": ["315fced1-167c-4436-a3e4-a5fc302f9eb0"], "operator": null, "metadata": {"aucs": [0.019827712241269224, 0.02370641940921492, 0.046956367582400294, 0.05264710355426505, 0.06231873379241093, 0.06450652095138443, 0.14778504740349363, 0.14398874745830326, 0.14476951802480065]}}
{"id": "f85ac213-4233-4b6c-b695-c6575a2560f7", "fitness": 0.09564031409620893, "name": "RefinedHybridDE_CMA", "description": "Improve HybridDE_CMA by introducing diversity promotion through random immigrants and adaptively switching between DE and CMA-ES based on performance variance.", "code": "import numpy as np\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        \n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Random immigrants to introduce diversity\n            num_immigrants = int(population_size * 0.1)\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 11, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09564 with standard deviation 0.03508.", "error": "", "parent_ids": ["315fced1-167c-4436-a3e4-a5fc302f9eb0"], "operator": null, "metadata": {"aucs": [0.09621312040255547, 0.07742891738895552, 0.08043802611944517, 0.05604942258292511, 0.05877976973206034, 0.06520000968525475, 0.1376104918676293, 0.1368455452380276, 0.15219752384902707]}}
{"id": "c5cd4fb5-9431-4018-a7db-43f46ec3cf72", "fitness": 0.0963114970677081, "name": "AdvancedHybridDE_CMA", "description": "Incorporate adaptive mutation and crossover rates in DE, use elitism with archive in CMA-ES, and dynamically adjust the balance between DE and CMA-ES based on performance and diversity metrics.", "code": "import numpy as np\n\nclass AdvancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 12, "feedback": "The algorithm AdvancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09631 with standard deviation 0.03498.", "error": "", "parent_ids": ["f85ac213-4233-4b6c-b695-c6575a2560f7"], "operator": null, "metadata": {"aucs": [0.09330500326576119, 0.07637258686398918, 0.10780908685368351, 0.05434722653438839, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13866355274979003, 0.13962294546070664]}}
{"id": "8b8b2375-4f4f-4553-af4d-8e2fb0b40ec0", "fitness": 0.0963114970677081, "name": "EnhancedHybridDE_CMA", "description": "Enhance AdvancedHybridDE_CMA with adaptive learning rates for DE and CMA-ES, introducing a fitness sharing mechanism to boost diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Fitness sharing to maintain diversity\n            fitness_shared = fitness / (1 + np.sum(np.exp(-np.linalg.norm(population[:, None] - population, axis=2)), axis=1))\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness_shared, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09631 with standard deviation 0.03498.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.09330500326576119, 0.07637258686398918, 0.10780908685368351, 0.05434722653438839, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13866355274979003, 0.13962294546070664]}}
{"id": "5bf88a6d-4f07-437c-b4ba-3e8371a541ea", "fitness": -Infinity, "name": "EnhancedHybridDE_CMA", "description": "Integrate a learning mechanism to adjust DE and CMA-ES strategy parameters based on historical performance, incorporating quasi-random sequences for enhanced diversity and convergence.", "code": "import numpy as np\nfrom scipy.stats import qmc\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        fitness_history = [previous_best_fitness]\n        sobol_engine = qmc.Sobol(d=self.dim, scramble=True)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = max(0.1, np.mean(fitness_history[-5:]) / np.std(fitness_history[-5:] + 1e-9)) * 0.5\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            sobol_points = sobol_engine.random(num_immigrants)\n            immigrants = np.array([bounds[:, 0] + point * (bounds[:, 1] - bounds[:, 0]) for point in sobol_points])\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            current_best_fitness = np.min(fitness)\n            fitness_history.append(current_best_fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 14, "feedback": "An exception occurred: TypeError('can only concatenate list (not \"float\") to list').", "error": "TypeError('can only concatenate list (not \"float\") to list')", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {}}
{"id": "58f4c954-b0fe-4b67-92ed-87eeb67da7b3", "fitness": 0.09407952204505302, "name": "AdvancedHybridDE_CMA_Enhanced", "description": "Introduce an environmental selection strategy and dynamic population size adjustment in AdvancedHybridDE_CMA to maintain diversity and adapt more effectively to different optimization landscapes.", "code": "import numpy as np\n\nclass AdvancedHybridDE_CMA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        initial_population_size = 4 + int(3 * np.log(self.dim))\n        population_size = initial_population_size\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Dynamic population size adjustment\n            if evaluations > self.budget * 0.5:\n                population_size = max(2, int(initial_population_size * adap_state))\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Environmental selection to maintain diversity\n            combined_population = np.vstack((population, pop_with_immigrants))\n            combined_fitness = np.concatenate((fitness, fitness_with_immigrants))\n            best_indices = np.argsort(combined_fitness)[:population_size]\n            population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n\n            # CMA-ES component\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 15, "feedback": "The algorithm AdvancedHybridDE_CMA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09408 with standard deviation 0.03661.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.08711300016048507, 0.06771571712899616, 0.1026883014445179, 0.05071611940248222, 0.06264952860049444, 0.05252465504694648, 0.14388955773833179, 0.13778378170091488, 0.1416350371823082]}}
{"id": "f7e21b10-2557-4c99-a0da-7566c40ffe0b", "fitness": 0.0963114970677081, "name": "AdvancedHybridDE_CMA", "description": "Introducing a dynamic adjustment of the DE scaling factor based on population diversity to further enhance exploration capabilities.", "code": "import numpy as np\n\nclass AdvancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n            # Adjust de_scale based on diversity\n            diversity = np.mean([np.linalg.norm(ind - np.mean(population, axis=0)) for ind in population])\n            de_scale = 0.1 + 0.4 * (1 - diversity / np.max([diversity, 1e-10]))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 16, "feedback": "The algorithm AdvancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09631 with standard deviation 0.03498.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.09330500326576119, 0.07637258686398918, 0.10780908685368351, 0.05434722653438839, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13866355274979003, 0.13962294546070664]}}
{"id": "e9e11be2-c4e1-410b-8290-690add3bda60", "fitness": 0.09557780760810874, "name": "AdvancedHybridDE_CMA", "description": "Enhance adaptive strategy by refining DE scaling and crossover adaptation for improved balance.", "code": "import numpy as np\n\nclass AdvancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.15 + 0.35 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.65 + 0.25 * (1 - adap_state)  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 17, "feedback": "The algorithm AdvancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09558 with standard deviation 0.04055.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.07488572896779755, 0.05576382591119389, 0.11441708924011296, 0.05898177268149307, 0.05511084884002038, 0.06143675932330517, 0.16475132567437234, 0.13625532845600752, 0.13859758937867583]}}
{"id": "83930046-60e0-42e2-9519-e06b540ea7b9", "fitness": -Infinity, "name": "AdvancedHybridDE_CMA_Niching", "description": "Introduce a dynamic niching strategy with adaptive local search intensification to maintain diversity and enhance convergence in AdvancedHybridDE_CMA.", "code": "import numpy as np\n\nclass AdvancedHybridDE_CMA_Niching:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            # Introduce niches to maintain diversity\n            niche_radius = np.std(population, axis=0) * 0.1\n            niches = np.unique((population / niche_radius).astype(int), axis=0)\n            niche_populations = [population[np.all((population / niche_radius).astype(int) == niche, axis=1)] \n                                 for niche in niches]\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            fitness_with_immigrants = np.array([func(ind) for ind in immigrants])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                niche = niche_populations[i % len(niche_populations)]\n                indices = np.random.choice(len(niche), 3, replace=False)\n                a, b, c = niche[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 18, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {}}
{"id": "98aefb13-fd05-4374-a960-9806afbeaf0f", "fitness": 0.08276496971619224, "name": "AdvancedHybridDE_CMA", "description": "Introduce an adaptive mutation strategy based on relative fitness improvement.", "code": "import numpy as np\n\nclass AdvancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                adaptive_scale = de_scale * (1 + (fitness[i] - np.min(fitness)) / (np.max(fitness) - np.min(fitness)))  # Adaptive mutation strategy\n                mutant = np.clip(a + adaptive_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 19, "feedback": "The algorithm AdvancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08276 with standard deviation 0.04518.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.03739177679699379, 0.04796319983150765, 0.050264106276215026, 0.056144476765259355, 0.05791742958695256, 0.057005276232703905, 0.1413016822795895, 0.14866525137056585, 0.14823152830594255]}}
{"id": "50247f02-0d34-4802-a0fa-dd89acb6523b", "fitness": 0.0963114970677081, "name": "RefinedHybridDE_CMA", "description": "Enhance AdvancedHybridDE_CMA by integrating dynamic learning rates for DE parameters, employing adaptive elitist selection in CMA-ES, and introducing a learning mechanism to adjust strategies based on problem landscape complexity.", "code": "import numpy as np\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        learning_rate = 0.1\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            de_scaling_update = np.zeros(population_size)\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    de_scaling_update[i] = 1\n\n            de_scale += learning_rate * (np.mean(de_scaling_update) - de_scale)\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 20, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09631 with standard deviation 0.03498.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.09330500326576119, 0.07637258686398918, 0.10780908685368351, 0.05434722653438839, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13866355274979003, 0.13962294546070664]}}
{"id": "a4819022-36ec-4379-853b-c0b376d8239b", "fitness": 0.07417079797258824, "name": "EnhancedHybridDE_CMA", "description": "Enhance AdvancedHybridDE_CMA by incorporating dynamic population resizing and local search intensification based on diversity and convergence metrics to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        min_pop_size = 4 + int(3 * np.log(self.dim))\n        max_pop_size = 10 * min_pop_size\n        population_size = min_pop_size\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            fitness_improvement = previous_best_fitness - current_best_fitness\n            previous_best_fitness = current_best_fitness\n\n            if fitness_variance < 1e-5 and fitness_improvement < 1e-6:\n                best_indices = np.argsort(fitness)[:population_size//2]\n                cma_population = population[best_indices]\n                cma_mean = np.mean(cma_population, axis=0)\n                cma_cov = np.cov(cma_population.T)\n                cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, population_size//2)\n\n                for sample in cma_samples:\n                    sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                    sample_fitness = func(sample)\n                    evaluations += 1\n\n                    if sample_fitness < np.max(fitness):\n                        worst_index = np.argmax(fitness)\n                        population[worst_index] = sample\n                        fitness[worst_index] = sample_fitness\n\n                    if evaluations >= self.budget:\n                        break\n\n            if fitness_improvement > 1e-3:\n                population_size = min(max_pop_size, int(population_size * 1.2))\n                new_population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size - len(population), self.dim))\n                population = np.vstack((population, new_population))\n                fitness = np.concatenate((fitness, np.array([func(ind) for ind in new_population])))\n                evaluations += len(new_population)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07417 with standard deviation 0.04825.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.03113926103543485, 0.036217915088011865, 0.020925745754120983, 0.05346411171150245, 0.04854075306562333, 0.05486144571967655, 0.14354516112841398, 0.13521128881724953, 0.1436314994332607]}}
{"id": "f5d812a8-a2e0-4c97-92d9-f3313c4d7e4b", "fitness": 0.07485611920907491, "name": "EnhancedHybridDE_CMA", "description": "Integrate adaptive differential evolution with covariance adaptation, mutation strength control, and strategic restarts to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        restart_threshold = 10  # Number of iterations after which to consider restarting\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state  # Adaptive DE scaling\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)  # Adaptive crossover rate\n            cma_sigma = 0.3 + 0.2 * adap_state  # Adaptive CMA sigma\n\n            # Random immigrants to introduce diversity\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            # Differential Evolution Step\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Check fitness variance for adaptive strategy switching\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                # Use CMA-ES if variance is low indicating stagnation\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n            # Strategic restart\n            if evaluations % restart_threshold == 0 and np.min(fitness) == previous_best_fitness:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07486 with standard deviation 0.05108.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.02233711428798013, 0.018665125185633014, 0.023402622253623995, 0.05094023944083448, 0.05786204158543207, 0.07210722426487548, 0.15448573176129998, 0.13761325532308455, 0.13629171877891044]}}
{"id": "510986a0-fdb7-4069-84c4-938104c56a3e", "fitness": 0.09629446426257887, "name": "EnhancedHybridDE_CMA", "description": "Integrate neighborhood-based adaptation and fitness diversity-driven exploration in a Hybrid DE-CMA approach to enhance convergence and robustness on multimodal landscapes.", "code": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        epsilon = 1e-8  # Small constant for stability\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            neighborhood_radius = np.mean(np.std(population, axis=0)) + epsilon\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                if np.linalg.norm(trial - population[i]) > neighborhood_radius:\n                    trial = np.clip(trial, bounds[:, 0], bounds[:, 1])  # Ensure bounds\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + epsilon * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09629 with standard deviation 0.03498.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.09315171658684318, 0.07637257829674404, 0.10780908685368351, 0.05434722653438839, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13866355274979003, 0.13962294546070664]}}
{"id": "d8b17e71-103e-47b3-88f1-dd232ce5487a", "fitness": 0.09857253032289366, "name": "ImprovedHybridDE_CMA", "description": "Introduce a self-adaptive learning mechanism that dynamically adjusts DE and CMA-ES operators based on success rates, and integrate a diversity preservation strategy using niching to enhance convergence and maintain exploration.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass ImprovedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            # Dynamic strategy adjustment based on success rates\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            # Enhance exploration through niching\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 24, "feedback": "The algorithm ImprovedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09857 with standard deviation 0.04088.", "error": "", "parent_ids": ["c5cd4fb5-9431-4018-a7db-43f46ec3cf72"], "operator": null, "metadata": {"aucs": [0.06859999850714082, 0.0743305216909742, 0.15203738499077257, 0.05432968722187903, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13888114401898954, 0.14229096459523283]}}
{"id": "7bbf18aa-3423-494f-b652-e5c4e506414e", "fitness": 0.09676040358325595, "name": "ImprovedHybridDE_CMA", "description": "Enhance exploitation by increasing CMA-ES sampling when success rates are low, and adjust DE mutation based on population diversity.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass ImprovedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.05:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size * 2)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            # Dynamic strategy adjustment based on success rates\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9 * (1 + 0.1 * np.std(fitness) / np.mean(fitness))\n\n            # Enhance exploration through niching\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 25, "feedback": "The algorithm ImprovedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09676 with standard deviation 0.03492.", "error": "", "parent_ids": ["d8b17e71-103e-47b3-88f1-dd232ce5487a"], "operator": null, "metadata": {"aucs": [0.09666695857973961, 0.07701544662965809, 0.10784443041396685, 0.05434722653438839, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13866355274979003, 0.13962294546070664]}}
{"id": "70d86564-f8de-424e-8a5f-88f191f39425", "fitness": 0.08754379576211359, "name": "RefinedHybridDE_CMA", "description": "Refine the balance between exploration and exploitation by incorporating adaptive parameter control for DE scale and crossover rate, integrating simulated annealing-inspired temperature control to guide exploration intensity, and enhancing niching by fostering elite diversity.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        temp_initial = 1.0\n        temp_min = 0.01\n        cooling_rate = 0.99\n\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n\n        while evaluations < self.budget:\n            temperature = max(temp_min, temp_initial * (cooling_rate ** (evaluations / self.budget)))\n\n            if np.random.rand() < 0.5:\n                de_scale = 0.1 + 0.4 * temperature\n                crossover_rate = 0.6 + 0.3 * (1 - temperature)\n            else:\n                cma_sigma = 0.3 + 0.2 * temperature\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n\n            if fitness_variance < 1e-5:\n                best_indices = np.argsort(fitness)[:cma_population_size]\n                cma_population = population[best_indices]\n                cma_mean = np.mean(cma_population, axis=0)\n                cma_cov = np.cov(cma_population.T)\n                cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n\n                for sample in cma_samples:\n                    sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                    sample_fitness = func(sample)\n                    evaluations += 1\n\n                    if sample_fitness < np.max(fitness):\n                        worst_index = np.argmax(fitness)\n                        population[worst_index] = sample\n                        fitness[worst_index] = sample_fitness\n\n                    if evaluations >= self.budget:\n                        break\n\n            distances = squareform(pdist(population))\n            diversity_preserved = np.zeros(population_size, dtype=bool)\n            for i in range(population_size):\n                if not diversity_preserved[i]:\n                    niching_indices = np.where(distances[i] < 0.1)[0]\n                    best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                    diversity_preserved[niching_indices] = True\n                    diversity_preserved[best_in_niche] = False\n\n            population = population[~diversity_preserved]\n            fitness = fitness[~diversity_preserved]\n            missing_count = population_size - len(population)\n            new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n            population = np.vstack((population, new_individuals))\n            fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n            evaluations += missing_count\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 26, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08754 with standard deviation 0.04069.", "error": "", "parent_ids": ["d8b17e71-103e-47b3-88f1-dd232ce5487a"], "operator": null, "metadata": {"aucs": [0.08212700049345767, 0.03722894105362229, 0.09265325663458768, 0.05384362347174754, 0.049861125942280426, 0.051398563771207106, 0.13968682555156275, 0.14798330961429096, 0.13311151532626586]}}
{"id": "c4e5bb6a-cbc4-48eb-9b86-45297d7582b8", "fitness": 0.09809962062046333, "name": "ImprovedHybridDE_CMA", "description": "Incrementally adjust mutation strategy by adding random Gaussian noise to DE mutations to explore new regions.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass ImprovedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c) + np.random.normal(0, 0.1, self.dim), bounds[:, 0], bounds[:, 1])  # Added Gaussian noise\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            # Dynamic strategy adjustment based on success rates\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            # Enhance exploration through niching\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 27, "feedback": "The algorithm ImprovedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09810 with standard deviation 0.03843.", "error": "", "parent_ids": ["d8b17e71-103e-47b3-88f1-dd232ce5487a"], "operator": null, "metadata": {"aucs": [0.07158918088559907, 0.13743214182849428, 0.09857360077108124, 0.056850014875897026, 0.04718360044871239, 0.05567549305382424, 0.1423456937340517, 0.13331332861923684, 0.13993353136727316]}}
{"id": "d3b9d947-81ac-46c4-baa5-4c7f68e4b826", "fitness": 0.0819342948185609, "name": "EnhancedHybridDE_CMA", "description": "Introduce a dynamic adaptive mechanism integrating DE, CMA-ES, and a diversity-preserving search approach with local exploitation for niche refinement to improve convergence and exploration balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            # Dynamic strategy adjustment based on success rates\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            # Enhanced exploration through characterizing niches\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                local_exploration_size = max(1, population_size // 5)\n                \n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                        \n                        # Local exploitation within niche\n                        local_candidates = np.random.uniform(bounds[:, 0], bounds[:, 1], (local_exploration_size, self.dim))\n                        local_fitness = np.array([func(candidate) for candidate in local_candidates])\n                        evaluations += local_exploration_size\n                        \n                        local_best_index = np.argmin(local_fitness)\n                        if local_fitness[local_best_index] < fitness[best_in_niche]:\n                            population[best_in_niche] = local_candidates[local_best_index]\n                            fitness[best_in_niche] = local_fitness[local_best_index]\n\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08193 with standard deviation 0.04087.", "error": "", "parent_ids": ["d8b17e71-103e-47b3-88f1-dd232ce5487a"], "operator": null, "metadata": {"aucs": [0.04465245466951662, 0.07040511470485811, 0.044010559594097054, 0.05398364606405748, 0.055330170525902944, 0.052504417784322466, 0.13734629467519022, 0.14052981846613566, 0.13864617688296754]}}
{"id": "4f3af123-c0f1-444c-8dc8-8e5a26d709d8", "fitness": 0.09925549742220942, "name": "EnhancedHybridDE_CMA", "description": "Enhance the adaptive hybrid mechanism by incorporating a dynamic parameter tuning based on current optimization landscape properties, and introduce a novel neighborhood-based exploitation strategy to improve convergence speed and robustness.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09926 with standard deviation 0.04119.", "error": "", "parent_ids": ["d8b17e71-103e-47b3-88f1-dd232ce5487a"], "operator": null, "metadata": {"aucs": [0.06818502568917928, 0.0776241581710464, 0.15530542522250368, 0.05432968722187903, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13888114401898954, 0.14229096459523283]}}
{"id": "fbb5371b-f48d-43c4-a82d-c9ad6effee02", "fitness": 0.08300057684438558, "name": "EnhancedHybridDE_CMA", "description": "Fine-tune DE mutation strategy with adaptive scaling based on population diversity to enhance exploitation capabilities.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                diversity_factor = np.std(pop_with_immigrants, axis=0).mean()  # New line\n                mutant = np.clip(a + de_scale * diversity_factor * (b - c), bounds[:, 0], bounds[:, 1])  # Modified line\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08300 with standard deviation 0.04134.", "error": "", "parent_ids": ["4f3af123-c0f1-444c-8dc8-8e5a26d709d8"], "operator": null, "metadata": {"aucs": [0.04654049694590101, 0.07917790723651474, 0.043979246160494534, 0.051914012832926626, 0.04899851070089334, 0.05690468033594154, 0.13635827335767536, 0.14045567083040755, 0.1426763931987155]}}
{"id": "0f50cdbc-4814-49de-9b26-126131d4581a", "fitness": 0.09925549742220942, "name": "EnhancedHybridDE_CMA_V2", "description": "Enhance adaptive hybrid DE-CMA by integrating adaptive niching to preserve diversity and incorporating a dynamic exploration-exploitation balance based on real-time fitness landscape analysis.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedHybridDE_CMA_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09926 with standard deviation 0.04119.", "error": "", "parent_ids": ["4f3af123-c0f1-444c-8dc8-8e5a26d709d8"], "operator": null, "metadata": {"aucs": [0.06818502568917928, 0.0776241581710464, 0.15530542522250368, 0.05432968722187903, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13888114401898954, 0.14229096459523283]}}
{"id": "90b81761-b46e-4776-979e-991d8c787595", "fitness": 0.0994105615733677, "name": "RefinedHybridDE_CMA", "description": "Introduce a dynamic learning rate for neighborhood exploitation and an adaptive restart mechanism to enhance exploration and prevent premature convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 32, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09941 with standard deviation 0.04180.", "error": "", "parent_ids": ["4f3af123-c0f1-444c-8dc8-8e5a26d709d8"], "operator": null, "metadata": {"aucs": [0.0695311686900395, 0.07434147306441874, 0.15863754468869562, 0.05432968722187903, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13888114401898954, 0.14229096459523283]}}
{"id": "95042966-7680-4be1-a107-620be26a3c85", "fitness": -Infinity, "name": "RefinedHybridDE_CMA", "description": "Enhance exploration and exploitation balance by dynamically adjusting crossover rate and niche radius based on fitness variance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                niche_radius = 0.1 + 0.1 * (1 - fitness_variance)  # Adjust niche radius\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < niche_radius)[0]  # Use niche_radius\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 33, "feedback": "An exception occurred: ValueError('attempt to get argmin of an empty sequence').", "error": "ValueError('attempt to get argmin of an empty sequence')", "parent_ids": ["90b81761-b46e-4776-979e-991d8c787595"], "operator": null, "metadata": {}}
{"id": "049f6eab-855a-4f5b-85ab-d3fd1342d455", "fitness": 0.07506556123791891, "name": "EnhancedHybridDE_CMA", "description": "Integrate a dynamically adjustable niching mechanism and a self-adaptive control parameter strategy to enhance diversity and convergence speed.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_threshold = np.quantile(distances[i], 0.2)\n                        niching_indices = np.where(distances[i] < niching_threshold)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07507 with standard deviation 0.04584.", "error": "", "parent_ids": ["90b81761-b46e-4776-979e-991d8c787595"], "operator": null, "metadata": {"aucs": [0.044065033930351216, 0.027422986456976717, 0.026992372377798723, 0.05616271482465318, 0.0530720848653804, 0.05338343475399321, 0.14683434768483006, 0.13487724960007752, 0.1327798266472091]}}
{"id": "ed7334df-bf56-44e5-b268-180920dd1a92", "fitness": 0.09929616734911535, "name": "RefinedHybridDE_CMA", "description": "Enhance the algorithm by dynamically adjusting the mutation factor based on the success rate, improving convergence speed without altering the exploration balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = max(0.1 + 0.4 * adap_state, 0.1 + 0.4 * (success_de / max(1, population_size)))  # Adjusted line\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 35, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09930 with standard deviation 0.04134.", "error": "", "parent_ids": ["90b81761-b46e-4776-979e-991d8c787595"], "operator": null, "metadata": {"aucs": [0.07030137377636714, 0.07485106495830163, 0.15629505952434752, 0.05436282738774556, 0.05287379020228322, 0.06258816844028958, 0.1412211132384812, 0.13888114401898954, 0.14229096459523283]}}
{"id": "f1591902-35ad-4f10-9fa7-e4b13028afce", "fitness": -Infinity, "name": "EnhancedHybridDE_CMA", "description": "Integrate a gradient-based local search for fine-tuning and adaptive population resizing to enhance convergence speed and accuracy.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            # Gradient-based local search for fine-tuning\n            if adap_counter % 10 == 0:\n                for i in range(population_size):\n                    res = minimize(func, population[i], bounds=func.bounds, method='L-BFGS-B')\n                    if res.fun < fitness[i]:\n                        population[i] = res.x\n                        fitness[i] = res.fun\n                        evaluations += res.nfev\n\n            # Adaptive population resizing\n            if adap_counter % 5 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 36, "feedback": "An exception occurred: TypeError('type object argument after * must be an iterable, not ioh.iohcpp.RealBounds').", "error": "TypeError('type object argument after * must be an iterable, not ioh.iohcpp.RealBounds')", "parent_ids": ["90b81761-b46e-4776-979e-991d8c787595"], "operator": null, "metadata": {}}
{"id": "5c45337b-2cbe-4da3-a91b-26be2db19b6e", "fitness": 0.10339850541541722, "name": "RefinedHybridDE_CMA", "description": "Add a dynamic scaling factor for the DE mutation step size based on success rates, enhancing adaptive exploitation.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 37, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10340 with standard deviation 0.03733.", "error": "", "parent_ids": ["90b81761-b46e-4776-979e-991d8c787595"], "operator": null, "metadata": {"aucs": [0.07968015124123007, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "3fe7ecad-bcd4-4df7-8648-7f25ba19d546", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Introduce a slight increase in the DE scaling factor's initial setting to balance exploration and exploitation.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.6  # Adjusted line: increased from 0.5 to 0.6\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 38, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "c37007f8-4d14-4f19-b5f4-1633689b7b61", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Add an adaptive restart mechanism based on fitness variance and evaluation budget, enhancing exploration and convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold * (evaluations / self.budget) and adap_counter % 20 == 0:  # Modified line\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 39, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "2319ebc8-b09b-4a30-b440-f6aae42f36a3", "fitness": 0.10213121175911209, "name": "RefinedHybridDE_CMA", "description": "Introduce a relaxation factor in the covariance matrix estimation of the CMA-ES to improve exploration.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim) * 1.1  # Relaxation factor added\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 40, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03830.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.06829138737499563, 0.09627335587473018, 0.13454149476498733, 0.06339421679174162, 0.05721393768476257, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "0f55dcd3-1513-40b5-846f-3ed52dc4e21c", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Introduce gradual adjustment to the DE mutation scaling factor for more robust exploration-exploitation balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.98  # Changed line: Adjust de_scale more gradually\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 41, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "baf9931a-cd1d-4aab-b043-8e22f03fa84b", "fitness": 0.10213307012873205, "name": "EnhancedHybridDE_CMA", "description": "Introduce self-adaptive parameter control and diversity-preservation techniques to enhance the exploration-exploitation balance in DE-CMA hybrid optimization.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "dab72d0b-1394-449f-9725-17c89667d685", "fitness": 0.10213307012873205, "name": "EnhancedHybridDE_CMA", "description": "Integrate an adaptive local search mechanism that dynamically adjusts its intensity based on population diversity and convergence speed to boost local exploitation and exploration balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "2afab25f-7494-45d3-a79c-658f48c978dd", "fitness": 0.10239506233288016, "name": "EnhancedHybridDE_CMA", "description": "Introduce adaptive niching and self-adjusting local search steps to enhance diversity and convergence in dynamic environments.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step_size = 0.1 * np.linalg.norm(population[i] - local_best)\n                        step = np.random.uniform(-1, 1, self.dim) * step_size\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10240 with standard deviation 0.03773.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.07345102618278976, 0.09602169120475712, 0.1326415934188171, 0.06275684604243936, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "3eca3709-a196-4d78-85b5-f43965036d2e", "fitness": 0.10281223117263304, "name": "AdvancedHybridDE_CMA", "description": "Introduce adaptive niching with a shifting niche radius and integrate a covariance matrix adjustment in CMA for enhanced exploration-exploitation balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdvancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n        niche_radius = 0.1\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov_adjust = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_cov_adjust -= np.outer(cma_mean - np.mean(population, axis=0), cma_mean - np.mean(population, axis=0)) * 0.1\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov_adjust, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                niche_radius *= 0.9 if adap_state < 0.5 else 1.1\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < niche_radius)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 45, "feedback": "The algorithm AdvancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10281 with standard deviation 0.03851.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.07320771716860641, 0.095529696186051, 0.13851484940280268, 0.058568203088002035, 0.05721393768476257, 0.0645152852290084, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "6b44c2bc-f5cc-4936-a0b7-ac2b89d909af", "fitness": -Infinity, "name": "AdaptiveHybridDE_CMA", "description": "Introduce an adaptive population size and mutation strategies based on diversity metrics to enhance convergence speed and exploration capabilities.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        initial_population_size = 4 + int(3 * np.log(self.dim))\n        max_population_size = 10 * initial_population_size\n        min_population_size = initial_population_size\n        population_size = initial_population_size\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n            \n            # Adaptive population size based on diversity\n            if adap_counter % 5 == 0:\n                distances = squareform(pdist(population))\n                diversity = np.mean(np.min(distances + np.eye(population_size) * np.max(distances), axis=1))\n                target_population_size = int(min_population_size + (max_population_size - min_population_size) * diversity / 0.5)\n                population_size = min(max(min_population_size, target_population_size), max_population_size)\n                if len(population) > population_size:\n                    worst_indices = np.argsort(fitness)[population_size:]\n                    population = np.delete(population, worst_indices, axis=0)\n                    fitness = np.delete(fitness, worst_indices)\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    cma_population_size = population_size // 2\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 46, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {}}
{"id": "ce76ff2a-ad95-46ca-b77f-e65d2629dae7", "fitness": 0.10245930990953016, "name": "RefinedHybridDE_CMA", "description": "Enhance local exploitation by introducing dynamic neighborhood sizes and adaptive niching.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_threshold = np.median(distances) * 0.1  # Dynamic threshold\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < diversity_threshold)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate * np.mean(distances))[0]  # Adaptive neighborhood\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 47, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10246 with standard deviation 0.03776.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.0827192887564202, 0.09458297345836397, 0.1315195573918171, 0.056631518553616034, 0.05721393768476257, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "17e6bb76-b757-468e-95b8-e65ac2d4d259", "fitness": 0.10237266930755767, "name": "EnhancedRefinedHybridDE_CMA", "description": "Integrate an adaptive learning rate for diversity preservation to enhance convergence speed and solution quality in hybrid DE-CMA-ES optimization.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedRefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n        learning_rate = 0.1\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = learning_rate * np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedRefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10237 with standard deviation 0.03791.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.07194167978278976, 0.09610345905895412, 0.1336012687541801, 0.06302321202497696, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "5b498e72-4465-4bcf-8a65-78290a6e30d5", "fitness": 0.09504516369495392, "name": "RefinedHybridDE_CMA", "description": "Introduce adaptive crossover rate based on population diversity to enhance exploration. ", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - np.std(fitness) / np.mean(fitness)) # adaptive crossover rate based on diversity\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 49, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09505 with standard deviation 0.03541.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.07079684339507497, 0.04399133009181, 0.10194947800121512, 0.06686746891578632, 0.07502463972907458, 0.07343076841732321, 0.14084485876058206, 0.14371590424416936, 0.13878518169954956]}}
{"id": "8d825cd6-8f6e-49b8-8582-99b4e65f0e0f", "fitness": 0.09652992200823199, "name": "RefinedHybridDE_CMA", "description": "Adjust crossover rate to dynamically adapt based on iteration progress and improve convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.1 * (1 - adap_state)  # Adjusted line\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 50, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09653 with standard deviation 0.03578.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.07329948872676861, 0.09566453542143583, 0.1251790280043864, 0.05635839184568825, 0.055157466878957506, 0.05249865361960748, 0.13468787902432344, 0.13619284789923047, 0.13973100665368987]}}
{"id": "7fba8c68-2e20-449d-bd66-ebdb90efc109", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Introduce adaptive population size scaling based on success rates to enhance exploration and exploitation balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))            \n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            population_size = max(4, population_size + int(0.1 * (success_de - success_cma)))  # Adjust population size\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 51, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "0a790a99-bd4b-4ff2-b7e2-fdc5bbdefedb", "fitness": -Infinity, "name": "RefinedHybridDE_CMA_Adaptive", "description": "Introduce an adaptive population size mechanism and stochastic rank-based selection in RefinedHybridDE_CMA to enhance exploration and exploitation balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        initial_population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        \n        def adjust_population_size(evaluations):\n            return max(4, initial_population_size * (1 - evaluations / self.budget))\n        \n        population_size = initial_population_size\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            rank = np.argsort(fitness_with_immigrants)\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False, p=rank/np.sum(rank))\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:population_size // 2]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, len(cma_population))\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n            population_size = int(adjust_population_size(evaluations))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 52, "feedback": "An exception occurred: IndexError('boolean index did not match indexed array along dimension 0; dimension is 12 but corresponding boolean dimension is 11').", "error": "IndexError('boolean index did not match indexed array along dimension 0; dimension is 12 but corresponding boolean dimension is 11')", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {}}
{"id": "7e9871bd-9ff1-4211-bab9-45814006d1b2", "fitness": 0.10973709699605645, "name": "RefinedHybridDE_CMA", "description": "Adjust the crossover rate based on the dimension size to enhance adaptation for high-dimensional problems.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 53, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10974 with standard deviation 0.03761.", "error": "", "parent_ids": ["5c45337b-2cbe-4da3-a91b-26be2db19b6e"], "operator": null, "metadata": {"aucs": [0.13672747546698327, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "1a259174-6bf9-4020-9fc8-e8dd46176fcd", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Integrate adaptive mutation rate scaling based on convergence progress for improved DE performance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            de_scale *= (1.1 if success_de > success_cma else 0.9)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 54, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "34467acb-da7f-4828-a4e5-7049bd76edce", "fitness": 0.08752188548258996, "name": "AdaptiveRecombHybridDE_CMA", "description": "Integrate an adaptive multi-parent recombination strategy to balance exploration and exploitation in high-dimensional search spaces.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveRecombHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        recomb_rate = 0.9\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n\n        while evaluations < self.budget:\n            # Adjust dynamic parameters\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state\n            recomb_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            # DE phase with multi-parent recombination\n            success_de = 0\n            for i in range(population_size):\n                parents_indices = np.random.choice(population_size, 5, replace=False)\n                parents = population[parents_indices]\n                mutant = np.clip(parents[0] + de_scale * (parents[1] - parents[2]) + de_scale * (parents[3] - parents[4]), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < recomb_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            # CMA-ES phase if needed\n            if success_de / population_size < 0.1:\n                best_indices = np.argsort(fitness)[:cma_population_size]\n                cma_population = population[best_indices]\n                cma_mean = np.mean(cma_population, axis=0)\n                cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                success_cma = 0\n\n                for sample in cma_samples:\n                    sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                    sample_fitness = func(sample)\n                    evaluations += 1\n\n                    if sample_fitness < np.max(fitness):\n                        worst_index = np.argmax(fitness)\n                        population[worst_index] = sample\n                        fitness[worst_index] = sample_fitness\n                        success_cma += 1\n\n                    if evaluations >= self.budget:\n                        break\n\n            # Diversity preservation\n            if evaluations % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 55, "feedback": "The algorithm AdaptiveRecombHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08752 with standard deviation 0.04195.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.062264346279294336, 0.0485093131630423, 0.04821292745630468, 0.053926237856436465, 0.05680510385767157, 0.0837390378273738, 0.13703645052423719, 0.15668301547615626, 0.1405205369027931]}}
{"id": "119143bc-fcc3-4c4c-8941-12ff4519eaa8", "fitness": 0.09267748427375004, "name": "RefinedHybridDE_CMA", "description": "Integrate an adaptive mutation and niche maintenance mechanism to enhance diversity and convergence in high-dimensional problems.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state) + 0.05 * np.sin(0.1 * evaluations)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.2)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 56, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09268 with standard deviation 0.03879.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0653948177082726, 0.05165172980480981, 0.12169540860277395, 0.05763565399023307, 0.06298449543844187, 0.05475551423570402, 0.13789311024574935, 0.14032011660901755, 0.1417665118287481]}}
{"id": "732693f9-7d61-4349-b53d-78e4a0a19b6b", "fitness": 0.09536930615243693, "name": "RefinedHybridDE_CMA", "description": "Enhance adaptive component integration for better synergy between DE and CMA-ES components.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.7 + 0.2 * (1 - adap_state)  # Modified line\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.85  # Modified line\n            else:\n                de_scale *= 0.85  # Modified line\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 57, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09537 with standard deviation 0.04139.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.049360312858049094, 0.04734023961318368, 0.14082438686688514, 0.07106052873185864, 0.05594490381431039, 0.07157030276682963, 0.13926468655722712, 0.1456604180660206, 0.137297976097568]}}
{"id": "652ce402-2b18-489f-b3e0-70efbe2166be", "fitness": 0.07904696550662216, "name": "AdaptiveHybridDE_CMA", "description": "Integrate adaptive learning rates and mutation strategies to dynamically balance exploration and exploitation for improved convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale_min, de_scale_max = 0.1, 0.9\n        crossover_rate_min, crossover_rate_max = 0.1, 0.9\n        cma_population_size = population_size // 2\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = de_scale_min + (de_scale_max - de_scale_min) * adap_state\n            crossover_rate = crossover_rate_min + (crossover_rate_max - crossover_rate_min) * (1 - adap_state)\n\n            for i in range(population_size):\n                indices = np.random.choice(population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, 0.3**2 * cma_cov, cma_population_size)\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n\n                        if evaluations >= self.budget:\n                            break\n\n            if fitness_variance < restart_threshold:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 58, "feedback": "The algorithm AdaptiveHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07905 with standard deviation 0.04767.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.034394879728541716, 0.023413434209893724, 0.06026418866001659, 0.05146204490714579, 0.050138307448614805, 0.05755259963064585, 0.14547926861674942, 0.14200818509572855, 0.14670978126226297]}}
{"id": "f33b1ba9-271d-4666-ab32-7bdbcd5174f7", "fitness": -Infinity, "name": "EnhancedHybridDE_CMA", "description": "Incorporate adaptive population size variation and differential mutation scaling to improve convergence in dynamic and high-dimensional landscapes.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        initial_population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = initial_population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = initial_population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population.shape[0] if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            if evaluations % (self.budget // 10) == 0:\n                population_size = int(initial_population_size * (0.5 + 0.5 * np.random.rand()))\n                if population_size < cma_population_size:\n                    population_size = cma_population_size\n                population = np.vstack((population, np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size - population.shape[0], self.dim))))\n                fitness = np.concatenate((fitness, [func(ind) for ind in population[population.shape[0] - (population_size - population.shape[0]):]]))\n                evaluations += population_size - population.shape[0]\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 59, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'population_size' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'population_size' referenced before assignment\")", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {}}
{"id": "6ef99707-fcf8-4deb-8c4d-d7236bf4b96e", "fitness": 0.10274059597895631, "name": "EnhancedHybridDE_CMA", "description": "Integrate adaptive niching strategies with dynamic parameter adjustment to balance exploration and exploitation for diverse solutions.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10274 with standard deviation 0.03779.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.07375896631308199, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "da01d29f-fef4-428a-b972-877f927c28b2", "fitness": 0.10213307012873205, "name": "AdaptiveHybridDE_CMA", "description": "Integrate adaptive mutation scaling based on success history and diversity maintenance for improved exploration and exploitation balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 61, "feedback": "The algorithm AdaptiveHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "f3095b02-f8c7-4077-9f9f-7bf28ac208fd", "fitness": 0.1020077876472017, "name": "RefinedHybridDE_CMA", "description": "Integrate adaptive parameter adjustment to balance exploration and exploitation by slightly adjusting the CMA-ES adaptation more effectively.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.25 * adap_state  # Adjusted line\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 62, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10201 with standard deviation 0.03812.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.06790996701042484, 0.09627335587473018, 0.13309089427966836, 0.0639602727648978, 0.057369085554302646, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "3ac9a781-84cd-4bfa-9e33-aaa5c5d19452", "fitness": 0.10227943029226766, "name": "EnhancedDE_CMA", "description": "Introduce a dynamic niching mechanism and adaptive exploration-exploitation balance in DE-CMA for enhanced diversity and convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.2)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.15 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10228 with standard deviation 0.03793.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.07317037395938064, 0.09416595142225137, 0.13395451928309332, 0.06253962381856537, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "880758b1-2dd5-49c8-8370-d18acfdc5e66", "fitness": 0.09240737252800453, "name": "RefinedHybridDE_CMA", "description": "Fine-tune the crossover rate to dynamically adapt to the population's diversity, aiming for improved convergence. ", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state) * (np.var(fitness) / 0.1)  # Changed line\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 64, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09241 with standard deviation 0.03427.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.04908134665889541, 0.045796064884506604, 0.07722637032249469, 0.07451502886762829, 0.09061957931467046, 0.08497548986037073, 0.13496906198157677, 0.14362424814086094, 0.13085916272103693]}}
{"id": "54d50d08-4348-4a94-94ed-c1b5f11073df", "fitness": 0.10280977718163885, "name": "RefinedHybridDE_CMA", "description": "Enhance adaptive parameters and hybrid strategy to improve convergence across varied dimensional spaces.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            # Enhance immigrant strategy\n            num_immigrants = max(1, int(population_size * 0.2))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.85\n            else:\n                de_scale *= 0.85\n\n            if adap_counter % 8 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 3 == 0:\n                local_exploit_rate = 0.15 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 15 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 65, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10281 with standard deviation 0.04324.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.059242797055113594, 0.11064945593480202, 0.15944445950172959, 0.051099066550688854, 0.06438864586582771, 0.05170409262823028, 0.13758841105688324, 0.14181963851913326, 0.1493514275223411]}}
{"id": "fd904de2-4c3b-4147-afdc-7fa35928ee4c", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Fine-tune the crossover rate for dimensions below 20 to improve convergence in lower-dimensional spaces.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.3 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 66, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "9fe70e8d-657f-47ed-a5bd-da24c9f8174b", "fitness": 0.10214927309391872, "name": "RefinedHybridDE_CMA", "description": "Fine-tune the mutation strategy by dynamically adjusting the scale factor based on the relative improvement in fitness to better balance exploration and exploitation.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            de_scale += 0.1 * (previous_best_fitness - np.min(fitness)) / (abs(previous_best_fitness) + 1e-9)  # Adjusted line\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 67, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10215 with standard deviation 0.03828.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.06844610442000709, 0.0962733302029174, 0.13453920372589068, 0.06340041534933516, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "076595bc-5c70-45c8-8b8d-ddb6793fa07f", "fitness": -Infinity, "name": "RefinedHybridDE_CMA", "description": "Increase initial population diversity by using Sobol sequences instead of uniform random sampling.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\nfrom scipy.stats import qmc\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        # Using Sobol sequences for initial population\n        sampler = qmc.Sobol(d=self.dim)\n        population = qmc.scale(sampler.random_base2(m=int(np.ceil(np.log2(population_size)))), bounds[:, 0], bounds[:, 1])\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 68, "feedback": "An exception occurred: IndexError('boolean index did not match indexed array along dimension 0; dimension is 16 but corresponding boolean dimension is 12').", "error": "IndexError('boolean index did not match indexed array along dimension 0; dimension is 16 but corresponding boolean dimension is 12')", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {}}
{"id": "be507ec2-cb82-47f9-bb18-b42da59200c1", "fitness": 0.10423218398213988, "name": "RefinedHybridDE_CMA", "description": "Introduce a self-adaptive mutation strategy in DE and incorporate a covariance matrix adaptation mechanism for enhanced exploration.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.normal(0, 0.1, self.dim) * (local_best - population[i])  # Gaussian perturbation\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 69, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10423 with standard deviation 0.03651.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.08710252194151769, 0.0959801347990924, 0.13296832637052425, 0.06535426858100635, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "6770b9f8-75e2-4d12-9ec6-887d9ec0e612", "fitness": 0.0951256498885337, "name": "RefinedHybridDE_CMA", "description": "Enhance diversity through adaptive crossover probability dynamically adjusted based on success rate.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.2 * (success_de / (success_de + success_cma + 1))  # Adjusted line\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 70, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09513 with standard deviation 0.03932.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.06358146959917033, 0.08242597842834076, 0.11474948792697004, 0.0513602976510209, 0.05979700303123947, 0.051587925205093255, 0.14875041363257313, 0.13669226230034714, 0.14718601122204822]}}
{"id": "5bce2fa1-8cbe-4d95-9e84-e04196f67785", "fitness": 0.10213307012873205, "name": "AdaptiveHybridDE_CMA", "description": "Utilize adaptive learning strategies for hybrid optimization by dynamically adjusting exploration and exploitation in DE and CMA-ES based on performance metrics to improve convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = max(2, population_size // 2)\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 71, "feedback": "The algorithm AdaptiveHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "d737fa8d-3d85-40a2-ad95-f00024b455cb", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Incorporate a dynamic adjustment to the mutation scale based on the current generation to enhance global exploration.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 72, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "a8e93af8-a3b7-4479-b267-5fafbfc6bb3c", "fitness": 0.09802408881803278, "name": "RefinedHybridDE_CMA", "description": "Enhance diversity by dynamically adjusting the immigrant rate based on the stagnation duration in the optimization process.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * (0.1 + 0.05 * (adap_counter // 10))))  # Adjusted line\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 73, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09802 with standard deviation 0.04069.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0722899509721634, 0.06640164915094382, 0.13453741522306217, 0.05657062094085308, 0.057532560024577406, 0.05761264037382208, 0.1489285008671789, 0.14968682527715615, 0.138656636532538]}}
{"id": "fab4eb05-44ba-41a0-82df-b0c9d990c154", "fitness": 0.10214926086622805, "name": "RefinedHybridDE_CMA", "description": "Introduce adaptive mutation scaling based on the best individual's improvement to enhance search dynamics.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            de_scale *= (1 + (previous_best_fitness - np.min(fitness)) / (np.abs(previous_best_fitness) + 1e-10))  # Newly adjusted line\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 74, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10215 with standard deviation 0.03828.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.06844582918349029, 0.09627332376595099, 0.13453944030780152, 0.06340035039169156, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "cbbce7aa-7c2c-4b87-b8a2-ef1c6c091097", "fitness": 0.10219605480479556, "name": "EnhancedNichingDE_CMA", "description": "Integrate niching and local search strategies dynamically to improve diversity and convergence rate in high-dimensional problem spaces.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedNichingDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                niche_radius = 0.1 * (1 - adap_state)  # Dynamic niche radius\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < niche_radius)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedNichingDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10220 with standard deviation 0.03807.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.06898413463683783, 0.09761402501584548, 0.1330746767085571, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "38259ebc-acfa-4dc3-8800-0bb4fd33e08f", "fitness": 0.10199388053201836, "name": "AdaptiveNichingDE_CMA", "description": "Incorporate adaptive niching and dynamic local search to enhance exploration-exploitation balance in high-dimensional optimization.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveNichingDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niche_indices = np.where(distances[i] < 0.1)[0]\n                        niche_best = niche_indices[np.argmin(fitness[niche_indices])]\n                        diversity_preserved[niche_indices] = True\n                        diversity_preserved[niche_best] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n            for i in range(population_size):\n                neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                if len(neighborhood_indices) > 1:\n                    local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                    step = np.random.uniform(-0.5, 0.5, self.dim) * (population[i] - local_best)\n                    new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                    new_fitness = func(new_solution)\n                    evaluations += 1\n                    if new_fitness < fitness[i]:\n                        population[i] = new_solution\n                        fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveNichingDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10199 with standard deviation 0.03818.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.06941955308157677, 0.0959207092051213, 0.13335488881564772, 0.06256536953870118, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "455a8cf6-43e9-406e-bc9e-659154e94415", "fitness": 0.10308410322490325, "name": "EnhancedHybridDE_CMA", "description": "Integrate an adaptive local search phase that dynamically adjusts exploration and exploitation based on solution diversity to improve convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            adapt_factor = 1.0 if success_de > success_cma else 0.9\n            cma_sigma *= adapt_factor\n            de_scale *= adapt_factor\n\n            if adap_counter % 15 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 7 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10308 with standard deviation 0.03792.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.07254568032482167, 0.09709077633024765, 0.13659824796095588, 0.06483782026098583, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "35037de2-c6cf-4ab6-b006-0258fc228402", "fitness": 0.09530309550077552, "name": "EnhancedHybridDE_CMA", "description": "Enhance population diversity and convergence by dynamically adjusting mutation strategies based on search progress, employing niching and multi-modal exploration tactics.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        adap_counter = 0\n        restart_threshold = 1e-6\n        success_de = 0\n        success_cma = 0\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.2 + 0.3 * (1 - adap_state) * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.5 + 0.4 * np.sin(np.pi * adap_state)\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                de_scale *= 0.95\n            else:\n                cma_population_size = int(cma_population_size * 1.05)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_threshold = np.mean(distances) * 0.5\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < diversity_threshold)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.2 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09530 with standard deviation 0.04091.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.08370025873026388, 0.06284874567925747, 0.12578058080669685, 0.048922171516020074, 0.05213167247341599, 0.05343655109088019, 0.15278835977698668, 0.14371346286848297, 0.13440605656497562]}}
{"id": "5939e069-03f2-436d-8973-5abca1477f72", "fitness": 0.09982382290623443, "name": "EnhancedAdaptiveDE_CMA", "description": "Incorporate adaptive scaling and crossover strategies based on problem difficulty to enhance convergence in diverse optimization landscapes.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedAdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.7\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.2 + 0.5 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.5 + 0.4 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.4 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.85\n            else:\n                de_scale *= 0.85\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedAdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09982 with standard deviation 0.03717.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.07955533606267662, 0.09391837689777105, 0.12256688101541813, 0.061247492867650966, 0.051942042577873604, 0.05729471440407763, 0.13985737451963076, 0.14358076612219373, 0.1484514216888173]}}
{"id": "68ee909a-f515-4623-94f9-2744784557e7", "fitness": 0.10213307012873205, "name": "AdaptivePopulationDE_CMA", "description": "Introduce an adaptive population size mechanism and enhanced mutation strategy to improve diversity and convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptivePopulationDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        initial_population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = initial_population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = initial_population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (initial_population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(initial_population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(initial_population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / initial_population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(initial_population_size, dtype=bool)\n                for i in range(initial_population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = initial_population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(initial_population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (initial_population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += initial_population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 80, "feedback": "The algorithm AdaptivePopulationDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "c3b6c6ec-0d33-458a-b9a0-0fbc9bd490c6", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Add dimension-dependent scaling to enhance DE strategy efficiency for varied problem sizes.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5 + 0.1 * (self.dim > 20)  # Adjusted line\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 81, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "dfd10932-82e4-4aa7-afd1-4f1849b10225", "fitness": 0.1030029700824719, "name": "RefinedHybridDE_CMA", "description": "Increase local exploration by enhancing local exploit rate adjustment for better niche exploration.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.2 * (1 - adap_state)  # Adjusted line\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 82, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10300 with standard deviation 0.03783.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.07333803015164164, 0.09612895492213325, 0.13611314604251246, 0.06476219547884166, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "fcb97a6b-821a-4b5d-b493-cf54c3fd1a5a", "fitness": -Infinity, "name": "RefinedHybridDE_CMA_Adaptive", "description": "Refine crossover strategy and introduce adaptive population size adjustments based on fitness improvement to enhance convergence efficiency.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        initial_population_size = 4 + int(3 * np.log(self.dim))\n        population_size = initial_population_size\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if success_de > 0.2 * population_size:\n                population_size = min(2 * initial_population_size, population_size + 5)\n            elif success_de < 0.05 * population_size:\n                population_size = max(initial_population_size // 2, population_size - 5)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 83, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {}}
{"id": "e2910bb1-1b53-4015-ae59-f99bdb77f484", "fitness": 0.09284894608107395, "name": "AdaptiveHybridDE_CMA", "description": "Incorporate dynamic adjustment of exploration and exploitation phases through an adaptive feedback mechanism to enhance convergence in varying problem landscapes.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.7 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.4 + 0.5 * (1 - adap_state)\n            cma_sigma = 0.5 + 0.3 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.2 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 84, "feedback": "The algorithm AdaptiveHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09285 with standard deviation 0.03808.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.07191175702531583, 0.03940622363052937, 0.12457273655490209, 0.06457468458138416, 0.060550241296948415, 0.062338340536349346, 0.13991684045553843, 0.13726107234752905, 0.13510861830116894]}}
{"id": "b895fa70-37e0-48d6-a4ae-8cae3b1bfb1f", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Incorporate a diversity preservation mechanism based on crowding distance to enhance exploration and maintain diversity in the population.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                crowding_distances = np.sum(distances, axis=1)\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 85, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "d94dfc18-ccb2-4564-b9ac-33fa8ff09adc", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Introduces adaptive mutation scaling based on the current best fitness improvement to enhance convergence speed.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n                de_scale = max(de_scale * 1.05, 0.1)  # Adaptive mutation scaling line\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 86, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "0b1636b1-3206-42a8-a61c-af8751097581", "fitness": 0.10213307012873205, "name": "EnhancedNichingDE_CMA", "description": "Introduce an adaptive niching strategy with differential evolution and CMA-ES to maintain diversity and improve convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedNichingDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedNichingDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "2100c246-d134-4b8b-bd0d-f8512b0be540", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Introduce a dynamic strategy to adaptively adjust the mutation scaling factor based on success rates to enhance exploration.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                de_scale *= 0.95  # Adjusted line: dynamic strategy for mutation scaling\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 88, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "e0183d15-3804-41a7-9116-ca136f29da38", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Enhance diversity by adjusting mutation strategy based on success rate of DE and CMA to maintain balance.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 89, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "d6435888-039d-4ede-a44d-4c7f994e641a", "fitness": 0.10401042872027176, "name": "EnhancedHybridDE_CMA", "description": "Introduce adaptive local search intensity based on fitness variance to improve convergence speed and maintain diversity.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.2 * (1 - adap_state) * (1 - fitness_variance / (1e-5 if fitness_variance < 1e-5 else fitness_variance))\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-0.5, 0.5, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10401 with standard deviation 0.03858.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.07475287524801966, 0.09616411913314249, 0.14403376048248628, 0.06445869947167926, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "57703c43-f290-48df-bb22-ec650618cb29", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Introduce adaptive immigrant strategy to enhance diversity and convergence in DE-CMA hybrid algorithm.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)  # Adjusted line\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1 * adap_state))  # Adjusted line\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 91, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "027ca754-76c6-4ddb-a6d3-4fd26846fd61", "fitness": -Infinity, "name": "AdaptiveRefinedHybridDE_CMA", "description": "Introduce adaptive population resizing and stochastic ranking to balance exploration-exploitation dynamically for improved convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass AdaptiveRefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        max_pop_size = 4 + int(3 * np.log(self.dim))\n        min_pop_size = 4\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = max_pop_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (max_pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = max_pop_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            pop_size = min_pop_size + int((max_pop_size - min_pop_size) * (1 - (evaluations / self.budget)))\n            population = population[:pop_size]\n            fitness = fitness[:pop_size]\n\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (pop_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(pop_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(pop_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / pop_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(pop_size, dtype=bool)\n                for i in range(pop_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = pop_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(pop_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (max_pop_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += max_pop_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 92, "feedback": "An exception occurred: IndexError('index 6 is out of bounds for axis 0 with size 6').", "error": "IndexError('index 6 is out of bounds for axis 0 with size 6')", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {}}
{"id": "0cfb10b3-16d2-4d74-8363-c672767d64e9", "fitness": 0.16760538587016072, "name": "RefinedHybridDE_CMA", "description": "Incorporate adaptive mutation scaling based on diversity metrics to enhance exploration in dynamic landscapes.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                # Change: Adaptive scaling of de_scale based on population diversity\n                de_scale *= 0.9 + 0.1 * np.log(1 + fitness_variance)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 93, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16761 with standard deviation 0.17700.", "error": "", "parent_ids": ["7e9871bd-9ff1-4211-bab9-45814006d1b2"], "operator": null, "metadata": {"aucs": [0.6575420753339216, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "fc066c2f-32cb-4b8b-b430-db565cbbeca3", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Introduce a diversity-centric restart strategy by triggering restarts based on a more dynamic diversity measure.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9 + 0.1 * np.log(1 + fitness_variance)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            # Updated line: Trigger restarts based on dynamic diversity measure\n            if (fitness_variance < restart_threshold or np.mean(pdist(population)) < 0.1) and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 94, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["0cfb10b3-16d2-4d74-8363-c672767d64e9"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "9e53c2b8-5525-4db9-811f-c4f182d2fa7d", "fitness": 0.10217345611507254, "name": "RefinedHybridDE_CMA", "description": "Introduce a slight change to the adaptive scaling of `cma_sigma` based on fitness variance to enhance convergence stability.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state + 0.05 * np.log(1 + np.var(fitness))\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9 + 0.1 * np.log(1 + fitness_variance)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 95, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10217 with standard deviation 0.03825.", "error": "", "parent_ids": ["0cfb10b3-16d2-4d74-8363-c672767d64e9"], "operator": null, "metadata": {"aucs": [0.06778160263530708, 0.09627335587473018, 0.13454146334572814, 0.06428423215433343, 0.05721393768476257, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "9ec3ee70-d41a-4838-bc4c-800c28f42cd5", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Implement a dual-phase strategy alternating between Differential Evolution and Covariance Matrix Adaptation, utilizing adaptive niching and local exploitation to maintain diversity and enhance convergence.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9 + 0.1 * np.log(1 + fitness_variance)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 96, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["0cfb10b3-16d2-4d74-8363-c672767d64e9"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "6680f410-b521-4e69-bd44-e8ba8fdebd3a", "fitness": 0.10213307012873205, "name": "RefinedHybridDE_CMA", "description": "Enhance mutation scaling by incorporating dynamic adjustment based on fitness variance to improve exploration.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass RefinedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9 + 0.1 * np.log1p(fitness_variance)  # Change: enhanced adaptive scaling based on fitness variance\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 97, "feedback": "The algorithm RefinedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["0cfb10b3-16d2-4d74-8363-c672767d64e9"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "b5ecf140-f755-4c7b-99e6-21d5dfaf669f", "fitness": 0.10213307012873205, "name": "EnhancedHybridDE_CMA", "description": "Integrate dynamic niching strategies with adaptive recombination to maintain population diversity and enhance local exploitation. ", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9 + 0.1 * np.log(1 + fitness_variance)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < 0.1)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10213 with standard deviation 0.03829.", "error": "", "parent_ids": ["0cfb10b3-16d2-4d74-8363-c672767d64e9"], "operator": null, "metadata": {"aucs": [0.0682912336610636, 0.09627335587473018, 0.13454138474087507, 0.06340725273480141, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
{"id": "d1328379-88c2-4535-8621-9ada704e8725", "fitness": 0.10235401222343142, "name": "EnhancedHybridDE_CMA", "description": "Introduce adaptive niching strategies to maintain population diversity and further improve convergence in varied landscapes.", "code": "import numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        population_size = 4 + int(3 * np.log(self.dim))\n        de_scale = 0.5\n        crossover_rate = 0.9 - 0.4 * (self.dim > 20)\n        cma_population_size = population_size // 2\n        cma_sigma = 0.5\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = population_size\n        previous_best_fitness = np.min(fitness)\n\n        success_de = 0\n        success_cma = 0\n        adap_counter = 0\n        restart_threshold = 1e-6\n\n        while evaluations < self.budget:\n            adap_state = (self.budget - evaluations) / self.budget\n            de_scale = 0.1 + 0.4 * adap_state * (success_de / (population_size if success_de > 0 else 1))\n            crossover_rate = 0.6 + 0.3 * (1 - adap_state)\n            cma_sigma = 0.3 + 0.2 * adap_state\n\n            num_immigrants = max(1, int(population_size * 0.1))\n            immigrants = np.random.uniform(bounds[:, 0], bounds[:, 1], (num_immigrants, self.dim))\n            pop_with_immigrants = np.vstack((population, immigrants))\n            fitness_with_immigrants = np.concatenate([fitness, np.array([func(ind) for ind in immigrants])])\n            evaluations += num_immigrants\n\n            success_de = 0\n            for i in range(population_size):\n                indices = np.random.choice(len(pop_with_immigrants), 3, replace=False)\n                a, b, c = pop_with_immigrants[indices]\n                mutant = np.clip(a + de_scale * (b - c), bounds[:, 0], bounds[:, 1])\n                crossover = np.random.rand(self.dim) < crossover_rate\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    success_de += 1\n\n            current_best_fitness = np.min(fitness)\n            fitness_variance = np.var(fitness)\n            if current_best_fitness < previous_best_fitness:\n                previous_best_fitness = current_best_fitness\n\n                if fitness_variance < 1e-5 or success_de / population_size < 0.1:\n                    best_indices = np.argsort(fitness)[:cma_population_size]\n                    cma_population = population[best_indices]\n                    cma_mean = np.mean(cma_population, axis=0)\n                    cma_cov = np.cov(cma_population.T) + 1e-8 * np.eye(self.dim)\n                    cma_samples = np.random.multivariate_normal(cma_mean, cma_sigma**2 * cma_cov, cma_population_size)\n                    success_cma = 0\n\n                    for sample in cma_samples:\n                        sample = np.clip(sample, bounds[:, 0], bounds[:, 1])\n                        sample_fitness = func(sample)\n                        evaluations += 1\n\n                        if sample_fitness < np.max(fitness):\n                            worst_index = np.argmax(fitness)\n                            population[worst_index] = sample\n                            fitness[worst_index] = sample_fitness\n                            success_cma += 1\n\n                        if evaluations >= self.budget:\n                            break\n\n            if success_de > success_cma:\n                cma_sigma *= 0.9\n            else:\n                de_scale *= 0.9 + 0.1 * np.log(1 + fitness_variance)\n\n            if adap_counter % 10 == 0:\n                distances = squareform(pdist(population))\n                niche_radius = 0.1 + 0.1 * (1 - adap_state)\n                diversity_preserved = np.zeros(population_size, dtype=bool)\n                for i in range(population_size):\n                    if not diversity_preserved[i]:\n                        niching_indices = np.where(distances[i] < niche_radius)[0]\n                        best_in_niche = niching_indices[np.argmin(fitness[niching_indices])]\n                        diversity_preserved[niching_indices] = True\n                        diversity_preserved[best_in_niche] = False\n                population = population[~diversity_preserved]\n                fitness = fitness[~diversity_preserved]\n                missing_count = population_size - len(population)\n                new_individuals = np.random.uniform(bounds[:, 0], bounds[:, 1], (missing_count, self.dim))\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, [func(ind) for ind in new_individuals]))\n                evaluations += missing_count\n\n            if adap_counter % 5 == 0:\n                local_exploit_rate = 0.1 + 0.1 * (1 - adap_state)\n                for i in range(population_size):\n                    neighborhood_indices = np.where(distances[i] < local_exploit_rate)[0]\n                    if len(neighborhood_indices) > 1:\n                        local_best = population[neighborhood_indices[np.argmin(fitness[neighborhood_indices])]]\n                        step = np.random.uniform(-1, 1, self.dim) * (population[i] - local_best)\n                        new_solution = np.clip(population[i] + step, bounds[:, 0], bounds[:, 1])\n                        new_fitness = func(new_solution)\n                        evaluations += 1\n                        if new_fitness < fitness[i]:\n                            population[i] = new_solution\n                            fitness[i] = new_fitness\n\n            if fitness_variance < restart_threshold and adap_counter % 20 == 0:\n                population = np.random.uniform(bounds[:, 0], bounds[:, 1], (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                evaluations += population_size\n\n            adap_counter += 1\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedHybridDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10235 with standard deviation 0.03807.", "error": "", "parent_ids": ["0cfb10b3-16d2-4d74-8363-c672767d64e9"], "operator": null, "metadata": {"aucs": [0.07030834114153783, 0.09607000247269071, 0.13447949239399415, 0.06364386985554193, 0.057217890806326666, 0.061706121546327264, 0.1489285008671789, 0.14947161623966343, 0.1393602746876219]}}
