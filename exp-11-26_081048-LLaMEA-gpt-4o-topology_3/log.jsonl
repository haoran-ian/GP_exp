{"id": "9b3f2d99-2115-4f2b-8f2c-eaff84ed8272", "fitness": 0.11716289384388226, "name": "HybridDEALS", "description": "Hybrid Differential Evolution with Adaptive Local Search for efficient exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(self.local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.05.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.16811878806607905, 0.14616026732591159, 0.13338908870990152, 0.16159211009577068, 0.143410542559692, 0.1459837997260668, 0.13819982443464496, 0.1886753781860091, 0.12269806010240425, 0.12063227985998481, 0.14350975993628134, 0.15510266113719084, 0.1458188005069504, 0.12628545742643826, 0.13588216392985342]}}
{"id": "aca37c34-f069-444c-9f58-e8c39054d926", "fitness": 0.11359040488698373, "name": "HybridDEALS", "description": "Hybrid Differential Evolution with Adaptive Local Search and Mutation Rate Adjustment for efficient exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.5 * np.random.rand()  # Adjusted differential weight\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(self.local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.05.", "error": "", "parent_ids": ["9b3f2d99-2115-4f2b-8f2c-eaff84ed8272"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.18653063655388114, 0.17185628915351514, 0.14107262900828055, 0.13143079690043546, 0.13903650603777584, 0.12178841862294065, 0.14621281483797877, 0.1222297595667301, 0.12387626124307816, 0.13311903013628712, 0.12397691733335647, 0.11302137715838456, 0.1432049837956757, 0.18723234119463406, 0.11942044132225471]}}
{"id": "8da320eb-bb59-4e60-80e8-52e33af4a457", "fitness": 0.4132492322765923, "name": "HybridDEALS", "description": "Enhanced Hybrid Differential Evolution with Adaptive Local Search, incorporating a dynamic crossover probability to improve convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(self.local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 2, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.24.", "error": "", "parent_ids": ["9b3f2d99-2115-4f2b-8f2c-eaff84ed8272"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4581186623149637, 0.6099334917254775, 0.4762998569144977, 0.5221534315922582, 0.46615310972109647, 0.6704845739393477, 0.7837468616654029, 0.5967729986355095, 0.4235465546783387, 0.578106956177828, 0.44352780360771726, 0.7495703997158095, 0.4614794128984703, 0.43265382380490414, 0.4246378132657589]}}
{"id": "c3bbf72e-8c3c-40dc-9a41-5d4bbaa0f98f", "fitness": 0.4218697661587039, "name": "HybridDEALS", "description": "Refined HybridDEALS with improved local search strategy using dynamic intensity based on convergence progress.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 3, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.24.", "error": "", "parent_ids": ["8da320eb-bb59-4e60-80e8-52e33af4a457"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6437952541145664, 0.4185519914846755, 0.5475925770058774, 0.49800089114386525, 0.5358343361879412, 0.6704845739393477, 0.5438626895103857, 0.5967030734600626, 0.4235465546783387, 0.5911289629470314, 0.45232535493660186, 0.7495363120769987, 0.4915798325044598, 0.46136090268298946, 0.6452931216264701]}}
{"id": "160ae145-2450-4e53-b76a-e2e2e8bddd60", "fitness": 0.366026519768469, "name": "HybridDEALS", "description": "Enhanced HybridDEALS by dynamically adjusting the differential weight F based on the evaluation progress to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.5 * (self.eval_count / self.budget)  # Dynamic differential weight\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.20.", "error": "", "parent_ids": ["c3bbf72e-8c3c-40dc-9a41-5d4bbaa0f98f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4326125345457901, 0.537458114303846, 0.4593593159872439, 0.6547030261337385, 0.5569092531842547, 0.4267322835160111, 0.4720724031260962, 0.5127454513876932, 0.41117297030110267, 0.42913401691683095, 0.5297817836255295, 0.3467148306899984, 0.3428604350264818, 0.45907110739739243, 0.5814039743529047]}}
{"id": "9d9da734-639f-43c9-8f15-1036485539c2", "fitness": 0.366026519768469, "name": "HybridDEALS", "description": "Enhanced HybridDEALS by incorporating dynamic differential weight adjustment for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.5 * (self.eval_count / self.budget)  # Dynamic differential weight\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 5, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.20.", "error": "", "parent_ids": ["c3bbf72e-8c3c-40dc-9a41-5d4bbaa0f98f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4326125345457901, 0.537458114303846, 0.4593593159872439, 0.6547030261337385, 0.5569092531842547, 0.4267322835160111, 0.4720724031260962, 0.5127454513876932, 0.41117297030110267, 0.42913401691683095, 0.5297817836255295, 0.3467148306899984, 0.3428604350264818, 0.45907110739739243, 0.5814039743529047]}}
{"id": "b5b7191d-45a5-4fee-bfaf-fdad04aad285", "fitness": 0.418184567372254, "name": "HybridDEALS", "description": "Improved HybridDEALS with adaptive population size reduction to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        \n        while self.eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n            # Reduce population size adaptively\n            self.population_size = max(2, self.population_size - int(self.population_size * 0.01))\n\n        return best_solution", "configspace": "", "generation": 6, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.24.", "error": "", "parent_ids": ["c3bbf72e-8c3c-40dc-9a41-5d4bbaa0f98f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5071754216897486, 0.551738265954641, 0.48459151475848283, 0.4899795400948149, 0.5454615501089675, 0.4866520564360852, 0.5209320770104473, 0.5760623700451772, 0.5272453229647687, 0.8850162956093067, 0.5488421232292049, 0.531376105791389, 0.5421885301759872, 0.5506164807149532, 0.44801479798664035]}}
{"id": "051bf5b9-5cca-4a09-a677-d8718fbc8bfc", "fitness": 0.4549493968933021, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with adaptive population resizing to boost exploration in the early stages and exploitation in the later stages.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 7, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_ids": ["c3bbf72e-8c3c-40dc-9a41-5d4bbaa0f98f"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6128294800177808, 0.5291905424275141, 0.5554055409136844, 0.6580268233621802, 0.8343626947717758, 0.5095242763682031, 0.49514884034802586, 0.619844304834092, 0.9241325494989683, 0.4537091054140451, 0.5636349910327533, 0.5423505044412564, 0.5199533540445453, 0.5452795184704492, 0.5677965170463026]}}
{"id": "c532212b-886a-4826-aaa9-39c8e8eae6ea", "fitness": 0.37590514632886546, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with dynamic mutation strategy to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.4 * (1 - self.eval_count / self.budget)  # Dynamic mutation strategy\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 8, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.21.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5941357708361391, 0.5769209196343672, 0.6561517880449137, 0.4719990606360619, 0.48137178175904183, 0.3732888165403565, 0.39806338713249323, 0.4536387443053843, 0.45134415118697135, 0.5268156389940507, 0.4483827316035851, 0.5465092171318109, 0.4932231173330156, 0.40518285733067905, 0.4732760492339725]}}
{"id": "55dde01d-dcfb-4eb6-9217-5e2cd853ef19", "fitness": 0.3989697231456734, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with adaptive mutation scaling based on fitness diversity to improve convergence rate.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                # Adaptive mutation scaling based on fitness diversity\n                self.F = 0.5 + 0.5 * np.std(fitness) / np.mean(fitness)  \n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 9, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.23.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4912008840693305, 0.5022621759368526, 0.46521423410865437, 0.638208362405956, 0.5153161147666494, 0.4843093455033254, 0.40878911116620575, 0.46499314963081584, 0.5087061673477111, 0.818501590439199, 0.5383253127795962, 0.43229331700338536, 0.5334282139516503, 0.5756148145044977, 0.43443277442517436]}}
{"id": "cc11ae76-d3e7-4ffd-870a-213f884a2e77", "fitness": 0.43865906383787434, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with adaptive mutation strategy to improve diversity and convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                dynamic_F = self.F + 0.2 * (1 - self.eval_count / self.budget)  # Adaptive F\n                mutant = np.clip(x1 + dynamic_F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 10, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5769816199663977, 0.5571082720435232, 0.7259501536383791, 0.5806024693958474, 0.692735397629258, 0.49284875521100235, 0.415528645412378, 0.5075492639338413, 0.43432603042599593, 0.9642787499900938, 0.5292540840860114, 0.6223670056868563, 0.6052610847402079, 0.4565953536158157, 0.4439954961074133]}}
{"id": "9b5ecc42-e067-445a-b482-ab2f129e1339", "fitness": 0.36630639970694634, "name": "HybridDEALS", "description": "Improved HybridDEALS by incorporating adaptive differential weight and enhancing mutation strategy for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            self.F = 0.4 + 0.5 * (1 - self.eval_count / self.budget)  # Adaptive Differential weight\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 11, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.20.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.516787988933435, 0.5038803510181276, 0.523429863010502, 0.5801832045059315, 0.5711676648957467, 0.4478017478187343, 0.4286857369885204, 0.4214830262070698, 0.4154569520432033, 0.44691835713547756, 0.43376172622969067, 0.4386232895156542, 0.5193192420378308, 0.4255392187395818, 0.4852907301849553]}}
{"id": "c95a809b-521c-4ea1-a01e-56cf9465a12d", "fitness": 0.12783149643978817, "name": "HybridDEALS", "description": "Refine crossover probability to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 + 0.2 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability adjustment\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 12, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.06.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.15412224482976644, 0.17813753439132318, 0.15907600498151542, 0.14908797102856608, 0.15133270227720386, 0.2032159456431082, 0.13388253253950289, 0.14562768467162568, 0.19964729591676733, 0.13238818185608558, 0.12778747608542917, 0.19575762804990182, 0.15372392104856958, 0.13792506275657412, 0.16711884784535724]}}
{"id": "acdccb0f-d644-4d05-b18e-de665669285c", "fitness": 0.20346078012820526, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with adaptive learning rates and strategic local search for improved convergence efficiency.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n        self.learning_rate = 0.1  # New parameter for adaptive learning rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))\n            population = population[:self.population_size]\n            \n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 + 0.2 * np.random.rand() * (1 - self.eval_count / self.budget)  # Refined dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, self.learning_rate, self.dim)  # Changed learning rate for local adjustments\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 13, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1632905813144634, 0.16124955645364725, 0.15375274922806625, 0.1843746145765507, 0.6364690667498002, 0.15387483236585275, 0.9013833479190095, 0.1533770714617343, 0.27556085140133135, 0.20031886701343937, 0.1283648002097031, 0.32197397752600565, 0.18120770898294702, 0.14415148467800132, 0.1420671978090865]}}
{"id": "8458d983-732f-41f5-93b1-29f0d1c1cfd4", "fitness": 0.41091817506180595, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with dynamic mutation factor scaling to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.5 * (self.eval_count / self.budget)  # Dynamic mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 14, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.23.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5017070757164344, 0.575709338446847, 0.5742909467771831, 0.45304309691330225, 0.5726403545694638, 0.49933509056081815, 0.44453919405376696, 0.4321693869031267, 0.4871140451830914, 0.64774770498395, 0.5892147499262204, 0.5809520783459339, 0.48339368643850256, 0.7272095821400473, 0.48149827540296475]}}
{"id": "54c4b234-43e1-4d54-a278-85226acb12b8", "fitness": 0.41091817506180595, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with dynamic mutation factor to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.5 * (self.eval_count / self.budget)  # Dynamic mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 15, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.23.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5017070757164344, 0.575709338446847, 0.5742909467771831, 0.45304309691330225, 0.5726403545694638, 0.49933509056081815, 0.44453919405376696, 0.4321693869031267, 0.4871140451830914, 0.64774770498395, 0.5892147499262204, 0.5809520783459339, 0.48339368643850256, 0.7272095821400473, 0.48149827540296475]}}
{"id": "b763a3ab-67c3-41df-aea2-463a303d0d28", "fitness": 0.39454233384636006, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with improved adaptive mutation strategy for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.4 * (self.eval_count / self.budget)  # Dynamic differential weight\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 16, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.21.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5751372567728232, 0.5919621162135699, 0.480446264392419, 0.5526382165538493, 0.5502812791061371, 0.5413565334084665, 0.5570620031930034, 0.468286792900547, 0.49734210205789986, 0.4791297561927731, 0.4509755053096327, 0.4239430953064607, 0.46392304312503974, 0.4591027761396007, 0.6314610413805118]}}
{"id": "1f389dc4-2237-4f4a-87df-2284cd4a01e1", "fitness": 0.4461078838678184, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with improved mutation strategy to increase diversity and solution quality.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3) + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)  # Slightly modified mutation strategy\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 17, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.24.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6140279038606542, 0.5299054000412096, 0.48951984511501845, 0.589206626392234, 0.5701810989326559, 0.5728947734935002, 0.502416731002526, 0.6713486033392897, 0.6183062106116521, 0.709035827666028, 0.4933449808636827, 0.6733774614125926, 0.567971619193584, 0.6002538719583924, 0.5525678285988823]}}
{"id": "b0c71545-9d87-4155-9ff4-67e533bc3859", "fitness": 0.41091817506180595, "name": "HybridDEALS", "description": "Enhanced HybridDEALS by making the differential weight dynamically adaptive to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.5 * (self.eval_count / self.budget)  # Dynamic differential weight\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - self.eval_count / self.budget)  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 18, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.23.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.5017070757164344, 0.575709338446847, 0.5742909467771831, 0.45304309691330225, 0.5726403545694638, 0.49933509056081815, 0.44453919405376696, 0.4321693869031267, 0.4871140451830914, 0.64774770498395, 0.5892147499262204, 0.5809520783459339, 0.48339368643850256, 0.7272095821400473, 0.48149827540296475]}}
{"id": "fa941a3a-113f-4576-9e0a-eb639fba3a4e", "fitness": 0.6180584419493084, "name": "HybridDEALS", "description": "Enhanced HybridDEALS with improved dynamic crossover probability scaling for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 19, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.34.", "error": "", "parent_ids": ["051bf5b9-5cca-4a09-a677-d8718fbc8bfc"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7651514489398221, 0.8063286266310549, 0.7202054768205559, 0.7762986319189211, 0.718089328589268, 0.8145271440297936, 0.871641473899502, 0.7307533266954349, 0.9412648947738929, 0.807014089138899, 0.8199910198385503, 0.8525783106242333, 0.8561114195726102, 0.9416894357357065, 0.7717253169034557]}}
{"id": "a9037c92-37aa-4498-84fe-a49ba925085a", "fitness": 0.4472679048149583, "name": "HybridDEALS", "description": "Improved HybridDEALS with adaptive mutation strategy and dynamic crossover probability for better search efficiency.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                # Adaptive mutation strategy\n                adaptive_F = 0.4 + 0.3 * np.random.rand()  # Adapt F dynamically\n                mutant = np.clip(x1 + adaptive_F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - np.exp(-3 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 20, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.37.", "error": "", "parent_ids": ["fa941a3a-113f-4576-9e0a-eb639fba3a4e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7900263778821236, 0.20395104569039557, 0.18721427995410023, 0.7664561811846441, 0.26172065580266757, 0.16218374910458377, 0.8230323160335656, 0.5119387238794095, 0.9823448702078071, 0.8622383659028979, 0.1763488280077149, 0.24118151167945323, 0.9216118921306119, 0.9824427463966651, 0.9048676575680609]}}
{"id": "f17ff023-27d5-48f9-b2bf-505dcb1c6c40", "fitness": 0.6243502917722439, "name": "HybridDEALS", "description": "HybridDEALS with adjusted mutation factor scaling for improved exploration in early stages.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 21, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["fa941a3a-113f-4576-9e0a-eb639fba3a4e"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8467808613881187, 0.6577718632779515, 0.7186478308982236, 0.8671816616442836, 0.8959899381940574, 0.7603893600696057, 0.8555088072895031, 0.9070675215288136, 0.8158830041351487, 0.8087130671664533, 0.8079357187346596, 0.8671016254876646, 0.7971800032563446, 0.9236741723029595, 0.7893815051966215]}}
{"id": "90d93cec-7512-48d1-9069-d31ab1c6abe3", "fitness": -Infinity, "name": "HybridDEALS", "description": "Enhanced local search by introducing adaptive Gaussian noise scaling based on fitness improvement.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        noise_scale = 0.1 * (1 - trial_fitness / best_fitness)  # Adaptive noise scaling\n                        local_candidate = trial + np.random.normal(0, noise_scale, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 22, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["f17ff023-27d5-48f9-b2bf-505dcb1c6c40"], "operator": null, "metadata": {}}
{"id": "5fbaaea6-20ff-4919-8f75-0c2e1d2f21e4", "fitness": 0.47871742620295665, "name": "HybridDEALS", "description": "Enhancing HybridDEALS by introducing a cooling schedule for mutation factor and dynamic crossover probability for better convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.4 * (1 - np.exp(-3 * self.eval_count / self.budget))  # Cooling schedule for mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * np.exp(-1.5 * self.eval_count / self.budget) + 0.1  # Dynamic crossover probability with a cooling effect\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 23, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_ids": ["f17ff023-27d5-48f9-b2bf-505dcb1c6c40"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6560911895008447, 0.6826639858906832, 0.517484868125251, 0.5383804008158619, 0.5992090727594959, 0.5655786566363215, 0.6551160479853955, 0.7612290806730716, 0.9742492173511228, 0.6921721029556451, 0.7110345959601785, 0.6129298290840963, 0.5180172480668133, 0.4637056905084117, 0.4586876428714729]}}
{"id": "b82e150d-fe8d-4222-904c-af730404dfe7", "fitness": 0.20391506676039972, "name": "HybridDEALS", "description": "Enhanced mutation and adaptive crossover to improve diversity and convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.3 * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 - 0.5 * np.exp(-3 * self.eval_count / self.budget)  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_ids": ["f17ff023-27d5-48f9-b2bf-505dcb1c6c40"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1676907134430594, 0.1665843480142658, 0.1719260046859159, 0.15612032967463985, 0.6491646507693637, 0.8323838159074649, 0.14487302006354208, 0.24293701884919483, 0.351740755686218, 0.17150439615452628, 0.18044305461806587, 0.14914137738653466, 0.16093207847753888, 0.21154082837199928, 0.1535200482311987]}}
{"id": "dff41581-e402-432a-a5ce-91a5aa896c5c", "fitness": 0.6410248747965375, "name": "HybridDEALS", "description": "Add randomness to the mutation factor for enhanced exploration.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 25, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["f17ff023-27d5-48f9-b2bf-505dcb1c6c40"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8018431059499467, 0.7889732872357634, 0.7688123805569429, 0.7799881175068127, 0.8627166113245808, 0.876247204818017, 0.7091461835019148, 0.8513727808293401, 0.9823423360293702, 0.9027960714034508, 0.8433626812375765, 0.8753029773327631, 0.8480554340366935, 0.9824108217555597, 0.7793286075375507]}}
{"id": "961b6c81-d87a-4c4d-b0cd-fdd9bf50f427", "fitness": 0.629844158771742, "name": "HybridDEALS", "description": "Introduce adaptive mutation factor decay for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget) ** 0.7  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 26, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6583589437715073, 0.8928225576898211, 0.6646046532275729, 0.8597452672720229, 0.7047225711127536, 0.8471641375884323, 0.8521445322663695, 0.8257818684654459, 0.9823423443444254, 0.8460903173649584, 0.8006118015150439, 0.8182318551677048, 0.8485280492796623, 0.9824108470928407, 0.8455245344018119]}}
{"id": "46c3346c-669a-4298-b1e2-562a43b9c3cf", "fitness": 0.6335064696210868, "name": "HybridDEALS", "description": "Incorporate adaptive scaling for local search intensity to refine exploration.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((1 - trial_fitness / self.budget) * 5)  # Modified line\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 27, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6860183660310146, 0.6637145016367222, 0.7892229652076282, 0.8306613004370105, 0.7892126312143611, 0.8043030336238627, 0.7845223060458897, 0.9047090861750557, 0.9823423360293702, 0.8421392081657981, 0.846228904925138, 0.810334105183264, 0.8629251137241197, 0.9824108217555597, 0.9235858173924745]}}
{"id": "58f3c1df-cff7-494a-a926-417a76dd36e7", "fitness": -Infinity, "name": "HybridDEALS", "description": "Enhance solution diversity by incorporating an elite selection mechanism.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n\n            # Elite selection mechanism\n            elite_population_size = max(1, int(0.1 * self.population_size))  # Select top 10% as elite\n            elite_indices = np.argsort(fitness)[:elite_population_size]\n            elite_population = population[elite_indices]\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 28, "feedback": "An exception occurred: IndexError('index 160 is out of bounds for axis 0 with size 160').", "error": "IndexError('index 160 is out of bounds for axis 0 with size 160')", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {}}
{"id": "34e05bf3-7b9a-4045-a215-20d8352037c0", "fitness": 0.601345253370604, "name": "HybridDEALS", "description": "Refine modulation of mutation factor and crossover probability to enhance convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.35 + 0.15 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.85 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 29, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.35.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6664946189582682, 0.686064238071082, 0.5479738784527726, 0.5984227896604689, 0.6687648832003823, 0.8886369925817059, 0.9238790717976797, 0.6770177811985698, 0.9823432671514465, 0.7419352643882895, 0.9211723363876437, 0.8487200712096271, 0.8184224399092989, 0.9824231199846972, 0.9068354195856824]}}
{"id": "4d676817-4fb6-4ac2-a28d-cca8196fd0b2", "fitness": -Infinity, "name": "HybridDEALS", "description": "Enhance local search via adaptive neighborhood scaling to improve exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_scale = 0.1 * (1 - trial_fitness / best_fitness)  # Line changed for adaptive local scaling\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_scale, self.dim)  # Line changed for adaptive local scaling\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 30, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {}}
{"id": "439b80b7-135f-4bb2-b106-36551e0ed0dd", "fitness": 0.6284785261598048, "name": "HybridDEALS", "description": "Adaptive mutation factor and enhanced local search to optimize exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 6)  # Slightly increased local search intensity\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 31, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.36.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8533290503717075, 0.864077284728812, 0.8037666446914986, 0.4769533247635376, 0.706540761836608, 0.8127446474859621, 0.7926455266969042, 0.8618867496088175, 0.9823436928210021, 0.8783444269348148, 0.7811037217425935, 0.8723665316486615, 0.874653532369638, 0.9824424005513117, 0.8585733320697598]}}
{"id": "8429d433-1884-4591-b30c-f010c77c5387", "fitness": 0.6388876473528564, "name": "HybridDEALS", "description": "Introduce adaptive differential weight scaling to improve convergence speed.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * (1 - fitness[i]/max(fitness)) * np.random.random()  # Adaptive differential weight scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 32, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8473818444656329, 0.8704121025917779, 0.7088584950316532, 0.7471257250063409, 0.7778477887973425, 0.8342952343834753, 0.6250537346795857, 0.8685650931394155, 0.9823426229289411, 0.9016476977615013, 0.86428088763743, 0.8986797800792196, 0.9116285637070186, 0.982411892394343, 0.7894225895789827]}}
{"id": "d4c1396b-a48e-4b34-8179-e5d62a7b2955", "fitness": 0.628507272869325, "name": "HybridDEALS", "description": "Add Gaussian noise to mutation factor for finer exploration control.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget) + np.random.normal(0, 0.1)  # Adjusted mutation factor with added Gaussian noise\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 33, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7312843484373828, 0.8032128411986381, 0.713261160974185, 0.9017267037051827, 0.8397876112808909, 0.830577648059968, 0.9121616260079581, 0.9099576630768256, 0.9102773002060476, 0.8416628765273064, 0.8463212460255805, 0.7684848828816596, 0.7526163463872937, 0.8649425971512883, 0.7760717105918261]}}
{"id": "66fc0038-edd9-486d-acf7-88490a437587", "fitness": 0.5961535004975924, "name": "HybridDEALS", "description": "Fine-tune mutation factor dynamics to enhance early-stage exploration and late-stage exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor with improved dynamics\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 34, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.34.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7266311311641783, 0.7537707329985452, 0.6922771103643632, 0.7527477060662111, 0.5894984034583965, 0.8007885448982104, 0.6853578146225294, 0.846358602085086, 0.9823448623984468, 0.8415890127190118, 0.7446714060826137, 0.8646498566349781, 0.6981837357962741, 0.9824427438171373, 0.7939594519714004]}}
{"id": "040480fd-9b67-4d77-a2ec-f174917099bf", "fitness": 0.6410248747965375, "name": "HybridDEALS", "description": "Introduced a dynamic mutation factor that decreases linearly with evaluations for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 35, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8018431059499467, 0.7889732872357634, 0.7688123805569429, 0.7799881175068127, 0.8627166113245808, 0.876247204818017, 0.7091461835019148, 0.8513727808293401, 0.9823423360293702, 0.9027960714034508, 0.8433626812375765, 0.8753029773327631, 0.8480554340366935, 0.9824108217555597, 0.7793286075375507]}}
{"id": "ba3bcab9-2df8-4f0f-9d7b-5fee47369286", "fitness": 0.6165456025710261, "name": "HybridDEALS", "description": "Introduce adaptive scaling for mutation factor randomness based on convergence rate.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - (best_fitness / np.mean(fitness)))  # Adaptive mutation factor based on convergence\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 36, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.37.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7794853645611127, 0.75291787256236, 0.7991146078512179, 0.22570353260679854, 0.8584188765630818, 0.8158548114766923, 0.8711960440031621, 0.8356980516794789, 0.9823419201009841, 0.8479083161428036, 0.8543340823572032, 0.8647098998989386, 0.8126876151189668, 0.9824098568231254, 0.8803323048001288]}}
{"id": "e1c2554c-b9db-46b3-aa76-28d53cb7a448", "fitness": 0.6410248747965375, "name": "HybridDEALS", "description": "Introduce an adaptive F and CR scaling towards convergence to enhance precision in later search stages.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 37, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8018431059499467, 0.7889732872357634, 0.7688123805569429, 0.7799881175068127, 0.8627166113245808, 0.876247204818017, 0.7091461835019148, 0.8513727808293401, 0.9823423360293702, 0.9027960714034508, 0.8433626812375765, 0.8753029773327631, 0.8480554340366935, 0.9824108217555597, 0.7793286075375507]}}
{"id": "bd5b3047-5898-4a87-9e60-3fd90eaf1f54", "fitness": 0.6410248747965375, "name": "HybridDEALS", "description": "Introduce adaptive scaling to the mutation factor based on the number of evaluations to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 38, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8018431059499467, 0.7889732872357634, 0.7688123805569429, 0.7799881175068127, 0.8627166113245808, 0.876247204818017, 0.7091461835019148, 0.8513727808293401, 0.9823423360293702, 0.9027960714034508, 0.8433626812375765, 0.8753029773327631, 0.8480554340366935, 0.9824108217555597, 0.7793286075375507]}}
{"id": "15eb1208-dc79-4c0c-b669-3cc4bcfbb82c", "fitness": 0.6182261875124905, "name": "HybridDEALS", "description": "Introduced adaptive local search scaling to enhance exploitation during the latter stages of optimization.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 7) # Increased scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 39, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.36.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4829117222409508, 0.7184546169223001, 0.6258758163800303, 0.6913277025572486, 0.8627166113245808, 0.876247204818017, 0.8031264821034265, 0.8415008118059902, 0.9823423360293702, 0.9027960714034508, 0.8432908705007015, 0.8753029773327631, 0.8480554340366935, 0.9824108217555597, 0.8603653761642605]}}
{"id": "52fd61c5-6eb6-4373-9b2a-4935ba51431c", "fitness": 0.6184596826209707, "name": "HybridDEALS", "description": "Enhance exploitation by dynamically adjusting both mutation factor variability and local search probability.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.25 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.15, self.dim)  # Increased local search probability\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 40, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.34.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8260343711373234, 0.8630822789187568, 0.8531205644700188, 0.7102028460894108, 0.692555562957997, 0.7863795638584, 0.8296855162333763, 0.8372992243332839, 0.8219229175621817, 0.8738286830031523, 0.8387420302448277, 0.7812247356921973, 0.8299056317332496, 0.8059678644289289, 0.8514429668818426]}}
{"id": "0bd01842-f619-4b0e-86a2-d7bd53eef2de", "fitness": 0.5810270640811206, "name": "HybridDEALS", "description": "Enhance exploration dynamics by introducing a dynamic scaling factor for trial vector generation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3) * (1 + 0.1 * np.random.randn()), self.lower_bound, self.upper_bound)  # Change: Added dynamic scaling factor\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, 0.1, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 41, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58 with standard deviation 0.32.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7978934572274343, 0.6221284617064512, 0.7077137622934777, 0.7992833899234717, 0.8455579876714945, 0.8696208016098489, 0.7761998014556507, 0.8417412103609296, 0.713528549307036, 0.7078140369938751, 0.7700124012865694, 0.8095050192247786, 0.7776946894622458, 0.740326920152546, 0.6737218980721382]}}
{"id": "61206c5c-191d-4510-8f68-f9259859a462", "fitness": 0.6474488275004259, "name": "HybridDEALS", "description": "Introduce an adaptive scaling factor for local search to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 42, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["dff41581-e402-432a-a5ce-91a5aa896c5c"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8018431059499467, 0.7889732872357634, 0.7688123805569429, 0.7799881175068127, 0.8627166113245808, 0.8762587528522066, 0.739952347149103, 0.8513973949334444, 0.9823422748115559, 0.9028130136318524, 0.8538115781581678, 0.8750796963764984, 0.8480937219112448, 0.9824105948307609, 0.8666847779051705]}}
{"id": "a8845685-3005-45d8-ac95-7363cfed92aa", "fitness": 0.6474488275004259, "name": "HybridDEALS", "description": "Introduce a dynamic restart mechanism to enhance exploration diversity and convergence reliability.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n            # Dynamic Restart Mechanism\n            if np.all(fitness == fitness[0]) and self.eval_count < self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.eval_count += self.population_size\n\n        return best_solution", "configspace": "", "generation": 43, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8018431059499467, 0.7889732872357634, 0.7688123805569429, 0.7799881175068127, 0.8627166113245808, 0.8762587528522066, 0.739952347149103, 0.8513973949334444, 0.9823422748115559, 0.9028130136318524, 0.8538115781581678, 0.8750796963764984, 0.8480937219112448, 0.9824105948307609, 0.8666847779051705]}}
{"id": "7c05a939-c10d-41fb-86c3-3c1ea396af11", "fitness": 0.6419390329050055, "name": "HybridDEALS", "description": "Introduce a dynamic mutation strategy with noise reduction to improve exploration without destabilizing convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.35 + 0.15 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 44, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8042106520743002, 0.7378054114381372, 0.8453253921277649, 0.7376812807477144, 0.7581589569872147, 0.9229475856819498, 0.8597988502853887, 0.8448755983043539, 0.9823431829863166, 0.8400200628782549, 0.7790315717292153, 0.9031170266041195, 0.8202368533163737, 0.9824162596232273, 0.8530130784413151]}}
{"id": "c2bdb370-2d5a-4c8f-86a0-911bb11517af", "fitness": 0.6473851361989442, "name": "HybridDEALS", "description": "Introduce randomness in adaptive local search intensity to enhance exploration.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5 * np.random.random())  # Introduced randomness\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 45, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7614961211227553, 0.76264437281977, 0.7585815412944477, 0.8040674724744475, 0.806175233466943, 0.7453051055679745, 0.8776524324264987, 0.853239807807999, 0.9366327566366947, 0.858536217034241, 0.9310915773794237, 0.9349653520320244, 0.8966359584331877, 0.9367338398126419, 0.916146040795369]}}
{"id": "617c6392-fe31-4541-84f6-408b2103cffd", "fitness": 0.5641555074019269, "name": "HybridDEALS", "description": "Adjust the crossover probability scaling to be more sensitive to the optimization stage for improved performance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-3 * self.eval_count / self.budget))  # Modified dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 46, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.38.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7427727774537336, 0.20574723548777885, 0.2985532066808926, 0.2742416451703319, 0.8530654110721093, 0.9161228895919283, 0.7798835625758331, 0.8967610088210624, 0.9823422748115559, 0.9202733964846914, 0.7475030022045139, 0.8037620450773075, 0.8185348364588896, 0.9824105948307609, 0.893337366442683]}}
{"id": "2b8c9402-97f1-4ae2-acb0-ed32bceacd27", "fitness": 0.6285370473204007, "name": "HybridDEALS", "description": "Introduce a dynamic scaling for mutation factor that decreases linearly with evaluations to enhance exploration early on and refine solutions later.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 - 0.2 * (self.eval_count / self.budget)  # Dynamic scaling for mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 47, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8467808613881187, 0.6577718632779515, 0.7186478308982236, 0.8671816616442836, 0.8959899381940574, 0.7606018773581196, 0.8556060564433683, 0.9071005301676088, 0.8167031284494847, 0.8123483359805701, 0.808469049132533, 0.8349678276475245, 0.9081212579456968, 0.9236735442607792, 0.7889782887452269]}}
{"id": "d7a3e055-e48f-4bf3-bc6e-278566243809", "fitness": 0.6182362379231428, "name": "HybridDEALS", "description": "Enhance diversity by introducing adaptive mutation rates based on fitness variance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget) * (1 + fitness_variance)  # Adjusted mutation factor scaling with added randomness and fitness variance\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 48, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7166656063531536, 0.6735053329204826, 0.7160551088233673, 0.791880382383805, 0.768447545008359, 0.883415417697915, 0.888021197770516, 0.8116937768954078, 0.982342304228177, 0.8486540584370581, 0.8553350840131506, 0.6467878036849182, 0.7642145539207625, 0.9824106788238615, 0.867497012627456]}}
{"id": "a627e6aa-725f-40da-928d-853b0c045add", "fitness": 0.20578457444132897, "name": "HybridDEALS", "description": "Enhance exploration by introducing a dynamic mutation strategy and adjust crossover adaptively for diversity.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_dynamic = 0.3 + 0.7 * np.exp(-2 * self.eval_count / self.budget)  # Dynamic mutation strategy\n                mutant = np.clip(x1 + F_dynamic * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - np.exp(-5 * self.eval_count / self.budget))  # Adjusted crossover probability more aggressively\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 49, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.2791207453799198, 0.16652524436380833, 0.1558594099356797, 0.20554495172409415, 0.19244962361272322, 0.22636454049936539, 0.27397654803773774, 0.21939452639891766, 0.1796886083843704, 0.21941254195632043, 0.27949596282285327, 0.18967060576888628, 0.9569294208903275, 0.18133694965214409, 0.22212291452496435]}}
{"id": "edb984dd-0e36-447b-8f8b-75dae0638a09", "fitness": 0.6318124820026354, "name": "HybridDEALS", "description": "Refine scaling and crossover adjustments to improve stability and efficiency under varying conditions.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))\n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.15 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.85 * (1 - np.exp(-1.5 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 50, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.6429118766405162, 0.8086035349316261, 0.7792035128200222, 0.6974640720907943, 0.7352977105800389, 0.8270702778141762, 0.9257259940557012, 0.825462732376202, 0.9823419297848698, 0.9024619751175449, 0.8025314339242808, 0.8805147935558135, 0.842386052221904, 0.9824097203232249, 0.8340651289415277]}}
{"id": "b7890f88-2bf2-4d0d-ab4b-93898c359bc2", "fitness": 0.5385899400956388, "name": "HybridDEALS", "description": "Introduce adaptive selection pressure by dynamically adjusting the selection threshold based on population diversity.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.2 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted mutation factor scaling with added randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection with adaptive threshold\n                diversity_metric = np.std(fitness) / max(0.001, np.mean(fitness))\n                selection_threshold = 1.0 - diversity_metric  # New adaptive selection pressure\n                if trial_fitness < fitness[i] * selection_threshold:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 51, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.35.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.4976254381562353, 0.7362740767143675, 0.6854095331752839, 0.432534860463194, 0.18617474451702754, 0.5950183999329197, 0.8297339775221055, 0.8290625160106544, 0.9823422748115559, 0.8768038576150645, 0.4548880379389568, 0.8125318165470428, 0.829303111875114, 0.9824105948307609, 0.8738866669280247]}}
{"id": "963fe7e5-0cf1-4337-a892-1bc18d5f5ffb", "fitness": 0.6538974906416452, "name": "HybridDEALS", "description": "Enhance the exploration capabilities by introducing a slight increase in the randomness of the mutation factor.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 52, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["61206c5c-191d-4510-8f68-f9259859a462"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8623472756090584, 0.7075716382230588, 0.8422790202510626, 0.8703199562964643, 0.8582240075247979, 0.8195312766011221, 0.778044753834585, 0.8959319572622546, 0.982342954326973, 0.7722787687882627, 0.9158438313465423, 0.8332582953357818, 0.9295275380411675, 0.9824135193870052, 0.8602361251303008]}}
{"id": "51b183e6-68dd-44e7-be1b-01a3426d2c59", "fitness": 0.6131078929295534, "name": "HybridDEALS", "description": "Slightly increase the differential weight and reduce the local search step size towards the end for refined exploration.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.35 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.05 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 53, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.34.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9013681670434625, 0.5140158910535795, 0.7493776574988753, 0.7507477497588203, 0.7777622383094429, 0.752616649631018, 0.8657759595035388, 0.819935390657748, 0.8786258255116315, 0.7958817092873465, 0.8265924019359588, 0.9191924649530344, 0.811265596911523, 0.8708742193842499, 0.8603270422763698]}}
{"id": "6d3fb029-3084-4a6a-bda5-64d07fcab4da", "fitness": 0.6538974906416452, "name": "HybridDEALS", "description": "Introduce a dynamic mutation scaling factor to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n\n                # Change 1: Implement a dynamic mutation scaling factor\n                self.F *= 1 + 0.1 * np.sin(2 * np.pi * self.eval_count / self.budget)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 54, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8623472756090584, 0.7075716382230588, 0.8422790202510626, 0.8703199562964643, 0.8582240075247979, 0.8195312766011221, 0.778044753834585, 0.8959319572622546, 0.982342954326973, 0.7722787687882627, 0.9158438313465423, 0.8332582953357818, 0.9295275380411675, 0.9824135193870052, 0.8602361251303008]}}
{"id": "30d67aa7-22e5-46ae-b521-9f3aeba1ac1e", "fitness": 0.6389964055834488, "name": "HybridDEALS", "description": "Improve convergence by adjusting mutation factor and dynamic crossover probability scaling.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusting baseline of randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.85 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Tuning crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 55, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7215476875190739, 0.8125275906576634, 0.8505800911569503, 0.8487974755501497, 0.7817622834265792, 0.8369347263348093, 0.7451428237996248, 0.830258033678416, 0.9823446996812772, 0.8991605332329532, 0.8293291163725663, 0.8389332585518001, 0.8075464917544268, 0.9824427438171373, 0.8448216612610852]}}
{"id": "a7fda7b7-f746-41ef-bbf3-8c6b6a51ee84", "fitness": 0.3250897968947377, "name": "HybridDEALS", "description": "Introduce an adaptive crossover probability to enhance convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 - 0.4 * (self.eval_count / self.budget)  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 56, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.21.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.24141132077903127, 0.2867180193494516, 0.2022069296929604, 0.2462392880292943, 0.39727875820630065, 0.4701960270711484, 0.5202832077890962, 0.6601458612922528, 0.5016274296875816, 0.33619948544316625, 0.3877720612906349, 0.7904260842036563, 0.4533763103867685, 0.44914825450243123, 0.39096800529651354]}}
{"id": "811bc0dc-1ed1-4802-9e82-446e1f093334", "fitness": 0.5627037828502021, "name": "HybridDEALS", "description": "Improve exploration by refining mutation and dynamically adjusting population size and crossover probability more effectively.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.85 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 57, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.34.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7585877883129184, 0.7307393809600193, 0.5930272125385718, 0.8388334486240975, 0.48998125034219975, 0.8375707126937617, 0.6784760689411852, 0.8015589355771708, 0.9823446833276896, 0.7910224517311849, 0.8586109525761335, 0.6136897536151666, 0.2587624864717447, 0.9824427563632173, 0.8706288800545128]}}
{"id": "fa7f867e-4e4f-4520-a7be-4ff0cb51e782", "fitness": 0.631091885175403, "name": "HybridDEALS", "description": "Introduce dynamic mutation scaling and enhanced local search to boost adaptability and convergence efficiency.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.4 * np.random.random() * (1 - np.tanh(self.eval_count / self.budget))  # Enhanced randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 58, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8533098256073779, 0.8227685893066351, 0.6752788387443576, 0.7145236576167822, 0.7909938246604833, 0.695623509313912, 0.7947937774961614, 0.7720532289705035, 0.9823435943779264, 0.8784970813412992, 0.8704081779957571, 0.8746827091434826, 0.8873423357014412, 0.9824424005533431, 0.8589772578041344]}}
{"id": "dabfc7e8-efe8-4a77-888b-6e2a999d5ff8", "fitness": 0.6134258543422387, "name": "HybridDEALS", "description": "Introduce adaptive population size scaling with a non-linear decay to improve diversity while keeping the mutation strategy consistent.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - (self.eval_count / self.budget)**2)))  # Non-linear decay\n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 59, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.34.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7016786732309757, 0.6048420532207888, 0.7487795957160415, 0.8759963598902383, 0.8580956011686145, 0.8741449237889823, 0.717005242254392, 0.8466144492340433, 0.8204956193467234, 0.9063046216262766, 0.8007071828890486, 0.8416588030412475, 0.8370247415300933, 0.8913582804333117, 0.7760120445995288]}}
{"id": "48f38040-757d-4795-860e-c1715a4866de", "fitness": 0.5175079494032305, "name": "HybridDEALS", "description": "Enhance exploration and convergence by integrating adaptive strategies in mutation and crossover processes.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-3 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 6)\n                adaptive_search_step = 0.12 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 60, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.38.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.3163816953536909, 0.584380914683156, 0.2544254626399589, 0.2210885012421484, 0.7849573130617704, 0.9046215140816974, 0.8854050152671993, 0.9295988029185188, 0.3042765517588617, 0.8713265098859322, 0.9295538004793098, 0.3421721480854846, 0.9293058539577455, 0.9824427563632173, 0.9424232534114512]}}
{"id": "c59f80fc-e8d9-4f24-825e-c25cfc170f2c", "fitness": 0.1739354092413829, "name": "HybridDEALS", "description": "Introduce adaptive mutation scaling and diversified crossover strategies to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.6 * np.random.random() * (1 - self.eval_count / self.budget)  # Adaptive mutation scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.7 + 0.3 * (1 - np.tanh(self.eval_count / self.budget))  # Diversified crossover strategy\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 61, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.12.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.2830293493826408, 0.1773699665043723, 0.3029150231451857, 0.2630961748036199, 0.24442434364365273, 0.1657285629437264, 0.40785236650541146, 0.13918246740488271, 0.12258181568555915, 0.14236608434080078, 0.16255608598938598, 0.4890166692351854, 0.1343867452828431, 0.1425081059534965, 0.1338955291324283]}}
{"id": "4257881c-f341-41c7-91de-71f29dd058ed", "fitness": 0.6538974906416452, "name": "HybridDEALS", "description": "Infuse intermittent reinforcement learning to dynamically tune mutation factor and crossover probability.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.F += 0.05 * (1 - self.eval_count / self.budget)  # Reinforcement learning adjustment\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 62, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8623472756090584, 0.7075716382230588, 0.8422790202510626, 0.8703199562964643, 0.8582240075247979, 0.8195312766011221, 0.778044753834585, 0.8959319572622546, 0.982342954326973, 0.7722787687882627, 0.9158438313465423, 0.8332582953357818, 0.9295275380411675, 0.9824135193870052, 0.8602361251303008]}}
{"id": "cb78cfa7-43cc-4d3f-a04e-f2ebd5bd30c4", "fitness": 0.4815633047095448, "name": "HybridDEALS", "description": "Enhance the diversity and exploration by adjusting mutation factor range and crossover probability scaling.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjust mutation factor range\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - np.exp(-3 * self.eval_count / self.budget))  # Adjust crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 63, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.23373113389734135, 0.8904300557496638, 0.1824512665666389, 0.7071055213201144, 0.7325155031492669, 0.28245702068358136, 0.19158115842510015, 0.6063350297160417, 0.9823446833276896, 0.8819816844663297, 0.8454131323434106, 0.9427752457615287, 0.6365041091630479, 0.9824427563632173, 0.3653988983834553]}}
{"id": "54d8d8cf-aa3c-44ce-bf0a-172886950f89", "fitness": 0.5923088643854313, "name": "HybridDEALS", "description": "Enhance mutation strategy by introducing a dynamic and self-adaptive differential weight and improve exploitation by adjusting local search intensity based on convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.5 + 0.2 * np.sin(0.5 * np.pi * self.eval_count / self.budget)  # Dynamically adaptive F\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 64, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.34.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8442724592677183, 0.8358058260813611, 0.7405824020273595, 0.8198614556319008, 0.7920086886746875, 0.8480823122694682, 0.8150428086521692, 0.8708970065352695, 0.8003045397829984, 0.831101540152747, 0.9034204244005172, 0.7947977420453606, 0.7729708066947867, 0.6979663814203573, 0.31126399919745773]}}
{"id": "776cd9ce-f60d-4fb2-ba14-dcdb1bc3750a", "fitness": 0.6359324253677275, "name": "HybridDEALS", "description": "Enhance the adaptability by adjusting the differential weight based on a cosine function.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget) * np.cos(np.pi * self.eval_count / (2 * self.budget))  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 65, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7414388928013617, 0.8793941467675296, 0.761829623172859, 0.8089047882798213, 0.7680661401451858, 0.8020970192994799, 0.7900831921748862, 0.8959977653391641, 0.9823429533920633, 0.752982687571463, 0.915845179704026, 0.8117335153317776, 0.9295308357512141, 0.9824135124907963, 0.7281893602584587]}}
{"id": "23ee8aca-28db-4ac7-8520-5531fc923696", "fitness": 0.4785164893086553, "name": "HybridDEALS", "description": "Further refine the exploration by dynamically adjusting the mutation factor and crossover probability based on the current best fitness.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget) + 0.1 * (1 - best_fitness)  # Further refined randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget) + 0.1 * (1 - best_fitness))  # Further refined dynamic crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 66, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8088305864547349, 0.2013852773120246, 0.22248954508289442, 0.7248457096963918, 0.8074129569592325, 0.8249191056033456, 0.5312088872762828, 0.7736233730913702, 0.9823445615790601, 0.23100881849435373, 0.25766135385599864, 0.25376220462111265, 0.9044742076017188, 0.9824427067728655, 0.896121596897255]}}
{"id": "e7225142-8a74-47d5-9b75-dd460606fbaa", "fitness": 0.6335543959434324, "name": "HybridDEALS", "description": "Enhance exploration by integrating a stochastic scaling factor into the mutation strategy.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget) \n                mutant = np.clip(x1 + self.F * (x2 - x3) * np.random.uniform(0.9, 1.1), self.lower_bound, self.upper_bound)  # Stochastic scaling\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  \n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget) \n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 67, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7284365244045071, 0.7574836428007194, 0.8569850227961644, 0.826098519679431, 0.6943932204234995, 0.8547931843177982, 0.86878358246044, 0.8488387511640818, 0.9167382919687797, 0.9563666479438219, 0.7823058890274357, 0.7159329434502124, 0.8356046216898338, 0.904814132583001, 0.9557140492844552]}}
{"id": "6717582d-38e6-42d7-bba4-cfdd4b064ae2", "fitness": 0.3273616787374038, "name": "HybridDEALS", "description": "Introduce dynamic mutation strategies and adaptive parameter tuning for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))\n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                F_dynamic = self.F_base * (1 + 0.2 * np.sin(2 * np.pi * self.eval_count / self.budget))  # Dynamic mutation\n                mutant = np.clip(x1 + F_dynamic * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.7 + 0.2 * np.random.rand() * np.sin(self.eval_count / self.budget)  # Slightly random crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.05 + 0.05 * np.cos(self.eval_count / self.budget * np.pi)  # Cosine-modulated step\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 68, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9249922893151574, 0.5770121193203086, 0.17407866989130671, 0.196721507667583, 0.21049713718814156, 0.1744690823753935, 0.14197846711152762, 0.5548606066013118, 0.14661440231519451, 0.8143943902366945, 0.8539439183290802, 0.16936125624124232, 0.7271557062216776, 0.22996533500816663, 0.4833897920508242]}}
{"id": "dc5910e8-6bce-4921-8673-a2d68d7ebaf2", "fitness": 0.3482862700025037, "name": "HybridDEALS", "description": "Introduce an adaptive crossover probability scaling factor that varies more dynamically with the evaluation count.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - np.exp(-5 * self.eval_count / self.budget))  # More dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 69, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.32.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.488992900485416, 0.16150208645050224, 0.8145255211171379, 0.19115756365913905, 0.1864896158338618, 0.29276007721567676, 0.46516412283489006, 0.35242708229815556, 0.982342954326973, 0.2091021479666363, 0.2924510505304977, 0.2145256535826362, 0.2277066128264731, 0.9824135193870052, 0.9363655966606054]}}
{"id": "4245a5ee-15f8-462a-93ca-7701934ad220", "fitness": 0.09944170916169628, "name": "HybridDEALS", "description": "Introduce adaptive scaling to both mutation factor and crossover probability based on population diversity to enhance convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))\n            population = population[:self.population_size]  # Resize population\n            \n            # Calculate population diversity\n            diversity = np.std(population, axis=0).mean()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 * (1 + diversity)  # Adjust F based on diversity\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.7 + 0.3 * (1 - np.exp(-diversity))  # Adjust CR based on diversity\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 70, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.05.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.17100475160702167, 0.11309687952484915, 0.17380799348359643, 0.14984850025560192, 0.17315955796004856, 0.12051389728120543, 0.08806974569186987, 0.10240391564320706, 0.10979902947041298, 0.10232006127191884, 0.10184992164842144, 0.09765427197745313, 0.10232666708762572, 0.11645282386542688, 0.09872727159080041]}}
{"id": "5bf58671-f98d-415c-8d67-f58a4fd7c1c9", "fitness": 0.16736822647545815, "name": "HybridDEALS", "description": "Enhance the exploitation phase with adaptive local search step size and improve convergence by adjusting crossover probability dynamically.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))\n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 + 0.1 * np.sin(np.pi * self.eval_count / self.budget)  # Adjust crossover probability dynamically\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget) * np.random.random()  # New adaptive scaling factor with randomness\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 71, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.13.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.22011335064212334, 0.15118062632294438, 0.1723801745357374, 0.1407049022155027, 0.1817995017872177, 0.19382156941255713, 0.1656531660536925, 0.19236049375629682, 0.21860827074337907, 0.17434172390916292, 0.14382828253869961, 0.23016424170344185, 0.16427390855550128, 0.16431517914690363, 0.6660202433115362]}}
{"id": "01b7a0a7-9754-4087-805e-2d40d9771700", "fitness": 0.20647777989863464, "name": "HybridDEALS", "description": "Introduce dynamic scaling factors for mutation and crossover, enhancing exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))\n            population = population[:self.population_size]\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.7 * np.random.random() * (1 - self.eval_count / self.budget)  # Enhanced randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                dynamic_CR = 0.7 + 0.3 * (1 - self.eval_count / self.budget)\n                self.CR = dynamic_CR  # Dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 72, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.14.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.3082089835610583, 0.1515341758037444, 0.16084409211540052, 0.21187386914762096, 0.14610081697663613, 0.49227157308262637, 0.20586836515447426, 0.3525314750562585, 0.14506332731014404, 0.17080597942963316, 0.35283790243493596, 0.24670956379210884, 0.34861479907536363, 0.5114589810581966, 0.15703279910002454]}}
{"id": "576bb3fa-ecf9-45f4-ba87-fc69050cc1d7", "fitness": 0.6151234157096473, "name": "HybridDEALS", "description": "Introduce adaptive mutation scaling and enhanced exploitation with focused local search adjustments.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Updated randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.05 * (1 - self.eval_count / self.budget)  # Refined adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 73, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7128612062469311, 0.8018721634519095, 0.7863196628636239, 0.7817635813076522, 0.8211294325450385, 0.5377873744933774, 0.8993523533334374, 0.880392510285749, 0.8132146014915087, 0.8988278138509849, 0.9157154861061624, 0.8135114890951518, 0.7168251271122722, 0.8698101532809646, 0.8852864638537163]}}
{"id": "879c9bdf-f7cc-4e64-b6c7-d5a5b561e5b6", "fitness": 0.6201976219473164, "name": "HybridDEALS", "description": "Adaptive hybrid algorithm integrating dynamic mutation scaling and convergence-driven local search refinement.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(8 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.7 * (1 - np.exp(-2.5 * self.eval_count / self.budget))  # Adjusted dynamic crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 7)\n                adaptive_search_step = 0.05 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 74, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8585719911172958, 0.7897807268673578, 0.7745640688432618, 0.6654123854931762, 0.6066882636728224, 0.8598039244305008, 0.8729566671327065, 0.8893341713498516, 0.8793320118799902, 0.8814874729373599, 0.7522801643883986, 0.7829469840448293, 0.8771182844014063, 0.8352068973600768, 0.9106695301528288]}}
{"id": "238ab66b-82d1-4905-9777-883850e50cb7", "fitness": 0.642474812896755, "name": "HybridDEALS", "description": "Boost exploration by integrating a dynamic mutation scaling factor that adapts to the convergence rate.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                # Dynamic mutation factor based on convergence rate\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget) * (best_fitness / (best_fitness + abs(fitness[i] - best_fitness)))\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 75, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8528151657843878, 0.8437634032327532, 0.7179210887009315, 0.8146751784789692, 0.7323109241015755, 0.8121539891026438, 0.754163077037671, 0.8413018149095113, 0.9823427100621526, 0.8902000677931794, 0.8445036950470736, 0.9010413119035341, 0.872956288719599, 0.982411711756866, 0.8391369364297849]}}
{"id": "3d46341e-0412-4dae-a4db-601896f72daa", "fitness": 0.585033153981266, "name": "HybridDEALS", "description": "Improve the adaptability of both mutation and crossover rates to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - np.exp(-2.5 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 76, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8140386104242343, 0.22538012970541998, 0.7581719348345833, 0.5028886526966003, 0.8478300438857883, 0.9051538768124989, 0.7030903637237722, 0.6861866019029971, 0.9823446833276896, 0.7364672785612438, 0.9020689435510201, 0.8465611801808801, 0.6974852196261196, 0.9824427563632173, 0.9427539091547879]}}
{"id": "2592c335-3c47-4e25-8457-d6de3efae121", "fitness": 0.5079718604849323, "name": "HybridDEALS", "description": "Refine the crossover probability scaling function to increase exploitation in later stages of optimization.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-3 * self.eval_count / self.budget))  # Modified dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 77, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.21176487948474743, 0.4114720263497812, 0.7471304492824014, 0.29673017995413287, 0.32118799674974463, 0.933216964061204, 0.6407817111265379, 0.9308229909799726, 0.982342954326973, 0.8007244585977271, 0.8343751400595062, 0.784891435728944, 0.8164550174601674, 0.9824135193870052, 0.29732859127533207]}}
{"id": "045676a5-9fae-4c94-bd45-cdfd16d54f62", "fitness": 0.6214690481525798, "name": "HybridDEALS", "description": "Incorporate adaptive scaling of differential weight and crossover probability with enhanced local search strategies.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.7 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 78, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7971341162759525, 0.8474292361707544, 0.766568526417807, 0.8059973419014153, 0.8382346662784251, 0.8281375309410974, 0.822622302095356, 0.7569404949940214, 0.9823446833276896, 0.6778937511742835, 0.8186643029629505, 0.8553298033203198, 0.7919802124644697, 0.9824427563632173, 0.6898623434893677]}}
{"id": "220e0382-6043-485a-9032-bdf2a2712b50", "fitness": 0.588555466761406, "name": "HybridDEALS", "description": "Introduce stochastic reseeding and use adaptive mutation factor for enhanced diversity and convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Adaptive randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n            # Stochastic Reseeding\n            if np.random.rand() < 0.1:\n                random_idx = np.random.randint(0, self.population_size)\n                population[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                fitness[random_idx] = func(population[random_idx])\n                self.eval_count += 1\n\n        return best_solution", "configspace": "", "generation": 79, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9063067521914888, 0.8941870686546294, 0.2840069205559752, 0.6551228218875493, 0.7053234912258526, 0.817728557591946, 0.7368086157902062, 0.7989721635676269, 0.9823446833276896, 0.5948053756991514, 0.8472014396852834, 0.731785258660191, 0.7826744194210322, 0.9824427563632173, 0.8836001157318125]}}
{"id": "e9e185ae-a3c9-4614-8b18-72d1b122da1a", "fitness": 0.6538974906416452, "name": "HybridDEALS", "description": "Enhance the exploration capabilities by introducing a slight increase in the randomness of the mutation factor and leveraging an adaptive mutation scale factor based on the evaluation count.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 80, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8623472756090584, 0.7075716382230588, 0.8422790202510626, 0.8703199562964643, 0.8582240075247979, 0.8195312766011221, 0.778044753834585, 0.8959319572622546, 0.982342954326973, 0.7722787687882627, 0.9158438313465423, 0.8332582953357818, 0.9295275380411675, 0.9824135193870052, 0.8602361251303008]}}
{"id": "6c8ccd73-abbd-477d-901e-012a17d07a63", "fitness": 0.637041054652164, "name": "HybridDEALS", "description": "Refine the adaptive parameters by including a global convergence factor to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                global_factor = (best_fitness - fitness[i]) / (best_fitness + 1e-9)  # New global convergence factor\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget) * global_factor  # Adjusted randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 81, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8051611600187533, 0.7860461344744145, 0.7569428116637416, 0.7306146230682836, 0.7841113786541312, 0.8470008257977073, 0.8660167484260793, 0.8879766493481156, 0.9823406251244843, 0.9037292506683176, 0.8345993013389494, 0.9021023207223107, 0.6199188557315074, 0.9824071727722072, 0.8840543403598099]}}
{"id": "0711bcfa-b633-408c-929f-722a91fa845a", "fitness": 0.5079718604849323, "name": "HybridDEALS", "description": "Fine-tune the dynamic crossover probability scaling for enhanced convergence rates.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-3 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 82, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.21176487948474743, 0.4114720263497812, 0.7471304492824014, 0.29673017995413287, 0.32118799674974463, 0.933216964061204, 0.6407817111265379, 0.9308229909799726, 0.982342954326973, 0.8007244585977271, 0.8343751400595062, 0.784891435728944, 0.8164550174601674, 0.9824135193870052, 0.29732859127533207]}}
{"id": "387972fc-d542-41a4-8ec2-64fe690e9665", "fitness": 0.6487419830381121, "name": "HybridDEALS", "description": "Further refine exploration dynamics by adjusting the mutation factor scaling and altering local search intensity scaling.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.35 + 0.25 * np.random.random() * (1 - self.eval_count / self.budget)  # Refined randomness scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 7)  # Updated dynamic scaling factor\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 83, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8747296471618856, 0.7599694030937052, 0.7387656771669875, 0.7886483399844488, 0.8104127726811985, 0.8053510367869763, 0.8597023468021467, 0.8356560696956339, 0.9823437995851412, 0.8980546159273286, 0.9017641228703175, 0.8941953586492836, 0.8607667578276913, 0.9824424677672872, 0.8142383498877437]}}
{"id": "1601a4d5-04e2-4f43-82ef-73e170e8077d", "fitness": 0.6207462232768768, "name": "HybridDEALS", "description": "Improve the balance between exploration and exploitation by adapting mutation and local search strategies dynamically.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted randomness factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-1.5 * self.eval_count / self.budget))  # Modified dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 6)  # Adjusted intensity\n                adaptive_search_step = 0.15 * (1 - self.eval_count / self.budget)  # Modified adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 84, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.34.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8495583239265576, 0.7968226854772523, 0.7507945295476315, 0.739564757240708, 0.8079516946770734, 0.7056072966579179, 0.8171117862962634, 0.8893654010453083, 0.8779541392105242, 0.8532125382474256, 0.7851703174239131, 0.8375823238147139, 0.7126034125186591, 0.9824424005513117, 0.8413839640278097]}}
{"id": "b209c12f-c82d-41ac-92a0-5126b21d49f4", "fitness": 0.6194691025293555, "name": "HybridDEALS", "description": "Enhance mutation strategy by introducing a more adaptive F scaling based on fitness variance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - np.std(fitness) / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 85, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8068797584143357, 0.8311147414684359, 0.7473839981473207, 0.7833887704434938, 0.7151902899100315, 0.7914122342367691, 0.7124596408193424, 0.8943730746348915, 0.9823429939249502, 0.8583444485379019, 0.8684769547808133, 0.7979112055257785, 0.6668895666676515, 0.9824138291188188, 0.7830016490821072]}}
{"id": "03b39184-9703-4bdc-993c-f91fca216c76", "fitness": 0.6260440874463191, "name": "HybridDEALS", "description": "Enhance adaptive strategies in the mutation factor and local search intensity for improved exploration.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.4 + 0.35 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 6)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 86, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7617163909367699, 0.7038316886352141, 0.7911828115793553, 0.6665843277573718, 0.8514679201941687, 0.8300124771262338, 0.8878301168146693, 0.8536283445549878, 0.9823447269922231, 0.8738762848747339, 0.8587936478782907, 0.748995825613505, 0.663679038888251, 0.9824427582799764, 0.8966964939261644]}}
{"id": "6b8eefd8-5f0d-4bd7-800f-9a1d2943fe4a", "fitness": 0.6259747253049839, "name": "HybridDEALS", "description": "Introduce an adaptive scaling for differential weight to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - (self.eval_count / self.budget)**2)  # Slightly increased randomness with adaptive scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 87, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8520344206882865, 0.7930063109140153, 0.7908988184732603, 0.804690629815152, 0.7519416783970021, 0.8244718286261912, 0.7626098650932538, 0.8944194679149134, 0.9823429931677271, 0.7936519116691332, 0.830882049062865, 0.7129947709215343, 0.7995509692997796, 0.9824138228438125, 0.7757860743382825]}}
{"id": "1392bc86-96c0-44c9-a9b6-0763f684b49f", "fitness": 0.30957414680977324, "name": "HybridDEALS_Improved", "description": "Introduce self-adaptive differential weight and crossover probability to enhance local and global search balance.", "code": "import numpy as np\n\nclass HybridDEALS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.5 * np.random.random() * (1 - self.eval_count / self.budget)  # Self-adaptive F\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.5 + 0.4 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Self-adaptive CR\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 88, "feedback": "The algorithm HybridDEALS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.29341682177534434, 0.24333630513954352, 0.16456384514699862, 0.21022310132681488, 0.1817203111902005, 0.6145300010864777, 0.1578176003218612, 0.1678164662691879, 0.7423420277741686, 0.4176051801312871, 0.1979001508195427, 0.729856845528565, 0.4360693461813908, 0.7667011104139646, 0.6997849282156514]}}
{"id": "465b42e8-ae7b-4a93-91fb-becc797d2662", "fitness": 0.2439310868457551, "name": "HybridDEALS", "description": "Enhance HybridDEALS by incorporating adaptive scaling of DE parameters and a more dynamic local search approach to improve convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Modified randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.7 + 0.2 * np.sin(np.pi * self.eval_count / (2 * self.budget))  # New dynamic crossover probability\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 10)\n                adaptive_search_step = 0.05 * (1 - self.eval_count / self.budget)  # Refined adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 89, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.17056159804564053, 0.309275160180452, 0.22694599148124117, 0.1835248478998074, 0.150022073466768, 0.7261096553227198, 0.4037468894443612, 0.13694474085553998, 0.1623994941112189, 0.19400483164634197, 0.15449696780619504, 0.742679218248391, 0.6965566145225355, 0.22063025399542058, 0.23292450501400241]}}
{"id": "a0d93263-e48c-4457-8382-6bcbc9b76001", "fitness": 0.6538974906416452, "name": "HybridDEALS", "description": "Introduce a diversity mechanism by dynamically adjusting mutation and crossover parameters based on population stagnation.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        stagnation_counter = 0  # New line\n\n        while self.eval_count < self.budget:\n            previous_best_fitness = best_fitness  # New line\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n                \n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n                    stagnation_counter = 0  # Reset stagnation\n\n                if self.eval_count >= self.budget:\n                    break\n            \n            if best_fitness == previous_best_fitness:\n                stagnation_counter += 1  # Increment stagnation counter\n                if stagnation_counter > 5:  # If stagnation persists\n                    self.F = min(0.9, self.F + 0.1)  # Increase F slightly\n                    self.CR = max(0.1, self.CR - 0.1)  # Decrease CR slightly\n\n        return best_solution", "configspace": "", "generation": 90, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8623472756090584, 0.7075716382230588, 0.8422790202510626, 0.8703199562964643, 0.8582240075247979, 0.8195312766011221, 0.778044753834585, 0.8959319572622546, 0.982342954326973, 0.7722787687882627, 0.9158438313465423, 0.8332582953357818, 0.9295275380411675, 0.9824135193870052, 0.8602361251303008]}}
{"id": "e082cf6b-9b97-42d1-8343-851852b211fa", "fitness": 0.6462141579775731, "name": "HybridDEALS", "description": "Introduce adaptive mutation factor scaling for enhanced exploration during the early stages of optimization.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget) * np.exp(-self.eval_count / self.budget)  # Adaptive scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 91, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8554322174794069, 0.7058265456932147, 0.7939560724532481, 0.7204641451767533, 0.7314661548549147, 0.8336387284873674, 0.8456630608263642, 0.9172314400454218, 0.9823429157340685, 0.8878616159900362, 0.8757414350519256, 0.8840221470244555, 0.9296515866241252, 0.9824132483847025, 0.8107729508509907]}}
{"id": "5326b307-18f0-4bcf-a67e-056ef8cc62e1", "fitness": 0.6368741642158896, "name": "HybridDEALS", "description": "Introduce a decay factor to the mutation factor to better balance exploration and exploitation over time.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = (0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)) * (1 - self.eval_count / self.budget)  # Introduced decay factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 92, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8142553108218413, 0.8351993807370369, 0.6588505294538887, 0.8456004165072326, 0.801787195262722, 0.7660504214427157, 0.7701026275156727, 0.8231535685228996, 0.9823427703665786, 0.8654579785735229, 0.7708173365816714, 0.876685174162466, 0.9298383192962179, 0.9824124144555305, 0.8471309457433297]}}
{"id": "bcfcf926-3746-4472-94ba-ee0ee0c1c62e", "fitness": 0.6538974906416452, "name": "HybridDEALS", "description": "Improve selection pressure by adjusting the differential weight dynamically as evaluations progress.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 93, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8623472756090584, 0.7075716382230588, 0.8422790202510626, 0.8703199562964643, 0.8582240075247979, 0.8195312766011221, 0.778044753834585, 0.8959319572622546, 0.982342954326973, 0.7722787687882627, 0.9158438313465423, 0.8332582953357818, 0.9295275380411675, 0.9824135193870052, 0.8602361251303008]}}
{"id": "f377aa79-1bec-4f2f-a480-33dae4c3ad20", "fitness": 0.6274911769503344, "name": "HybridDEALS", "description": "Optimize mutation factor adaptively based on solution quality for improved performance.  ", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - fitness[i] / best_fitness)  # Adaptive mutation factor\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 94, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.36.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7435214658115394, 0.5489335654304389, 0.8336633851407529, 0.8259515560773998, 0.7945118637688164, 0.840872650271115, 0.8166152491871123, 0.8663828316526905, 0.9823406196577502, 0.6468253688707507, 0.8911780482262541, 0.8803968999453601, 0.8452093793051658, 0.9824071610076671, 0.8832145997794087]}}
{"id": "398c2a94-17b8-43bc-9c38-0cbb3281d0c2", "fitness": 0.54921674125871, "name": "HybridDEALS", "description": "Employ adaptive mutation strategies and dynamic population adjustments to enhance exploration and convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))\n            population = population[:self.population_size]\n\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.4 * np.random.random() * (1 - self.eval_count / self.budget)  # Adjusted randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2.5 * self.eval_count / self.budget))  # Adjusted dynamic scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.15 * (1 - self.eval_count / self.budget)  # New scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 95, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.25715762080630267, 0.4573689106386727, 0.6363405405359477, 0.8365992958212958, 0.8052142120872061, 0.7393805080076208, 0.8882130988525705, 0.732737367677306, 0.7303670202710822, 0.8991090655358136, 0.8184144799943905, 0.8305685448319897, 0.35266280491901847, 0.9824424005513117, 0.8499600597692047]}}
{"id": "c40ad0aa-7b2e-447a-b038-ae7c69f3e025", "fitness": 0.62284542093042, "name": "HybridDEALS", "description": "Incorporate dynamic scaling of the differential weight to enhance exploration and convergence balance.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget) + 0.2 * np.sin(np.pi * self.eval_count / self.budget)  # Slightly increased randomness with dynamic scaling\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 96, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.9252340589635907, 0.8290696687322685, 0.7960783735176766, 0.688688069014837, 0.7854529482231001, 0.6316640608920799, 0.9002134538706935, 0.7475414787304818, 0.9823432507280159, 0.8412491437445822, 0.8093395307247248, 0.84730789157875, 0.7352406907513045, 0.9824185536687525, 0.7872683505930779]}}
{"id": "e7ac2e95-7936-462e-802c-63c16ffb81d9", "fitness": 0.6342287411919015, "name": "HybridDEALS", "description": "Introduce exponential decay to mutation factor F for enhanced convergence.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 * np.exp(-5 * (self.eval_count / self.budget))  # Exponential decay for F\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 97, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8076591278467038, 0.8013678696756933, 0.8169272805239736, 0.7343486648636192, 0.7542432671485724, 0.8887761914181376, 0.8551262435398459, 0.8748907973757845, 0.8298040741444752, 0.8596700314318126, 0.8259238323070018, 0.8938804375214322, 0.8433453759175475, 0.8640737598467045, 0.8667389754022627]}}
{"id": "5685953c-c98e-42e9-94ac-c16bb5611d46", "fitness": 0.6209369624793715, "name": "HybridDEALS", "description": "Introduce chaotic initialization to improve diversity in the initial population.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population with chaotic sequence\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.sin(np.pi * np.random.rand(self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                self.F = 0.3 + 0.3 * np.random.random() * (1 - self.eval_count / self.budget)  # Slightly increased randomness\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.8 * (1 - np.exp(-2 * self.eval_count / self.budget))  # Improved dynamic crossover probability scaling\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 98, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.35.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.7941626983864156, 0.7987427745643217, 0.7595503160873056, 0.6979890327319875, 0.6321526650896809, 0.8029419498020517, 0.8214525617530252, 0.9413920652708925, 0.8676746695638914, 0.915084360618511, 0.8304590254101913, 0.8260552917269713, 0.9724297862598902, 0.8295981292504255, 0.7612550281974001]}}
{"id": "8259fd67-c258-464a-90e9-38102f0288f3", "fitness": 0.49805136085016033, "name": "HybridDEALS", "description": "Enhance the exploration and exploitation balance by dynamically adjusting mutation factor and crossover probability based on current population diversity.", "code": "import numpy as np\n\nclass HybridDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.local_search_intensity = 4\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n\n        while self.eval_count < self.budget:\n            # Adaptive Population Resizing\n            self.population_size = max(4, int(10 * self.dim * (1 - self.eval_count / self.budget)))  \n            population = population[:self.population_size]  # Resize population\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n                pop_diversity = np.std(population, axis=0).mean()  # Calculate population diversity\n                self.F = 0.3 + 0.6 * np.random.random() * (1 - pop_diversity)  # Adjusted randomness using diversity\n                mutant = np.clip(x1 + self.F * (x2 - x3), self.lower_bound, self.upper_bound)\n                self.CR = 0.9 * (1 - np.exp(-pop_diversity))  # Dynamic crossover probability based on diversity\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Adaptive Local Search (if budget allows)\n                dynamic_local_search_intensity = self.local_search_intensity + int((self.eval_count / self.budget) * 5)\n                adaptive_search_step = 0.1 * (1 - self.eval_count / self.budget)  # New adaptive scaling factor\n                if self.eval_count < self.budget and trial_fitness < best_fitness:\n                    for _ in range(dynamic_local_search_intensity):\n                        local_candidate = trial + np.random.normal(0, adaptive_search_step, self.dim)\n                        local_candidate = np.clip(local_candidate, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_candidate)\n                        self.eval_count += 1\n                        if local_fitness < trial_fitness:\n                            trial, trial_fitness = local_candidate, local_fitness\n                            population[i] = trial\n                            fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if self.eval_count >= self.budget:\n                    break\n\n        return best_solution", "configspace": "", "generation": 99, "feedback": "The algorithm HybridDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.34.", "error": "", "parent_ids": ["963fe7e5-0cf1-4337-a892-1bc18d5f5ffb"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.2288500689064189, 0.7792115937149927, 0.295581785755632, 0.3155274654501842, 0.22857154743167418, 0.9570273340537019, 0.7149641559849205, 0.7319230302426767, 0.8029967504707636, 0.7787192390264991, 0.8617503928724255, 0.7726111401440082, 0.9248633892030856, 0.6994832789874853, 0.7011471498842727]}}
