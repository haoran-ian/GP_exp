{"id": "5639ccff-bbf4-46b1-b57d-5bfd7c1c2024", "fitness": 0.11742741398177133, "name": "HybridPSODE", "description": "A hybrid metaheuristic combining Particle Swarm Optimization (PSO) with Differential Evolution (DE) for robust search and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11743 with standard deviation 0.00563.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.11086299818239564, 0.12460268341804615, 0.1168165603448722]}}
{"id": "12741f96-35a0-47aa-a498-f093c237601b", "fitness": 0.1043044171807133, "name": "AdaptiveHybridPSODE", "description": "Introducing adaptive parameter control to HybridPSODE for improved convergence by dynamically adjusting PSO and DE parameters based on performance.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.initial_mutation_factor = 0.9\n        self.final_mutation_factor = 0.5\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            inertia_weight = self.initial_inertia_weight - (\n                (self.initial_inertia_weight - self.final_inertia_weight) * \n                (self.curr_evaluations / self.budget)\n            )\n            mutation_factor = self.initial_mutation_factor - (\n                (self.initial_mutation_factor - self.final_mutation_factor) * \n                (self.curr_evaluations / self.budget)\n            )\n\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10430 with standard deviation 0.00762.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.1011378310760942, 0.11481415231984526, 0.09696126814620043]}}
{"id": "409b622e-3b7e-4291-859a-3d376fa85cfd", "fitness": 0.09605850275427714, "name": "HybridPSODEPlus", "description": "The HybridPSODE+ introduces adaptive parameters and dynamic population size for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.curr_evaluations = 0\n        self.inertia_weight = 0.9  # Start with higher inertia\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            if self.curr_evaluations % (self.budget // 4) == 0:  # Dynamic population adjustment\n                self.pop_size = max(20, self.pop_size - 5)  # Decrease population size\n                swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n                vel = np.zeros((self.pop_size, self.dim))\n\n            for i in range(self.pop_size):\n                # Adaptive inertia weight\n                inertia = ((self.budget - self.curr_evaluations) / self.budget) * 0.5 + 0.4\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (inertia * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09606 with standard deviation 0.00443.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10230174681854542, 0.09256617244447429, 0.09330758899981173]}}
{"id": "a4bcea56-dd2a-4461-a101-b59c786367d4", "fitness": 0.10444235743015746, "name": "HybridPSODE", "description": "Introduce adaptive inertia weight in PSO for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)  # Adaptive inertia weight\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10444 with standard deviation 0.01330.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10323695260773735, 0.12129606455434006, 0.088794055128395]}}
{"id": "4247de11-fc4e-4e0c-bb04-6ff803b2aa12", "fitness": 0.10189069612721331, "name": "HybridPSODE", "description": "An enhanced hybrid metaheuristic blending PSO and DE with adaptive parameters for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            # Adaptive inertia weight\n            inertia_weight = (self.initial_inertia_weight - self.final_inertia_weight) * \\\n                             (1 - self.curr_evaluations / self.budget) + self.final_inertia_weight\n            \n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10189 with standard deviation 0.00614.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10190399522610172, 0.1094054037507719, 0.09436268940476633]}}
{"id": "0c845d4e-2537-4c26-959d-09dae3b97518", "fitness": 0.11111543035379816, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive parameters for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            # Adaptive inertia weight\n            self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                # Adaptive mutation factor\n                self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11112 with standard deviation 0.00405.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10561812662855807, 0.1124725811400693, 0.11525558329276708]}}
{"id": "5d3dde4d-c322-403d-9a03-48d6dfa2caf0", "fitness": 0.10444235743015746, "name": "HybridPSODE", "description": "Introduce adaptive inertia weight in PSO to improve exploration-exploitation balance dynamically.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = ((0.9 - 0.4) * (self.budget - self.curr_evaluations) / self.budget + 0.4) * vel[i] + \\\n                         self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) + \\\n                         self.social_coeff * r2 * (gbest_position - swarm[i])\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10444 with standard deviation 0.01330.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10323695260773735, 0.12129606455434006, 0.088794055128395]}}
{"id": "42239f48-0c8b-4403-8ea7-e03b56d7f30a", "fitness": 0.10830606383770532, "name": "AdaptiveHybridPSODE", "description": "A novel hybrid algorithm that adaptively combines PSO with DE while introducing dynamic inertia weight adjustment for improved convergence speed and accuracy.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.inertia_weight_min = 0.4\n        self.inertia_weight_decay = (self.inertia_weight - self.inertia_weight_min) / (0.5 * self.budget)\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Dynamic inertia weight adjustment\n                if self.inertia_weight > self.inertia_weight_min:\n                    self.inertia_weight -= self.inertia_weight_decay\n                \n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10831 with standard deviation 0.00623.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.11711413188653175, 0.10399528303459804, 0.10380877659198617]}}
{"id": "9b586c5d-113d-435b-8671-0d589d6b8caa", "fitness": 0.08786819693455213, "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid algorithm integrating an adaptive inertia weight in PSO and opposition-based learning to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            inertia_weight = self.inertia_weight_max - (\n                (self.inertia_weight_max - self.inertia_weight_min) *\n                (self.curr_evaluations / self.budget)\n            )\n            \n            for i in range(self.pop_size):\n                # PSO Update with adaptive inertia weight\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Opposition-based learning\n                opp_vector = lb + ub - trial_vector\n                opp_vector = np.clip(opp_vector, lb, ub)\n                \n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                opp_score = func(opp_vector)\n                self.curr_evaluations += 2\n                \n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                if opp_score < swarm_scores[i]:\n                    swarm[i] = opp_vector\n                    swarm_scores[i] = opp_score\n                \n                if swarm_scores[i] < pbest_scores[i]:\n                    pbest_scores[i] = swarm_scores[i]\n                    pbest_positions[i] = swarm[i]\n\n                    if swarm_scores[i] < pbest_scores[gbest_idx]:\n                        gbest_position = swarm[i]\n                        gbest_idx = i\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08787 with standard deviation 0.00367.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.08999991204084601, 0.09090172601220492, 0.08270295275060546]}}
{"id": "35f08d6b-fcd9-4cd1-8037-7cdd24a8ddc7", "fitness": 0.0926953740846247, "name": "EnhancedHybridPSODE", "description": "Introduce adaptive strategy for PSO parameters and incorporate local search phases to enhance convergence speed and accuracy.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.9\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.random.uniform(-1, 1, (self.pop_size, self.dim)) * (ub - lb)\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            adaptive_inertia = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (adaptive_inertia * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Local Search Phase\n            if self.curr_evaluations < self.budget and np.random.rand() < 0.1:\n                for _ in range(5):\n                    local_search = gbest_position + np.random.uniform(-0.1, 0.1, self.dim) * (ub - lb)\n                    local_search = np.clip(local_search, lb, ub)\n                    local_score = func(local_search)\n                    self.curr_evaluations += 1\n\n                    if local_score < pbest_scores[gbest_idx]:\n                        gbest_position = local_search\n                        pbest_scores[gbest_idx] = local_score\n\n                    if self.curr_evaluations >= self.budget:\n                        break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09270 with standard deviation 0.01563.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.07335681932180027, 0.09309341250219316, 0.11163589042988065]}}
{"id": "89b85701-b34e-4220-8e91-fdb26ec37a47", "fitness": 0.09960134236788365, "name": "HybridPSODE", "description": "Enhanced hybrid PSO-DE with adaptive parameters for improved convergence and exploitation-exploration balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.cognitive_coeff = 1.8  # Increased cognitive coefficient\n        self.social_coeff = 1.8  # Increased social coefficient\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n            # Adaptive parameters\n            self.inertia_weight = 0.4 + 0.5 * (self.budget - self.curr_evaluations) / self.budget\n            self.cognitive_coeff = 1.2 + 0.6 * (self.curr_evaluations / self.budget)\n            self.social_coeff = 1.2 + 0.6 * (self.curr_evaluations / self.budget)\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09960 with standard deviation 0.00619.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.09656567540629524, 0.09400782478209568, 0.10823052691526003]}}
{"id": "29d25cf5-923f-4eb9-8a04-5c993419fc6b", "fitness": 0.10139875282033665, "name": "AdaptiveHybridPSODE", "description": "A refined hybrid of Particle Swarm Optimization (PSO) and Differential Evolution (DE) incorporating an adaptive inertia weight and differential mutation factor for enhanced convergence and adaptability.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Start with a higher inertia\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            # Adapt inertia weight and mutation factor\n            self.inertia_weight = 0.4 + (0.5 * (self.budget - self.curr_evaluations) / self.budget)\n            self.mutation_factor = 0.5 + (0.3 * (self.budget - self.curr_evaluations) / self.budget)\n\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10140 with standard deviation 0.00634.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10718474856060967, 0.1044298451919321, 0.09258166470846818]}}
{"id": "304e6064-bb20-4430-9231-2360c078f8a4", "fitness": 0.11358487421083947, "name": "HybridPSODE", "description": "An enhanced hybrid PSO-DE algorithm incorporating adaptive parameter tuning for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            # Adaptive inertia weight adjustment\n            self.inertia_weight = 0.4 + 0.3 * ((self.budget - self.curr_evaluations) / self.budget)\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11358 with standard deviation 0.00703.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.1060007103709758, 0.12294463414372558, 0.11180927811781705]}}
{"id": "9ffa8db6-e3d5-43fd-8f11-71714c24c2d8", "fitness": 0.10189069612721331, "name": "HybridPSODE", "description": "An enhanced hybrid algorithm with adaptive inertia weight and elitism strategy for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9  # Changed from 0.7 to 0.9 for initialization\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            # Adapt inertia weight\n            self.inertia_weight = 0.4 + 0.5 * ((self.budget - self.curr_evaluations) / self.budget)\n            \n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10189 with standard deviation 0.00614.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10190399522610172, 0.1094054037507719, 0.09436268940476633]}}
{"id": "9082d75b-8745-42ac-b01c-b60cf84a4308", "fitness": 0.10850854922412205, "name": "HybridPSODE", "description": "HybridPSODE with adaptive parameters for dynamic balance between exploration and exploitation in optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.curr_evaluations = 0\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            inertia_weight = 0.9 - (0.7 * (self.curr_evaluations / self.budget))\n            cognitive_coeff = 1.5 + (1.0 * (self.curr_evaluations / self.budget))\n            social_coeff = 1.5 - (1.0 * (self.curr_evaluations / self.budget))\n            mutation_factor = 0.8 - (0.4 * (self.curr_evaluations / self.budget))\n            cross_prob = 0.7 + (0.2 * (self.curr_evaluations / self.budget))\n            \n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (inertia_weight * vel[i] + \n                          cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10851 with standard deviation 0.00733.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.11884318394663729, 0.10259569451187012, 0.10408676921385873]}}
{"id": "6f3d956e-833d-4381-a5e8-73408e8e9e04", "fitness": 0.09826055966436087, "name": "AdaptiveHybridPSODE", "description": "Integrate adaptive parameter control and local search into HybridPSODE for enhanced convergence and solution quality.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n            self.local_search(swarm, func, lb, ub)\n\n        return gbest_position, pbest_scores[gbest_idx]\n\n    def adapt_parameters(self):\n        progress_ratio = self.curr_evaluations / self.budget\n        self.inertia_weight = 0.9 - 0.5 * progress_ratio\n        self.mutation_factor = 0.8 + 0.2 * progress_ratio\n\n    def local_search(self, swarm, func, lb, ub):\n        # Simple local search by slight perturbation\n        for i in range(self.pop_size):\n            perturbation = np.random.uniform(-0.01, 0.01, self.dim)\n            candidate = np.clip(swarm[i] + perturbation, lb, ub)\n            candidate_score = func(candidate)\n            if candidate_score < func(swarm[i]):\n                swarm[i] = candidate", "configspace": "", "generation": 15, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09826 with standard deviation 0.00928.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.09556275666067149, 0.11072935091298719, 0.08848957141942393]}}
{"id": "0f9d2777-f5b7-48d5-b483-434df7998b07", "fitness": 0.09708915828957632, "name": "RefinedHybridPSODE", "description": "A refined hybrid metaheuristic combining PSO with DE, introducing adaptive parameters for dynamic search behavior adjustment for improved convergence.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.inertia_min = 0.4\n        self.inertia_max = 0.9\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            # Adaptive inertia weight adjustment\n            self.inertia_weight = self.inertia_max - ((self.inertia_max - self.inertia_min) * (self.curr_evaluations / self.budget))\n\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                        if self.curr_evaluations >= self.budget:\n                            break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09709 with standard deviation 0.00815.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.08800773219354907, 0.09548091391138447, 0.10777882876379541]}}
{"id": "90343bc3-2c0e-45e3-b56c-504f7f648407", "fitness": 0.10857378144504481, "name": "HybridPSODE", "description": "Enhances the HybridPSODE algorithm by dynamically adjusting weights and introducing elitism for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.inertia_weight = 0.5 + 0.2 * np.random.rand()  # Dynamic inertia adjustment\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n            best_idx = np.argmin(swarm_scores)  # Ensure elitism\n            gbest_position = swarm[best_idx]\n            if self.curr_evaluations >= self.budget:\n                break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10857 with standard deviation 0.01510.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.10411719170288469, 0.12889014668738863, 0.09271400594486112]}}
{"id": "3fa254c7-bc22-460e-befa-a0a075314326", "fitness": 0.12058599863697113, "name": "ImprovedHybridPSODE", "description": "Improved HybridPSODE with adaptive parameters and archiving mechanism to enhance global search and convergence.", "code": "import numpy as np\n\nclass ImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n\n    def adapt_parameters(self):\n        # Adaptive inertia weight decreasing linearly\n        self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n        # Adaptive mutation factor based on success rate\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.5 + 0.3 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))  # Archive success\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))  # Archive failure\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm ImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12059 with standard deviation 0.00186.", "error": "", "parent_ids": ["5639ccff-bbf4-46b1-b57d-5bfd7c1c2024"], "operator": null, "metadata": {"aucs": [0.1179672342512097, 0.12208508764026882, 0.12170567401943488]}}
{"id": "0d86fdee-cea7-4a4e-b4ec-d6b7d34612af", "fitness": -Infinity, "name": "EnhancedHybridPSODE", "description": "EnhancedHybridPSODE incorporates an adaptive escape mechanism for local optima and dynamic parameter tuning to accelerate convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.escape_prob = 0.1\n\n    def adapt_parameters(self):\n        # Adaptive inertia weight decreasing linearly\n        self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n        # Adaptive mutation factor based on success rate\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.5 + 0.3 * success_rate\n        # Update escape probability to encourage exploration\n        self.escape_prob = 0.1 + 0.2 * (1 - success_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                new_position = swarm[i] + vel[i]\n                # Escape Strategy\n                if np.random.rand() < self.escape_prob:\n                    new_position = np.random.uniform(lb, ub, self.dim)\n                swarm[i] = np.clip(new_position, lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))  # Archive success\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))  # Archive failure\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 19, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'success_rate' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'success_rate' referenced before assignment\")", "parent_ids": ["3fa254c7-bc22-460e-befa-a0a075314326"], "operator": null, "metadata": {}}
{"id": "26c2962f-b1da-4c40-b06a-49cf19020219", "fitness": 0.12316884716503944, "name": "ImprovedHybridPSODE", "description": "Enhanced HybridPSODE by optimizing swarm initialization and refining parameter adaptation for better convergence.", "code": "import numpy as np\n\nclass ImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n\n    def adapt_parameters(self):\n        # Adaptive inertia weight decreasing linearly\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)  # slightly refined\n        # Adaptive mutation factor based on success rate\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate  # slightly refined\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))  # refined initialization\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # DE Mutation and Crossover\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                # Evaluate and Select\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))  # Archive success\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))  # Archive failure\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm ImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12317 with standard deviation 0.01092.", "error": "", "parent_ids": ["3fa254c7-bc22-460e-befa-a0a075314326"], "operator": null, "metadata": {"aucs": [0.10856703660183098, 0.13482060151933084, 0.12611890337395648]}}
{"id": "796b2fc8-04e7-44f8-95bd-0a8476b259e4", "fitness": 0.13182843755920645, "name": "ImprovedHybridPSODE", "description": "Improved exploitation by incorporating adaptive mutation scaling and enhanced crossover mechanisms.", "code": "import numpy as np\n\nclass ImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate  # adjusted crossover probability\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector) # added greedy selection\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])  # enhanced crossover\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm ImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13183 with standard deviation 0.02068.", "error": "", "parent_ids": ["26c2962f-b1da-4c40-b06a-49cf19020219"], "operator": null, "metadata": {"aucs": [0.11752434356364727, 0.16106651098172775, 0.1168944581322443]}}
{"id": "a7c17cf6-d82e-4bfc-8e6b-f6e583e78ff4", "fitness": 0.13571779624134572, "name": "EnhancedImprovedHybridPSODE", "description": "Enhanced exploration via adaptive velocity clamping and swarm diversity preservation to balance global and local search.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                # Apply velocity clamping\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13572 with standard deviation 0.00150.", "error": "", "parent_ids": ["796b2fc8-04e7-44f8-95bd-0a8476b259e4"], "operator": null, "metadata": {"aucs": [0.1354805351803986, 0.13400838008450244, 0.13766447345913613]}}
{"id": "05557d2f-2c25-46ce-b115-35b700e465ed", "fitness": 0.09923089268027689, "name": "EnhancedImprovedHybridPSODE", "description": "Enhanced exploration and exploitation through dynamic inertia adjustment and adaptive mutation balance based on swarm diversity metrics.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        diversity = np.std(self.swarm, axis=0).mean()\n        self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n        self.mutation_factor = 0.5 + 0.5 * np.clip(diversity / (self.dim * 0.1), 0, 1)\n        self.cross_prob = 0.6 + 0.3 * (1 - np.clip(diversity / (self.dim * 0.1), 0, 1))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(self.swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, self.swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = self.swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - self.swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - self.swarm[i]))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                self.swarm[i] += vel[i]\n                self.swarm[i] = np.clip(self.swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], self.swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, self.swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    self.swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(self.swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09923 with standard deviation 0.00113.", "error": "", "parent_ids": ["a7c17cf6-d82e-4bfc-8e6b-f6e583e78ff4"], "operator": null, "metadata": {"aucs": [0.09889940174587064, 0.10075468457624415, 0.09803859171871587]}}
{"id": "b59c2d5d-4ff8-4492-964a-23054ce1ef9b", "fitness": 0.1076845827943242, "name": "EnhancedImprovedHybridPSODE", "description": "Enhanced exploration through adaptive velocity clamping with a focus on chaotic local search to improve global and local balance.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def chaotic_local_search(self, swarm, lb, ub):\n        # Introducing a chaotic local search to enhance local exploitation\n        chaotic_factor = np.random.uniform(0, 1, self.dim) * np.cosh(3.8 * swarm - 3.8 * np.floor(swarm))\n        swarm = np.clip(swarm + chaotic_factor * (ub - lb) * 0.01, lb, ub)\n        return swarm\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                # Apply velocity clamping\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = self.chaotic_local_search(swarm[i], lb, ub)  # Apply chaotic local search\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10768 with standard deviation 0.00953.", "error": "", "parent_ids": ["a7c17cf6-d82e-4bfc-8e6b-f6e583e78ff4"], "operator": null, "metadata": {"aucs": [0.10456155512489318, 0.12060460336360357, 0.09788758989447588]}}
{"id": "cd2b7500-190e-408c-843d-0629040c0705", "fitness": 0.10571360984189593, "name": "EnhancedImprovedHybridPSODE", "description": "Enhanced exploration via adaptive velocity clamping and swarm diversity preservation with dynamic population size adjustment.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            # Dynamically adjust population size\n            self.pop_size = max(30, int(50 * (1 - self.curr_evaluations / self.budget)))\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                # Apply velocity clamping\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10571 with standard deviation 0.00359.", "error": "", "parent_ids": ["a7c17cf6-d82e-4bfc-8e6b-f6e583e78ff4"], "operator": null, "metadata": {"aucs": [0.10417781504125079, 0.1106718322568786, 0.1022911822275584]}}
{"id": "dbddfd82-657b-4c8a-9722-d001723e66bd", "fitness": 0.14124694335655363, "name": "EnhancedImprovedHybridPSODE", "description": "Enhance exploration by adjusting the cognitive coefficient adaptively based on diversity.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()  # Calculate diversity\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())  # adaptive cognitive coefficient\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                # Apply velocity clamping\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14125 with standard deviation 0.00308.", "error": "", "parent_ids": ["a7c17cf6-d82e-4bfc-8e6b-f6e583e78ff4"], "operator": null, "metadata": {"aucs": [0.1392663418598279, 0.1388800221574381, 0.1455944660523949]}}
{"id": "b42fe262-673c-4250-ac8a-309f0dded033", "fitness": 0.12262836348207155, "name": "EnhancedImprovedHybridPSODE", "description": "Enhance solution exploitation by introducing a dynamic local search around top-performing particles and adaptive neighborhood size.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.adaptive_neighborhood = 5\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n            self.adaptive_neighborhood = max(2, int(self.pop_size * (1 - success_rate)))\n\n    def local_search(self, position, func, lb, ub):\n        perturbation = (ub - lb) * 0.05 * np.random.randn(self.dim)\n        trial_position = np.clip(position + perturbation, lb, ub)\n        trial_score = func(trial_position)\n        return trial_position, trial_score\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n            top_performers_idx = np.argsort(pbest_scores)[:self.adaptive_neighborhood]\n            for idx in top_performers_idx:\n                new_position, new_score = self.local_search(pbest_positions[idx], func, lb, ub)\n                self.curr_evaluations += 1\n                if new_score < pbest_scores[idx]:\n                    pbest_scores[idx] = new_score\n                    pbest_positions[idx] = new_position\n                    if new_score < pbest_scores[gbest_idx]:\n                        gbest_position = new_position\n                        gbest_idx = idx\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12263 with standard deviation 0.00805.", "error": "", "parent_ids": ["dbddfd82-657b-4c8a-9722-d001723e66bd"], "operator": null, "metadata": {"aucs": [0.11457453586152078, 0.13362708851217941, 0.11968346607251446]}}
{"id": "2cb49343-ad69-4516-a0a7-cc5d4ce4d76c", "fitness": 0.1068195053978855, "name": "EnhancedImprovedHybridPSODE", "description": "Introduced dynamic velocity clamping based on fitness progress to enhance local exploitation.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()  # Calculate diversity\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())  # adaptive cognitive coefficient\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                # Apply velocity clamping\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm_scores) * 0.05  # Modified line for dynamic clamping\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10682 with standard deviation 0.00532.", "error": "", "parent_ids": ["dbddfd82-657b-4c8a-9722-d001723e66bd"], "operator": null, "metadata": {"aucs": [0.10550814465514291, 0.11388608165639691, 0.10106428988211669]}}
{"id": "bca16cfb-2d9f-4bc5-b66b-d16495d20ff0", "fitness": 0.13680573108532856, "name": "EnhancedImprovedHybridPSODE", "description": "Introduce a Lvy flight strategy to enhance global exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        return u / np.abs(v) ** (1 / beta)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.3:\n                    swarm[i] += self.levy_flight(swarm[i])  # Introduce Lvy flight exploration\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13681 with standard deviation 0.00500.", "error": "", "parent_ids": ["dbddfd82-657b-4c8a-9722-d001723e66bd"], "operator": null, "metadata": {"aucs": [0.14363059545284607, 0.13181399133271599, 0.13497260647042364]}}
{"id": "342ddce9-cc69-46cc-a3f4-0618493165fe", "fitness": 0.14563293023098775, "name": "EnhancedImprovedHybridPSODE", "description": "Enhance search balance by tuning the social coefficient based on convergence rate.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()  # Calculate diversity\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())  # adaptive cognitive coefficient\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())  # adaptive social coefficient\n                vel[i] = (self.inertia_weight * vel[i] + \n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                # Apply velocity clamping\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14563 with standard deviation 0.00407.", "error": "", "parent_ids": ["dbddfd82-657b-4c8a-9722-d001723e66bd"], "operator": null, "metadata": {"aucs": [0.14377026750720645, 0.14185261005686722, 0.15127591312888955]}}
{"id": "265df595-d0a9-444e-9f16-d857ffea2c2c", "fitness": 0.10036999561341746, "name": "AdaptiveMultiPopulationPSODE", "description": "Integrate adaptive multi-population strategies to dynamically balance exploration and exploitation based on convergence trends.", "code": "import numpy as np\n\nclass AdaptiveMultiPopulationPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.num_subpopulations = 2\n        self.subpop_size = self.pop_size // self.num_subpopulations\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        subpopulations = [np.random.uniform(lb, ub, (self.subpop_size, self.dim)) for _ in range(self.num_subpopulations)]\n        velocities = [np.zeros((self.subpop_size, self.dim)) for _ in range(self.num_subpopulations)]\n        pbest_positions = [np.copy(subpop) for subpop in subpopulations]\n        pbest_scores = [np.full(self.subpop_size, np.inf) for _ in range(self.num_subpopulations)]\n        \n        subpop_scores = [np.apply_along_axis(func, 1, subpop) for subpop in subpopulations]\n        self.curr_evaluations += self.pop_size\n\n        for idx, scores in enumerate(subpop_scores):\n            for i in range(self.subpop_size):\n                if scores[i] < pbest_scores[idx][i]:\n                    pbest_scores[idx][i] = scores[i]\n                    pbest_positions[idx][i] = subpopulations[idx][i]\n\n        gbest_position = None\n        gbest_score = np.inf\n        for idx in range(self.num_subpopulations):\n            gbest_idx = np.argmin(pbest_scores[idx])\n            if pbest_scores[idx][gbest_idx] < gbest_score:\n                gbest_position = pbest_positions[idx][gbest_idx]\n                gbest_score = pbest_scores[idx][gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for subpop_idx, (subpop, vel, p_positions, p_scores) in enumerate(zip(subpopulations, velocities, pbest_positions, pbest_scores)):\n                for i in range(self.subpop_size):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    vel[i] = (self.inertia_weight * vel[i] + \n                              self.cognitive_coeff * r1 * (p_positions[i] - subpop[i]) +\n                              self.social_coeff * r2 * (gbest_position - subpop[i]))\n                    vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                    subpop[i] += vel[i]\n                    subpop[i] = np.clip(subpop[i], lb, ub)\n\n                    idxs = [idx for idx in range(self.subpop_size) if idx != i]\n                    a, b, c = subpop[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                    crossover = np.random.rand(self.dim) < self.cross_prob\n                    greedy_vector = np.where(subpop_scores[subpop_idx][i] < p_scores[i], subpop[i], mutant_vector)\n                    trial_vector = np.where(crossover, greedy_vector, subpop[i])\n\n                    trial_score = func(trial_vector)\n                    self.curr_evaluations += 1\n\n                    if trial_score < subpop_scores[subpop_idx][i]:\n                        self.archive.append((i, True))\n                        subpop[i] = trial_vector\n                        subpop_scores[subpop_idx][i] = trial_score\n                        \n                        if trial_score < p_scores[i]:\n                            p_scores[i] = trial_score\n                            p_positions[i] = trial_vector\n\n                            if trial_score < gbest_score:\n                                gbest_position = trial_vector\n                                gbest_score = trial_score\n\n                    else:\n                        self.archive.append((i, False))\n\n                    if self.curr_evaluations >= self.budget:\n                        break\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std([np.std(subpop, axis=0) for subpop in subpopulations], axis=0).mean() * 0.1\n\n        return gbest_position, gbest_score", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveMultiPopulationPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10037 with standard deviation 0.00107.", "error": "", "parent_ids": ["342ddce9-cc69-46cc-a3f4-0618493165fe"], "operator": null, "metadata": {"aucs": [0.09886560070039752, 0.10103699788554055, 0.1012073882543143]}}
{"id": "c0f5bb90-c14e-4098-9028-c07b1ca00137", "fitness": 0.14921431711522562, "name": "EnhancedImprovedHybridPSODE", "description": "Introduce differential velocity adaptation to enhance global exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()  # Calculate diversity\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())  # adaptive cognitive coefficient\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())  # adaptive social coefficient\n                # Differential velocity adaptation\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (gbest_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                # Apply velocity clamping\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14921 with standard deviation 0.00123.", "error": "", "parent_ids": ["342ddce9-cc69-46cc-a3f4-0618493165fe"], "operator": null, "metadata": {"aucs": [0.1475462374495521, 0.1496190838975966, 0.1504776299985282]}}
{"id": "b93a4c75-fdb5-48c4-ae4e-773f2d86bd10", "fitness": 0.1271099530145076, "name": "EnhancedDynamicInertiaPSODE", "description": "Integrate dynamic inertia reduction and adaptive differential mutation strategy for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicInertiaPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n\n    def adapt_parameters(self):\n        \"\"\"Dynamic adjustment of parameters.\"\"\"\n        # Gradually reduce inertia weight\n        self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n        # Determine success rate\n        if self.archive:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.7 + 0.3 * success_rate\n            self.cross_prob = 0.8 - 0.3 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n        \n        # Initial evaluation\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                # Dynamic cognitive and social coefficients based on diversity\n                diversity = np.std(swarm, axis=0).mean()\n                self.cognitive_coeff = 2.0 - 0.5 * (diversity / (ub - lb).mean())\n                self.social_coeff = 1.5 + 0.5 * (1.0 - diversity / (ub - lb).mean())\n                \n                # Update velocity with adaptive inertia\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                \n                # Update position\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Update velocity clamping factor to promote diversity\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedDynamicInertiaPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12711 with standard deviation 0.00149.", "error": "", "parent_ids": ["c0f5bb90-c14e-4098-9028-c07b1ca00137"], "operator": null, "metadata": {"aucs": [0.12872192305308627, 0.12747542893585262, 0.1251325070545839]}}
{"id": "406973b3-82b4-4c08-aa2e-e73fee142b3e", "fitness": 0.15748852945448533, "name": "EnhancedImprovedHybridPSODE", "description": "Introduce adaptive inertia weight and enhanced diversity preservation for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()  # Calculate diversity\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())  # adaptive cognitive coefficient\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())  # adaptive social coefficient\n                \n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (gbest_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15749 with standard deviation 0.00199.", "error": "", "parent_ids": ["c0f5bb90-c14e-4098-9028-c07b1ca00137"], "operator": null, "metadata": {"aucs": [0.15896107750952404, 0.15882542081492912, 0.15467909003900282]}}
{"id": "5d134a9f-92b2-4bb3-8e99-1c90c7b30d6a", "fitness": 0.14439151285421134, "name": "AdaptiveMultiPhasePSODE", "description": "Adaptive multi-phase PSO-DE hybrid with dynamic velocity adjustment and context-sensitive parameter tuning for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.5 + 0.4 * success_rate\n            self.cross_prob = 0.5 + 0.3 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + 0.1 * (ub - lb), ub - 0.1 * (ub - lb), (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n                \n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 5) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.1\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14439 with standard deviation 0.01141.", "error": "", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {"aucs": [0.1322826178137423, 0.14120999074235263, 0.15968193000653907]}}
{"id": "4558eafd-5cbb-4be6-925f-56728d7f611e", "fitness": 0.1273560474843144, "name": "AdaptiveDiversityDrivenPSO_DE", "description": "Adaptive Diversity-Driven PSO-DE: Enhances exploration by dynamically adjusting parameters based on swarm diversity and performance feedback.", "code": "import numpy as np\n\nclass AdaptiveDiversityDrivenPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n\n    def adapt_parameters(self, success_rate, diversity, lb, ub):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        self.mutation_factor = 0.6 + 0.4 * success_rate\n        self.cross_prob = 0.6 + 0.2 * success_rate\n        self.cognitive_coeff = 2.0 - 1.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.0 + 0.5 * (diversity / (ub - lb).mean())\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            success_rate = sum(1 for _, succ in self.archive if succ) / max(1, len(self.archive))\n            self.adapt_parameters(success_rate, diversity, lb, ub)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (gbest_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm AdaptiveDiversityDrivenPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12736 with standard deviation 0.00602.", "error": "", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {"aucs": [0.12317582698847063, 0.13586822624456807, 0.12302408921990449]}}
{"id": "b3875e4e-9269-4a74-9b83-1e5e2ea989ef", "fitness": 0.15508213442194851, "name": "EnhancedImprovedHybridPSODE", "description": "Fine-tune the velocity clamping dynamically based on diversity to enhance convergence reliability.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()  # Calculate diversity\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())  # adaptive cognitive coefficient\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())  # adaptive social coefficient\n                \n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (gbest_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -diversity * 0.1, diversity * 0.1)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15508 with standard deviation 0.00423.", "error": "", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {"aucs": [0.15983113124883075, 0.15585492917115584, 0.14956034284585895]}}
{"id": "ec4103a8-1ed9-4706-8134-86042a77f81a", "fitness": 0.10834352268624221, "name": "EnhancedImprovedHybridPSODE", "description": "Introduce an adaptive velocity clamping mechanism to enhance convergence dynamics.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()  # Calculate diversity\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())  # adaptive cognitive coefficient\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())  # adaptive social coefficient\n                \n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (gbest_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = min(np.std(swarm, axis=0).mean() * 0.15, 0.2)  # Adaptive velocity clamping\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10834 with standard deviation 0.00664.", "error": "", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {"aucs": [0.11671475996136449, 0.10782920707780208, 0.10048660101956008]}}
{"id": "c5a168fc-129f-49ea-a5a6-282fb5f0e353", "fitness": 0.1398178530069858, "name": "EnhancedImprovedHybridPSODEv2", "description": "Implement dynamic switching between exploration and exploitation using adaptive velocity scaling and enhanced selection diversity.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.switch_threshold = 0.1  # new parameter for exploration-exploitation switch\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n        success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive) if len(self.archive) > 0 else 0\n        self.mutation_factor = 0.6 + 0.4 * success_rate\n        self.cross_prob = 0.6 + 0.3 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n\n                # Dynamic velocity scaling for exploration-exploitation switching\n                velocity_scale = 1.0 if diversity > self.switch_threshold else 0.5\n                vel[i] = (self.inertia_weight * vel[i] +\n                          velocity_scale * (self.cognitive_coeff * r1 + self.social_coeff * r2) * (gbest_position - swarm[i]))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedImprovedHybridPSODEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13982 with standard deviation 0.00811.", "error": "", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {"aucs": [0.13852034700397098, 0.13060037845317374, 0.15033283356381266]}}
{"id": "9301b01d-4f40-4893-9224-9b567b431cbc", "fitness": 0.15691277817334814, "name": "ChaoticEnhancedHybridPSODE", "description": "Integrate a chaotic map and adaptive velocity adjustment to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ChaoticEnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.chaos_sequence = self.generate_chaos_sequence(self.pop_size)\n        self.vel_decay_factor = 0.98\n\n    def generate_chaos_sequence(self, length):\n        # Logistic map for chaos sequence generation\n        chaos_sequence = np.zeros(length)\n        chaos_sequence[0] = 0.5  # initial value\n        for i in range(1, length):\n            chaos_sequence[i] = 4.0 * chaos_sequence[i-1] * (1 - chaos_sequence[i-1])\n        return chaos_sequence\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                diversity = np.std(swarm, axis=0).mean()\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n                \n                chaotic_influence = self.chaos_sequence[i % len(self.chaos_sequence)]\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (gbest_position - swarm[i]) +\n                          chaotic_influence * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i] * self.vel_decay_factor, -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 40, "feedback": "The algorithm ChaoticEnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15691 with standard deviation 0.00219.", "error": "", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {"aucs": [0.15690770134197118, 0.15959666583017496, 0.1542339673478983]}}
{"id": "ac4eacf7-4645-4e28-a4b9-ff39a2333558", "fitness": -Infinity, "name": "EnhancedImprovedHybridPSODE", "description": "Introduce multi-population strategy with dynamic regrouping and enhanced velocity adaptation to improve convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.num_subpops = 3\n        self.subpop_size = self.pop_size // self.num_subpops\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def dynamic_regrouping(self, swarm, scores):\n        # Regrouping strategy: every 20% of the budget, regroup the populations\n        if self.curr_evaluations % (self.budget // 5) == 0: \n            indices = np.argsort(scores)\n            best_indices = indices[:self.subpop_size]\n            remaining_indices = indices[self.subpop_size:]\n            np.random.shuffle(remaining_indices)\n            subpops = [best_indices] + np.split(remaining_indices, self.num_subpops - 1)\n            return [swarm[subpop] for subpop in subpops]\n        else:\n            return [swarm[i:i + self.subpop_size] for i in range(0, self.pop_size, self.subpop_size)]\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            subpopulations = self.dynamic_regrouping(swarm, pbest_scores)\n            for subpop in subpopulations:\n                for i in range(len(subpop)):\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    diversity = np.std(subpop, axis=0).mean()\n                    self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n                    self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n                    \n                    vel[i] = (self.inertia_weight * vel[i] +\n                              (self.cognitive_coeff * r1 + self.social_coeff * r2) * (gbest_position - subpop[i]) +\n                              0.1 * (np.random.rand(self.dim) - 0.5))\n                    vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                    subpop[i] += vel[i]\n                    subpop[i] = np.clip(subpop[i], lb, ub)\n\n                    idxs = [idx for idx in range(len(subpop)) if idx != i]\n                    a, b, c = subpop[np.random.choice(idxs, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                    crossover = np.random.rand(self.dim) < self.cross_prob\n                    greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], subpop[i], mutant_vector)\n                    trial_vector = np.where(crossover, greedy_vector, subpop[i])\n\n                    trial_score = func(trial_vector)\n                    self.curr_evaluations += 1\n\n                    if trial_score < swarm_scores[i]:\n                        self.archive.append((i, True))\n                        subpop[i] = trial_vector\n                        swarm_scores[i] = trial_score\n                        \n                        if trial_score < pbest_scores[i]:\n                            pbest_scores[i] = trial_score\n                            pbest_positions[i] = trial_vector\n\n                            if trial_score < pbest_scores[gbest_idx]:\n                                gbest_position = trial_vector\n                                gbest_idx = i\n\n                    else:\n                        self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 41, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {}}
{"id": "e94b5c8c-770e-4880-b0ff-078b6e001729", "fitness": 0.1655619530607788, "name": "EnhancedImprovedHybridPSODE", "description": "Improve exploration-exploitation balance using adaptive parameter updating and leader-follower dynamics inspired by social animal behavior.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n        self.leader_follower_ratio = 0.2\n\n    def adapt_parameters(self):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            self.adapt_parameters()\n            diversity = np.std(swarm, axis=0).mean()\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n                self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n\n                leader_follower = np.random.rand() < self.leader_follower_ratio\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16556 with standard deviation 0.00432.", "error": "", "parent_ids": ["406973b3-82b4-4c08-aa2e-e73fee142b3e"], "operator": null, "metadata": {"aucs": [0.16740140536492087, 0.16968565215118891, 0.15959880166622664]}}
{"id": "f185d3f3-bfd7-4d69-8f4a-5435a5e3251c", "fitness": 0.16038736564978442, "name": "EnhancedImprovedHybridPSODEv2", "description": "Enhance convergence by introducing a dynamic leader-follower switch and adaptive exploration-exploitation adjustment based on fitness diversity.", "code": "import numpy as np\n\nclass EnhancedImprovedHybridPSODEv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (self.budget / 100))\n        self.social_coeff = 1.5 + 0.2 * (1.0 - diversity / (self.budget / 100))\n\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm_scores)\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < self.leader_follower_ratio\n                if leader_follower:\n                    target_position = swarm[np.random.choice(range(self.pop_size))]\n                else:\n                    target_position = gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                \n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    \n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n                        \n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedImprovedHybridPSODEv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16039 with standard deviation 0.00124.", "error": "", "parent_ids": ["e94b5c8c-770e-4880-b0ff-078b6e001729"], "operator": null, "metadata": {"aucs": [0.16152125685248786, 0.1586585219939043, 0.16098231810296115]}}
{"id": "797f7064-e526-4e95-916b-62bfeea4ec6e", "fitness": 0.15601682697155175, "name": "RefinedEnhancedHybridPSODE", "description": "Enhance swarm intelligence by integrating adaptive inertia weight, variable leader-follower dynamics, and diversity-driven parameter tuning for superior exploration and exploitation equilibrium.", "code": "import numpy as np\n\nclass RefinedEnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff_base = 1.5\n        self.social_coeff_base = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1  # initial velocity clamping factor\n        self.leader_follower_ratio = 0.2\n\n    def adapt_parameters(self, diversity_ratio):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n        self.cognitive_coeff = self.cognitive_coeff_base * (1 + 0.5 * diversity_ratio)\n        self.social_coeff = self.social_coeff_base * (1 - 0.3 * diversity_ratio)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            diversity_ratio = diversity / (ub - lb).mean()\n            self.adapt_parameters(diversity_ratio)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                leader_follower = np.random.rand() < self.leader_follower_ratio\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm RefinedEnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15602 with standard deviation 0.00410.", "error": "", "parent_ids": ["e94b5c8c-770e-4880-b0ff-078b6e001729"], "operator": null, "metadata": {"aucs": [0.1578026217449272, 0.1503482821605412, 0.1598995770091869]}}
{"id": "9630b210-8b22-4b4e-898e-54eac740b284", "fitness": 0.16755373341508614, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance adaptive parameter tuning and leader-follower dynamics by incorporating environment sensing and swarm intelligence principles inspired by ant colony optimization.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16755 with standard deviation 0.00679.", "error": "", "parent_ids": ["e94b5c8c-770e-4880-b0ff-078b6e001729"], "operator": null, "metadata": {"aucs": [0.15810635532688944, 0.17081316544200376, 0.1737416794763652]}}
{"id": "36c2773f-51da-4298-a178-c46447fbcba3", "fitness": -Infinity, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce pheromone evaporation rate adjustment to dynamically influence exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= (1.1 + 0.05 * success_rate)  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= (0.9 - 0.05 * success_rate)  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 46, "feedback": "An exception occurred: NameError(\"name 'success_rate' is not defined\").", "error": "NameError(\"name 'success_rate' is not defined\")", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {}}
{"id": "4cb7d7ed-548c-4723-9c07-39a22a5eb193", "fitness": 0.16538860361682986, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce a dynamic velocity scaling and diversity-driven population update to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.dynamic_velocity_scaling = 0.5  # New parameter\n\n    def adapt_parameters(self, diversity):\n        # Introduce dynamic inertia weight adjustment based on diversity\n        self.inertia_weight = 0.7 + 0.2 * (diversity / (ub - lb).mean())\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                # Apply dynamic velocity scaling\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          self.dynamic_velocity_scaling * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16539 with standard deviation 0.00596.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.15707256858772323, 0.1683530687769046, 0.1707401734858618]}}
{"id": "574baeae-ba1e-4d32-87a0-060272517451", "fitness": -Infinity, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce adaptive pheromone decay and employ dynamic population sizing to enhance exploration-exploitation balance in the EnhancedHybridAntInspiredPSODE.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n        self.initial_pheromone = 1.0\n        self.pheromone_decay = 0.95\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive) if self.archive else 0\n        self.mutation_factor = 0.6 + 0.3 * success_rate\n        self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] = self.initial_pheromone  # reset pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= self.pheromone_decay  # decay pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n                self.dynamic_population_adjustment()\n\n        return gbest_position, pbest_scores[gbest_idx]\n\n    def dynamic_population_adjustment(self):\n        success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive) if self.archive else 0\n        if success_rate < 0.1:\n            self.pop_size = max(20, int(self.pop_size * 0.9))\n        elif success_rate > 0.3:\n            self.pop_size = min(100, int(self.pop_size * 1.1))\n        self.pheromone = np.ones(self.pop_size) * self.initial_pheromone", "configspace": "", "generation": 48, "feedback": "An exception occurred: IndexError('index 54 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 54 is out of bounds for axis 0 with size 50')", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {}}
{"id": "a3c93e3b-bd6c-4516-b446-a1d7a8e8d22e", "fitness": 0.1464614279141455, "name": "EnhancedHybridAntInspiredPSODEImproved", "description": "Enhance swarm adaptability and convergence by integrating feedback loops and hybrid strategies inspired by nature-inspired optimization techniques.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODEImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.9\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.successful_pheromone_increase = 1.05\n        self.unsuccessful_pheromone_decrease = 0.95\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= self.successful_pheromone_increase\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= self.unsuccessful_pheromone_decrease\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedHybridAntInspiredPSODEImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14646 with standard deviation 0.00281.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.15043157478299418, 0.14427889536809435, 0.1446738135913479]}}
{"id": "d3f2de2d-3475-4252-be12-9448656c5d78", "fitness": 0.10041865538202636, "name": "EnhancedHybridAntInspiredPSODE", "description": "Integrate adaptive pheromone evaporation rates and dynamic swarm resizing to enhance exploration-exploitation balance and convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 50\n        self.pop_size = self.initial_pop_size\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.initial_pop_size)  # pheromone trail for each particle\n        self.evaporation_rate = 0.1\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n        # Adjust population size dynamically based on evaluations\n        self.pop_size = max(10, int(self.initial_pop_size * (1 - self.curr_evaluations / self.budget)))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.initial_pop_size, self.dim))\n        vel = np.zeros((self.initial_pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.initial_pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.initial_pop_size\n        \n        for i in range(self.initial_pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= (1 - self.evaporation_rate)  # adaptive pheromone evaporation\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10042 with standard deviation 0.00541.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.09942664506693599, 0.09434020713909996, 0.10748911394004312]}}
{"id": "dc6a2c12-892f-42d7-8493-a2ac80412a8c", "fitness": 0.16568913660125753, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce adaptive pheromone adjustment based on evaluation feedback and inject diversity through stochastic velocity perturbation to enhance global exploration.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                # Inject diversity directly in velocity\n                vel[i] += 0.05 * np.random.randn(self.dim)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    # More aggressive pheromone increase\n                    self.pheromone[i] = min(1.0, self.pheromone[i] * 1.2)\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] = max(0.1, self.pheromone[i] * 0.85)  # decrease pheromone more softly\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16569 with standard deviation 0.00202.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.16600881728024763, 0.16306571890690158, 0.1679928736166234]}}
{"id": "9d6c45b0-d543-479a-9db9-72f40fa67272", "fitness": 0.16316290038162148, "name": "EnhancedHybridAntInspiredPSODE", "description": "Integrate situational awareness and adaptive neighborhood learning to enhance exploration-exploitation balance for solving black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        \n        # New: Tracking success rate and adaptive neighborhood\n        self.neighborhood_size = max(3, self.pop_size // 10)\n        self.success_rate = np.zeros(self.pop_size)\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n        \n        avg_pheromone = np.mean(self.pheromone)\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * avg_pheromone\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                if leader_follower:\n                    neighborhood = np.random.choice(self.pop_size, self.neighborhood_size, replace=False)\n                    target_position = swarm[np.argmin([swarm_scores[n] for n in neighborhood])]\n                else:\n                    target_position = gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16316 with standard deviation 0.00677.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.1610406661490531, 0.17230588109470257, 0.15614215390110875]}}
{"id": "3a417d5f-651d-4856-bbad-ae64a0f2bfc3", "fitness": 0.1601066349812673, "name": "EnhancedHybridAntInspiredPSODE", "description": "Slightly increase the influence of the pheromone trail on leader-follower dynamics to enhance exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + 1.1 * self.pheromone[i])  # Slightly increased influence\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16011 with standard deviation 0.00937.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.14689900694874047, 0.1675665041486163, 0.16585439384644507]}}
{"id": "8e47c708-7386-4028-a9d8-363187ffc2a5", "fitness": 0.16092077830178153, "name": "EnhancedDynamicPheromonePSODE", "description": "Integrate adaptive pheromone management and dynamic velocity adaptation for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicPheromonePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n        self.pheromone_decay = 0.95  # decay rate for pheromone trails\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] = min(self.pheromone[i] * 1.2, 1.0)  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= self.pheromone_decay  # decay pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedDynamicPheromonePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16092 with standard deviation 0.00971.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.14781099162445877, 0.16392352963178236, 0.17102781364910347]}}
{"id": "a85a7325-1171-4ac5-a3d8-5df347968aac", "fitness": 0.1572862806534848, "name": "RefinedAntInspiredPSODE", "description": "Introduce dynamic pheromone update and variable inertia weight for enhanced adaptive exploration and exploitation balance inspired by ant colony and particle swarm intelligence.", "code": "import numpy as np\n\nclass RefinedAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight_init = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor_init = 0.8\n        self.cross_prob_init = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.evaporate_rate = 0.9\n        self.boost_factor = 1.2\n\n    def adapt_parameters(self, diversity):\n        progress = self.curr_evaluations / self.budget\n        self.inertia_weight = (self.inertia_weight_init - self.inertia_weight_final) * (1 - progress) + self.inertia_weight_final\n        self.mutation_factor = self.mutation_factor_init * (1 - progress)\n        self.cross_prob = self.cross_prob_init * (1 - progress)\n\n        success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive) if len(self.archive) > 0 else 0\n        self.cognitive_coeff = 1.5 + 0.5 * success_rate\n        self.social_coeff = 1.5 + 0.5 * (1 - success_rate) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (target_position - swarm[i]))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                a, b, c = swarm[np.random.choice(range(self.pop_size), 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= self.boost_factor\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= self.evaporate_rate\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 55, "feedback": "The algorithm RefinedAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15729 with standard deviation 0.00776.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.14631989373136756, 0.16326030943897085, 0.16227863879011595]}}
{"id": "a5379f8c-095a-46fb-99bd-837dd57ac1b5", "fitness": 0.13201605797971558, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance convergence speed by introducing a dynamic population size adjustment based on the evaluation budget.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = int(50 * (budget / 1000)) if budget > 500 else 50  # Adjust population size based on budget\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13202 with standard deviation 0.00207.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.1326430624205034, 0.13417961453329164, 0.12922549698535168]}}
{"id": "6324466d-aa0b-4845-aaba-2db66f52b3cb", "fitness": 0.16453541360783405, "name": "EnhancedHybridAntInspiredPSODE", "description": "Fine-tune leader-follower dynamics by adjusting the pheromone update rule for a more balanced exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] = 0.9 * self.pheromone[i] + 0.2  # adjust pheromone update rule\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16454 with standard deviation 0.00655.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.15909347101688187, 0.17374303744390684, 0.1607697323627134]}}
{"id": "44db9704-121d-4671-a33a-4b26d3e86016", "fitness": 0.16388315997427064, "name": "EnhancedHybridAntInspiredPSODE", "description": "Refine the adaptive strategies by integrating a diversity-enhanced pheromone feedback mechanism to bolster exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def update_pheromone(self, scores, prev_scores, diversity):\n        for i in range(self.pop_size):\n            delta = (prev_scores[i] - scores[i]) / prev_scores[i] if prev_scores[i] != 0 else 0\n            self.pheromone[i] = min(2.0, max(0.5, self.pheromone[i] + delta * diversity * 0.01))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n            prev_swarm_scores = np.copy(swarm_scores)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(swarm_scores, prev_swarm_scores, diversity)\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16388 with standard deviation 0.01116.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.14873300852859295, 0.17529991831470304, 0.16761655307951595]}}
{"id": "657c56fd-ec68-4bf5-a60e-6da39905f076", "fitness": 0.1654308967119604, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce dynamic environment sensing with adaptive pheromone reinforcement and velocity modulation for improved convergence and stability in swarm-based optimization.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        \n        # Introduce adaptive pheromone reinforcement based on diversity\n        pheromone_effect = min(1.0, 2.0 * (diversity / (ub - lb).mean()))\n        self.pheromone *= pheromone_effect\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16543 with standard deviation 0.00411.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.15965097295246078, 0.16885654420935237, 0.16778517297406803]}}
{"id": "d8c777ae-4898-40e6-ae03-92332b43d1f4", "fitness": 0.16703429806610048, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance adaptive leader-follower dynamics and introduce energy-efficient computational strategies for resource allocation and search space exploration.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.energy_levels = np.ones(self.pop_size)  # energy levels of each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def update_energy(self, index, success):\n        if success:\n            self.energy_levels[index] += 0.1\n        else:\n            self.energy_levels[index] -= 0.1\n        self.energy_levels[index] = np.clip(self.energy_levels[index], 0.5, 1.5)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * self.energy_levels[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                success = trial_score < swarm_scores[i]\n                if success:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9\n\n                self.update_energy(i, success)\n\n                if trial_score < pbest_scores[i]:\n                    pbest_scores[i] = trial_score\n                    pbest_positions[i] = trial_vector\n\n                    if trial_score < pbest_scores[gbest_idx]:\n                        gbest_position = trial_vector\n                        gbest_idx = i\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16703 with standard deviation 0.00291.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.16296784600532166, 0.1695815797589021, 0.1685534684340777]}}
{"id": "98eefd2e-e6c6-4a52-954d-fa09027e97a7", "fitness": 0.16109534934377087, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce adaptive mutation factor scaling based on improving swarm diversity to enhance exploration.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        self.mutation_factor *= 1.2 if diversity < (ub - lb).mean() * 0.2 else 0.9  # Adaptive scaling\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16110 with standard deviation 0.00885.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.15142958071349688, 0.15904708884175034, 0.17280937847606537]}}
{"id": "2a034ab4-37cf-47d3-920f-25b0f3b43215", "fitness": 0.16391132715922696, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance exploration by adjusting leader-follower ratio based on swarm performance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n                    self.leader_follower_ratio = min(0.3, self.leader_follower_ratio * 1.05)\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n                    self.leader_follower_ratio = max(0.1, self.leader_follower_ratio * 0.95)\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16391 with standard deviation 0.00547.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.15622660082379525, 0.16699160272517066, 0.16851577792871497]}}
{"id": "100f06e4-4b6f-4e9e-9cad-c6e865d180f0", "fitness": 0.10448362758093992, "name": "QuantumEnhancedAntInspiredPSO", "description": "Integrate quantum-inspired mechanisms and adaptive learning rates to enhance exploration diversity and convergence efficiency in ant-inspired particle swarm optimization.", "code": "import numpy as np\n\nclass QuantumEnhancedAntInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n        self.learning_rate = 0.01  # adaptive learning rate\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def quantum_perturbation(self, position):\n        alpha = np.random.uniform(-1, 1, self.dim)\n        return position + self.learning_rate * alpha\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                # Quantum-inspired perturbation for enhanced exploration\n                quantum_position = self.quantum_perturbation(swarm[i])\n                quantum_position = np.clip(quantum_position, lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                quantum_score = func(quantum_position)\n                self.curr_evaluations += 2\n\n                if trial_score < swarm_scores[i] or quantum_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    if quantum_score < trial_score:\n                        swarm[i] = quantum_position\n                        swarm_scores[i] = quantum_score\n                    else:\n                        swarm[i] = trial_vector\n                        swarm_scores[i] = trial_score\n\n                    self.pheromone[i] *= 1.1  # increase pheromone for successful paths\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9  # decrease pheromone for unsuccessful paths\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm QuantumEnhancedAntInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10448 with standard deviation 0.00686.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.10920619415215793, 0.10946456908444502, 0.09478011950621679]}}
{"id": "8a65cfe7-8420-40dc-b069-a47bb0a1b7d3", "fitness": 0.15494218196149853, "name": "EnhancedAdaptiveAntBeeInspiredPSODE", "description": "Enhance adaptive parameter tuning, leader-follower strategy, and pheromone-based path reinforcement by integrating dynamic population resizing and feedback-driven velocity adaptation inspired by ant and bee colony behaviors to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveAntBeeInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.dynamic_pop_size = self.pop_size\n\n    def adapt_parameters(self, diversity, success_rate):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        self.mutation_factor = 0.6 + 0.3 * success_rate\n        self.cross_prob = 0.6 + 0.2 * success_rate\n\n        # Adjust coefficients and population size based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (self.dynamic_pop_size * (ub - lb).mean()))\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (self.dynamic_pop_size * (ub - lb).mean())) + 0.1 * np.mean(self.pheromone)\n        self.dynamic_pop_size = max(20, int(self.pop_size * (1 + 0.5 * (1 - success_rate))))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive) if self.archive else 0\n            self.adapt_parameters(diversity, success_rate)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                target_position = gbest_position if not leader_follower else swarm[np.random.choice(range(self.pop_size))]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= 0.9\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedAdaptiveAntBeeInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15494 with standard deviation 0.01475.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.13480291996116445, 0.16970036153481605, 0.16032326438851507]}}
{"id": "20dff42b-5461-45f8-9185-efb58d4c191d", "fitness": -Infinity, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce adaptive pheromone evaporation and dynamic leader selection to enhance swarm intelligence exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)  # pheromone trail for each particle\n        self.evaporate_rate = 0.95  # initial evaporation rate\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n        \n        # Adapt social and cognitive coefficients based on diversity\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n        # Adapt pheromone evaporation rate based on success rate\n        self.evaporate_rate = 0.90 + 0.05 * (1.0 - success_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                # Update particles with consideration for pheromone levels\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                if leader_follower:\n                    leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / self.pheromone.sum())\n                    target_position = swarm[leader_idx]\n                else:\n                    target_position = gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] = self.pheromone[i] * 1.1 * self.evaporate_rate  # increase pheromone\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= self.evaporate_rate  # decrease pheromone\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 65, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'success_rate' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'success_rate' referenced before assignment\")", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {}}
{"id": "b1ac2932-79e7-4444-bcb5-6a7900436912", "fitness": 0.15643417038013804, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introducing an adaptive pheromone evaporation and neighborhood learning mechanism to improve global exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.evaporation_rate = 0.02  # Adaptive pheromone evaporation rate\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                if leader_follower:\n                    neighbors = np.argsort(np.linalg.norm(swarm - swarm[i], axis=1))[:5]\n                    target_position = swarm[np.random.choice(neighbors)]\n                else:\n                    target_position = gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                else:\n                    self.archive.append((i, False))\n                    self.pheromone[i] *= (1.0 - self.evaporation_rate)\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n                self.evaporation_rate = 0.02 + 0.03 * (1.0 - np.mean(self.pheromone / self.pheromone.max()))\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15643 with standard deviation 0.00233.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.15874330602426634, 0.1532454306874983, 0.15731377442864947]}}
{"id": "7205705f-2979-4604-bb02-5f10b5866567", "fitness": 0.17163850296366, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce an adaptive pheromone evaporation strategy and dynamic leader selection to improve exploration and exploitation balance in Ant-Inspired PSO.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17164 with standard deviation 0.00264.", "error": "", "parent_ids": ["9630b210-8b22-4b4e-898e-54eac740b284"], "operator": null, "metadata": {"aucs": [0.17112359159765544, 0.16869922292555706, 0.17509269436776753]}}
{"id": "ea1d49b5-8a99-47b0-9030-e8a46be0abf6", "fitness": 0.16890454971654922, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance leader selection by introducing stochastic ranking to balance exploration-exploitation in the Enhanced Hybrid Ant-Inspired PSO.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                # Stochastic ranking for leader selection\n                scores_with_idx = list(enumerate(swarm_scores))\n                sorted_scores = sorted(scores_with_idx, key=lambda x: x[1])\n                rank_based_probs = np.array([0.9 ** rank for rank, _ in enumerate(sorted_scores)])\n                rank_based_probs /= rank_based_probs.sum()\n                leader_idx = np.random.choice([idx for idx, _ in sorted_scores], p=rank_based_probs)\n                \n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16890 with standard deviation 0.00381.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.16435566239813826, 0.16868291119830403, 0.17367507555320538]}}
{"id": "f19b14b4-f10f-4a08-82fc-c072cb46bf0b", "fitness": -Infinity, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce adaptive dynamic parameter control and pheromone decay influenced by historical success to enhance convergence dynamics in Ant-Inspired PSO.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate * (1 + success_rate))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 69, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'success_rate' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'success_rate' referenced before assignment\")", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {}}
{"id": "2c2ba17f-deec-40cb-9871-b5fa99a2db3e", "fitness": 0.17053985731800178, "name": "EnhancedHybridAntInspiredPSODE", "description": "Incorporate a dynamic learning rate adaptation based on convergence speed and swarm diversity to enhance exploration-exploitation trade-off in EnhancedHybridAntInspiredPSODE.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.learning_rate = 0.1\n\n    def adapt_parameters(self, diversity, conv_speed):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n        self.learning_rate = 0.1 + 0.9 * (1 - conv_speed)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n        prev_gbest_score = pbest_scores[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            conv_speed = (prev_gbest_score - pbest_scores[gbest_idx]) / prev_gbest_score if prev_gbest_score != 0 else 0\n            self.adapt_parameters(diversity, conv_speed)\n            prev_gbest_score = pbest_scores[gbest_idx]\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.learning_rate * ((self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i])) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17054 with standard deviation 0.00601.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.1636826636392622, 0.16961003818911657, 0.17832687012562654]}}
{"id": "c677c423-ad18-4579-a779-1c29ff3222ee", "fitness": 0.16588455266370453, "name": "EnhancedHybridAntInspiredPSODE", "description": "Refine the pheromone update and leader selection mechanism to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                if np.random.rand() < 0.1:  # Added randomness to improve exploration\n                    leader_idx = np.random.choice(range(self.pop_size))\n                else:\n                    leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                \n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1 + 0.05 * (pbest_scores[i] - trial_score)  # Modified pheromone update\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16588 with standard deviation 0.00555.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.17205944483120883, 0.16699521285237195, 0.15859900030753282]}}
{"id": "e448d18d-2342-4421-9440-1eff26e498de", "fitness": 0.17163850296366, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce a diversity-driven adaptive parameter tuning and a elitist archive mechanism to improve convergence efficiency and avoid stagnation in Ant-Inspired PSO.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.elite_archive_size = 5\n        self.elite_archive = []\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def update_elite_archive(self, position, score):\n        if len(self.elite_archive) < self.elite_archive_size:\n            self.elite_archive.append((np.copy(position), score))\n        else:\n            max_idx = np.argmax([s for _, s in self.elite_archive])\n            if score < self.elite_archive[max_idx][1]:\n                self.elite_archive[max_idx] = (np.copy(position), score)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                    self.update_elite_archive(trial_vector, trial_score)\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17164 with standard deviation 0.00264.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.17112359159765544, 0.16869922292555706, 0.17509269436776753]}}
{"id": "d8f1a811-4aba-4d79-a04e-5ba955cdee63", "fitness": 0.15846205641828306, "name": "EnhancedHybridAntInspiredPSODE", "description": "Employ a synergy between adaptive multi-leader selection and pheromone-guided mutation to enhance diversity and convergence in Ant-Inspired PSO.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.pheromone = np.ones(self.pop_size)\n        self.multi_leader_ratio = 0.3  # New parameter for multi-leader selection\n    \n    def adapt_parameters(self, diversity, lb, ub):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n        \n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity, lb, ub)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                \n                leader_indices = np.argsort(self.pheromone)[-int(self.multi_leader_ratio * self.pop_size):]\n                leader_idx = np.random.choice(leader_indices)\n                target_position = swarm[leader_idx]\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15846 with standard deviation 0.00577.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.15520723572483575, 0.16657479559956823, 0.15360413793044525]}}
{"id": "4e0be4ed-8772-4f8b-b60b-0bc118e317c9", "fitness": 0.16026502987809613, "name": "EnhancedHybridAntInspiredPSODE", "description": "Refine pheromone update by increasing its influence on leader selection to enhance convergence rate.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio * np.max(self.pheromone[i]) + 0.1)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16027 with standard deviation 0.01071.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.165283457067669, 0.14537689090601613, 0.17013474166060327]}}
{"id": "2e9b7d6b-fd67-4746-86af-6cfcd8f8d307", "fitness": 0.17163850296366, "name": "EnhancedHybridAntInspiredPSODE", "description": "Integrate a dynamic neighborhood learning strategy to enhance local search capability and update pheromones based on neighborhood success rate.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n                neighborhood_success_rate = sum(1 for j in range(self.pop_size) if np.linalg.norm(swarm[i] - swarm[j]) < 0.1 and swarm_scores[j] < pbest_scores[i])/self.pop_size\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1 + 0.1 * neighborhood_success_rate\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17164 with standard deviation 0.00264.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.17112359159765544, 0.16869922292555706, 0.17509269436776753]}}
{"id": "c83784c8-706f-47a4-ad57-040d23eb6189", "fitness": 0.16586802451203722, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce a non-linear dynamic inertia weight and pheromone scaling to further enhance convergence speed and exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.9 - 0.5 * np.sin((np.pi / 2) * (self.curr_evaluations / self.budget))\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1 + 0.2 * (self.curr_evaluations / self.budget)\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16587 with standard deviation 0.00116.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.1646724725191545, 0.16744690502639126, 0.16548469599056592]}}
{"id": "ef6c8bbf-4336-4d82-bc05-6a2b8d0dc9f9", "fitness": 0.16350236669279775, "name": "EnhancedHybridAntInspiredPSODE", "description": "Augment EnhancedHybridAntInspiredPSODE with probabilistic velocity update to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                if np.random.rand() < 0.7:  # Probabilistic velocity update\n                    vel[i] = (self.inertia_weight * vel[i] +\n                              (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                              0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16350 with standard deviation 0.00255.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.16066628401962013, 0.16298810755074866, 0.16685270850802447]}}
{"id": "e0f82d14-a4aa-4af3-a0df-6d26fa1a32d4", "fitness": 0.1668964406699864, "name": "PredatorPreyAntInspiredPSODE", "description": "Integrate a predator-prey dynamic with variable mutation strategies in the Ant-Inspired PSO to enhance convergence speed and global search capabilities.", "code": "import numpy as np\n\nclass PredatorPreyAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.predator_threshold = 0.3\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def predator_effect(self, scores):\n        worst_idx = np.argsort(scores)[-int(self.predator_threshold * self.pop_size):]\n        for idx in worst_idx:\n            self.pheromone[idx] *= 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n            self.predator_effect(swarm_scores)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm PredatorPreyAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16690 with standard deviation 0.00204.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.1644654034376838, 0.1667766711622709, 0.1694472474100045]}}
{"id": "bb02bcb5-acae-4684-9a4a-32e5f0f28b7c", "fitness": 0.17163850296366, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance exploitation by introducing a dynamic inertia weight adjustment based on recent improvement rates and swarm convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        last_improvement = 0\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                            last_improvement = self.curr_evaluations  # Track last improvement\n\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            # Adjust inertia weight based on improvement rate\n            if self.curr_evaluations - last_improvement > self.budget // 20:\n                self.inertia_weight *= 0.95\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17164 with standard deviation 0.00264.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.17112359159765544, 0.16869922292555706, 0.17509269436776753]}}
{"id": "48b0dc60-9b84-4ca0-86eb-0692ce5330bf", "fitness": 0.18223455752922776, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce a dynamic velocity update mechanism and a more adaptive mutation scheme to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)  # Changed mutation factor from self.mutation_factor to 0.5\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18223 with standard deviation 0.00230.", "error": "", "parent_ids": ["7205705f-2979-4604-bb02-5f10b5866567"], "operator": null, "metadata": {"aucs": [0.1854736308766336, 0.18039401635247754, 0.18083602535857213]}}
{"id": "3f287ca1-9591-46dc-b5c5-10b4928053b5", "fitness": 0.1687100834017072, "name": "RefinedHybridAntInspiredPSODE", "description": "Introduce adaptive pheromone mechanisms and enhanced communication strategies to improve convergence and robustness.", "code": "import numpy as np\n\nclass RefinedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.pheromone_decay = 0.01\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        self.pheromone *= (1 - self.pheromone_decay)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                r3 = np.random.rand()\n\n                leader_follower = r3 < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] = (1 - self.pheromone_decay) * self.pheromone[i] + 0.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm RefinedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16871 with standard deviation 0.01044.", "error": "", "parent_ids": ["48b0dc60-9b84-4ca0-86eb-0692ce5330bf"], "operator": null, "metadata": {"aucs": [0.15960262305203898, 0.1833348487561164, 0.16319277839696622]}}
{"id": "63268c8f-b6c1-4fc6-a2da-964bf111e7c4", "fitness": 0.15660831507614534, "name": "EnhancedHybridAntInspiredPSODE", "description": "Refine exploration by adjusting leader selection probability and enhancing mutation diversity through adaptive mechanisms.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.3  # Changed from 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.7 + 0.3 * success_rate  # Changed from 0.6\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.02 + 0.1 * (1.0 - diversity / (ub - lb).mean())  # Changed from 0.01\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)  # Enhanced mutation diversity\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15661 with standard deviation 0.00460.", "error": "", "parent_ids": ["48b0dc60-9b84-4ca0-86eb-0692ce5330bf"], "operator": null, "metadata": {"aucs": [0.1514655460409371, 0.16263630828698084, 0.15572309090051806]}}
{"id": "3973fe8d-c102-4b24-8387-2ff978b36a86", "fitness": 0.12140855859554085, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce adaptive velocity clamping and pheromone reinforcement based on diversity to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n        self.vel_clamp = 0.05 + 0.25 * (diversity / (ub - lb).mean())  # Changed velocity clamping strategy\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i])\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)  # Restored mutation factor to self.mutation_factor\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.2  # Increased pheromone reinforcement factor\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.15\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12141 with standard deviation 0.00960.", "error": "", "parent_ids": ["48b0dc60-9b84-4ca0-86eb-0692ce5330bf"], "operator": null, "metadata": {"aucs": [0.12336621823780913, 0.10879560483346495, 0.13206385271534848]}}
{"id": "51dc1d4f-79c8-4ad7-81c3-4fe4b89b2b03", "fitness": 0.18737458690137787, "name": "EnhancedHybridAntInspiredPSODE", "description": "Introduce adaptive pheromone influence and dynamic velocity clamping to improve exploration-exploitation balance and convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.2\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18737 with standard deviation 0.00312.", "error": "", "parent_ids": ["48b0dc60-9b84-4ca0-86eb-0692ce5330bf"], "operator": null, "metadata": {"aucs": [0.18788448257758417, 0.18332887330542924, 0.1909104048211202]}}
{"id": "222cf742-57f6-44a8-a4d6-f80aa464e0f9", "fitness": 0.17448344770942392, "name": "RefinedHybridAntInspiredPSODE", "description": "Integrate dynamic swarm intelligence and hybrid mutation-crossover strategies to enhance convergence efficiency and solution accuracy.", "code": "import numpy as np\n\nclass RefinedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.global_diversity = []\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n        self.global_diversity.append(diversity)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.2\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm RefinedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17448 with standard deviation 0.00493.", "error": "", "parent_ids": ["51dc1d4f-79c8-4ad7-81c3-4fe4b89b2b03"], "operator": null, "metadata": {"aucs": [0.1682786656719304, 0.18034160379005326, 0.1748300736662881]}}
{"id": "1e84bf5c-df12-4be1-81bd-ca67bfac137d", "fitness": 0.18333780298922087, "name": "EnhancedHybridAntInspiredPSODE", "description": "Improve convergence by introducing adaptive velocity scaling and enhanced pheromone update.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.vel_scaling_factor = 0.9  # New line for adaptive velocity scaling\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n        self.vel_scaling_factor = 0.5 + 0.4 * (1.0 - diversity / (ub - lb).mean())  # Updated line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp * self.vel_scaling_factor, self.vel_clamp * self.vel_scaling_factor)  # Updated line\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] = min(self.pheromone[i] * 1.2, 1.5)  # Updated line\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.2\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18334 with standard deviation 0.00253.", "error": "", "parent_ids": ["51dc1d4f-79c8-4ad7-81c3-4fe4b89b2b03"], "operator": null, "metadata": {"aucs": [0.18545918179272614, 0.17977669958782538, 0.18477752758711108]}}
{"id": "cd3e184c-f8cf-4d69-b753-4353ca8dcad2", "fitness": 0.11789471054042903, "name": "EnhancedHybridAntInspiredPSODE", "description": "Integrate diversity-driven dynamic pheromone adjustment and velocity scaling to refine swarm adaptability and convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n        self.vel_clamp = 0.05 + 0.15 * (diversity / (ub - lb).mean())  # Modified line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.2\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11789 with standard deviation 0.00728.", "error": "", "parent_ids": ["51dc1d4f-79c8-4ad7-81c3-4fe4b89b2b03"], "operator": null, "metadata": {"aucs": [0.12671266712962947, 0.11807950766861552, 0.10889195682304209]}}
{"id": "06813b08-7b56-496a-9e86-b504baba9ebb", "fitness": 0.18814226213800225, "name": "EnhancedHybridAntInspiredPSODE", "description": "Implement adaptive leader selection and velocity perturbation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] += 0.05 * (np.random.rand(self.dim) - 0.5)  # Added perturbation for velocity\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.2\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18814 with standard deviation 0.00331.", "error": "", "parent_ids": ["51dc1d4f-79c8-4ad7-81c3-4fe4b89b2b03"], "operator": null, "metadata": {"aucs": [0.18561578204991003, 0.19281428551583513, 0.18599671884826163]}}
{"id": "fba87845-cd43-4dfd-945c-4e0de52683b4", "fitness": -Infinity, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance exploration with dynamic population size and introduction of elitism to improve convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.elite_fraction = 0.1  # Added\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] += 0.05 * (np.random.rand(self.dim) - 0.5)  # Added perturbation for velocity\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.2\n\n            # Update 1: Introducing elitism\n            elite_count = int(self.pop_size * self.elite_fraction)\n            elite_indices = np.argsort(swarm_scores)[:elite_count]\n            elite_swarm = swarm[elite_indices]\n            self.pop_size += elite_count  # Update 2: Dynamic population\n            \n            swarm = np.vstack((swarm, elite_swarm))  # Add elite to the swarm (Update 3)\n            swarm_scores = np.append(swarm_scores, swarm_scores[elite_indices])  # Update 4\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 89, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_ids": ["06813b08-7b56-496a-9e86-b504baba9ebb"], "operator": null, "metadata": {}}
{"id": "c06908a1-96b9-45b4-9ead-14b6f2323137", "fitness": 0.17622832384193574, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhance balance between exploration and exploitation by adjusting the mutation factor and leader-following probability based on current diversity.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.1 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9 + 0.1 * diversity / (ub - lb).mean())  # Change 1\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] += 0.05 * (np.random.rand(self.dim) - 0.5)  # Added perturbation for velocity\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)  # Change 2\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.2\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17623 with standard deviation 0.00590.", "error": "", "parent_ids": ["06813b08-7b56-496a-9e86-b504baba9ebb"], "operator": null, "metadata": {"aucs": [0.1694955515613189, 0.1753276906279252, 0.18386172933656308]}}
{"id": "5fe1fb7b-5980-4a88-92f9-2dc29208dc19", "fitness": 0.18930361432079693, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhanced population diversity control and adaptive parameter adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.2 * (1.0 - diversity / (ub - lb).mean())  # Adjusted evaporation rate\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] += 0.1 * (np.random.rand(self.dim) - 0.5)  # Increased perturbation for velocity\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.2  # Increased pheromone update factor\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.3  # Changed velocity clamping strategy\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18930 with standard deviation 0.00154.", "error": "", "parent_ids": ["06813b08-7b56-496a-9e86-b504baba9ebb"], "operator": null, "metadata": {"aucs": [0.1886819731668259, 0.18780082176503388, 0.19142804803053104]}}
{"id": "3dd6ab71-6486-4f93-b1fc-94216220d165", "fitness": -Infinity, "name": "EnhancedDynamicSwarmPSO", "description": "Introduce dynamic swarm restructuring and adaptive memory retention for enhanced convergence in varying search landscapes.", "code": "import numpy as np\n\nclass EnhancedDynamicSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.memory = np.random.uniform(size=(self.pop_size, self.dim))\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def dynamic_swarm_restructuring(self, swarm, scores, gbest_position):\n        idx = np.random.choice(range(self.pop_size), size=int(self.pop_size * 0.1), replace=False)\n        swarm[idx] = gbest_position + np.random.randn(len(idx), self.dim) * 0.1\n        scores[idx] = np.apply_along_axis(func, 1, swarm[idx])\n        self.curr_evaluations += len(idx)\n        return swarm, scores\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.2\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            swarm, swarm_scores = self.dynamic_swarm_restructuring(swarm, swarm_scores, gbest_position)\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.3\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 92, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {}}
{"id": "a817ae18-a1f8-4f50-b6ff-0e4b1187e8a3", "fitness": 0.17443919299537883, "name": "EnhancedHybridAntInspiredPSODE", "description": "Adaptive velocity and pheromone strategies with dynamic leader selection for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (target_position - swarm[i]))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.2\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.3\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17444 with standard deviation 0.00140.", "error": "", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {"aucs": [0.17380410558934234, 0.17312822053262222, 0.17638525286417195]}}
{"id": "828a9452-0448-420b-b03c-42e30d2ede89", "fitness": -Infinity, "name": "MultiPhaseAdaptiveSwarmOptimizer", "description": "Introduce adaptive multi-phase search strategy with dynamic swarm restructuring for enhanced exploration and exploitation balance across different optimization phases.", "code": "import numpy as np\n\nclass MultiPhaseAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.vel_clamp = 0.1\n        self.phase_thresholds = [0.3, 0.7]  # Phase thresholds as fractions of budget\n        self.phase = 0\n        self.pheromone = np.ones(self.pop_size)\n\n    def adapt_parameters(self, diversity):\n        if self.phase == 1:\n            self.inertia_weight *= 0.95  # Gradual reduction in inertia weight\n        elif self.phase == 2:\n            self.social_coeff += 0.1 * (1.0 - diversity / (ub - lb).mean())  # Increase social influence\n\n        evaporation_rate = 0.01 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def update_phase(self):\n        budget_fraction = self.curr_evaluations / self.budget\n        if budget_fraction > self.phase_thresholds[self.phase] and self.phase < len(self.phase_thresholds):\n            self.phase += 1\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.update_phase()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if np.random.rand() < self.pheromone[i] else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n\n                self.pheromone[i] *= 0.9\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.3\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 94, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {}}
{"id": "c5efe849-1d94-4ed0-a00b-e84c48b8b772", "fitness": 0.15957026355115908, "name": "RefinedHybridAntInspiredPSODE", "description": "Hybrid Optimization with Enhanced Social Learning and Dynamic Exploration via Adaptive Archive Management", "code": "import numpy as np\n\nclass RefinedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.dynamic_exploration_factor = 0.1\n\n    def adapt_parameters(self, diversity, success_rate):\n        self.inertia_weight = 0.9 - 0.5 * (self.curr_evaluations / self.budget)\n        self.mutation_factor = 0.5 + 0.4 * success_rate\n        self.cross_prob = 0.6 + 0.3 * success_rate\n        self.dynamic_exploration_factor = 0.1 + 0.4 * (1.0 - diversity / (ub - lb).mean()) * np.mean(self.pheromone)\n        self.cognitive_coeff = 1.4 + 0.6 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.2 + 0.3 * (1.0 - diversity / (ub - lb).mean()) + 0.2 * np.mean(self.pheromone)\n        evaporation_rate = 0.05 + 0.15 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive) if self.archive else 0\n            self.adapt_parameters(diversity, success_rate)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.8)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.cognitive_coeff * r1 * (pbest_positions[i] - swarm[i]) +\n                          self.social_coeff * r2 * (target_position - swarm[i]) +\n                          self.dynamic_exploration_factor * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                trial_vector = np.where(crossover, mutant_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.25\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm RefinedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15957 with standard deviation 0.00216.", "error": "", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {"aucs": [0.1602590463253979, 0.15664447729939945, 0.16180726702867987]}}
{"id": "1dddcd5f-41ab-4361-a86c-667487c6ef2c", "fitness": -Infinity, "name": "QuantumChaoticEnhancedPSODE", "description": "Integration of quantum-inspired techniques and chaotic maps for enhanced diversification and convergence speed in optimization.", "code": "import numpy as np\n\nclass QuantumChaoticEnhancedPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.chaotic_seq = np.random.random(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def quantum_perturbation(self, position, lb, ub):\n        perturbation = np.random.uniform(-1, 1, self.dim)\n        quantum_position = position + perturbation * (self.chaotic_seq * (ub - lb))\n        return np.clip(quantum_position, lb, ub)\n\n    def update_chaotic_sequence(self):\n        self.chaotic_seq = 4 * self.chaotic_seq * (1 - self.chaotic_seq)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n            self.update_chaotic_sequence()\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] += 0.1 * (np.random.rand(self.dim) - 0.5)\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] = self.quantum_perturbation(swarm[i] + vel[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.2\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.3\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 96, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,) (20,) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,) (20,) ')", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {}}
{"id": "0f4c1685-cd1b-4e01-b759-08a886599f8e", "fitness": 0.16627311612611628, "name": "EnhancedHybridAntInspiredPSODE", "description": "Integrating dynamic learning rates and robust pheromone management for enhanced adaptability in diverse optimization landscapes.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.9\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n        self.initial_learning_rate = 0.5\n        self.learning_rate_decay = 0.99\n\n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.8 - 0.3 * (self.curr_evaluations / self.budget)\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.3 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.02 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n        self.learning_rate = self.initial_learning_rate * (self.learning_rate_decay ** (self.curr_evaluations / self.pop_size))\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n\n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          self.learning_rate * (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.1\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n\n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.3\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16627 with standard deviation 0.00161.", "error": "", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {"aucs": [0.16796278209722826, 0.1667558282499303, 0.1641007380311903]}}
{"id": "dfbe8b2e-8fc3-415c-bb1d-88cbefd56a1d", "fitness": 0.17067994778670012, "name": "EnhancedHybridAntInspiredPSODE", "description": "Fine-tuned the algorithm by modifying pheromone update, velocity clamping, and mutation factor to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.85  # 1. Adjusted mutation factor\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.15  # 2. Increased initial velocity clamp\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.6 + 0.2 * success_rate\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.2 * (1.0 - diversity / (ub - lb).mean()) + 0.1 * np.mean(self.pheromone)\n        evaporation_rate = 0.01 + 0.2 * (1.0 - diversity / (ub - lb).mean())\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.9)\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] += 0.1 * (np.random.rand(self.dim) - 0.5)\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), lb, ub)  # 3. Fixed mutation factor usage\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.25  # 4. Adjusted pheromone update factor\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.35  # 5. Adjusted velocity clamping strategy\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17068 with standard deviation 0.01299.", "error": "", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {"aucs": [0.15256155461509724, 0.1770898402029758, 0.1823884485420273]}}
{"id": "7d69705b-8773-41a6-85dd-52ff1ceb0963", "fitness": 0.19112563859413834, "name": "EnhancedHybridAntInspiredPSODE", "description": "Enhanced adaptive mechanisms for parameter tuning and pheromone update to improve convergence and exploration.  ", "code": "import numpy as np\n\nclass EnhancedHybridAntInspiredPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_factor = 0.8\n        self.cross_prob = 0.7\n        self.curr_evaluations = 0\n        self.archive = []\n        self.vel_clamp = 0.1\n        self.leader_follower_ratio = 0.2\n        self.pheromone = np.ones(self.pop_size)\n    \n    def adapt_parameters(self, diversity):\n        self.inertia_weight = 0.85 - 0.4 * (self.curr_evaluations / self.budget)\n        if len(self.archive) > 0:\n            success_rate = sum(1 for _, succ in self.archive if succ) / len(self.archive)\n            self.mutation_factor = 0.6 + 0.3 * success_rate\n            self.cross_prob = 0.65 + 0.15 * success_rate  # Adjusted crossover probability\n\n        self.cognitive_coeff = 1.5 + 0.5 * (diversity / (ub - lb).mean())\n        self.social_coeff = 1.3 + 0.25 * (1.0 - diversity / (ub - lb).mean())  # Adjusted social coefficient\n        evaporation_rate = 0.015 + 0.15 * (1.0 - diversity / (ub - lb).mean())  # Adjusted evaporation rate\n        self.pheromone *= (1 - evaporation_rate)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb + (ub - lb) * 0.1, ub - (ub - lb) * 0.1, (self.pop_size, self.dim))\n        vel = np.zeros((self.pop_size, self.dim))\n        pbest_positions = np.copy(swarm)\n        pbest_scores = np.full(self.pop_size, np.inf)\n\n        swarm_scores = np.apply_along_axis(func, 1, swarm)\n        self.curr_evaluations += self.pop_size\n        \n        for i in range(self.pop_size):\n            if swarm_scores[i] < pbest_scores[i]:\n                pbest_scores[i] = swarm_scores[i]\n                pbest_positions[i] = swarm[i]\n\n        gbest_idx = np.argmin(pbest_scores)\n        gbest_position = pbest_positions[gbest_idx]\n\n        while self.curr_evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n\n                leader_follower = np.random.rand() < (self.leader_follower_ratio + self.pheromone[i] * 0.85)  # Adjusted leader selection\n                leader_idx = np.random.choice(range(self.pop_size), p=self.pheromone / np.sum(self.pheromone))\n                target_position = swarm[leader_idx] if leader_follower else gbest_position\n\n                vel[i] = (self.inertia_weight * vel[i] +\n                          (self.cognitive_coeff * r1 + self.social_coeff * r2) * (target_position - swarm[i]) +\n                          0.1 * (np.random.rand(self.dim) - 0.5))\n                vel[i] += 0.1 * (np.random.rand(self.dim) - 0.5)\n                vel[i] = np.clip(vel[i], -self.vel_clamp, self.vel_clamp)\n                swarm[i] += vel[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = swarm[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + 0.5 * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cross_prob\n                greedy_vector = np.where(swarm_scores[i] < pbest_scores[i], swarm[i], mutant_vector)\n                trial_vector = np.where(crossover, greedy_vector, swarm[i])\n\n                trial_score = func(trial_vector)\n                self.curr_evaluations += 1\n\n                if trial_score < swarm_scores[i]:\n                    self.archive.append((i, True))\n                    swarm[i] = trial_vector\n                    swarm_scores[i] = trial_score\n                    self.pheromone[i] *= 1.25  # Adjusted pheromone update factor\n\n                    if trial_score < pbest_scores[i]:\n                        pbest_scores[i] = trial_score\n                        pbest_positions[i] = trial_vector\n\n                        if trial_score < pbest_scores[gbest_idx]:\n                            gbest_position = trial_vector\n                            gbest_idx = i\n                else:\n                    self.archive.append((i, False))\n\n                if self.curr_evaluations >= self.budget:\n                    break\n            \n            if self.curr_evaluations % (self.budget // 10) == 0:\n                self.vel_clamp = np.std(swarm, axis=0).mean() * 0.3\n\n        return gbest_position, pbest_scores[gbest_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedHybridAntInspiredPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19113 with standard deviation 0.00447.", "error": "", "parent_ids": ["5fe1fb7b-5980-4a88-92f9-2dc29208dc19"], "operator": null, "metadata": {"aucs": [0.19547032891418947, 0.19292743808474289, 0.18497914878348265]}}
