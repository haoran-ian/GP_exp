{"id": "f897e7a7-09a5-4fc3-8bf3-78e826985a0d", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that combines differential evolution with a simulated annealing-inspired acceptance mechanism to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "bf5c51d9-10e0-4894-85cb-d59c0c6fc100", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid algorithm that integrates a chaos-enhanced mutation into differential evolution, balanced by simulated annealing for improved exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def chaotic_sequence(self, size):\n        # Generate a chaotic sequence for enhancing exploration\n        x = 0.4\n        sequence = []\n        for _ in range(size):\n            x = 4 * x * (1 - x)\n            sequence.append(x)\n        return np.array(sequence)\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            chaos = self.chaotic_sequence(self.population_size)\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with chaos-enhancement\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + chaos[i] * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "8441c8ae-f97d-4f10-9ac2-b7f4791719f0", "fitness": 1.0, "name": "AdaptiveHybridDE_SA", "description": "An enhanced hybrid algorithm with adaptive mutation and crossover rates for improved dynamic balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        # Adaptive parameters\n        mutation_rate = 0.8\n        crossover_rate = 0.9\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive rate\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + mutation_rate * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive crossover\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n                \n                # Update adaptive parameters based on progress\n                mutation_rate = 0.5 + 0.3 * np.random.rand()\n                crossover_rate = 0.6 + 0.3 * np.random.rand()\n\n        return best", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "89298ab2-7ed1-43a7-a8a1-cd8b28d7b16a", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that combines differential evolution with a simulated annealing-inspired acceptance mechanism and dynamic crossover probability to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover\n                crossover_rate = 0.9 * (1 - self.current_budget / self.budget) + 0.1\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 3, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "eb673e53-7435-4cf9-9294-3bc3af24f020", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced the HybridDE_SA algorithm by using adaptive mutation and crossover rates in Differential Evolution for better convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        F_base = 0.5  # Base mutation factor\n        Cr_base = 0.9  # Base crossover rate\n\n        while self.current_budget < self.budget:\n            F = F_base + np.random.rand() * 0.4  # Adaptive mutation\n            Cr = Cr_base + np.random.rand() * 0.1  # Adaptive crossover\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 4, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "2722de6d-67e6-4543-af1b-1bc69c244f22", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid algorithm integrating differential evolution with a simulated annealing acceptance mechanism, now incorporating adaptive crossover probability for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_prob = 0.9 * (1 - self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 5, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "607e3efb-7c1c-4722-a3ba-457f213e87fe", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive mutation factor to improve exploration-exploitation balance.  ", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                # Change: Adaptive mutation factor based on current progress\n                F = 0.5 + 0.3 * (1 - self.current_budget / self.budget)\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 6, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "20e26de8-adf1-490b-b388-ef8fa671042b", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive crossover rate for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_rate = 0.9 - (0.8 * self.current_budget / self.budget)  # Adapt crossover rate based on budget\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 7, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "216f8dce-127d-4439-8d43-db9a2c02b4b4", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduce adaptive scaling factor in Differential Evolution to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * (1 - self.current_budget / self.budget)  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 8, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "e4bf4fd1-937d-49ba-abf2-2c9feb265bbf", "fitness": 1.0, "name": "HybridDE_SA", "description": "Improve the exploitation capability by slightly adjusting the crossover probability.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.85  # Adjusted crossover probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 9, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "1b1b27a7-04e2-4117-8c09-0bb6e7d21a5e", "fitness": 1.0, "name": "HybridDE_SA", "description": "An optimized HybridDE_SA algorithm with adaptive crossover probability for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_prob = 0.9 - 0.5 * (self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 10, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "9c73501d-4c25-4048-a652-18688f6b98d9", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced exploration by adaptive mutation scaling and dynamic crossover in HybridDE_SA.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation scaling\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_rate = 0.6 + 0.3 * np.random.rand()  # Dynamic crossover rate\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 11, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "128b78c1-b723-473e-8012-655e1e8e9ed6", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduced adaptive scaling factor for mutation in Differential Evolution to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * (1 - self.current_budget / self.budget)  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 12, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "9675eaa8-6d16-443f-b8a1-840f3836a6ff", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that combines differential evolution and simulated annealing with an adaptive mutation factor to enhance convergence speed and precision.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 + 0.2 * (1 - self.current_budget / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 13, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "b0e8cbc0-cb18-456c-b0cc-f7bf0060f60b", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid algorithm that enhances diversity by periodically injecting random solutions, improving exploration while retaining convergence speed.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n        self.injection_interval = self.budget // 5  # New line\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n            # Periodic injection of random solutions\n            if self.current_budget % self.injection_interval == 0:\n                random_indices = np.random.choice(self.population_size, self.dim, replace=False)\n                population[random_indices] = self.lower_bound + np.random.rand(len(random_indices), self.dim) * (self.upper_bound - self.lower_bound)\n                fitness[random_indices] = np.array([func(ind) for ind in population[random_indices]])\n\n        return best", "configspace": "", "generation": 14, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "815a6e46-3daa-420a-bf13-357511cedf7d", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA using adaptive mutation rates and dynamic population resizing for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            adaptive_mutation = 0.5 + 0.4 * np.random.rand()  # Adaptive mutation rate\n            if self.current_budget > self.budget // 2:\n                self.population_size = max(5, self.population_size // 2)  # Dynamic resizing\n\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(len(population), 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + adaptive_mutation * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 15, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "ed1fa019-d9d4-4f13-9c73-c928d9801c51", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduced dynamic scaling of the crossover rate to balance exploration and exploitation more effectively in different budget phases.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover\n                crossover_rate = 0.9 * (1 - self.current_budget/self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 16, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "2a9b5a2b-feec-402a-93d6-429c583144a2", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduced adaptive differential evolution scaling factor for dynamic balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 + 0.2 * (self.current_budget / self.budget)  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 17, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "8a158d5b-b1d9-4ccf-90bc-11e86d828703", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid optimization algorithm that adjusts mutation factor dynamically to improve convergence speed and accuracy with minimal code alteration.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with dynamic mutation factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + (0.9 - 0.5) * (self.current_budget / self.budget)  # Dynamic mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 18, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "24c21f85-6832-45f6-92df-b1a89920dcca", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that combines differential evolution with a simulated annealing-inspired acceptance mechanism and adaptive mutation scaling to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 * (1 - self.current_budget / self.budget)  # Adaptive mutation scaling\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 19, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "524d82a0-a4be-4a43-a66e-d4e341753098", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive mutation scaling and elite preservation to improve convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive mutation scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 + 0.2 * (1 - self.current_budget / self.budget)  # Adaptive F\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n            # Elite preservation - replace worst with best if necessary\n            worst_idx = np.argmax(fitness)\n            if best_fitness < fitness[worst_idx]:\n                population[worst_idx] = best\n\n        return best", "configspace": "", "generation": 20, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "c8fed679-617e-47b4-a805-8d2bf82f2758", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that combines differential evolution with a simulated annealing-inspired acceptance mechanism and adaptive mutation factor to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 + 0.2 * (1 - self.current_budget / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 21, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "437a8524-7c47-47f3-8e92-61a920448056", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive mutation factor and dynamic population resizing for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            dynamic_population_size = max(4, int(self.population_size * (1 - self.current_budget / self.budget)))  # Dynamic resizing\n            for i in range(dynamic_population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Adaptive Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.4 * (self.current_budget / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 22, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "a0532665-d7bd-44e0-8bd1-0f7e8e1ad492", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive mutation factor and dynamic population size to achieve faster convergence and better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Adaptive Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.5 * (self.current_budget / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 23, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "a0b34837-8b02-4d8b-9ddb-7d9c8374a05f", "fitness": 1.0, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid optimization algorithm integrating a dynamic mutation strategy with adaptive simulated annealing for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        mutation_factor = 0.8\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Adaptive Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutation_factor = 0.5 + 0.3 * np.random.rand()  # Dynamic mutation factor\n                mutant = np.clip(x0 + mutation_factor * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Adaptive Simulated Annealing-inspired acceptance\n                temp = max(1.0, (1.0 - self.current_budget / self.budget))\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temp):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = EnhancedHybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "53cd5628-5ad9-46d8-9eb5-c9ea73b4ef11", "fitness": 1.0, "name": "HybridDE_SA", "description": "HybridDE_SA with adaptive crossover rate based on budget to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive rate\n                crossover_rate = 0.9 - 0.5 * (self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 25, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "a0e60737-2a1c-41c9-844d-3e1cb75c064f", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid algorithm integrating adaptive scaling of the DE mutation factor to dynamically adjust exploration based on convergence progress.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.5 * (1 - self.current_budget / self.budget)  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 26, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "5932d454-ed6b-41c6-a25a-c39acb4eba0e", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid optimization algorithm that combines differential evolution with a simulated annealing-inspired acceptance mechanism and adaptive parameter tuning to improve performance and balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        F = 0.8\n        CR = 0.9\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n                        F = 0.5 + 0.5 * np.random.rand()  # Adapt F adaptively\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 27, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "a1837ba6-14c6-4ae6-9c88-e79736e93655", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid algorithm that introduces adaptive crossover rates in Differential Evolution for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_rate = 0.9 - (0.8 * (self.current_budget / self.budget))\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 28, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "d914bbee-d7f3-4c51-b1af-6d19ea0b6050", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid optimization algorithm that enhances the crossover strategy by introducing a dynamic crossover rate to improve exploration capabilities.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover\n                crossover_rate = 0.9 - 0.4 * (self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 29, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "7a42dafb-2461-4777-83e0-f270dbe73f43", "fitness": 1.0, "name": "HybridDE_SA_Enhanced", "description": "An enhanced hybrid algorithm combining differential evolution and simulated annealing with adaptive mutation and crossover to improve convergence speed and global search capability.", "code": "import numpy as np\n\nclass HybridDE_SA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Adaptive Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                CR = 0.7 + 0.2 * np.random.rand()  # Adaptive crossover rate\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance with dynamic temperature\n                temperature = 1 + (5 * (1 - self.current_budget / self.budget))\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 30, "feedback": "The algorithm HybridDE_SA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "5145be29-f575-42be-8b0c-8e7e45c9643f", "fitness": 1.0, "name": "RefinedHybridDE_SA", "description": "An enhanced hybrid optimization algorithm incorporating adaptive differential evolution and selective local search to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass RefinedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        F = 0.5  # Differential evolution mutation factor\n        CR = 0.9  # Crossover probability\n        \n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n                        # Adaptive mutation factor\n                        F = 0.5 + 0.3 * np.random.rand()\n\n        return best\n\n# Example usage:\n# optimizer = RefinedHybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 31, "feedback": "The algorithm RefinedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "fe2fd35e-d524-4d13-b862-42ccaa99c56a", "fitness": 1.0, "name": "HybridDE_SA", "description": "HybridDE_SA_V2: Enhances the mutation strategy by adjusting the differential weight dynamically to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with dynamic F\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * np.random.rand()  # Dynamic differential weight\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 32, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "b589a474-38db-48ed-9525-a8cccfcccdeb", "fitness": 1.0, "name": "HybridDE_SA", "description": "Improved acceptance probability in HybridDE_SA by tuning the simulated annealing-inspired factor for enhanced convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (0.1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 33, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "61c50fd9-3a3c-461a-b68a-6ece85d5b502", "fitness": 1.0, "name": "HybridDE_SA", "description": "An improved hybrid optimization algorithm combining differential evolution with simulated annealing, now using adaptive mutation scaling for enhanced exploration.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.5 * (self.budget - self.current_budget) / self.budget  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 34, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "1cc28728-efed-4f05-95f5-ab15cc8f9fbc", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive crossover and mutation rates for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            adaptive_factor = 1 - self.current_budget / self.budget\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * adaptive_factor  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                CR = 0.8 + 0.1 * adaptive_factor  # Adaptive crossover rate\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 35, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "a5e04d31-5cb4-4947-9336-3b7c6f1895ba", "fitness": 1.0, "name": "HybridDE_StochasticTunneling", "description": "An enhanced hybrid optimization algorithm that integrates adaptive differential evolution with a stochastic tunneling acceptance mechanism to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass HybridDE_StochasticTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Adaptive Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + np.random.rand() * 0.3  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Stochastic tunneling acceptance\n                delta = trial_fitness - fitness[i]\n                if delta < 0 or np.random.rand() < np.exp(-delta / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_StochasticTunneling(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 36, "feedback": "The algorithm HybridDE_StochasticTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "6035e6b6-a0ee-4ed3-99eb-2e762755a81a", "fitness": 1.0, "name": "HybridDE_SA", "description": "A subtle change in the crossover strategy enhances exploration by increasing genetic diversity in the population.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover with higher probability\n                crossover_mask = np.random.rand(self.dim) < 0.95  # Increased probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 37, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "ff8af17f-b92b-48a0-8c4d-b02fba6e6cad", "fitness": 1.0, "name": "HybridDE_SA", "description": "Slightly improved exploration by adjusting the crossover mask probability in the DE process.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.95  # Adjusted crossover probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 38, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "446ccc4d-53aa-4352-b17f-376d3b789c2e", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid optimization algorithm that enhances adaptive learning during differential evolution to improve convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + np.random.rand() * 0.4  # Adaptation: random scaling factor F\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 39, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "ced67525-fe56-4238-8ef1-66b559034784", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA algorithm by integrating a local search phase to refine promising solutions for improved exploitation.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n            # Local Search Phase\n            if self.current_budget < self.budget:\n                result = minimize(func, best, bounds=[(self.lower_bound, self.upper_bound)]*self.dim, method='L-BFGS-B')\n                if result.fun < best_fitness:\n                    best = result.x\n                    best_fitness = result.fun\n                    self.current_budget += result.nfev\n\n        return best", "configspace": "", "generation": 40, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "c3a57173-71d1-4494-a0ae-95a7052a4058", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced hybrid optimization by dynamically adjusting mutation factor and crossover probability.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Dynamic mutation factor and crossover probability\n                mutation_factor = 0.5 + 0.5 * (1 - self.current_budget / self.budget)\n                crossover_prob = 0.9 - 0.4 * (self.current_budget / self.budget)\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + mutation_factor * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 41, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "509a1eb5-e3e5-43e8-b8cf-2485eeef1a41", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by introducing a dynamic crossover probability, which gradually decreases over time to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover\n                crossover_prob = 0.9 * (1 - self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 42, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "590a3dec-5b40-45e2-9c88-0e74821655f8", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by adjusting DE mutation factor and dynamic crossover probability based on progress.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adjusted factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + (0.3 * (self.current_budget / self.budget))  # Mutate Factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover probability based on progress\n                crossover_prob = 0.9 * (1 - (self.current_budget / self.budget))\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 43, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "ef03ed9c-6c0a-4fd3-a4f6-0af729bbae67", "fitness": 1.0, "name": "HybridDE_SA", "description": "Slightly modified the mutation strategy of the Differential Evolution to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adjusted F parameter\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.85 * (x1 - x2), self.lower_bound, self.upper_bound)  # Adjusted F from 0.8 to 0.85\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 44, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "8a8a6bee-efbe-4702-abde-6dcd4da7ea37", "fitness": 1.0, "name": "HybridDE_SA", "description": "Hybrid algorithm with adaptive mutation scaling to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                scale_factor = 0.8 + 0.2 * np.random.rand()  # Adaptive mutation scaling\n                mutant = np.clip(x0 + scale_factor * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 45, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "8629e9a0-8bd5-406a-80e6-b4c83a17ad49", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid optimization algorithm that modifies the mutation strategy in differential evolution and utilizes an adaptive crossover rate for improved performance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation (Enhanced strategy)\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.9 * (x1 - x2) + 0.1 * (best - x0), self.lower_bound, self.upper_bound)\n\n                # Crossover (Adaptive rate)\n                crossover_prob = 0.8 + 0.2 * (1 - self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 46, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "ef55caef-878f-46ef-9d56-515cbe169a4f", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive crossover probability to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_prob = 0.9 + 0.1 * (self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 47, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "b09c3f0a-850b-455b-b49e-6c61b7c58730", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid optimization algorithm that combines differential evolution with a simulated annealing-inspired acceptance mechanism and adaptive crossover probability to improve search efficiency.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            crossover_rate = 0.9 * (1 - self.current_budget / self.budget) + 0.1  # Adaptive crossover probability\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 48, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "d11a9f92-3725-4e22-82ab-fa1c61118074", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive mutation and crossover strategies to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Adaptive Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + np.random.rand() * 0.5  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                CR = 0.7 + np.random.rand() * 0.3  # Adaptive crossover probability\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 49, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "c5b936e0-dd44-4513-86b8-b9cf45603a9c", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced mutation strategy by incorporating adaptive scaling factor in HybridDE_SA to improve convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + np.random.rand() * 0.3  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 50, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "b7c1c44e-0878-496b-9531-5395176273c6", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that augments Differential Evolution and Simulated Annealing with adaptive control of crossover rate based on the current budget.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive rate\n                adaptive_crossover_rate = 0.9 * (1 - self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 51, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "88e769f6-4c72-4df3-9987-0e1d36be0c06", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid optimization algorithm that enhances exploration by introducing adaptive crossover rates in differential evolution.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_rate = 0.9 - 0.5 * (self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 52, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "77a090e7-a380-4509-b6db-c0c86ae58d81", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced trial acceptance by incorporating adaptive mutation scaling based on progress.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.4 * np.exp(-5 * self.current_budget / self.budget)  # Adaptive mutation scaling\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 53, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "f8525b67-be71-4c24-9110-61ea0d984ff0", "fitness": 1.0, "name": "HybridDE_SA", "description": "Improved HybridDE_SA by adjusting the crossover probability to increase diversity and enhance exploration.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.95  # Changed line: increased crossover probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 54, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "fd905bdc-bdb4-4a53-8771-6608b7d8ebb0", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid optimization algorithm that enhances convergence by dynamically adjusting crossover probability in differential evolution based on current budget usage.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Dynamically adjusted crossover probability\n                crossover_prob = 0.9 * (1 - self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 55, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "adb7950b-429e-459d-bf7c-f21506169b23", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by adjusting crossover rate and adaptive mutation scaling for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_rate = 0.95 if (self.current_budget / self.budget) < 0.5 else 0.85\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 56, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "bd935e23-b89e-446b-bb7e-d583ec604dc5", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduced adaptive parameters in the mutation and crossover operations of the HybridDE_SA algorithm to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n            CR = 0.7 + 0.2 * np.random.rand()  # Adaptive crossover rate\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 57, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "93a2ecd7-86b5-4842-a207-e8f0ad04d6ef", "fitness": 1.0, "name": "EnhancedHybridDE_SA", "description": "Enhanced HybridDE_SA: An improved hybrid optimization algorithm that utilizes adaptive mutation and elitism within differential evolution to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            F = 0.5 + 0.3 * (1 - self.current_budget / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n            # Elitism: Preserve the best solution found\n            elite_idx = np.argmin(fitness)\n            if fitness[elite_idx] < best_fitness:\n                best = population[elite_idx]\n                best_fitness = fitness[elite_idx]\n\n        return best\n\n# Example usage:\n# optimizer = EnhancedHybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "5c87f4ca-45c6-4334-9cb0-8d69918b3001", "fitness": 1.0, "name": "HybridDE_SA", "description": "HybridDE_SA with adaptive scaling factor to enhance exploration.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                scaling_factor = 0.8 + 0.2 * (self.current_budget / self.budget)  # Adaptive scaling factor\n                mutant = np.clip(x0 + scaling_factor * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 59, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "37eddbb0-44f7-4fa6-8878-5505e65b5747", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid optimization algorithm that improves exploration by using a dynamic crossover rate based on population diversity.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic rate based on diversity\n                diversity = np.std(population, axis=0).mean()\n                crossover_prob = 0.5 + 0.4 * (diversity / (self.upper_bound - self.lower_bound))\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 60, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "88ce8262-f6ce-43b1-b8d1-3b1ff39cba3e", "fitness": 1.0, "name": "HybridDE_SA_Adaptive", "description": "Enhanced HybridDE_SA with adaptive crossover and mutation strategies to improve convergence efficiency.", "code": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            F = 0.5 + 0.3 * (1 - self.current_budget / self.budget)  # Adaptive mutation factor\n            CR = 0.9 - 0.5 * (self.current_budget / self.budget)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA_Adaptive(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 61, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "946ad9ef-37fc-4e8d-8aa7-a871c958f045", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA algorithm that incorporates adaptive mutation and crossover rates to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        initial_temperature = 1.0\n        final_temperature = 0.01\n        temperature_decay = (final_temperature / initial_temperature) ** (1.0 / (self.budget - 1))\n\n        while self.current_budget < self.budget:\n            adaptive_mutation_rate = 0.5 + 0.3 * np.random.rand()\n            adaptive_crossover_rate = 0.7 + 0.2 * np.random.rand()\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + adaptive_mutation_rate * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                temperature = initial_temperature * (temperature_decay ** self.current_budget)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 62, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "96f42291-7770-47a8-a9ce-cfad3eb7c0d5", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by adjusting the crossover probability to increase diversity and improve exploration.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover with increased probability\n                crossover_mask = np.random.rand(self.dim) < 0.95  # Changed from 0.9 to 0.95\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 63, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "fea3799c-27fc-444e-ae71-d6a3c19d959a", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introducing random scaling in mutation for enhanced diversity without losing original efficiency.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + np.random.rand() * 0.5  # Random scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 64, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "8fa8d2f3-fb1e-4869-a095-1b9bf96cd204", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhance exploration by adjusting the crossover probability dynamically based on progress within budget.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic probability\n                crossover_prob = 0.9 - 0.5 * (self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 65, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "6d5c5cc1-d80f-4d6b-9805-9355c10ef5e7", "fitness": 1.0, "name": "HybridDE_SA", "description": "Integrate adaptive mutation scaling to enhance exploration in the Differential Evolution phase.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + np.random.rand() * 0.5  # Adaptive mutation scaling\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 66, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "7876284e-8a73-4525-bc13-41a4a5f1a9bf", "fitness": 1.0, "name": "HybridDE_SA", "description": "HybridDE_SA with adaptive mutation factor for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * (1 - self.current_budget / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 67, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "eed2421d-7626-441e-9a99-35174b058ada", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhance population diversity by adjusting the crossover probability based on the current budget.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjust crossover probability based on budget\n                crossover_prob = 0.9 * (1 - self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 68, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "4b98f93b-2519-4f2d-a9d3-986936afbcce", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced mutation strategy with scaled difference vectors for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = population[indices]\n                mutant = np.clip(x0 + 0.5 * (x1 - x2) + 0.3 * (x3 - x4), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 69, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "3896a931-61ae-44df-b5bf-7c15696b30a4", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced crossover strategy in the hybrid optimization algorithm to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Enhanced Crossover\n                crossover_rate = 0.95  # Increased exploration probability\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 70, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "8a3d84ea-9935-4041-8196-e03e38030782", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid optimization algorithm that introduces adaptive scaling for Differential Evolution to dynamically adjust exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                F = 0.8 * (1 - self.current_budget / self.budget)  # Adaptive scaling factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 71, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "113f581e-20f6-4cdc-9d16-e1acf42582f1", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that enhances exploration by adapting the mutation factor in differential evolution dynamically.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with dynamic factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutation_factor = 0.5 + 0.3 * np.sin(self.current_budget / self.budget * np.pi)\n                mutant = np.clip(x0 + mutation_factor * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 72, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "7c423d1f-49ed-454c-8ebe-8c2d171576e1", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhancing the mutation strategy by using a dynamic scaling factor to improve exploration during early iterations and exploitation in later stages.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with dynamic scaling factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 * (1 - self.current_budget / self.budget) + 0.3  # Dynamic scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 73, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "e67b3255-45fa-4328-be81-08123f7ad4a6", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced exploration in the mutation step of the hybrid DE-SA algorithm to improve convergence by adjusting the scaling factor dynamically.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 + 0.2 * (self.current_budget / self.budget)  # Dynamic scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 74, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "4aadce36-4fd6-4d34-86aa-e36980b83eb8", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhance the crossover mechanism by adjusting the crossover probability dynamically based on iteration progress to improve exploration and exploitation balance in HybridDE_SA.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Dynamically adjust crossover probability\n                crossover_prob = 0.9 + 0.1 * (self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 75, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "7e95be5b-a1c6-4077-afc6-b750718cea30", "fitness": 1.0, "name": "HybridDE_SA", "description": "Slightly adjusted the crossover probability to potentially improve the trade-off between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.8  # Changed from 0.9 to 0.8\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 76, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "1f8024be-72d5-40fb-a73f-9514d35c2ade", "fitness": -Infinity, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA algorithm with adaptive mutation factor and dynamic population resizing for improved performance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Adaptive mutation factor\n                F = 0.5 + np.random.rand() * 0.5\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n            # Dynamic population resizing\n            if self.current_budget < self.budget * 0.5:\n                self.population_size = min(self.population_size * 2, 50 * dim)\n            elif self.current_budget > self.budget * 0.75:\n                self.population_size = max(self.population_size // 2, 5 * dim)\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 77, "feedback": "An exception occurred: NameError(\"name 'dim' is not defined\").", "error": "NameError(\"name 'dim' is not defined\")", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {}}
{"id": "283635c9-5a06-440c-bdb7-e61e692ecab3", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by incorporating adaptive crossover probability and dynamic scaling factor for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * (self.current_budget / self.budget)  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = 0.9 - 0.4 * (self.current_budget / self.budget)  # Adaptive crossover probability\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 78, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "44fe68f8-822f-4ab3-ba78-9a96f261b53b", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid optimization algorithm combining differential evolution and simulated annealing, with an improved crossover probability for enhanced balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover with improved probability\n                crossover_mask = np.random.rand(self.dim) < 0.95\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 79, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "52247e5c-3c39-479e-b6d8-3f9dab1abd1c", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by adding adaptive control to the crossover probability for balancing exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_prob = 0.9 * (self.budget - self.current_budget) / self.budget\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 80, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "d15945cd-a37b-4c97-acc7-2f0eee376b57", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhance crossover strategy by incorporating an adaptive crossover probability to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover Probability\n                cr = 0.9 - 0.5 * (self.current_budget / self.budget)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 81, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "3efeda19-736a-48c8-b960-603c058533f6", "fitness": 1.0, "name": "HybridDE_SA", "description": "An improved hybrid optimization algorithm with adaptive mutation factor in differential evolution for enhanced convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 82, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "f84021a5-b2dc-4f86-b4d7-c2b49ffd6991", "fitness": 1.0, "name": "HybridDE_SA", "description": "A refined hybrid algorithm combining differential evolution and simulated annealing, now with adaptive mutation step size to enhance convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive step size\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 * (1 - self.current_budget / self.budget) # Adaptive mutation step size\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 83, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "78acc681-031f-466b-8ff1-1ade0075be10", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by tweaking the differential evolution parameters for better convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.7 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.85\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 84, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "b596b43a-3513-42a2-abb6-d76df17bfcff", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA by adjusting mutation factor and incorporating adaptive crossover probability to improve convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.6 * (x1 - x2), self.lower_bound, self.upper_bound)  # Adjusted mutation factor\n\n                # Crossover\n                crossover_prob = 0.9 - 0.7 * (self.current_budget / self.budget)  # Adaptive crossover probability\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 85, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "8f71697f-75a8-47e7-818d-cab986c69262", "fitness": 1.0, "name": "HybridDE_SA", "description": "An enhanced hybrid algorithm optimizing differential evolution's mutation scale factor for better convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * np.random.rand()  # Adjust mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 86, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "4a50e214-fbe9-4419-9ea4-fb9a3e329785", "fitness": 1.0, "name": "HybridDE_SA", "description": "Modified the mutation factor in differential evolution to enhance exploration capabilities.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.9 * (x1 - x2), self.lower_bound, self.upper_bound)  # Changed mutation factor\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 87, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "fe522465-4847-4c6a-8a6d-bbbb5a2f52f8", "fitness": 1.0, "name": "HybridDE_SA", "description": "Improved HybridDE_SA using adaptive parameter control and local search to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            F = 0.8 + 0.2 * (self.current_budget / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_prob = 0.9 - 0.4 * (self.current_budget / self.budget)  # Adaptive crossover probability\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n                # Local Search Enhancement\n                if np.random.rand() < 0.1:\n                    local_trial = trial + 0.1 * np.random.randn(self.dim)\n                    local_trial = np.clip(local_trial, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_trial)\n                    self.current_budget += 1\n\n                    if local_fitness < trial_fitness:\n                        population[i] = local_trial\n                        fitness[i] = local_fitness\n                        if local_fitness < best_fitness:\n                            best = local_trial\n                            best_fitness = local_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 88, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "1b882b13-d636-4a28-a907-bf3aeadfd025", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduced adaptive mutation scaling in DE to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.5 * (self.current_budget / self.budget)  # Adaptive mutation scaling\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 89, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "50849882-8357-4640-ada9-a067f28b6ee7", "fitness": 1.0, "name": "ImprovedHybridDE_SA", "description": "Improved HybridDE_SA combines differential evolution with adaptive simulated annealing and dynamic crossover rate for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            F = 0.5 + (0.9 - 0.5) * (1 - self.current_budget / self.budget)  # Dynamic mutation factor\n            CR = 0.5 + (0.9 - 0.5) * np.exp(-self.current_budget / self.budget)  # Dynamic crossover rate\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / ((1 + self.current_budget / self.budget) * np.std(fitness))):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = ImprovedHybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 90, "feedback": "The algorithm ImprovedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "715c1e26-d9a0-49c9-a78d-98ac36f11422", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduce a dynamic scaling factor in the mutation step of Differential Evolution to enhance adaptability across iterations.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with dynamic scaling factor\n                F = 0.5 + (0.8 - 0.5) * (1 - self.current_budget / self.budget) # Dynamic scaling factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 91, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "c0dc2f5a-ede5-4632-944d-a4f2190e0ec3", "fitness": 1.0, "name": "HybridDE_SA", "description": "A hybrid optimization algorithm that integrates adaptive parameter tuning in differential evolution with a simulated annealing-inspired acceptance mechanism to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 - (0.5 * (self.current_budget / self.budget))  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 92, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "5fab732d-18b1-4ea8-b18d-b8fb87c9a34d", "fitness": 1.0, "name": "HybridDE_SA", "description": "An advanced hybrid method enhancing exploration-exploitation balance by tweaking mutation strategy in differential evolution.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.8 + 0.2 * (self.current_budget / self.budget)  # Adaptive F factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 93, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "28d17d40-b23c-48f5-bd6c-f34d1652277e", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhance HybridDE_SA by incorporating an adaptive scaling factor in the mutation process to improve exploration during optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.5 * np.random.rand()  # Adaptive scaling factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 94, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "88113cea-7425-415e-a220-fc599fa45b2d", "fitness": 1.0, "name": "HybridDE_SA", "description": "Enhancing the mutation strategy in the HybridDE_SA algorithm by adjusting the differential weight dynamically based on the remaining budget.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with dynamic weight\n                F = 0.5 + 0.5 * (self.current_budget / self.budget)  # Changed line\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 95, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "3d21ebe5-d49e-4541-ad54-8eced0d6c01c", "fitness": 1.0, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid optimization algorithm integrating chaotic maps for diversity and an adaptive crossover strategy to boost convergence speed and precision.", "code": "import numpy as np\nfrom scipy.stats import norm\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def chaotic_map(self, x):\n        # Logistic map for generating chaotic sequences\n        r = 3.8\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        # Initialize population with chaotic sequence\n        chaotic_sequence = np.zeros(self.population_size)\n        chaotic_sequence[0] = 0.7  # Initial value for the logistic map\n        for i in range(1, self.population_size):\n            chaotic_sequence[i] = self.chaotic_map(chaotic_sequence[i-1])\n        population = self.lower_bound + chaotic_sequence.reshape(self.population_size, 1) * np.ones(self.dim) * (self.upper_bound - self.lower_bound)\n        \n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover using Gaussian function\n                crossover_prob = norm.pdf(self.current_budget/self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = EnhancedHybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "48adc1b5-5b85-440a-9380-06449dce239b", "fitness": 1.0, "name": "HybridDE_SA", "description": "Introduction of an adaptive mutation factor for improved exploration and exploitation balance in HybridDE_SA.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation with adaptive factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F = 0.5 + (0.8 - 0.5) * (1 - self.current_budget / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_SA(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 97, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "b7979ed6-70f2-4340-822e-d82b0446ef8d", "fitness": 1.0, "name": "HybridDE_SA", "description": "Refined HybridDE_SA with adaptive crossover rate for enhanced convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + 0.8 * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_rate = 0.5 + 0.4 * (1 - self.current_budget / self.budget)\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best", "configspace": "", "generation": 98, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
{"id": "43a46e38-5f96-4213-a9d2-5ee5df947ea3", "fitness": 1.0, "name": "HybridDE_Adaptive", "description": "A refined hybrid algorithm that enhances differential evolution with adaptive mutation and adaptive parallel local search for improved convergence.  ", "code": "import numpy as np\n\nclass HybridDE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.current_budget = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = self.lower_bound + np.random.rand(self.population_size, self.dim) * (self.upper_bound - self.lower_bound)\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_budget < self.budget:\n            F = 0.5 + np.random.rand() * 0.5  # Adaptive mutation factor\n            for i in range(self.population_size):\n                if self.current_budget >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_rate = 0.9 - 0.4 * (self.current_budget / self.budget)  # Adaptive crossover rate\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_budget += 1\n\n                # Simulated Annealing-inspired acceptance\n                acceptance_prob = np.exp((fitness[i] - trial_fitness) / (1 + self.current_budget / self.budget))\n                if trial_fitness < fitness[i] or np.random.rand() < acceptance_prob:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best = trial\n                        best_fitness = trial_fitness\n\n        return best\n\n# Example usage:\n# optimizer = HybridDE_Adaptive(budget=1000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "configspace": "", "generation": 99, "feedback": "The algorithm HybridDE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 1.00 with standard deviation 0.00.", "error": "", "parent_ids": ["f897e7a7-09a5-4fc3-8bf3-78e826985a0d"], "operator": null, "metadata": {"aucs": [1.0, 1.0, 1.0, 1.0, 1.0]}}
