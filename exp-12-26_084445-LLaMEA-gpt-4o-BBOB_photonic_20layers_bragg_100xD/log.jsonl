{"id": "ed59a39f-d545-4d7f-9235-cfcfcab25ed5", "fitness": 0.0649587218050986, "name": "AQIEA", "description": "Adaptive Quantum-Inspired Evolutionary Algorithm (AQIEA) using quantum superposition principles to maintain diversity and accelerate convergence in black box optimization.", "code": "import numpy as np\n\nclass AQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.observables = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * normalized_fitness[i] * self.quantum_states[i] + (1 - normalized_fitness[i]) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * normalized_fitness[i] * self.quantum_states[i] + (1 - normalized_fitness[i]) * np.random.rand(self.dim)))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 0, "feedback": "The algorithm AQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06496 with standard deviation 0.05725.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.13345837602665167, 0.14102119093512555, 0.14394921293508556, 0.05193319535394991, 0.05567638308408762, 0.05709013791098727, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA using a dynamic population strategy and adaptive rotation angles for improved diversity and convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["ed59a39f-d545-4d7f-9235-cfcfcab25ed5"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6b425755-ac5f-4c85-9577-21dc3bb57528", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with an adaptive factor increment strategy for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n        self.adaptive_factor += 0.01  # Increment adaptive factor\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "748ff978-1d3a-4285-aa58-0d4bebb6a452", "fitness": 0.06503663866310909, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with refined adaptive quantum update by scaling adaptive_factor for dynamic convergence balance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * (0.5 + np.random.rand() * 0.5)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06504 with standard deviation 0.05892.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.14737174901712646, 0.14333544615057747, 0.13784565522297199, 0.051359696813610634, 0.05021800256625353, 0.053699198197441844, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "cfc4ad91-56ce-4833-8122-196df7a21091", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with dynamic adaptive factor for more flexible rotation adjustments in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        self.adaptive_factor = 0.05 + 0.1 * (1 - normalized_fitness.mean())  # Dynamic adjustment added\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "bbbdf751-3371-44f9-9d0e-9e688fee23a8", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Improved EnhancedAQIEA by introducing non-uniform quantum state initialization for better exploration-exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))  # This line is modified\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "54d7565c-cb8f-42f6-880d-16ef1e6ec283", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced Quantum-Inspired Evolutionary Algorithm with Diversity-Preserving Mechanism and Dynamic Quantum Rotation for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.diversity_threshold = 0.1\n        self.dynamic_rotation_factor = 0.1\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        diversity = np.std(fitness_values) / (fitness_values.mean() + 1e-6)\n        rotation_factor = self.dynamic_rotation_factor * (1 - diversity / self.diversity_threshold)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment + rotation_factor) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment + rotation_factor) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a262dd08-25aa-4b51-bca8-f21c888b62f0", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Improved EnhancedAQIEA by fine-tuning the adaptive factor for a better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.03  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "88f6a738-0675-455a-ada8-2a4e4551a5f4", "fitness": 0.06672979896379809, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with improved quantum state update by introducing a small randomness factor for diversity.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            random_factor = np.random.normal(0, 0.01, self.dim)  # added randomness\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * (self.quantum_states[i] + random_factor) +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * (self.quantum_states[i] + random_factor) +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06673 with standard deviation 0.05876.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.13610669922631213, 0.1451582130055955, 0.14811442167869338, 0.05338259146056534, 0.057374612116018575, 0.058931653186998, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "eae77961-0a5c-4a5e-beb5-dbc35a5ab296", "fitness": 0.06829736260420181, "name": "RefinedEnhancedAQIEA", "description": "Refined Enhanced AQIEA with a dual-adaptive quantum mechanism and learning rate modulation to improve exploitation and exploration balance in black box optimization.", "code": "import numpy as np\n\nclass RefinedEnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.base_adaptive_factor = 0.05\n        self.learning_rate = 0.1  # New learning rate for controlling adaptive factor\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def dual_adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        adaptive_factor = self.base_adaptive_factor + self.learning_rate * np.std(normalized_fitness)\n        for i in range(self.population_size):\n            adjustment = adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.dual_adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 9, "feedback": "The algorithm RefinedEnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "cc0c9abc-cf11-47c8-9c87-ba791b5e8638", "fitness": -Infinity, "name": "EnhancedAQIEA", "description": "Adaptive Quantum-Inspired Evolutionary Algorithm (AQIEA) with dynamic adaptive quantum rotation and elite preservation for enhanced convergence and diversity in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elite_preservation_rate = 0.1  # New parameter for elite preservation\n        self.elite_quantum_states = None\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            angle = np.pi * (normalized_fitness[i] + adjustment)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(angle * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(angle * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        new_population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        if new_population_size < self.population_size:\n            self.elite_quantum_states = self.quantum_states[np.argsort(fitness_values)[:int(self.elite_preservation_rate * self.population_size)]]\n        self.population_size = new_population_size\n        new_quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        if self.elite_quantum_states is not None:\n            self.quantum_states[:len(self.elite_quantum_states)] = self.elite_quantum_states\n            self.quantum_states[len(self.elite_quantum_states):] = new_quantum_states[len(self.elite_quantum_states):]\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 10, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {}}
{"id": "0a5198b0-a297-49a6-8e6c-6bae78d0eb34", "fitness": 0.07064783890481263, "name": "EnhancedAQIEA", "description": "Introducing an adaptive factor decay to the Enhanced AQIEA to improve convergence by refining rotation angle adjustments over time.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07065 with standard deviation 0.06389.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.17324922568577028, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "1aefbf58-dc24-4f1b-85b3-1d245471d732", "fitness": 0.06472826932542303, "name": "EnhancedAQIEA", "description": "Introducing adaptive mutation and dynamic population resizing in EnhancedAQIEA to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n        self.mutation_rate = 0.1  # New parameter for mutation rate\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            # Apply mutation\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.normal(0, 0.1, self.dim)\n                self.quantum_states[i] = np.clip(self.quantum_states[i] + mutation_vector, 0, 1)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n        self.mutation_rate *= 0.98  # Decay mutation rate over time\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06473 with standard deviation 0.05859.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14221538416395652, 0.1514985776517499, 0.1317039995897743, 0.05209489468074835, 0.051243223216317135, 0.05229834462626115, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "26e3f518-1d7d-43a6-b8bf-29794d5182fe", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhancing the quantum state evolution by introducing fitness-proportionate scaling and dynamic rotation probability adjustment to improve exploration.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        scale_factor = 1.0 + (1 - normalized_fitness)**2  # Scale based on fitness\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            rotation_prob = 0.5 + 0.3 * normalized_fitness[i]  # Dynamic rotation probability\n            if np.random.rand() < rotation_prob:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * scale_factor[i] * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * scale_factor[i] * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "14133062-312b-46fc-b348-48394f90cb77", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Refine adaptive factor by introducing a dynamic adjustment based on the best fitness improvement rate.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        improvement_rate = (self.best_fitness / (self.budget - evaluations + 1e-6))  # Dynamic adjustment\n        self.adaptive_factor *= 0.99 + 0.01 * improvement_rate  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a9dcc50c-1665-481c-bd4c-7a26c5ddd62f", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a minor adjustment to the quantum state update formula for enhanced solution diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * (np.random.rand(self.dim) * 0.5)))  # Minor change here\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ca787b33-5ceb-40b8-ac79-cc00ca3a9e65", "fitness": -Infinity, "name": "EnhancedAQIEA", "description": "Introducing a dynamic adaptive factor to improve convergence by scaling the factor based on fitness improvements over iterations.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= (0.99 if self.best_fitness < np.mean(fitness_values) else 1.01)  # Dynamic adaptive factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 16, "feedback": "An exception occurred: NameError(\"name 'fitness_values' is not defined\").", "error": "NameError(\"name 'fitness_values' is not defined\")", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {}}
{"id": "d5a10b96-d2a7-4dc8-9c10-2bf514ad7555", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhance quantum state initialization with a focus on variance reduction to improve convergence stability.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0.45, 0.55, (self.population_size, self.dim))  # Adjusted initialization range\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "91586f2d-d520-49fd-b184-6355320d6bd3", "fitness": 0.06587278991071782, "name": "EnhancedAQIEA_Improved", "description": "EnhancedAQIEA with dynamic adaptive factor and elitism to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elitism_rate = 0.1  # Preserve top solutions\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        elite_count = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(fitness_values)[:elite_count]\n\n        for i in range(self.population_size):\n            if i not in elite_indices:  # Apply updates only to non-elite solutions\n                adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n                if np.random.rand() < 0.5:\n                    self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n                else:\n                    self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.995  # Dynamic adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedAQIEA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06587 with standard deviation 0.05769.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14133453103159832, 0.14223790336265218, 0.13875383196110969, 0.055231272608390336, 0.054099794390506606, 0.05969777584220348, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c19bea26-6e91-4ec8-9e67-015013673046", "fitness": 0.0660801219302844, "name": "EnhancedAQIEA", "description": "Introducing a stochastic component in population size adjustment to enhance exploration capabilities while maintaining convergence control.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        # Introduce stochastic component in population adjustment\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress) * np.random.uniform(0.9, 1.1))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06608 with standard deviation 0.06063.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.1413097946684292, 0.1397864803789053, 0.1576713232311081, 0.04598686078429581, 0.05137488704459814, 0.057091751265223256, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fabfd937-9bc8-48e8-b312-a8573c31b03b", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with dynamic adjustment of quantum state perturbations based on convergence speed to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.convergence_speed_threshold = 0.01\n        self.previous_best_fitness = np.inf\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def dynamic_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        convergence_speed = np.abs(self.previous_best_fitness - self.best_fitness)\n        perturbation_factor = 0.5 if convergence_speed > self.convergence_speed_threshold else 1.0\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * perturbation_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.dynamic_quantum_update(fitness_values)\n            self.previous_best_fitness = self.best_fitness\n        return self.best_solution", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "eb477bec-2fd2-4afc-9d28-5db7bdac498b", "fitness": 0.06739260820729337, "name": "EnhancedAQIEA", "description": "Introducing dynamic mutation scaling to Enhanced AQIEA for improved exploration by adjusting mutation intensity based on search progress.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.mutation_scale = 0.1  # New parameter for mutation intensity\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            random_mutation = np.random.normal(0, self.mutation_scale, self.dim)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                       (1 - (normalized_fitness[i] + adjustment)) * random_mutation))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                       (1 - (normalized_fitness[i] + adjustment)) * random_mutation))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.mutation_scale *= 0.98  # Dynamic mutation scaling\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06739 with standard deviation 0.05813.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13983394797244386, 0.14539157858915086, 0.14105116450805855, 0.06013535575704254, 0.06421226850781558, 0.05440915853112904, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9be76052-66be-4b6d-a794-2fef9c26afd1", "fitness": 0.06594183444480493, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with progressive population mutation and dynamic adaptive factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.mutation_rate = 0.1\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            # Introduce mutation for additional exploration\n            if np.random.rand() < self.mutation_rate:\n                self.quantum_states[i] += np.random.normal(0, adjustment, self.dim)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def dynamic_mutation_rate(self, evaluations):\n        self.mutation_rate = 0.1 + 0.9 * (evaluations / self.budget)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            self.dynamic_mutation_rate(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06594 with standard deviation 0.05889.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13289811884413127, 0.15167898700812787, 0.1441302187262965, 0.05222409382420934, 0.05762781984524268, 0.05341727175523692, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ce7311bc-9783-4a09-9a58-654033357553", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic adaptive factor adjustment to further fine-tune the population convergence process in the Enhanced AQIEA.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99 + 0.01 * np.sin(evaluations / self.budget * np.pi)  # Dynamic adaptive factor adjustment\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "d6f8eef9-c757-4605-ad11-150c07b7bc2c", "fitness": 0.06792187166247471, "name": "EnhancedAQIEA_DE", "description": "Introducing differential evolution-inspired mutations in Enhanced AQIEA to enhance exploration and maintain diversity, combined with adaptive quantum rotations for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def differential_evolution_mutation(self):\n        indices = np.arange(self.population_size)\n        for i in range(self.population_size):\n            x1, x2, x3 = self.quantum_states[np.random.choice(indices[indices != i], 3, replace=False)]\n            mutant = x1 + self.mutation_factor * (x2 - x3)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.quantum_states[i])\n            self.quantum_states[i] = np.clip(trial, 0, 1)\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.differential_evolution_mutation()\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedAQIEA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06792 with standard deviation 0.06165.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15968705144517092, 0.14146219789479164, 0.14620183339220383, 0.058871644142215684, 0.050233107344460626, 0.053341010743429784, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "91a0fe1f-f321-4132-8626-40704f8860fa", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic learning rate to the Enhanced AQIEA to adaptively scale quantum state updates based on fitness improvement trends.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.learning_rate = 0.1  # New parameter for dynamic learning rate adjustment\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n        self.learning_rate *= 0.95  # Adaptive decay of learning rate\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9111703c-ef73-4110-8ec9-6c97d75845d8", "fitness": 0.06592556895384127, "name": "EnhancedAQIEA", "description": "Introducing a dynamic rotation selection in Enhanced AQIEA to improve exploration by alternating between sine and cosine updates based on fitness trends.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if normalized_fitness[i] < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06593 with standard deviation 0.05977.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14652783803185487, 0.14118847251295685, 0.14709403487874195, 0.049859521182927025, 0.05347843367074023, 0.05368182030735069, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8fb5e3a4-88c9-41cc-8614-5ce5b4c059a4", "fitness": 0.06829736260420181, "name": "EnhancedAQIEAImproved", "description": "Enhance convergence by incorporating elite preservation and dynamic quantum rotation based on fitness variance to the Enhanced AQIEA algorithm.", "code": "import numpy as np\n\nclass EnhancedAQIEAImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elite_ratio = 0.1  # Proportion of elite individuals to preserve\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def preserve_elite(self, fitness_values):\n        elite_count = max(1, int(self.elite_ratio * self.population_size))\n        elite_indices = np.argsort(fitness_values)[:elite_count]\n        return self.quantum_states[elite_indices]\n\n    def adaptive_quantum_update(self, fitness_values, elites):\n        variance = np.var(fitness_values)\n        rotation_factor = self.adaptive_factor * (1 / (1 + variance))\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n\n        for i in range(self.population_size):\n            if i not in elites:\n                adjustment = rotation_factor * (1 - normalized_fitness[i])\n                if np.random.rand() < 0.5:\n                    self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n                else:\n                    self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            elites = self.preserve_elite(fitness_values)\n            self.adaptive_quantum_update(fitness_values, elites)\n        return self.best_solution", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedAQIEAImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "723a1193-7ec7-4469-a1a5-7728dabc0d6b", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhance convergence by dynamically updating the adaptive factor based on fitness variance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= np.var(self.quantum_states)  # Dynamic adaptive factor update based on variance\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ea6d65ce-9e4d-4c3e-9b04-7ddde32e7c70", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic population diversity mechanism and enhanced adaptive factor strategy to improve exploration and exploitation balance in Enhanced AQIEA.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.diversity_factor = 0.1  # New parameter for dynamic diversity\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            random_factor = np.random.uniform(-self.diversity_factor, self.diversity_factor, self.dim)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * random_factor))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * random_factor))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.995  # More gradual adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8e10ecde-5164-4929-9dbe-134c7b57d52e", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Incorporate dynamic adaptive factor decay based on population diversity to further refine convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        diversity = np.mean(np.std(self.quantum_states, axis=0))  # Calculate diversity\n        self.adaptive_factor *= (0.98 + 0.02 * diversity)  # Adaptive factor decay based on diversity\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7c8a1f1b-39a8-4b96-87a9-93f1dbc30cf3", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with adaptive quantum update based on diversity, refining state transitions over time.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        diversity = np.std(fitness_values)  # Added line to calculate diversity\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fded7498-2760-433f-8594-93dbf4c3a0c3", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce weighted average in adaptive factor to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n    \n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99 * (0.5 + 0.5 * progress)  # Weighted average in adaptive factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "bb49fa0e-7584-446d-862d-16f7776336fb", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce a dynamic learning rate mechanism to the Enhanced AQIEA that adapts based on convergence progress to balance exploration and exploitation throughout the optimization process.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.learning_rate = 1.0\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * self.learning_rate * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size_and_learning_rate(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.learning_rate = 1.0 - progress  # Dynamic learning rate\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size_and_learning_rate(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e0845a3d-5faf-4b00-a1c2-a78651aa40da", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic quantum state initialization to the Enhanced AQIEA for better exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def initialize_quantum_states(self):\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.initialize_quantum_states()\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        self.initialize_quantum_states()\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "eccdf4ae-260a-429a-a078-9f53348e8a4c", "fitness": 0.06829736260420181, "name": "ImprovedAQIEA", "description": "Introducing a convergence rate monitoring mechanism to dynamically adjust the adaptive factor and prevent premature convergence in Enhanced AQIEA.", "code": "import numpy as np\n\nclass ImprovedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.convergence_threshold = 1e-5  # Threshold to detect stagnation\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations, previous_best_fitness):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        if abs(previous_best_fitness - self.best_fitness) < self.convergence_threshold:\n            self.adaptive_factor *= 1.01  # Slightly increase adaptive factor if stagnation detected\n        else:\n            self.adaptive_factor *= 0.99  # Otherwise, continue reducing\n\n    def __call__(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations, previous_best_fitness)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n            previous_best_fitness = self.best_fitness\n        return self.best_solution", "configspace": "", "generation": 35, "feedback": "The algorithm ImprovedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5b823cec-8973-4747-9019-252c6fc6cd0d", "fitness": 0.0672012282791696, "name": "EnhancedAQIEA", "description": "Enhance exploration by implementing a dynamic crossover strategy based on adaptive factor in Enhanced AQIEA.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * (0.5 * (np.random.rand(self.dim) + self.quantum_states[np.random.randint(self.population_size)]))))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06720 with standard deviation 0.06026.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15368663183089648, 0.14345862771295914, 0.14185484885181898, 0.054346896390484956, 0.05323483133544504, 0.05672921839092204, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
