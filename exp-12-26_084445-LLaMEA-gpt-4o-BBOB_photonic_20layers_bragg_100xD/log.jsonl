{"id": "ed59a39f-d545-4d7f-9235-cfcfcab25ed5", "fitness": 0.0649587218050986, "name": "AQIEA", "description": "Adaptive Quantum-Inspired Evolutionary Algorithm (AQIEA) using quantum superposition principles to maintain diversity and accelerate convergence in black box optimization.", "code": "import numpy as np\n\nclass AQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.observables = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * normalized_fitness[i] * self.quantum_states[i] + (1 - normalized_fitness[i]) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * normalized_fitness[i] * self.quantum_states[i] + (1 - normalized_fitness[i]) * np.random.rand(self.dim)))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 0, "feedback": "The algorithm AQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06496 with standard deviation 0.05725.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.13345837602665167, 0.14102119093512555, 0.14394921293508556, 0.05193319535394991, 0.05567638308408762, 0.05709013791098727, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA using a dynamic population strategy and adaptive rotation angles for improved diversity and convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["ed59a39f-d545-4d7f-9235-cfcfcab25ed5"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6b425755-ac5f-4c85-9577-21dc3bb57528", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with an adaptive factor increment strategy for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n        self.adaptive_factor += 0.01  # Increment adaptive factor\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "748ff978-1d3a-4285-aa58-0d4bebb6a452", "fitness": 0.06503663866310909, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with refined adaptive quantum update by scaling adaptive_factor for dynamic convergence balance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * (0.5 + np.random.rand() * 0.5)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06504 with standard deviation 0.05892.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.14737174901712646, 0.14333544615057747, 0.13784565522297199, 0.051359696813610634, 0.05021800256625353, 0.053699198197441844, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "cfc4ad91-56ce-4833-8122-196df7a21091", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with dynamic adaptive factor for more flexible rotation adjustments in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        self.adaptive_factor = 0.05 + 0.1 * (1 - normalized_fitness.mean())  # Dynamic adjustment added\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "bbbdf751-3371-44f9-9d0e-9e688fee23a8", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Improved EnhancedAQIEA by introducing non-uniform quantum state initialization for better exploration-exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))  # This line is modified\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "54d7565c-cb8f-42f6-880d-16ef1e6ec283", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced Quantum-Inspired Evolutionary Algorithm with Diversity-Preserving Mechanism and Dynamic Quantum Rotation for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.diversity_threshold = 0.1\n        self.dynamic_rotation_factor = 0.1\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        diversity = np.std(fitness_values) / (fitness_values.mean() + 1e-6)\n        rotation_factor = self.dynamic_rotation_factor * (1 - diversity / self.diversity_threshold)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment + rotation_factor) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment + rotation_factor) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a262dd08-25aa-4b51-bca8-f21c888b62f0", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Improved EnhancedAQIEA by fine-tuning the adaptive factor for a better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.03  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "88f6a738-0675-455a-ada8-2a4e4551a5f4", "fitness": 0.06672979896379809, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with improved quantum state update by introducing a small randomness factor for diversity.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            random_factor = np.random.normal(0, 0.01, self.dim)  # added randomness\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * (self.quantum_states[i] + random_factor) +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * (self.quantum_states[i] + random_factor) +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06673 with standard deviation 0.05876.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.13610669922631213, 0.1451582130055955, 0.14811442167869338, 0.05338259146056534, 0.057374612116018575, 0.058931653186998, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "eae77961-0a5c-4a5e-beb5-dbc35a5ab296", "fitness": 0.06829736260420181, "name": "RefinedEnhancedAQIEA", "description": "Refined Enhanced AQIEA with a dual-adaptive quantum mechanism and learning rate modulation to improve exploitation and exploration balance in black box optimization.", "code": "import numpy as np\n\nclass RefinedEnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.base_adaptive_factor = 0.05\n        self.learning_rate = 0.1  # New learning rate for controlling adaptive factor\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def dual_adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        adaptive_factor = self.base_adaptive_factor + self.learning_rate * np.std(normalized_fitness)\n        for i in range(self.population_size):\n            adjustment = adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.dual_adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 9, "feedback": "The algorithm RefinedEnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "cc0c9abc-cf11-47c8-9c87-ba791b5e8638", "fitness": -Infinity, "name": "EnhancedAQIEA", "description": "Adaptive Quantum-Inspired Evolutionary Algorithm (AQIEA) with dynamic adaptive quantum rotation and elite preservation for enhanced convergence and diversity in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elite_preservation_rate = 0.1  # New parameter for elite preservation\n        self.elite_quantum_states = None\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            angle = np.pi * (normalized_fitness[i] + adjustment)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(angle * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(angle * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        new_population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        if new_population_size < self.population_size:\n            self.elite_quantum_states = self.quantum_states[np.argsort(fitness_values)[:int(self.elite_preservation_rate * self.population_size)]]\n        self.population_size = new_population_size\n        new_quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        if self.elite_quantum_states is not None:\n            self.quantum_states[:len(self.elite_quantum_states)] = self.elite_quantum_states\n            self.quantum_states[len(self.elite_quantum_states):] = new_quantum_states[len(self.elite_quantum_states):]\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 10, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {}}
{"id": "0a5198b0-a297-49a6-8e6c-6bae78d0eb34", "fitness": 0.07064783890481263, "name": "EnhancedAQIEA", "description": "Introducing an adaptive factor decay to the Enhanced AQIEA to improve convergence by refining rotation angle adjustments over time.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07065 with standard deviation 0.06389.", "error": "", "parent_ids": ["2a48d03f-a565-43d8-9ef8-1cb18b7dc9c9"], "operator": null, "metadata": {"aucs": [0.17324922568577028, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "1aefbf58-dc24-4f1b-85b3-1d245471d732", "fitness": 0.06472826932542303, "name": "EnhancedAQIEA", "description": "Introducing adaptive mutation and dynamic population resizing in EnhancedAQIEA to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n        self.mutation_rate = 0.1  # New parameter for mutation rate\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            # Apply mutation\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.normal(0, 0.1, self.dim)\n                self.quantum_states[i] = np.clip(self.quantum_states[i] + mutation_vector, 0, 1)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n        self.mutation_rate *= 0.98  # Decay mutation rate over time\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06473 with standard deviation 0.05859.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14221538416395652, 0.1514985776517499, 0.1317039995897743, 0.05209489468074835, 0.051243223216317135, 0.05229834462626115, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "26e3f518-1d7d-43a6-b8bf-29794d5182fe", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhancing the quantum state evolution by introducing fitness-proportionate scaling and dynamic rotation probability adjustment to improve exploration.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        scale_factor = 1.0 + (1 - normalized_fitness)**2  # Scale based on fitness\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            rotation_prob = 0.5 + 0.3 * normalized_fitness[i]  # Dynamic rotation probability\n            if np.random.rand() < rotation_prob:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * scale_factor[i] * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * scale_factor[i] * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "14133062-312b-46fc-b348-48394f90cb77", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Refine adaptive factor by introducing a dynamic adjustment based on the best fitness improvement rate.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        improvement_rate = (self.best_fitness / (self.budget - evaluations + 1e-6))  # Dynamic adjustment\n        self.adaptive_factor *= 0.99 + 0.01 * improvement_rate  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a9dcc50c-1665-481c-bd4c-7a26c5ddd62f", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a minor adjustment to the quantum state update formula for enhanced solution diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * (np.random.rand(self.dim) * 0.5)))  # Minor change here\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ca787b33-5ceb-40b8-ac79-cc00ca3a9e65", "fitness": -Infinity, "name": "EnhancedAQIEA", "description": "Introducing a dynamic adaptive factor to improve convergence by scaling the factor based on fitness improvements over iterations.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= (0.99 if self.best_fitness < np.mean(fitness_values) else 1.01)  # Dynamic adaptive factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 16, "feedback": "An exception occurred: NameError(\"name 'fitness_values' is not defined\").", "error": "NameError(\"name 'fitness_values' is not defined\")", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {}}
{"id": "d5a10b96-d2a7-4dc8-9c10-2bf514ad7555", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhance quantum state initialization with a focus on variance reduction to improve convergence stability.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0.45, 0.55, (self.population_size, self.dim))  # Adjusted initialization range\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "91586f2d-d520-49fd-b184-6355320d6bd3", "fitness": 0.06587278991071782, "name": "EnhancedAQIEA_Improved", "description": "EnhancedAQIEA with dynamic adaptive factor and elitism to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elitism_rate = 0.1  # Preserve top solutions\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        elite_count = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(fitness_values)[:elite_count]\n\n        for i in range(self.population_size):\n            if i not in elite_indices:  # Apply updates only to non-elite solutions\n                adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n                if np.random.rand() < 0.5:\n                    self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n                else:\n                    self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.995  # Dynamic adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedAQIEA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06587 with standard deviation 0.05769.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14133453103159832, 0.14223790336265218, 0.13875383196110969, 0.055231272608390336, 0.054099794390506606, 0.05969777584220348, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c19bea26-6e91-4ec8-9e67-015013673046", "fitness": 0.0660801219302844, "name": "EnhancedAQIEA", "description": "Introducing a stochastic component in population size adjustment to enhance exploration capabilities while maintaining convergence control.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        # Introduce stochastic component in population adjustment\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress) * np.random.uniform(0.9, 1.1))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06608 with standard deviation 0.06063.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.1413097946684292, 0.1397864803789053, 0.1576713232311081, 0.04598686078429581, 0.05137488704459814, 0.057091751265223256, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fabfd937-9bc8-48e8-b312-a8573c31b03b", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with dynamic adjustment of quantum state perturbations based on convergence speed to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.convergence_speed_threshold = 0.01\n        self.previous_best_fitness = np.inf\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def dynamic_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        convergence_speed = np.abs(self.previous_best_fitness - self.best_fitness)\n        perturbation_factor = 0.5 if convergence_speed > self.convergence_speed_threshold else 1.0\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * perturbation_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.dynamic_quantum_update(fitness_values)\n            self.previous_best_fitness = self.best_fitness\n        return self.best_solution", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "eb477bec-2fd2-4afc-9d28-5db7bdac498b", "fitness": 0.06739260820729337, "name": "EnhancedAQIEA", "description": "Introducing dynamic mutation scaling to Enhanced AQIEA for improved exploration by adjusting mutation intensity based on search progress.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.mutation_scale = 0.1  # New parameter for mutation intensity\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            random_mutation = np.random.normal(0, self.mutation_scale, self.dim)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                       (1 - (normalized_fitness[i] + adjustment)) * random_mutation))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                       (1 - (normalized_fitness[i] + adjustment)) * random_mutation))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.mutation_scale *= 0.98  # Dynamic mutation scaling\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06739 with standard deviation 0.05813.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13983394797244386, 0.14539157858915086, 0.14105116450805855, 0.06013535575704254, 0.06421226850781558, 0.05440915853112904, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9be76052-66be-4b6d-a794-2fef9c26afd1", "fitness": 0.06594183444480493, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with progressive population mutation and dynamic adaptive factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.mutation_rate = 0.1\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            # Introduce mutation for additional exploration\n            if np.random.rand() < self.mutation_rate:\n                self.quantum_states[i] += np.random.normal(0, adjustment, self.dim)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def dynamic_mutation_rate(self, evaluations):\n        self.mutation_rate = 0.1 + 0.9 * (evaluations / self.budget)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            self.dynamic_mutation_rate(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06594 with standard deviation 0.05889.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13289811884413127, 0.15167898700812787, 0.1441302187262965, 0.05222409382420934, 0.05762781984524268, 0.05341727175523692, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ce7311bc-9783-4a09-9a58-654033357553", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic adaptive factor adjustment to further fine-tune the population convergence process in the Enhanced AQIEA.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99 + 0.01 * np.sin(evaluations / self.budget * np.pi)  # Dynamic adaptive factor adjustment\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "d6f8eef9-c757-4605-ad11-150c07b7bc2c", "fitness": 0.06792187166247471, "name": "EnhancedAQIEA_DE", "description": "Introducing differential evolution-inspired mutations in Enhanced AQIEA to enhance exploration and maintain diversity, combined with adaptive quantum rotations for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def differential_evolution_mutation(self):\n        indices = np.arange(self.population_size)\n        for i in range(self.population_size):\n            x1, x2, x3 = self.quantum_states[np.random.choice(indices[indices != i], 3, replace=False)]\n            mutant = x1 + self.mutation_factor * (x2 - x3)\n            trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.quantum_states[i])\n            self.quantum_states[i] = np.clip(trial, 0, 1)\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.differential_evolution_mutation()\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedAQIEA_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06792 with standard deviation 0.06165.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15968705144517092, 0.14146219789479164, 0.14620183339220383, 0.058871644142215684, 0.050233107344460626, 0.053341010743429784, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "91a0fe1f-f321-4132-8626-40704f8860fa", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic learning rate to the Enhanced AQIEA to adaptively scale quantum state updates based on fitness improvement trends.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.learning_rate = 0.1  # New parameter for dynamic learning rate adjustment\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n        self.learning_rate *= 0.95  # Adaptive decay of learning rate\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9111703c-ef73-4110-8ec9-6c97d75845d8", "fitness": 0.06592556895384127, "name": "EnhancedAQIEA", "description": "Introducing a dynamic rotation selection in Enhanced AQIEA to improve exploration by alternating between sine and cosine updates based on fitness trends.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if normalized_fitness[i] < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06593 with standard deviation 0.05977.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14652783803185487, 0.14118847251295685, 0.14709403487874195, 0.049859521182927025, 0.05347843367074023, 0.05368182030735069, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8fb5e3a4-88c9-41cc-8614-5ce5b4c059a4", "fitness": 0.06829736260420181, "name": "EnhancedAQIEAImproved", "description": "Enhance convergence by incorporating elite preservation and dynamic quantum rotation based on fitness variance to the Enhanced AQIEA algorithm.", "code": "import numpy as np\n\nclass EnhancedAQIEAImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elite_ratio = 0.1  # Proportion of elite individuals to preserve\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def preserve_elite(self, fitness_values):\n        elite_count = max(1, int(self.elite_ratio * self.population_size))\n        elite_indices = np.argsort(fitness_values)[:elite_count]\n        return self.quantum_states[elite_indices]\n\n    def adaptive_quantum_update(self, fitness_values, elites):\n        variance = np.var(fitness_values)\n        rotation_factor = self.adaptive_factor * (1 / (1 + variance))\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n\n        for i in range(self.population_size):\n            if i not in elites:\n                adjustment = rotation_factor * (1 - normalized_fitness[i])\n                if np.random.rand() < 0.5:\n                    self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n                else:\n                    self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            elites = self.preserve_elite(fitness_values)\n            self.adaptive_quantum_update(fitness_values, elites)\n        return self.best_solution", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedAQIEAImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "723a1193-7ec7-4469-a1a5-7728dabc0d6b", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhance convergence by dynamically updating the adaptive factor based on fitness variance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= np.var(self.quantum_states)  # Dynamic adaptive factor update based on variance\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ea6d65ce-9e4d-4c3e-9b04-7ddde32e7c70", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic population diversity mechanism and enhanced adaptive factor strategy to improve exploration and exploitation balance in Enhanced AQIEA.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.diversity_factor = 0.1  # New parameter for dynamic diversity\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            random_factor = np.random.uniform(-self.diversity_factor, self.diversity_factor, self.dim)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * random_factor))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * random_factor))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.995  # More gradual adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8e10ecde-5164-4929-9dbe-134c7b57d52e", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Incorporate dynamic adaptive factor decay based on population diversity to further refine convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        diversity = np.mean(np.std(self.quantum_states, axis=0))  # Calculate diversity\n        self.adaptive_factor *= (0.98 + 0.02 * diversity)  # Adaptive factor decay based on diversity\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7c8a1f1b-39a8-4b96-87a9-93f1dbc30cf3", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with adaptive quantum update based on diversity, refining state transitions over time.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        diversity = np.std(fitness_values)  # Added line to calculate diversity\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fded7498-2760-433f-8594-93dbf4c3a0c3", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce weighted average in adaptive factor to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n    \n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99 * (0.5 + 0.5 * progress)  # Weighted average in adaptive factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "bb49fa0e-7584-446d-862d-16f7776336fb", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce a dynamic learning rate mechanism to the Enhanced AQIEA that adapts based on convergence progress to balance exploration and exploitation throughout the optimization process.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.learning_rate = 1.0\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * self.learning_rate * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size_and_learning_rate(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.learning_rate = 1.0 - progress  # Dynamic learning rate\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size_and_learning_rate(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e0845a3d-5faf-4b00-a1c2-a78651aa40da", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic quantum state initialization to the Enhanced AQIEA for better exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def initialize_quantum_states(self):\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.initialize_quantum_states()\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        self.initialize_quantum_states()\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "eccdf4ae-260a-429a-a078-9f53348e8a4c", "fitness": 0.06829736260420181, "name": "ImprovedAQIEA", "description": "Introducing a convergence rate monitoring mechanism to dynamically adjust the adaptive factor and prevent premature convergence in Enhanced AQIEA.", "code": "import numpy as np\n\nclass ImprovedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.convergence_threshold = 1e-5  # Threshold to detect stagnation\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations, previous_best_fitness):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        if abs(previous_best_fitness - self.best_fitness) < self.convergence_threshold:\n            self.adaptive_factor *= 1.01  # Slightly increase adaptive factor if stagnation detected\n        else:\n            self.adaptive_factor *= 0.99  # Otherwise, continue reducing\n\n    def __call__(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations, previous_best_fitness)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n            previous_best_fitness = self.best_fitness\n        return self.best_solution", "configspace": "", "generation": 35, "feedback": "The algorithm ImprovedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5b823cec-8973-4747-9019-252c6fc6cd0d", "fitness": 0.0672012282791696, "name": "EnhancedAQIEA", "description": "Enhance exploration by implementing a dynamic crossover strategy based on adaptive factor in Enhanced AQIEA.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * (0.5 * (np.random.rand(self.dim) + self.quantum_states[np.random.randint(self.population_size)]))))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06720 with standard deviation 0.06026.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15368663183089648, 0.14345862771295914, 0.14185484885181898, 0.054346896390484956, 0.05323483133544504, 0.05672921839092204, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c0d856fd-5d38-4606-bfe5-0cd278e1ad55", "fitness": 0.06829736260420181, "name": "RefinedEnhancedAQIEA", "description": "Leverage a dynamic oscillatory factor in the adaptive quantum update to better explore and exploit the search space.", "code": "import numpy as np\n\nclass RefinedEnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.oscillation_amplitude = 0.1\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values, evaluations):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        oscillation = self.oscillation_amplitude * np.sin(np.pi * evaluations / self.budget)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) + oscillation\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values, evaluations)\n        return self.best_solution", "configspace": "", "generation": 37, "feedback": "The algorithm RefinedEnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "16ba9455-b23e-42f0-8c58-1f82ccb1dd7f", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce a dynamic population adjustment threshold to the Enhanced AQIEA for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n        if self.best_fitness < 1e-5:  # Dynamic threshold adjustment\n            self.population_size = max(self.min_population_size, int(self.population_size * 0.9))\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fa48c15b-e85e-4b68-a714-32552762efe8", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce a gradual increase in the initial adaptive factor to enhance exploration before focusing on convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.01  # Adjusted initial adaptive factor\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "42e14277-1ff1-4191-a591-928df9553caa", "fitness": 0.06587278991071782, "name": "EnhancedAQIEA", "description": "Enhanced AQIEA with adaptive mutation and elitism to improve convergence by maintaining diversity while preserving the best solutions.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elite_fraction = 0.1  # Fraction of population to be considered elite\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        elite_count = int(self.elite_fraction * self.population_size)\n        elite_indices = np.argpartition(fitness_values, elite_count)[:elite_count]\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if i not in elite_indices:\n                if np.random.rand() < 0.5:\n                    self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n                else:\n                    self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06587 with standard deviation 0.05769.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14133453103159832, 0.14223790336265218, 0.13875383196110969, 0.055231272608390336, 0.054099794390506606, 0.05969777584220348, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "18b41958-e8ab-4344-a5bf-9b67fa94dae0", "fitness": 0.06540590203819496, "name": "EnhancedAQIEA", "description": "Introducing a dynamic adaptive factor and elitism strategy to Enhanced AQIEA to improve convergence stability by balancing exploration and exploitation over time.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.dynamic_decay_rate = 0.99\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        elite_threshold = np.percentile(fitness_values, 20)  # 20% elitism\n        for i in range(self.population_size):\n            if fitness_values[i] <= elite_threshold:\n                adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n                if np.random.rand() < 0.5:\n                    self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n                else:\n                    self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                            (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= self.dynamic_decay_rate  # Dynamic adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06541 with standard deviation 0.05750.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13982574619592014, 0.14118847251295685, 0.1397007136822489, 0.0562106323251812, 0.05807089738878901, 0.05215665623865873, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "287015c9-7160-41ff-8d44-4847cbc7c68c", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Integrating a restart mechanism and global search phase to the Enhanced AQIEA for escaping local optima and enhancing exploration.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n        self.restart_threshold = 0.1 * self.budget\n        self.global_search_phase = False\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def restart_if_needed(self, evaluations):\n        if evaluations > 0 and evaluations % self.restart_threshold == 0:\n            self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n            self.global_search_phase = True\n\n    def global_search(self, fitness_values):\n        if self.global_search_phase:\n            for i in range(self.population_size):\n                self.quantum_states[i] = np.random.uniform(0, 1, self.dim)\n            self.global_search_phase = False\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            self.restart_if_needed(evaluations)\n            fitness_values = self.evaluate_population(func)\n            self.global_search(fitness_values)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "adae678a-7a97-4f10-8129-f02a176cecb5", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Integrate a dynamic rotation strategy in EnhancedAQIEA to adaptively shift quantum states' angles based on exploration-exploitation balance, enhancing convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.rotation_factor = 0.01  # New parameter to dynamically adjust rotation angles\n        self.rotation_decay = 0.995  # Decay rotation factor over time\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            rotation_adjustment = self.rotation_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment + rotation_adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment + rotation_adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment + rotation_adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment + rotation_adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.rotation_factor *= self.rotation_decay  # Apply decay to rotation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9674e928-076d-434d-94ed-388317c302df", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce a dynamic adjustment to the adaptive factor's decay rate based on the current progress to enhance convergence stability.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99 + 0.005 * progress  # Changed line: Dynamic decay rate adjustment\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ed9f4418-47e8-4387-95af-f6c361b349d2", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduced dynamic scaling of the adaptive factor decay based on remaining budget to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= (0.99 + 0.01 * (1 - progress))  # Dynamic adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "75d69159-6ea9-47f5-9d9f-43daa8b4777c", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic adjustment to the adaptive factor decay rate for Enhanced AQIEA to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= (0.99 + 0.01 * (1 - progress))  # Dynamic adjustment to adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "93302b23-f54d-4ada-a965-d81d00b9a1d9", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Add elite preservation strategy by retaining top solutions over iterations to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        elites = []  # Added to retain top solutions\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            elites.append(self.best_solution)  # Storing the best solution\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "d57b6c19-0afd-46be-a1e6-dc3d47b4e007", "fitness": 0.06510874227818889, "name": "EnhancedAQIEA", "description": "Refining quantum state updates using a blend of sine and cosine functions for smoother transitions and better convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                   (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim))) * 0.5 + \\\n                                     np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                   (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim))) * 0.5\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06511 with standard deviation 0.05847.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.149982073525193, 0.141989599969934, 0.13358198985975522, 0.05263076387030574, 0.05468042247747429, 0.051613830801037874, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ef6f0533-0baf-438d-a0e9-52060895465e", "fitness": 0.06501146470653804, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with improved population adjustment strategy for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] + (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] + (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * np.sqrt(1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06501 with standard deviation 0.05866.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13227747369246923, 0.1476107880975367, 0.1465176174371734, 0.049611042834780905, 0.052224591049886526, 0.055361669246995815, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "33f3c02d-55e7-4b35-a130-4dada3fe1de6", "fitness": 0.06503663866310909, "name": "EnhancedAQIEA", "description": "Introducing dynamic population diversity mechanisms to Enhanced AQIEA to improve exploration and convergence by varying diversity control based on optimization progress.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.diversity_factor = 0.1  # New parameter for diversity control\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            diversity_adjustment = self.diversity_factor * (0.5 - np.random.rand())  # Introduce controlled diversity\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) + diversity_adjustment\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.diversity_factor *= 0.98  # Decay diversity factor for fine-tuning\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06504 with standard deviation 0.05892.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14737174901712646, 0.14333544615057747, 0.13784565522297199, 0.051359696813610634, 0.05021800256625353, 0.053699198197441844, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "d39eef9a-fc58-4e51-bb6e-b392d6c0b204", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing dynamic adjustment of the adaptive factor based on evaluation progress to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor = 0.05 * (1 - progress)  # Dynamic adaptive factor based on progress\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "431f8277-7c51-4243-b736-eaaf033be630", "fitness": 0.06479186128119006, "name": "EnhancedAQIEAWithElitism", "description": "Introducing a dynamic elitism strategy and smart diversity maintenance in Enhanced AQIEA to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAQIEAWithElitism:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.elite_portion = 0.2  # Portion of population considered elite\n        self.diversity_threshold = 0.1  # Threshold for diversity maintenance\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        elite_count = int(self.elite_portion * self.population_size)\n        elite_indices = np.argsort(fitness_values)[:elite_count]\n        for i in range(self.population_size):\n            if i in elite_indices:\n                continue\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def maintain_diversity(self):\n        mean_state = np.mean(self.quantum_states, axis=0)\n        for i in range(self.population_size):\n            distance = np.linalg.norm(self.quantum_states[i] - mean_state)\n            if distance < self.diversity_threshold:\n                self.quantum_states[i] = np.random.rand(self.dim)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n            self.maintain_diversity()\n        return self.best_solution", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedAQIEAWithElitism got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06479 with standard deviation 0.05853.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13888156498709858, 0.14889181891208447, 0.1380647033260025, 0.05366569451400327, 0.05050913899048404, 0.051613830801037874, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ec554b12-5bd6-426f-9a39-ff281e1b2966", "fitness": 0.06517396956580562, "name": "EnhancedAQIEA", "description": "Introducing a dynamic quantum state mixing mechanism to EnhancedAQIEA for improved exploration and convergence by leveraging diverse state interactions.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def dynamic_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            rand_idx = np.random.choice(self.population_size)\n            mix_state = 0.5 * (self.quantum_states[i] + self.quantum_states[rand_idx])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * mix_state +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * mix_state +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.dynamic_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06517 with standard deviation 0.05771.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.13511523463429786, 0.14530707909850227, 0.14098294064691064, 0.05848167286870909, 0.05148457142203533, 0.053694227421795526, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ca4fdea0-bb67-48aa-b2ab-877a1a3faaf7", "fitness": 0.06667472588063703, "name": "EnhancedAQIEA", "description": "Introducing a dynamic population size adjustment strategy with enhanced quantum state exploration to improve convergence by increasing diversity and precision in solution space sampling.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # Adaptive factor for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            rotation = np.random.rand(self.dim) * 2 * np.pi  # Random rotation angle for diversity\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim) + rotation))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim) + rotation))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        # Dynamic adjustment of population size based on the search progress\n        if progress < 0.3:\n            self.population_size = self.max_population_size\n        elif progress < 0.7:\n            self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (0.7 - progress) / 0.4)\n        else:\n            self.population_size = self.min_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.98  # Slightly faster decay for the adaptive factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06667 with standard deviation 0.06053.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.14995131686971952, 0.1460905525879922, 0.14421215994113767, 0.0533332659551049, 0.05069353398372578, 0.05429170358805335, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4b1d28b4-14e3-4b73-803a-acc930b8986c", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Improved adaptive decay strategy by modifying the decay rate to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.995  # Adjusted adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7921168c-386c-45b7-9015-1d9de586db27", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dynamic adjustment to the adaptive factor decay based on evaluation progress to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= (0.99 + 0.009 * progress)  # Dynamic adjustment to adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c96005ee-82e5-4074-9797-ddb0c945d942", "fitness": 0.0660801219302844, "name": "EnhancedAQIEA", "description": "Introducing a stochastic population size adjustment in Enhanced AQIEA to enhance exploration and avoid premature convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress) * np.random.uniform(0.9, 1.1))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06608 with standard deviation 0.06063.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.1413097946684292, 0.1397864803789053, 0.1576713232311081, 0.04598686078429581, 0.05137488704459814, 0.057091751265223256, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c5346972-4c97-409b-95dd-c7d5175b1244", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Fine-tuning the adaptive factor decay rate to enhance convergence by balancing exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.995  # Adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "87e33a0b-1911-4429-90c9-ff2da5ff77d1", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Implement a dynamic adaptive factor by modifying the decay to be proportional to the current best fitness improvement rate.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05  # New parameter for adjusting rotations\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= (1 - (self.best_fitness / (self.best_fitness + 1)))  # Dynamic adaptive factor decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "debdf94f-ada0-4262-bfda-b6096ecb5571", "fitness": -Infinity, "name": "EnhancedAQIEA", "description": "Integrate dynamic crossover and mutation strategies with adaptive population control to enhance exploration and exploitation balance in Enhanced AQIEA.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def dynamic_crossover_mutation(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        crossover_prob = 0.5 + 0.3 * (1 - normalized_fitness)\n        mutation_rate = 0.1 * (1 + normalized_fitness)\n\n        for i in range(self.population_size):\n            if np.random.rand() < crossover_prob[i]:\n                partner_idx = np.random.randint(0, self.population_size)\n                partner_state = self.quantum_states[partner_idx]\n                self.quantum_states[i] = (self.quantum_states[i] + partner_state) / 2\n\n            if np.random.rand() < mutation_rate[i]:\n                mutation_vector = np.random.normal(0, 0.1, self.dim)\n                self.quantum_states[i] += mutation_vector\n                self.quantum_states[i] = np.clip(self.quantum_states[i], 0, 1)\n\n    def adaptive_quantum_update(self, fitness_values):\n        self.dynamic_crossover_mutation(fitness_values)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 60, "feedback": "An exception occurred: NameError(\"name 'normalized_fitness' is not defined\").", "error": "NameError(\"name 'normalized_fitness' is not defined\")", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {}}
{"id": "d117109c-0719-481a-9cda-1ea1b6b214bb", "fitness": 0.073022865718625, "name": "EnhancedAQIEA", "description": "Introducing a dynamic quantum state adjustment based on variance reduction to improve solution exploration and exploitation balance over time.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07302 with standard deviation 0.06793.", "error": "", "parent_ids": ["0a5198b0-a297-49a6-8e6c-6bae78d0eb34"], "operator": null, "metadata": {"aucs": [0.19462446701008163, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a6c5042a-8910-4ced-b613-c0bb86142a87", "fitness": 0.06645748950431024, "name": "AdaptiveAQIEA", "description": "Incorporate an adaptive learning rate based on convergence speed and directional mutation to enhance exploration-exploitation balance dynamically.", "code": "import numpy as np\n\nclass AdaptiveAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.learning_rate = 0.1\n        self.directional_mutation_probability = 0.1\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * np.random.rand(self.dim)))\n            if np.random.rand() < self.directional_mutation_probability:\n                direction = np.random.choice([-1, 1], size=self.dim)\n                self.quantum_states[i] = np.clip(self.quantum_states[i] + self.learning_rate * direction, 0, 1)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.learning_rate *= 0.95\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 62, "feedback": "The algorithm AdaptiveAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06646 with standard deviation 0.05902.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.14533294129707908, 0.1467783899026075, 0.13887930567365248, 0.05543310365754872, 0.055377649037632426, 0.05481601597027219, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ab3cb08a-d5ed-46b5-b058-9413771e6279", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "EnhancedAQIEA with adaptive mutation by introducing a dynamic learning rate based on population diversity to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.learning_rate = 0.1  # New dynamic learning rate parameter\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        diversity = np.mean(np.std(self.quantum_states, axis=0))  # Calculate diversity of the population\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * (1 - diversity)\n            variance_adjustment = self.variance_reduction_factor\n            learning_adjustment = self.learning_rate * diversity\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) *\n                                                        (variance_adjustment + learning_adjustment) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) *\n                                                        (variance_adjustment + learning_adjustment) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n        self.learning_rate *= 0.97  # Decay for learning rate\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ca4a210d-b6fa-496d-8f27-90b3d79a5808", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA_V2", "description": "Integrate a diversity-preserving mechanism by introducing an entropy-based adjustment to maintain population diversity and improve convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.entropy_factor = 0.1  # New parameter for entropy-based diversity preservation\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def calculate_entropy(self):\n        # Compute entropy of the quantum states to measure diversity\n        probabilities = np.clip(self.quantum_states, 1e-10, 1.0)\n        entropy = -np.sum(probabilities * np.log(probabilities), axis=1)\n        return entropy\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        entropy = self.calculate_entropy()\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) + self.entropy_factor * entropy[i]\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedAQIEA_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "70657c1f-5c84-4ac6-bec7-7bc099cb00e0", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a variance-driven probability factor for quantum state adjustment to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < normalized_fitness[i]:  # Changed from 0.5 to normalized_fitness[i]\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "247db092-8dd3-445d-8230-3bb22b9fa7a5", "fitness": 0.06829736260420181, "name": "EnhancedAQIEAPlus", "description": "Integrate a diversity preservation mechanism with a self-adaptive quantum state adjustment for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAQIEAPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.diversity_threshold = 0.1\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def calculate_diversity(self):\n        mean_positions = np.mean(self.quantum_states, axis=0)\n        diversity = np.mean(np.linalg.norm(self.quantum_states - mean_positions, axis=1))\n        return diversity\n\n    def adaptive_quantum_update(self, fitness_values):\n        diversity = self.calculate_diversity()\n        diversity_factor = 1 + max(0, (self.diversity_threshold - diversity))\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * diversity_factor\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedAQIEAPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "02d46120-69c8-4caa-99f7-5c55239b4dd3", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introduce a dynamic mutation rate adjustment to slightly enhance exploration capabilities without drastically altering the balance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n        self.mutation_rate = 0.1  # New parameter for dynamic mutation\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < self.mutation_rate:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fbd7cd47-4ac5-4e1e-a144-f99796045888", "fitness": 0.06829736260420181, "name": "CoEvolutionaryAQIEA", "description": "Utilize co-evolutionary quantum states with adaptive variance in quantum state transitions and dynamic population management for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass CoEvolutionaryAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            influence_factor = np.random.rand()\n            if influence_factor < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 68, "feedback": "The algorithm CoEvolutionaryAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "af5ae7ea-be9d-4acb-879d-e18aa5e2bcf7", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Implemented a more aggressive decay on the variance reduction factor to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.95  # Aggressive decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "73644534-2312-4206-ad92-30e7c7b67136", "fitness": 0.06446287804420026, "name": "EnhancedAQIEA", "description": "Introducing a dynamic quantum state adjustment with adaptive mutation and crossover inspired by evolutionary algorithms to enhance exploration and exploitation capabilities.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < self.crossover_rate:\n                partner_index = np.random.randint(0, self.population_size)\n                self.quantum_states[i] = 0.5 * (self.quantum_states[i] + self.quantum_states[partner_index])\n            if np.random.rand() < self.mutation_rate:\n                self.quantum_states[i] += variance_adjustment * np.random.normal(0, 1, self.dim)\n            self.quantum_states[i] = np.abs(np.clip(self.quantum_states[i], 0, 1))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06446 with standard deviation 0.05821.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.13997086041488227, 0.1463673044821444, 0.13733633956835434, 0.048518356377316496, 0.053303561481805595, 0.05316948007329936, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "f121be76-3b32-4a7f-8e9f-9cc247b35047", "fitness": 0.06592556895384127, "name": "EnhancedAQIEA", "description": "Enhancing convergence by dynamically adjusting quantum states with cosine perturbation and improved variance decay.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                    (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim) + 0.1))\n            \n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.985  # Slightly slower decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06593 with standard deviation 0.05977.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.14652783803185487, 0.14118847251295685, 0.14709403487874195, 0.049859521182927025, 0.05347843367074023, 0.05368182030735069, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "1d00bb99-8e1f-4687-a031-519f268271ea", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a layered quantum state adaptation mechanism to enhance convergence speed by utilizing progressive variance control and adaptive population dynamics.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  \n        self.layer_factor = 0.5  # New parameter for layered adaptation\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def layered_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor * (1 - self.layer_factor * normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n        self.layer_factor *= 0.98  # Decay for layered factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.layered_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4c8db098-1d7b-4ad8-9bdb-0c5639d00b85", "fitness": 0.06682880944476063, "name": "EnhancedAQIEA", "description": "Introducing a stochastic sine-cosine dual adjustment mechanism to enhance diversity and escape local optima.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        variance_adjustment * np.random.randn(self.dim)))  # Changed line\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06683 with standard deviation 0.05943.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.13977453038903842, 0.14735725872520045, 0.1466356798450701, 0.05806341965710671, 0.05651456558539236, 0.051613830801037874, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7707282a-b3d1-42bd-a496-942363435eb7", "fitness": 0.06829736260420181, "name": "RefinedEnhancedAQIEA", "description": "Introducing multi-phase adaptive strategy integrating quantum-inspired operators to enhance convergence by dynamically adjusting exploration-exploitation balance.", "code": "import numpy as np\n\nclass RefinedEnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.phase_threshold = 0.5  # New parameter to switch phases\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n        \n    def multi_phase_adaptation(self, evaluations):\n        progress = evaluations / self.budget\n        if progress < self.phase_threshold:\n            self.adaptive_factor = 0.1  # More exploration in the early phase\n        else:\n            self.adaptive_factor = 0.02  # More exploitation in the later phase\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.multi_phase_adaptation(evaluations)\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 74, "feedback": "The algorithm RefinedEnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "02cdcb96-eb18-4eca-8cde-477c45eaeca5", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced adaptive factor decay to balance exploration and exploitation more effectively over time.  ", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.985  # Change the decay rate slightly\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "41d60fed-d80f-4dd4-b991-414de0c8e2a8", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Refining the variance reduction strategy by incorporating adaptive variance scaling based on progress to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= (0.98 + 0.02 * progress)  # Change: Adaptive variance scaling\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "06b42721-99e3-4437-b72c-bf4623565b4c", "fitness": -Infinity, "name": "EnhancedAQIEA", "description": "Introducing a probabilistic adaptive quantum state update mechanism using Lvy flights for enhanced exploration and exploitation balance in solution search.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            \n            # Implementing Lvy flight\n            beta = 1.5\n            sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                     (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v)**(1 / beta)\n            \n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * step))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * step))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 77, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {}}
{"id": "3cad5b76-e3b0-4c70-a653-130db2f712bb", "fitness": 0.0693984042965679, "name": "EnhancedAQIEA", "description": "Enhance solution diversity by introducing a slight variance adjustment in the quantum state update.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.normal(0, 1, self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06940 with standard deviation 0.06559.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.18911626476389043, 0.14169311854848632, 0.13327097357887552, 0.048105922784085764, 0.05502020467938773, 0.055879154314385504, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "eff8ad06-d309-4144-a41d-8d0e981a75a6", "fitness": -Infinity, "name": "EnhancedAQIEA", "description": "Integrate a momentum factor in quantum state updates to enhance convergence stability and speed.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.momentum = np.zeros((self.population_size, self.dim))  # Add a momentum term\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                update = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                       (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                update = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                       (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            self.momentum[i] = 0.9 * self.momentum[i] + update  # Update momentum\n            self.quantum_states[i] = update + self.momentum[i]  # Apply momentum\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 79, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {}}
{"id": "0c3a25fa-5ece-4ba4-a906-fa4e69594113", "fitness": 0.073022865718625, "name": "RefinedAQIEA", "description": "Introduce dynamic evolutionary factors and collaborative quantum states to further balance exploration and exploitation, reducing convergence time and enhancing solution diversity.", "code": "import numpy as np\n\nclass RefinedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.collaboration_factor = 0.1  # New parameter for state collaboration\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            collaboration_adjustment = self.collaboration_factor * np.mean(self.quantum_states, axis=0)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * (variance_adjustment + collaboration_adjustment) * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * (variance_adjustment + collaboration_adjustment) * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n        self.collaboration_factor *= 0.97  # Decay for collaboration adjustment\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 80, "feedback": "The algorithm RefinedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07302 with standard deviation 0.06793.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.19462446701008163, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "00a1c70e-d910-4287-a079-ce36cb62fc72", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Improved the adaptive factor decay to balance exploration and exploitation over the optimization process.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.995  # Slightly altered decay rate for adaptive factor\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "17b986de-b293-4b5c-ab52-826ee0b473fc", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a slightly enhanced quantum state adjustment factor to further balance solution exploration and exploitation, aiming for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment + 0.01) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "40becd94-8956-447a-af1d-4a4b070a4d7b", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing an adaptive mutation mechanism with dynamic variance scaling based on fitness improvements to enhance convergence in the quantum-inspired evolutionary algorithm.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor * (1 + 0.1 * (fitness_values.min() - self.best_fitness))  # Modified line\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3c56d287-c6e4-4808-8b24-698e8639219e", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA_Entropy", "description": "Implement a quantum-inspired dynamic population diversity mechanism with entropy-based adaptation to enhance exploration capabilities and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAQIEA_Entropy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n        self.entropy_threshold = 0.1  # New parameter for entropy-based adaptation\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def entropy_based_adaptation(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        entropy = -np.sum(normalized_fitness * np.log(normalized_fitness + 1e-6)) / self.population_size\n        if entropy < self.entropy_threshold:\n            self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.entropy_based_adaptation(fitness_values)\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedAQIEA_Entropy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "4a198b6b-d671-4281-b76e-39ae4465c78f", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA_V2", "description": "Introducing adaptive quantum state transitions with entropy-guided exploration and variance decay feedback for improved convergence stability and precision.", "code": "import numpy as np\n\nclass EnhancedAQIEA_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_decay = 0.95  # Decay factor for variance\n        self.exploration_entropy = 0.1  # New parameter for entropy-based exploration\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        entropy_weights = np.exp(-normalized_fitness / self.exploration_entropy)\n\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * entropy_weights[i]\n            variance_adjustment = self.variance_decay * np.random.rand(self.dim)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_decay *= 0.98  # Decay for variance feedback\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedAQIEA_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c3bbed79-7a8e-4495-a0b3-a5466d3df741", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Enhanced adaptive variance reduction for quantum state adjustment.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor * (0.5 + 0.5 * normalized_fitness[i])  # Enhanced variance reduction\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "26340030-417c-4a78-bdb2-122fac514b17", "fitness": 0.06793671673365027, "name": "EnhancedAQIEA", "description": "Introducing a random perturbation factor in the adaptive quantum state update to enhance exploration.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        random_perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Added perturbation factor\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim) + random_perturbation))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim) + random_perturbation))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06794 with standard deviation 0.06040.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.1521961399734807, 0.1475754462645863, 0.14009104784315451, 0.05148951527545731, 0.06692785906598109, 0.05165044218019277, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "999e3678-9c4b-4b24-be12-2ca44d30f0c4", "fitness": 0.0647074494361287, "name": "EnhancedAQIEARefined", "description": "Introducing Gaussian noise into the quantum state collapses and using fitness diversity to dynamically adjust exploration and exploitation balance for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEARefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.noise_scale = 0.1\n\n    def collapse_state(self, state, bounds):\n        collapsed_state = bounds.lb + (bounds.ub - bounds.lb) * state\n        noise = np.random.normal(0, self.noise_scale, self.dim)\n        return np.clip(collapsed_state + noise, bounds.lb, bounds.ub)\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        fitness_diversity = np.var(fitness_values)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i]) * fitness_diversity\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n        self.noise_scale *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedAQIEARefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06471 with standard deviation 0.05899.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.13587824027831918, 0.15491491012115854, 0.1367126471514909, 0.052401579976075086, 0.051884329577533306, 0.04907533782058149, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "68cb1b8c-c6a9-4bac-a743-7a662bd11606", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a dual-phase adaptive strategy to balance exploration and exploitation by dynamically adjusting influence based on fitness variance and convergence progress.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values, evaluations):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        progress = evaluations / self.budget\n        exploration_influence = 0.5 * (1 - progress)\n        exploitation_influence = 0.5 * progress\n\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor * (1 - progress)\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(\n                    np.pi * (normalized_fitness[i] * exploitation_influence + adjustment + exploration_influence) * self.quantum_states[i] +\n                    (1 - normalized_fitness[i] - adjustment) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(\n                    np.pi * (normalized_fitness[i] * exploitation_influence + adjustment + exploration_influence) * self.quantum_states[i] +\n                    (1 - normalized_fitness[i] - adjustment) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values, evaluations)\n        return self.best_solution", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ca3d739d-9865-496b-8fdd-ec6c5f730830", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Refined variance reduction mechanism to improve exploration-exploitation trade-off efficiency.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.90  # Changed from 0.95 to 0.90\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "d72155dd-3d41-44a4-95eb-c5004f4c7f70", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Adjusted variance reduction decay to enhance exploration-exploitation balance in later stages of optimization.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.995  # Adjusted decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "dbbd2429-cb8a-41ef-9690-bbeaf0813b90", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Slightly adjust the variance reduction factor decay rate for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.975  # Slight change in decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e977c30c-c925-4878-8e55-b02e278b447c", "fitness": 0.06592556895384127, "name": "EnhancedAQIEA_RL", "description": "Integrated adaptive variance reduction and reinforcement learning inspired adaptive quantum update to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass EnhancedAQIEA_RL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.learning_rate = 0.1\n        self.exploitation_threshold = 0.2\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            reward = 1 - normalized_fitness[i]\n            adjustment = self.adaptive_factor * reward\n            variance_adjustment = self.variance_reduction_factor\n            if reward > self.exploitation_threshold:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n            # Reinforcement learning-inspired update\n            self.adaptive_factor += self.learning_rate * (reward - self.adaptive_factor)\n            self.exploitation_threshold += self.learning_rate * ((1 - reward) - self.exploitation_threshold)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedAQIEA_RL got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06593 with standard deviation 0.05977.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.14652783803185487, 0.14118847251295685, 0.14709403487874195, 0.049859521182927025, 0.05347843367074023, 0.05368182030735069, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3034cadc-c953-4587-b00f-dd2c91be6392", "fitness": 0.06433196286173244, "name": "EnhancedMLQIEA", "description": "Leveraging multi-layered quantum coherence with adaptive inertia to enhance solution accuracy and convergence speed.", "code": "import numpy as np\n\nclass EnhancedMLQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim, 2))  # Adding extra layer for coherence\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.inertia_weight = 0.9  # New parameter for inertia\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i, :, 0], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            inertia_adjustment = self.inertia_weight * np.sum(self.quantum_states[i, :, 1]) / self.dim\n            if np.random.rand() < 0.5:\n                self.quantum_states[i, :, 0] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment + inertia_adjustment) * self.quantum_states[i, :, 0] +\n                                                             (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i, :, 0] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment + inertia_adjustment) * self.quantum_states[i, :, 0] +\n                                                             (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            self.quantum_states[i, :, 1] = self.quantum_states[i, :, 0]  # Update the coherence layer\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim, 2))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n        self.inertia_weight *= 0.97  # Decay for inertia\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedMLQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06433 with standard deviation 0.05859.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.1478489240396711, 0.13754107220143108, 0.14013647751129787, 0.05512495009110063, 0.04774835418719847, 0.04908788772489303, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c601eec0-72cd-4aa0-8982-c1dee5a3ca7c", "fitness": 0.06476370346794358, "name": "EnhancedAQIEA", "description": "Introducing a stochastically enhanced variance reduction factor adjustment to improve convergence speed and accuracy.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= (0.98 + 0.02 * np.random.rand())  # Stochastically enhanced decay for variance reduction\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06476 with standard deviation 0.05784.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.13149519037857293, 0.14794808181027408, 0.14187439469076368, 0.05449532408544577, 0.05119078040286873, 0.05436955984356717, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2f7e6ef5-e68b-4006-9ef8-d0b8270d76e3", "fitness": 0.06829736260420181, "name": "EnhancedAQIEA", "description": "Introducing a self-adaptive mutation mechanism to further enhance quantum state diversity and solution exploration.", "code": "import numpy as np\n\nclass EnhancedAQIEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95  # New parameter for variance reduction\n        self.mutation_probability = 0.1  # New parameter for mutation probability\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5 + self.mutation_probability * (1 - normalized_fitness[i]):  # Adjusted line\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98  # Decay for variance reduction\n        self.mutation_probability *= 0.99  # Decay for mutation probability\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedAQIEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e6fd454e-dd88-4dea-90b4-9c112a702b76", "fitness": 0.06586594854467169, "name": "EnhancedAQIEA_v2", "description": "Introducing self-adaptive mutation strategies and diversity preservation to enhance exploration-exploitation trade-off and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAQIEA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.diversity_threshold = 0.1  # New parameter for diversity preservation\n        self.mutation_rate = 0.1  # Mutation rate for diversity\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            # Mutation to maintain diversity\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.normal(0, self.diversity_threshold, self.dim)\n                self.quantum_states[i] += mutation_vector\n                self.quantum_states[i] = np.clip(self.quantum_states[i], 0, 1)\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedAQIEA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06587 with standard deviation 0.05974.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.14659433997533566, 0.1495556158608411, 0.13813701410384438, 0.050444310592953734, 0.05231204245935106, 0.0542502139097194, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9e9a4c89-988d-4113-be7d-9785f937767f", "fitness": 0.06829736260420181, "name": "EnhancedAQIEARefined", "description": "Implementing dynamic quantum state adaptation with adaptive variance scaling and nonlinear transformation for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEARefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 100\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_scaling = 0.95  # Modified parameter for adaptive variance scaling\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * np.exp(-normalized_fitness[i])  # Nonlinear transformation\n            variance_adjustment = self.variance_scaling * (1 - normalized_fitness[i])\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim)))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.98  # Faster decay for adaptive factor\n        self.variance_scaling *= 0.97  # Adaptive scaling decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedAQIEARefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06830 with standard deviation 0.06036.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.15209493898027293, 0.1483494867888966, 0.1400535370102256, 0.05423473885136787, 0.06487417523880579, 0.05356938656824772, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5c884c61-b4d5-4487-b71d-c5f0c7402a32", "fitness": 0.06630228810854685, "name": "EnhancedAQIEA2", "description": "Introducing a diversity-driven quantum state adjustment with adaptive population control to enhance exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedAQIEA2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.min_population_size = 10\n        self.max_population_size = 150\n        self.population_size = self.initial_population_size\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_factor = 0.05\n        self.variance_reduction_factor = 0.95\n        self.diversity_factor = 0.1  # New parameter for diversity enhancement\n\n    def collapse_state(self, state, bounds):\n        return bounds.lb + (bounds.ub - bounds.lb) * state\n\n    def evaluate_population(self, func):\n        fitness_values = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            solution = self.collapse_state(self.quantum_states[i], func.bounds)\n            fitness_values[i] = func(solution)\n            if fitness_values[i] < self.best_fitness:\n                self.best_fitness = fitness_values[i]\n                self.best_solution = solution\n        return fitness_values\n\n    def adaptive_quantum_update(self, fitness_values):\n        normalized_fitness = (fitness_values - fitness_values.min()) / (fitness_values.max() - fitness_values.min() + 1e-6)\n        diversity = np.std(self.quantum_states, axis=0)\n        for i in range(self.population_size):\n            adjustment = self.adaptive_factor * (1 - normalized_fitness[i])\n            variance_adjustment = self.variance_reduction_factor\n            diversity_adjustment = self.diversity_factor * diversity\n            if np.random.rand() < 0.5:\n                self.quantum_states[i] = np.abs(np.sin(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim) +\n                                                        diversity_adjustment))\n            else:\n                self.quantum_states[i] = np.abs(np.cos(np.pi * (normalized_fitness[i] + adjustment) * self.quantum_states[i] +\n                                                        (1 - (normalized_fitness[i] + adjustment)) * variance_adjustment * np.random.rand(self.dim) +\n                                                        diversity_adjustment))\n\n    def adjust_population_size(self, evaluations):\n        progress = evaluations / self.budget\n        self.population_size = int(self.min_population_size + (self.max_population_size - self.min_population_size) * (1 - progress))\n        self.quantum_states = np.random.uniform(0, 1, (self.population_size, self.dim))\n        self.adaptive_factor *= 0.99\n        self.variance_reduction_factor *= 0.98\n        self.diversity_factor *= 0.97  # Decay for diversity enhancement\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.adjust_population_size(evaluations)\n            fitness_values = self.evaluate_population(func)\n            evaluations += self.population_size\n            if evaluations >= self.budget:\n                break\n            self.adaptive_quantum_update(fitness_values)\n        return self.best_solution", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedAQIEA2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06630 with standard deviation 0.05790.", "error": "", "parent_ids": ["d117109c-0719-481a-9cda-1ea1b6b214bb"], "operator": null, "metadata": {"aucs": [0.1368708098775614, 0.1483549550731471, 0.13802974841911608, 0.06411369295915015, 0.051748543181147744, 0.05610284346679939, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
